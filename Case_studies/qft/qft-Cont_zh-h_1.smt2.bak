(set-logic AUFNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: real arithmetic
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun prefix_mndt (t) t)

(declare-fun infix_pldt (t t) t)

(declare-fun infix_asdt (t t) t)

;; Unit_def_r
  (assert (forall ((x t)) (= (infix_pldt x tzero) x)))

;; NonTrivialRing
  (assert (not (= tzero tone)))

(declare-fun infix_mndt (t t) t)

;; infix -._def
  (assert
  (forall ((x t) (y t)) (= (infix_mndt x y) (infix_pldt x (prefix_mndt y)))))

;; opposite
  (assert (forall ((a t)) (= (infix_mndt a a) tzero)))

(declare-fun im () t)

(declare-fun r_to_t (Real) t)

;; r_to_t_zero
  (assert (= (r_to_t 0.0) tzero))

;; r_to_t_inv
  (assert (forall ((i Real)) (= (r_to_t (- i)) (prefix_mndt (r_to_t i)))))

(declare-fun real_part (t) Real)

(declare-fun im_part (t) Real)

;; Real_part_add
  (assert
  (forall ((i t) (j t))
  (= (real_part (infix_pldt i j)) (+ (real_part i) (real_part j)))))

;; Complex_decomp
  (assert
  (forall ((i t))
  (= i (infix_pldt (r_to_t (real_part i))
       (infix_asdt im (r_to_t (im_part i)))))))

(declare-fun real_ (t) Bool)

;; real__def
  (assert (forall ((x t)) (= (real_ x) (= (im_part x) 0.0))))

;; real_r_to_t
  (assert (forall ((x Real)) (real_ (r_to_t x))))

(declare-fun t_real_part (t) t)

;; t_real_part_def
  (assert (forall ((x t)) (= (t_real_part x) (r_to_t (real_part x)))))

(declare-fun infix_mngt (ty ty) ty)

(declare-fun exp (t) t)

(declare-fun cos1 (t) t)

;; cos_zero
  (assert (= (cos1 tzero) tone))

;; euler_real
  (assert
  (forall ((x t))
  (=> (real_ x) (= (cos1 x) (t_real_part (exp (infix_asdt im x)))))))

(declare-sort angle_c 0)

(declare-fun angle_c1 () ty)

(declare-fun ang_exp_c (angle_c) t)

(declare-fun int_to_ang_c (Int Int) angle_c)

(declare-fun ang_inv_c (angle_c) angle_c)

;; ang_exp_c_zero
  (assert (= (ang_exp_c (int_to_ang_c 0 0)) tone))

(declare-fun real_to_ang_c (t) angle_c)

;; Real_To_Ang_up
  (assert
  (forall ((phi t))
  (=> (real_ phi)
  (= (real_to_ang_c phi) (real_to_ang_c (infix_pldt tone phi))))))

;; Real_zero_n
  (assert (= (real_to_ang_c tzero) (int_to_ang_c 0 0)))

;; Int_To_Ang_inv
  (assert
  (forall ((k Int) (n Int))
  (=> (<= 0 n) (= (ang_inv_c (int_to_ang_c k n)) (int_to_ang_c (- k) n)))))

;; ang_minus_one_from_real
  (assert (= (int_to_ang_c 1 1) (real_to_ang_c (prefix_mndt tone))))

;; omega_d11
  (assert (= (ang_exp_c (int_to_ang_c 1 1)) (prefix_mndt tone)))

(assert
;; h
  (not false))
(check-sat)

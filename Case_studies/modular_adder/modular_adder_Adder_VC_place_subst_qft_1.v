(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Reals.R_sqrt.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.EuclideanDivision.
Require real.Real.
Require real.FromInt.
Require real.Square.
Require map.Map.
Require map.Const.
Require set.Set.

Parameter infix_eqeq: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom infix_eqeq_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a), (infix_eqeq a1 b) -> (a1 = b).

Axiom infix_eqeq_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a), (a1 = b) -> infix_eqeq a1 b.

Axiom assert_equal : True.

Axiom goal_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a), (a1 = b) -> (b = a1).

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter teq: t -> t -> Prop.

Axiom teq_def : forall (x:t) (y:t), (teq x y) <-> (infix_eqeq x y).

Axiom teq_spec : forall (x:t) (y:t), (teq x y) -> (x = y).

Axiom teq_spec1 : forall (x:t) (y:t), (x = y) -> teq x y.

Parameter tzero: t.

Parameter tone: t.

Parameter prefix_mndt: t -> t.

Parameter infix_pldt: t -> t -> t.

Parameter infix_asdt: t -> t -> t.

Parameter inv: t -> t.

Axiom Assoc :
  forall (x:t) (y:t) (z:t),
  ((infix_pldt (infix_pldt x y) z) = (infix_pldt x (infix_pldt y z))).

Axiom Unit_def_l : forall (x:t), ((infix_pldt tzero x) = x).

Axiom Unit_def_r : forall (x:t), ((infix_pldt x tzero) = x).

Axiom Inv_def_l : forall (x:t), ((infix_pldt (prefix_mndt x) x) = tzero).

Axiom Inv_def_r : forall (x:t), ((infix_pldt x (prefix_mndt x)) = tzero).

Axiom Comm : forall (x:t) (y:t), ((infix_pldt x y) = (infix_pldt y x)).

Axiom Assoc1 :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt (infix_asdt x y) z) = (infix_asdt x (infix_asdt y z))).

Axiom Mul_distr_l :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt x (infix_pldt y z)) =
   (infix_pldt (infix_asdt x y) (infix_asdt x z))).

Axiom Mul_distr_r :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt (infix_pldt y z) x) =
   (infix_pldt (infix_asdt y x) (infix_asdt z x))).

Axiom Comm1 : forall (x:t) (y:t), ((infix_asdt x y) = (infix_asdt y x)).

Axiom Unitary : forall (x:t), ((infix_asdt tone x) = x).

Axiom NonTrivialRing : ~ (tzero = tone).

Axiom Inverse :
  forall (x:t), ~ (x = tzero) -> ((infix_asdt x (inv x)) = tone).

Parameter infix_mn: t -> t -> t.

Axiom infix_mn_def :
  forall (x:t) (y:t), ((infix_mn x y) = (infix_pldt x (prefix_mndt y))).

Parameter infix_sl: t -> t -> t.

Axiom infix_sl_def :
  forall (x:t) (y:t), ((infix_sl x y) = (infix_asdt x (inv y))).

Axiom add_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sl (infix_pldt x y) z) =
   (infix_pldt (infix_sl x z) (infix_sl y z))).

Axiom sub_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sl (infix_mn x y) z) = (infix_mn (infix_sl x z) (infix_sl y z))).

Axiom neg_div :
  forall (x:t) (y:t), ~ (y = tzero) ->
  ((infix_sl (prefix_mndt x) y) = (prefix_mndt (infix_sl x y))).

Axiom assoc_mul_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sl (infix_asdt x y) z) = (infix_asdt x (infix_sl y z))).

Axiom assoc_div_mul :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sl (infix_sl x y) z) = (infix_sl x (infix_asdt y z))).

Axiom assoc_div_div :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sl x (infix_sl y z)) = (infix_sl (infix_asdt x z) y)).

Parameter infix_mndt: t -> t -> t.

Axiom infix_mndt_def :
  forall (x:t) (y:t), ((infix_mndt x y) = (infix_pldt x (prefix_mndt y))).

Parameter infix_sldt: t -> t -> t.

Axiom infix_sldt_def :
  forall (x:t) (y:t), ~ (y = tzero) ->
  ((infix_sldt x y) = (infix_asdt x (inv y))).

Axiom infix_sldt_spec :
  forall (x:t) (y:t), ~ (y = tzero) ->
  ((infix_sldt x y) = (infix_asdt x (inv y))).

Parameter infix_slas: R -> R -> R.

Axiom infix_slas_def :
  forall (x:R) (y:R), ~ (y = 0%R) -> ((infix_slas x y) = (x / y)%R).

Parameter infix_eqas: R -> R -> Prop.

Axiom infix_eqas_def :
  forall (x:R) (y:R), (infix_eqas x y) <-> (infix_eqeq x y).

Axiom infix_eqas_spec : forall (x:R) (y:R), (infix_eqas x y) -> (x = y).

Axiom infix_eqas_spec1 : forall (x:R) (y:R), (x = y) -> infix_eqas x y.

Parameter infix_lsgtas: R -> R -> Prop.

Axiom infix_lsgtas_def :
  forall (x:R) (y:R), (infix_lsgtas x y) <-> ~ (infix_eqeq x y).

Axiom infix_lsgtas_spec :
  forall (x:R) (y:R), (infix_lsgtas x y) -> ~ (x = y).

Axiom infix_lsgtas_spec1 : forall (x:R) (y:R), ~ (x = y) -> infix_lsgtas x y.

Parameter infix_plas: R -> R -> R.

Axiom infix_plas_def : forall (x:R) (y:R), ((infix_plas x y) = (x + y)%R).

Parameter infix_mnas: R -> R -> R.

Axiom infix_mnas_def :
  forall (x:R) (y:R), ((infix_mnas x y) = (x + (-y)%R)%R).

Parameter infix_asas: R -> R -> R.

Axiom infix_asas_def : forall (x:R) (y:R), ((infix_asas x y) = (x * y)%R).

Parameter infix_lseqas: R -> R -> Prop.

Axiom infix_lseqas_def :
  forall (x:R) (y:R), (infix_lseqas x y) <-> (x <= y)%R.

Parameter prefix_mnas: R -> R.

Axiom prefix_mnas_def : forall (y:R), ((prefix_mnas y) = (-y)%R).

Parameter infix_lsas: R -> R -> Prop.

Axiom infix_lsas_def :
  forall (x:R) (y:R),
  (infix_lsas x y) <-> ((infix_lseqas x y) /\ (infix_lsgtas x y)).

Parameter infix_gtas: R -> R -> Prop.

Axiom infix_gtas_def :
  forall (x:R) (y:R), (infix_gtas x y) <-> (infix_lsas y x).

Parameter infix_gteqas: R -> R -> Prop.

Axiom infix_gteqas_def :
  forall (x:R) (y:R), (infix_gteqas x y) <-> (infix_lseqas y x).

Parameter from_int: Z -> R.

Axiom from_int_spec : forall (x:Z), ((from_int x) = (BuiltIn.IZR x)).

Axiom Zero : ((from_int 0%Z) = 0%R).

Axiom Add :
  forall (x:Z) (y:Z),
  ((from_int (x + y)%Z) = (infix_plas (from_int x) (from_int y))).

Axiom One : ((from_int 1%Z) = 1%R).

Axiom Sub :
  forall (x:Z) (y:Z),
  ((from_int (x - y)%Z) = (infix_mnas (from_int x) (from_int y))).

Axiom mul_pos :
  forall (x:Z) (y:Z), (0%Z <= y)%Z ->
  ((from_int (x * y)%Z) = (infix_asas (from_int x) (from_int y))).

Axiom mul :
  forall (x:Z) (y:Z), (0%Z <= y)%Z ->
  ((from_int (x * y)%Z) = (infix_asas (from_int x) (from_int y))).

Axiom mul_rev :
  forall (x:Z) (y:Z), (0%Z <= y)%Z ->
  ((infix_asas (from_int x) (from_int y)) = (from_int (x * y)%Z)).

Axiom neg : forall (x:Z), ((from_int (-x)%Z) = (prefix_mnas (from_int x))).

Axiom injective :
  forall (x:Z) (y:Z), ((from_int x) = (from_int y)) -> (x = y).

Axiom Monotonic :
  forall (x:Z) (y:Z), (x <= y)%Z -> infix_lseqas (from_int x) (from_int y).

Axiom positive_inv :
  forall (x:R), (infix_lsas 0%R x) -> infix_lsas 0%R (infix_slas 1%R x).

Axiom r_zeroLessOne : infix_lseqas 0%R 1%R.

Axiom r_compatOrderAdd :
  forall (x:R) (y:R) (z:R), (infix_lseqas x y) ->
  infix_lseqas (infix_plas x z) (infix_plas y z).

Axiom r_compatOrderMult :
  forall (x:R) (y:R) (z:R), (infix_lseqas x y) -> (infix_lseqas 0%R z) ->
  infix_lseqas (infix_asas x z) (infix_asas y z).

Axiom inv_order :
  forall (a:R) (b:R), (infix_lsas 0%R a) -> (infix_lsas 0%R b) ->
  (infix_lseqas a b) -> infix_lseqas (1%R / b)%R (1%R / a)%R.

Axiom inv_strict_order :
  forall (a:R) (b:R), (infix_lsas 0%R a) -> (infix_lsas 0%R b) ->
  (infix_lsas a b) -> infix_lsas (1%R / b)%R (1%R / a)%R.

Axiom invol_neg : forall (a:t), ((prefix_mndt (prefix_mndt a)) = a).

Axiom injective_neg :
  forall (a:t) (b:t), ((prefix_mndt a) = (prefix_mndt b)) -> (a = b).

Axiom find_opposite :
  forall (a:t) (b:t), ((infix_mndt a b) = tzero) -> (a = b).

Axiom add_opposite : forall (a:t), ((infix_pldt a (prefix_mndt a)) = tzero).

Axiom opposite : forall (a:t), ((infix_mndt a a) = tzero).

Axiom mult_num :
  forall (a:t) (b:t) (c:t), ~ (c = tzero) ->
  ((infix_sldt (infix_asdt a b) c) = (infix_asdt a (infix_sldt b c))).

Axiom div_as_mult_inv :
  forall (a:t) (b:t), ~ (b = tzero) ->
  ((infix_sldt a b) = (infix_asdt a (infix_sldt tone b))).

Axiom div_rev :
  forall (a:t) (b:t), ~ (b = tzero) ->
  ((infix_asdt a (infix_sldt tone b)) = (infix_sldt a b)).

Axiom mult_div_num :
  forall (a:t) (b:t) (c:t), ~ (c = tzero) ->
  ((infix_asdt (infix_sldt a c) b) = (infix_sldt (infix_asdt a b) c)).

Axiom mult_denom :
  forall (a:t) (b:t) (c:t), ~ (c = tzero) -> ~ (b = tzero) ->
  ((infix_sldt a (infix_asdt b c)) =
   (infix_asdt (infix_sldt a b) (infix_sldt tone c))).

Axiom mult_simpl :
  forall (a:t) (b:t) (c:t), ~ (c = tzero) -> ~ (b = tzero) ->
  ((infix_sldt (infix_asdt a b) (infix_asdt c b)) = (infix_sldt a c)).

Axiom simpl_with_tone :
  forall (a:t) (b:t), ~ (a = tzero) -> ~ (b = tzero) ->
  ((infix_asdt (infix_sldt a b) (infix_sldt tone a)) = (infix_sldt tone b)).

Parameter im: t.

Axiom im_Def : ((infix_asdt im im) = (prefix_mndt tone)).

Parameter ttwo: t.

Axiom ttwo_def : (ttwo = (infix_pldt tone tone)).

Parameter r_to_t: R -> t.

Axiom r_to_t_zero : ((r_to_t 0%R) = tzero).

Axiom r_to_t_one : ((r_to_t 1%R) = tone).

Axiom r_to_t_add :
  forall (i:R) (j:R),
  ((infix_pldt (r_to_t i) (r_to_t j)) = (r_to_t (infix_plas i j))).

Axiom r_to_t_opp :
  forall (i:R), ((r_to_t (prefix_mnas i)) = (prefix_mndt (r_to_t i))).

Axiom r_to_t_div :
  forall (i:R) (j:R), ~ (j = 0%R) ->
  ((r_to_t (infix_slas i j)) = (infix_sldt (r_to_t i) (r_to_t j))).

Axiom r_to_t_mult :
  forall (i:R) (j:R),
  ((infix_asdt (r_to_t i) (r_to_t j)) = (r_to_t (infix_asas i j))).

Axiom r_to_t_sub :
  forall (i:R) (j:R),
  ((infix_mndt (r_to_t i) (r_to_t j)) = (r_to_t (infix_mnas i j))).

Parameter real_part: t -> R.

Parameter im_part: t -> R.

Axiom Real_part_add :
  forall (i:t) (j:t),
  ((real_part (infix_pldt i j)) = (infix_plas (real_part i) (real_part j))).

Axiom Im_part_add :
  forall (i:t) (j:t),
  ((im_part (infix_pldt i j)) = (infix_plas (im_part i) (im_part j))).

Axiom Real_part_opposite :
  forall (i:t), ((real_part (prefix_mndt i)) = (prefix_mnas (real_part i))).

Axiom Im_part_opposite :
  forall (i:t), ((im_part (prefix_mndt i)) = (prefix_mnas (im_part i))).

Axiom Complex_decomp :
  forall (i:t),
  (i =
   (infix_pldt (r_to_t (real_part i)) (infix_asdt im (r_to_t (im_part i))))).

Axiom Unic_decomp :
  forall (i:t), forall (x:R) (y:R),
  (i = (infix_pldt (r_to_t x) (infix_asdt im (r_to_t y)))) ->
  (x = (real_part i)).

Axiom Unic_decomp1 :
  forall (i:t), forall (x:R) (y:R),
  (i = (infix_pldt (r_to_t x) (infix_asdt im (r_to_t y)))) ->
  (y = (im_part i)).

Axiom unic_decomp :
  forall (i:t) (x:R) (y:R),
  (i = (infix_pldt (r_to_t x) (infix_asdt im (r_to_t y)))) ->
  (x = (real_part i)).

Axiom unic_decomp1 :
  forall (i:t) (x:R) (y:R),
  (i = (infix_pldt (r_to_t x) (infix_asdt im (r_to_t y)))) ->
  (y = (im_part i)).

Axiom decomp_mult :
  forall (a:t) (b:t),
  ((infix_asdt a b) =
   (infix_pldt
    (infix_mndt (infix_asdt (r_to_t (real_part a)) (r_to_t (real_part b)))
     (infix_asdt (r_to_t (im_part a)) (r_to_t (im_part b))))
    (infix_asdt im
     (infix_pldt (infix_asdt (r_to_t (real_part a)) (r_to_t (im_part b)))
      (infix_asdt (r_to_t (real_part b)) (r_to_t (im_part a))))))).

Axiom decomp_mult_real_part :
  forall (a:t) (b:t),
  ((real_part (infix_asdt a b)) =
   (infix_mnas (infix_asas (real_part a) (real_part b))
    (infix_asas (im_part a) (im_part b)))).

Axiom decomp_mult_im_part :
  forall (a:t) (b:t),
  ((im_part (infix_asdt a b)) =
   (infix_plas (infix_asas (real_part a) (im_part b))
    (infix_asas (real_part b) (im_part a)))).

Axiom non_zero_prod :
  forall (a:t) (b:t), ~ (a = tzero) -> ~ (b = tzero) ->
  ~ ((infix_asdt a b) = tzero).

Axiom minus_tone :
  forall (a:t), ((prefix_mndt a) = (infix_asdt (prefix_mndt tone) a)).

Axiom mult_neg_l :
  forall (a:t) (b:t),
  ((infix_asdt (prefix_mndt a) b) = (prefix_mndt (infix_asdt a b))).

Axiom mult_neg_r :
  forall (a:t) (b:t),
  ((infix_asdt a (prefix_mndt b)) = (prefix_mndt (infix_asdt a b))).

Axiom neg_neg_out : forall (a:t), ((prefix_mndt (prefix_mndt a)) = a).

Axiom div_neg_l :
  forall (a:t) (b:t), ~ (b = tzero) ->
  ((infix_sldt (prefix_mndt a) b) = (prefix_mndt (infix_sldt a b))).

Axiom div_neg_r :
  forall (a:t) (b:t), ~ (b = tzero) ->
  ((infix_sldt a (prefix_mndt b)) = (prefix_mndt (infix_sldt a b))).

Axiom invadd :
  forall (i:t), ((prefix_mndt i) = (infix_asdt (prefix_mndt tone) i)).

Axiom notZeroAdd :
  forall (x:t) (y:t), ~ (x = tzero) -> ~ ((infix_pldt x y) = y).

Axiom Absorbing_zero :
  forall (a:t) (b:t), ((infix_asdt a b) = tzero) -> ~ (a = tzero) ->
  (b = tzero).

Axiom Absorbing_zero1 :
  forall (a:t) (b:t), (a = tzero) -> ((infix_asdt a b) = tzero).

Axiom Absorbing_zero2 :
  forall (a:t) (b:t), (b = tzero) -> ((infix_asdt a b) = tzero).

Axiom real_part_add :
  forall (i:t) (j:t),
  ((real_part (infix_pldt i j)) = (infix_plas (real_part i) (real_part j))).

Axiom mult_im_rev : forall (a:t), ((infix_asdt a im) = (infix_asdt im a)).

Axiom im_im_elim :
  forall (a:t), ((infix_asdt im (infix_asdt im a)) = (prefix_mndt a)).

Axiom im_im_fact :
  forall (a:t) (b:t),
  ((infix_asdt (infix_asdt im a) (infix_asdt im b)) =
   (prefix_mndt (infix_asdt a b))).

Axiom minus_minus_fact :
  forall (a:t) (b:t),
  ((infix_asdt (prefix_mndt a) (prefix_mndt b)) = (infix_asdt a b)).

Axiom minus_minus_add :
  forall (a:t) (b:t),
  ((infix_pldt (prefix_mndt a) (prefix_mndt b)) =
   (prefix_mndt (infix_pldt a b))).

Axiom minus_minus_add_rev :
  forall (a:t) (b:t),
  ((prefix_mndt (infix_pldt a b)) =
   (infix_pldt (prefix_mndt a) (prefix_mndt b))).

Axiom minus_out_left :
  forall (a:t) (b:t),
  ((infix_asdt (prefix_mndt a) b) = (prefix_mndt (infix_asdt a b))).

Axiom minus_out_right :
  forall (a:t) (b:t),
  ((infix_asdt a (prefix_mndt b)) = (prefix_mndt (infix_asdt a b))).

Axiom minus_in_left :
  forall (a:t) (b:t),
  ((prefix_mndt (infix_asdt a b)) = (infix_asdt (prefix_mndt a) b)).

Axiom minus_in_right :
  forall (a:t) (b:t),
  ((prefix_mndt (infix_asdt a b)) = (infix_asdt a (prefix_mndt b))).

Axiom minus_add_out_left :
  forall (a:t) (b:t),
  ((infix_pldt (prefix_mndt a) b) =
   (prefix_mndt (infix_pldt a (prefix_mndt b)))).

Axiom minus_add_out_right :
  forall (a:t) (b:t),
  ((infix_pldt a (prefix_mndt b)) =
   (prefix_mndt (infix_pldt (prefix_mndt a) b))).

Axiom minus_add_in :
  forall (a:t) (b:t),
  ((prefix_mndt (infix_pldt a b)) =
   (infix_pldt (prefix_mndt a) (prefix_mndt b))).

Axiom minus_add_out :
  forall (a:t) (b:t),
  ((infix_pldt (prefix_mndt a) (prefix_mndt b)) =
   (prefix_mndt (infix_pldt a b))).

Axiom minus_eq :
  forall (a:t) (b:t), (a = b) -> ((prefix_mndt a) = (prefix_mndt b)).

Axiom im_out_right :
  forall (a:t) (b:t),
  ((infix_asdt (infix_asdt im a) b) = (infix_asdt im (infix_asdt a b))).

Axiom im_out_left :
  forall (a:t) (b:t),
  ((infix_asdt a (infix_asdt im b)) = (infix_asdt im (infix_asdt a b))).

Axiom im_part_add :
  forall (i:t) (j:t),
  ((im_part (infix_pldt i j)) = (infix_plas (im_part i) (im_part j))).

Axiom injective_real_part :
  forall (i:t) (j:t), ~ ((real_part i) = (real_part j)) -> ~ (i = j).

Axiom injective_im_part :
  forall (i:t) (j:t), ~ ((im_part i) = (im_part j)) -> ~ (i = j).

Axiom complex_decomp :
  forall (i:t),
  (i =
   (infix_pldt (r_to_t (real_part i)) (infix_asdt im (r_to_t (im_part i))))).

Parameter real_: t -> Prop.

Axiom real__def : forall (x:t), (real_ x) <-> (infix_eqeq (im_part x) 0%R).

Parameter pure_im_: t -> Prop.

Axiom pure_im__def :
  forall (x:t), (pure_im_ x) <-> (infix_eqeq (real_part x) 0%R).

Axiom r_to_t_real : forall (x:t), (real_ x) -> (x = (r_to_t (real_part x))).

Axiom real_r_to_t : forall (x:R), real_ (r_to_t x).

Axiom r_to_t_pure_im :
  forall (x:t), (pure_im_ x) -> (x = (infix_asdt im (r_to_t (im_part x)))).

Axiom simpl_frac :
  forall (x:t) (y:t), ~ (y = tzero) -> ((infix_sldt (infix_asdt x y) y) = x).

Axiom simpl_frac_ :
  forall (x:t) (y:t) (z:t), ~ (y = tzero) -> ~ (z = tzero) ->
  ((infix_sldt (infix_asdt x y) (infix_asdt z y)) = (infix_sldt x z)).

Axiom fact_frac :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sldt (infix_asdt x y) z) = (infix_asdt x (infix_sldt y z))).

Axiom fact_frac_rev :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_asdt x (infix_sldt y z)) = (infix_sldt (infix_asdt x y) z)).

Axiom inv_mult :
  forall (x:t) (y:t), ~ (x = tzero) -> ~ (y = tzero) ->
  ((infix_asdt (infix_sldt tone x) (infix_sldt tone y)) =
   (infix_sldt tone (infix_asdt x y))).

Axiom div_div :
  forall (x:t) (y:t) (z:t), ~ (y = tzero) -> ~ (z = tzero) ->
  ((infix_sldt (infix_sldt x y) z) = (infix_sldt x (infix_asdt y z))).

Axiom div_div_rev :
  forall (x:t) (y:t) (z:t), ~ (y = tzero) -> ~ (z = tzero) ->
  ((infix_sldt x (infix_asdt y z)) = (infix_sldt (infix_sldt x y) z)).

Axiom involutive_inv :
  forall (a:t), ~ (a = tzero) -> ((infix_sldt tone (infix_sldt tone a)) = a).

Axiom twice : forall (i:t), ((infix_asdt ttwo i) = (infix_pldt i i)).

Axiom twice_half : ((infix_asdt ttwo (infix_sldt tone ttwo)) = tone).

Axiom half_plus_half :
  forall (i:t), ((infix_pldt (infix_sldt i ttwo) (infix_sldt i ttwo)) = i).

Parameter infix_lseqdt: t -> t -> Prop.

Axiom infix_lseqdt_def :
  forall (x:t) (y:t),
  (infix_lseqdt x y) <->
  (((real_ x) /\ ((real_ y) /\ (infix_lseqas (real_part x) (real_part y)))) \/
   (infix_eqeq x y)).

Parameter infix_lsdt: t -> t -> Prop.

Axiom infix_lsdt_def :
  forall (x:t) (y:t),
  (infix_lsdt x y) <-> ((infix_lseqdt x y) /\ ~ (infix_eqeq x y)).

Parameter infix_gteqdt: t -> t -> Prop.

Axiom infix_gteqdt_def :
  forall (x:t) (y:t), (infix_gteqdt x y) <-> (infix_lseqdt y x).

Parameter infix_gtdt: t -> t -> Prop.

Axiom infix_gtdt_def :
  forall (x:t) (y:t),
  (infix_gtdt x y) <-> ((infix_gteqdt x y) /\ ~ (infix_eqeq x y)).

Axiom Refl : forall (x:t), infix_lseqdt x x.

Axiom Trans :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (infix_lseqdt y z) ->
  infix_lseqdt x z.

Axiom Antisymm :
  forall (x:t) (y:t), (infix_lseqdt x y) -> (infix_lseqdt y x) -> (x = y).

Axiom Refl1 : forall (x:t), infix_gteqdt x x.

Axiom Trans1 :
  forall (x:t) (y:t) (z:t), (infix_gteqdt x y) -> (infix_gteqdt y z) ->
  infix_gteqdt x z.

Axiom Antisymm1 :
  forall (x:t) (y:t), (infix_gteqdt x y) -> (infix_gteqdt y x) -> (x = y).

Axiom Trans2 :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (infix_lsdt y z) ->
  infix_lsdt x z.

Axiom Asymm : forall (x:t) (y:t), (infix_lsdt x y) -> ~ (infix_lsdt y x).

Axiom Trans3 :
  forall (x:t) (y:t) (z:t), (infix_gtdt x y) -> (infix_gtdt y z) ->
  infix_gtdt x z.

Axiom Asymm1 : forall (x:t) (y:t), (infix_gtdt x y) -> ~ (infix_gtdt y x).

Axiom r_to_t_inf :
  forall (i:R) (j:R), (infix_lseqdt (r_to_t i) (r_to_t j)) ->
  infix_lseqas i j.

Axiom r_to_t_inf1 :
  forall (i:R) (j:R), (infix_lseqas i j) ->
  infix_lseqdt (r_to_t i) (r_to_t j).

Parameter pi: t.

Axiom pi_def : real_ pi.

Axiom pi_def1 : infix_lsdt tzero pi.

Axiom inf_to_non_sup_eq :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> (infix_lsdt x y) ->
  ~ (infix_gteqdt x y).

Axiom sup_eq_to_non_inf :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> (infix_gteqdt x y) ->
  ~ (infix_lsdt x y).

Axiom sup_to_inf :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> (infix_gtdt x y) ->
  infix_lsdt y x.

Axiom inf_to_sup :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> (infix_lsdt x y) ->
  infix_gtdt y x.

Axiom sup_to_non_inf_eq :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> (infix_gtdt x y) ->
  ~ (infix_lseqdt x y).

Axiom inf_eq_to_non_sup :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> (infix_lseqdt x y) ->
  ~ (infix_gtdt x y).

Axiom non_inf_eq_to_sup :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> ~ (infix_lseqdt x y) ->
  infix_gtdt x y.

Axiom non_sup_toinf_eq :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> ~ (infix_gtdt x y) ->
  infix_lseqdt x y.

Axiom eq_to_leq_t :
  forall (a:t) (b:t), (real_ a) -> (a = b) -> infix_lseqdt a b.

Axiom compat_r_to_t_infeq :
  forall (a:R) (b:R), (infix_lseqas a b) ->
  infix_lseqdt (r_to_t a) (r_to_t b).

Axiom compat_r_to_t_inf :
  forall (a:R) (b:R), (infix_lsas a b) -> infix_lsdt (r_to_t a) (r_to_t b).

Axiom compat_r_to_t_supeq :
  forall (a:R) (b:R), (infix_gteqas a b) ->
  infix_gteqdt (r_to_t a) (r_to_t b).

Axiom compat_r_to_t_sup :
  forall (a:R) (b:R), (infix_gtas a b) -> infix_gtdt (r_to_t a) (r_to_t b).

Axiom unic_inv :
  forall (i:t) (j:t), ~ (i = tzero) -> ((infix_asdt i j) = tone) ->
  (j = (inv i)).

Axiom inf_eq_def :
  forall (x:t) (y:t), (infix_lseqdt x y) -> (real_ x) \/ (x = y).

Axiom inf_eq_def1 :
  forall (x:t) (y:t), (infix_lseqdt x y) -> (real_ y) \/ (x = y).

Axiom inf_eq_def2 :
  forall (x:t) (y:t), (infix_lseqdt x y) ->
  (infix_lseqas (real_part x) (real_part y)) \/ (x = y).

Axiom inf_eq_def3 :
  forall (x:t) (y:t),
  ((real_ x) /\ ((real_ y) /\ (infix_lseqas (real_part x) (real_part y)))) ->
  infix_lseqdt x y.

Axiom inf_eq_def4 : forall (x:t) (y:t), (x = y) -> infix_lseqdt x y.

Axiom inf_minus :
  forall (x:t) (y:t), (infix_lsdt x y) ->
  infix_lsdt (prefix_mndt y) (prefix_mndt x).

Parameter t_real_part: t -> t.

Axiom t_real_part_def :
  forall (x:t), ((t_real_part x) = (r_to_t (real_part x))).

Axiom t_real_part_spec : forall (x:t), real_ (t_real_part x).

Axiom t_real_part_inv :
  forall (x:t),
  ((t_real_part (prefix_mndt x)) = (prefix_mndt (t_real_part x))).

Parameter t_im_part: t -> t.

Axiom t_im_part_def : forall (x:t), ((t_im_part x) = (r_to_t (im_part x))).

Axiom t_im_part_spec : forall (x:t), real_ (t_im_part x).

Axiom t_im_part_inv :
  forall (x:t), ((t_im_part (prefix_mndt x)) = (prefix_mndt (t_im_part x))).

Axiom absorbing_zero :
  forall (a:t) (b:t), ((infix_asdt a b) = tzero) -> ~ (a = tzero) ->
  (b = tzero).

Axiom absorbing_zero1 :
  forall (a:t) (b:t), ((infix_asdt a b) = tzero) -> ~ (b = tzero) ->
  (a = tzero).

Axiom t_mult_real :
  forall (a:t) (b:t),
  ((t_real_part (infix_asdt a b)) =
   (infix_mndt (infix_asdt (t_real_part a) (t_real_part b))
    (infix_asdt (t_im_part a) (t_im_part b)))).

Axiom mult_real_real :
  forall (a:t) (b:t), (real_ a) -> (real_ b) ->
  ((infix_asdt a b) =
   (infix_asdt (r_to_t (real_part a)) (r_to_t (real_part b)))).

Axiom mult_real_real1 :
  forall (a:t) (b:t), (real_ a) -> (real_ b) ->
  ((infix_asdt (r_to_t (real_part a)) (r_to_t (real_part b))) =
   (r_to_t (infix_asas (real_part a) (real_part b)))).

Axiom mult_real_real2 :
  forall (a:t) (b:t), (real_ a) -> (real_ b) ->
  ((real_part (infix_asdt a b)) = (infix_asas (real_part a) (real_part b))).

Axiom mult_real_real3 :
  forall (a:t) (b:t), (real_ a) -> (real_ b) ->
  ((im_part (infix_asdt a b)) = 0%R).

Axiom compat_order_mult :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lseqdt tzero z) ->
  infix_lseqdt (infix_asdt x z) (infix_asdt y z).

Axiom mult_pos :
  forall (x:t) (y:t), (infix_lseqdt tzero x) -> (infix_lseqdt tzero y) ->
  infix_lseqdt tzero (infix_asdt x y).

Axiom strict_mult_pos :
  forall (x:t) (y:t), (infix_lsdt tzero x) -> (infix_lsdt tzero y) ->
  infix_lsdt tzero (infix_asdt x y).

Axiom rewrite_supeq :
  forall (x:t) (y:t), (infix_lseqdt x y) -> infix_gteqdt y x.

Axiom rewrite_sup : forall (x:t) (y:t), (infix_lsdt x y) -> infix_gtdt y x.

Axiom inf_def : forall (x:t) (y:t), (infix_lsdt x y) -> real_ x.

Axiom inf_def1 : forall (x:t) (y:t), (infix_lsdt x y) -> real_ y.

Axiom inf_def2 :
  forall (x:t) (y:t), (infix_lsdt x y) ->
  infix_lsas (real_part x) (real_part y).

Axiom inf_def3 :
  forall (x:t) (y:t),
  ((real_ x) /\ ((real_ y) /\ (infix_lsas (real_part x) (real_part y)))) ->
  infix_lsdt x y.

Axiom sup_eq_def :
  forall (x:t) (y:t), (infix_gteqdt x y) -> (real_ x) \/ (x = y).

Axiom sup_eq_def1 :
  forall (x:t) (y:t), (infix_gteqdt x y) -> (real_ y) \/ (x = y).

Axiom sup_eq_def2 :
  forall (x:t) (y:t), (infix_gteqdt x y) ->
  (infix_gteqas (real_part x) (real_part y)) \/ (x = y).

Axiom sup_eq_def3 :
  forall (x:t) (y:t),
  ((real_ x) /\ ((real_ y) /\ (infix_gteqas (real_part x) (real_part y)))) ->
  infix_gteqdt x y.

Axiom sup_eq_def4 : forall (x:t) (y:t), (x = y) -> infix_gteqdt x y.

Axiom sup_def : forall (x:t) (y:t), (infix_gtdt x y) -> real_ x.

Axiom sup_def1 : forall (x:t) (y:t), (infix_gtdt x y) -> real_ y.

Axiom sup_def2 :
  forall (x:t) (y:t), (infix_gtdt x y) ->
  infix_gtas (real_part x) (real_part y).

Axiom sup_def3 :
  forall (x:t) (y:t),
  ((real_ x) /\ ((real_ y) /\ (infix_gtas (real_part x) (real_part y)))) ->
  infix_gtdt x y.

Axiom assoc_mult_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_asdt x (infix_sldt y z)) = (infix_sldt (infix_asdt x y) z)).

Axiom transitive_infeq :
  forall (a:t) (b:t) (c:t), (infix_lseqdt a b) -> (infix_lseqdt b c) ->
  infix_lseqdt a c.

Axiom infeq_scal_r :
  forall (a:t) (b:t) (c:t), (infix_lseqdt a c) -> (infix_lseqdt tzero b) ->
  infix_lseqdt (infix_asdt a b) (infix_asdt c b).

Axiom infeq_scal_l :
  forall (a:t) (b:t) (c:t), (infix_lseqdt a c) -> (infix_lseqdt tzero b) ->
  infix_lseqdt (infix_asdt b a) (infix_asdt b c).

Axiom transitive_supeq :
  forall (a:t) (b:t) (c:t), (infix_gteqdt a b) -> (infix_gteqdt b c) ->
  infix_gteqdt a c.

Axiom transitive_inf_l :
  forall (a:t) (b:t) (c:t), (infix_lsdt a b) -> (infix_lseqdt b c) ->
  infix_lsdt a c.

Axiom transitive_sup_l :
  forall (a:t) (b:t) (c:t), (infix_gtdt a b) -> (infix_gteqdt b c) ->
  infix_gtdt a c.

Axiom transitive_inf_r :
  forall (a:t) (b:t) (c:t), (infix_lseqdt a b) -> (infix_lsdt b c) ->
  infix_lsdt a c.

Axiom transitive_sup_r :
  forall (a:t) (b:t) (c:t), (infix_gteqdt a b) -> (infix_gtdt b c) ->
  infix_gtdt a c.

Axiom compat_mult_sup_eq_right :
  forall (a:t) (b:t) (c:t), (infix_lseqdt tzero a) -> (infix_gteqdt b c) ->
  infix_gteqdt (infix_asdt a b) (infix_asdt a c).

Axiom compat_mult_sup_right :
  forall (a:t) (b:t) (c:t), (infix_lsdt tzero a) -> (infix_gtdt b c) ->
  infix_gtdt (infix_asdt a b) (infix_asdt a c).

Axiom compat_mult_inf_right :
  forall (a:t) (b:t) (c:t), (infix_lsdt tzero a) -> (infix_lsdt b c) ->
  infix_lsdt (infix_asdt a b) (infix_asdt a c).

Axiom infeq_to_supeq :
  forall (a:t) (b:t), (infix_lseqdt a b) -> infix_gteqdt b a.

Axiom supeq_elim_left :
  forall (a:t) (b:t), (infix_gteqdt a b) ->
  infix_gteqdt tzero (infix_mndt b a).

Axiom sup_elim_left :
  forall (a:t) (b:t), (infix_gtdt a b) -> infix_gtdt tzero (infix_mndt b a).

Axiom infeq_elim_left :
  forall (a:t) (b:t), (infix_lseqdt a b) ->
  infix_lseqdt tzero (infix_mndt b a).

Axiom inf_elim_left :
  forall (a:t) (b:t), (infix_lsdt a b) -> infix_lsdt tzero (infix_mndt b a).

Axiom t_im_real :
  forall (a:t) (b:t),
  ((t_im_part (infix_asdt a b)) =
   (infix_pldt (infix_asdt (t_real_part a) (t_im_part b))
    (infix_asdt (t_im_part a) (t_real_part b)))).

Axiom t_decomp_mult :
  forall (a:t) (b:t),
  ((infix_asdt a b) =
   (infix_pldt
    (infix_mndt (infix_asdt (t_real_part a) (t_real_part b))
     (infix_asdt (t_im_part a) (t_im_part b)))
    (infix_asdt im
     (infix_pldt (infix_asdt (t_real_part a) (t_im_part b))
      (infix_asdt (t_im_part a) (t_real_part b)))))).

Axiom t_complex_decomp :
  forall (i:t),
  (i = (infix_pldt (t_real_part i) (infix_asdt im (t_im_part i)))).

Axiom t_unic_decomp :
  forall (i:t) (a:t) (b:t), (real_ a) -> (real_ b) ->
  (i = (infix_pldt a (infix_asdt im b))) -> (a = (t_real_part i)).

Axiom t_unic_decomp1 :
  forall (i:t) (a:t) (b:t), (real_ a) -> (real_ b) ->
  (i = (infix_pldt a (infix_asdt im b))) -> (b = (t_im_part i)).

Axiom t_decomp_minus :
  forall (i:t) (a:t) (b:t), (real_ a) -> (real_ b) ->
  (i = (infix_mndt a (infix_asdt im b))) -> (a = (t_real_part i)).

Axiom t_decomp_minus1 :
  forall (i:t) (a:t) (b:t), (real_ a) -> (real_ b) ->
  (i = (infix_mndt a (infix_asdt im b))) -> ((prefix_mndt b) = (t_im_part i)).

Axiom real_sum :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> real_ (infix_pldt x y).

Axiom set : forall (a:Type), Type.
Parameter set_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set a).
Existing Instance set_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> Prop.

Parameter infix_eqeq1:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom infix_eqeq_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq1 s1 s2) -> forall (x:a),
  (mem x s1) -> mem x s2.

Axiom infix_eqeq_spec3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq1 s1 s2) -> forall (x:a),
  (mem x s2) -> mem x s1.

Axiom infix_eqeq_spec4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (forall (x:a), (mem x s1) <-> (mem x s2)) ->
  infix_eqeq1 s1 s2.

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq1 s1 s2) -> (s1 = s2).

Parameter subset:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) -> forall (x:a), (mem x s1) ->
  mem x s2.

Axiom subset_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (forall (x:a), (mem x s1) -> mem x s2) ->
  subset s1 s2.

Axiom subset_refl :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set a), subset s s.

Axiom subset_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (s3:set a), (subset s1 s2) ->
  (subset s2 s3) -> subset s1 s3.

Parameter is_empty: forall {a:Type} {a_WT:WhyType a}, (set a) -> Prop.

Axiom is_empty_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (is_empty s) -> forall (x:a), ~ (mem x s).

Axiom is_empty_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (x:a), ~ (mem x s)) -> is_empty s.

Parameter empty: forall {a:Type} {a_WT:WhyType a}, set a.

Axiom empty_def : forall {a:Type} {a_WT:WhyType a}, is_empty (empty : set a).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom add_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a), (mem y (add x s)) ->
  (y = x) \/ (mem y s).

Axiom add_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a), (y = x) -> mem y (add x s).

Axiom add_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a), (mem y s) -> mem y (add x s).

Parameter singleton: forall {a:Type} {a_WT:WhyType a}, a -> set a.

Axiom singleton_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), ((singleton x) = (add x (empty : set a))).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom remove_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a), (mem y (remove x s)) -> ~ (y = x).

Axiom remove_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a), (mem y (remove x s)) -> mem y s.

Axiom remove_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a), (~ (y = x) /\ (mem y s)) ->
  mem y (remove x s).

Axiom add_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), (mem x s) -> ((add x (remove x s)) = s).

Axiom remove_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), ((remove x (add x s)) = (remove x s)).

Axiom subset_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), subset (remove x s) s.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), (mem x (union s1 s2)) ->
  (mem x s1) \/ (mem x s2).

Axiom union_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), (mem x s1) ->
  mem x (union s1 s2).

Axiom union_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), (mem x s2) ->
  mem x (union s1 s2).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom inter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), (mem x (inter s1 s2)) ->
  mem x s1.

Axiom inter_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), (mem x (inter s1 s2)) ->
  mem x s2.

Axiom inter_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), ((mem x s1) /\ (mem x s2)) ->
  mem x (inter s1 s2).

Parameter diff:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom diff_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), (mem x (diff s1 s2)) ->
  mem x s1.

Axiom diff_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), (mem x (diff s1 s2)) ->
  ~ (mem x s2).

Axiom diff_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a), ((mem x s1) /\ ~ (mem x s2)) ->
  mem x (diff s1 s2).

Axiom subset_diff :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), subset (diff s1 s2) s1.

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom choose_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> mem (choose s) s.

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set a) -> Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) >= 0%Z)%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 0%Z) -> is_empty s.

Axiom cardinal_empty1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (is_empty s) -> ((cardinal s) = 0%Z).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), ~ (mem x s) ->
  ((cardinal (add x s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), (mem x s) ->
  ((cardinal s) = (1%Z + (cardinal (remove x s)))%Z).

Axiom cardinal_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) <= (cardinal s2))%Z.

Axiom subset_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) = (cardinal s2)) -> infix_eqeq1 s1 s2.

Axiom cardinal1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) ->
  (x = (choose s)).

Axiom real_diff :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> real_ (infix_mndt x y).

Axiom pure_im_sum :
  forall (x:t) (y:t), (pure_im_ x) -> (pure_im_ y) ->
  pure_im_ (infix_pldt x y).

Axiom equal_decomp :
  forall (x:t) (y:t), ((real_part x) = (real_part y)) ->
  ((im_part x) = (im_part y)) -> (x = y).

Axiom t_equal_decomp :
  forall (x:t) (y:t), ((t_real_part x) = (t_real_part y)) ->
  ((t_im_part x) = (t_im_part y)) -> (x = y).

Axiom pure_im_diff :
  forall (x:t) (y:t), (pure_im_ x) -> (pure_im_ y) ->
  pure_im_ (infix_mndt x y).

Axiom real_mult :
  forall (x:t) (y:t), (real_ x) -> (real_ y) -> real_ (infix_asdt x y).

Axiom real_inv :
  forall (x:t), (real_ x) -> ~ (x = tzero) -> real_ (infix_sldt tone x).

Axiom inv_pos :
  forall (x:t), (real_ x) -> (infix_lsdt tzero x) ->
  infix_gtdt (infix_sldt tone x) tzero.

Axiom lower_over_cons :
  forall (a:t) (b:t) (c:t), (infix_lsdt tzero c) -> (infix_lseqdt tzero a) ->
  (infix_lseqdt a b) -> infix_lseqdt (infix_sldt a c) (infix_sldt b c).

Axiom real_div :
  forall (x:t) (y:t), (real_ x) -> ~ (y = tzero) -> (real_ y) ->
  real_ (infix_sldt x y).

Axiom mult_im_im :
  forall (a:t) (b:t), (pure_im_ a) -> (pure_im_ b) ->
  ((infix_asdt a b) =
   (infix_asdt (infix_asdt im im)
    (infix_asdt (r_to_t (im_part a)) (r_to_t (im_part b))))).

Axiom mult_im_im1 :
  forall (a:t) (b:t), (pure_im_ a) -> (pure_im_ b) ->
  ((infix_asdt a b) =
   (prefix_mndt (r_to_t (infix_asas (im_part a) (im_part b))))).

Axiom mult_im_im2 :
  forall (a:t) (b:t), (pure_im_ a) -> (pure_im_ b) ->
  ((real_part (infix_asdt a b)) =
   (prefix_mnas (infix_asas (im_part a) (im_part b)))).

Axiom mult_im_im3 :
  forall (a:t) (b:t), (pure_im_ a) -> (pure_im_ b) ->
  ((im_part (infix_asdt a b)) = 0%R).

Axiom mult_real_im :
  forall (a:t) (b:t), (real_ a) -> (pure_im_ b) ->
  ((infix_asdt a b) =
   (infix_asdt im (infix_asdt (r_to_t (real_part a)) (r_to_t (im_part b))))).

Axiom mult_real_im1 :
  forall (a:t) (b:t), (real_ a) -> (pure_im_ b) ->
  ((infix_asdt a b) =
   (infix_asdt im (r_to_t (infix_asas (real_part a) (im_part b))))).

Axiom mult_real_im2 :
  forall (a:t) (b:t), (real_ a) -> (pure_im_ b) ->
  ((real_part (infix_asdt a b)) = 0%R).

Axiom mult_real_im3 :
  forall (a:t) (b:t), (real_ a) -> (pure_im_ b) ->
  ((im_part (infix_asdt a b)) = (infix_asas (real_part a) (im_part b))).

Axiom mult_im_real :
  forall (a:t) (b:t), (pure_im_ a) -> (real_ b) ->
  ((infix_asdt a b) =
   (infix_asdt im (infix_asdt (r_to_t (im_part a)) (r_to_t (real_part b))))).

Axiom mult_im_real1 :
  forall (a:t) (b:t), (pure_im_ a) -> (real_ b) ->
  ((infix_asdt a b) =
   (infix_asdt im (r_to_t (infix_asas (im_part a) (real_part b))))).

Axiom mult_im_real2 :
  forall (a:t) (b:t), (pure_im_ a) -> (real_ b) ->
  ((real_part (infix_asdt a b)) = 0%R).

Axiom mult_im_real3 :
  forall (a:t) (b:t), (pure_im_ a) -> (real_ b) ->
  ((im_part (infix_asdt a b)) = (infix_asas (im_part a) (real_part b))).

Axiom decomp_mult_gen :
  forall (a:t) (b:t),
  ((real_part (infix_asdt a b)) =
   (infix_mnas (infix_asas (real_part a) (real_part b))
    (infix_asas (im_part a) (im_part b)))).

Axiom decomp_mult_gen1 :
  forall (a:t) (b:t),
  ((im_part (infix_asdt a b)) =
   (infix_plas (infix_asas (real_part a) (im_part b))
    (infix_asas (im_part a) (real_part b)))).

Axiom inv_real :
  forall (a:t), ~ (a = tzero) -> (real_ a) ->
  ((real_part (infix_sldt tone a)) = (infix_slas 1%R (real_part a))).

Axiom inv_real1 :
  forall (a:t), ~ (a = tzero) -> (real_ a) -> real_ (infix_sldt tone a).

Axiom zeroLessOne : infix_lseqdt tzero tone.

Axiom compatOrderAdd :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> infix_lseqdt (infix_pldt x z) (infix_pldt y z).

Axiom positive_add :
  forall (x:t) (y:t), (infix_lseqdt tzero x) -> (infix_lseqdt tzero y) ->
  infix_lseqdt tzero (infix_pldt x y).

Axiom strict_positive_add_l :
  forall (x:t) (y:t), (infix_lsdt tzero x) -> (infix_lseqdt tzero y) ->
  infix_lsdt tzero (infix_pldt x y).

Axiom strict_compatOrderAdd :
  forall (x:t) (y:t) (z:t) (t1:t), (infix_lsdt x y) -> (infix_lsdt z t1) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (real_ t1) ->
  infix_lsdt (infix_pldt x z) (infix_pldt y t1).

Axiom compat_sup_add :
  forall (x:t) (y:t) (z:t) (t1:t), (infix_gtdt x y) -> (infix_gtdt z t1) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (real_ t1) ->
  infix_gtdt (infix_pldt x z) (infix_pldt y t1).

Axiom compat_supeq_mult :
  forall (x:t) (y:t) (z:t), (infix_gteqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lseqdt tzero z) ->
  infix_gteqdt (infix_asdt x z) (infix_asdt y z).

Axiom compat_supeq_div :
  forall (x:t) (y:t) (z:t), (infix_gteqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_gteqdt (infix_sldt x z) (infix_sldt y z).

Axiom compat_infeq_div :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_lseqdt (infix_sldt x z) (infix_sldt y z).

Axiom compat_sup_div :
  forall (x:t) (y:t) (z:t), (infix_gtdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_gtdt (infix_sldt x z) (infix_sldt y z).

Axiom compat_inf_div :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_lsdt (infix_sldt x z) (infix_sldt y z).

Axiom strict_compat_order_mult :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_lsdt (infix_asdt x z) (infix_asdt y z).

Axiom compat_order_mult_left :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lseqdt tzero z) ->
  infix_lseqdt (infix_asdt x z) (infix_asdt y z).

Axiom strict_compat_order_mult_left :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_lsdt (infix_asdt z x) (infix_asdt z y).

Axiom positive_prod_itself :
  forall (x:t), (real_ x) -> infix_lseqdt tzero (infix_asdt x x).

Axiom strict_positive_prod_itself :
  forall (x:t), (real_ x) -> ~ (x = tzero) ->
  infix_lsdt tzero (infix_asdt x x).

Axiom compat_sup_mult :
  forall (x:t) (y:t) (z:t), (infix_gteqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lseqdt tzero z) ->
  infix_gteqdt (infix_asdt x z) (infix_asdt y z).

Axiom strict_compat_sup_mult :
  forall (x:t) (y:t) (z:t), (infix_gtdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_gtdt (infix_asdt x z) (infix_asdt y z).

Axiom compat_sup_mult_left :
  forall (x:t) (y:t) (z:t), (infix_gteqdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lseqdt tzero z) ->
  infix_gteqdt (infix_asdt z x) (infix_asdt z y).

Axiom strict_compat_sup_mult_left :
  forall (x:t) (y:t) (z:t), (infix_gtdt x y) -> (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt tzero z) ->
  infix_gtdt (infix_asdt z x) (infix_asdt z y).

Axiom inv_inf_eq :
  forall (a:t) (b:t), (infix_lsdt tzero a) -> (infix_lsdt tzero b) ->
  (infix_lseqdt a b) -> infix_lseqdt (infix_sldt tone b) (infix_sldt tone a).

Axiom inv_sup_eq :
  forall (a:t) (b:t), (infix_lsdt tzero a) -> (infix_lsdt tzero b) ->
  (infix_gteqdt a b) -> infix_gteqdt (infix_sldt tone b) (infix_sldt tone a).

Axiom inv_sup :
  forall (x:t) (y:t), (real_ x) -> (real_ y) ->
  ((infix_lsdt tzero x) /\ (infix_lsdt x y)) ->
  infix_gtdt (infix_sldt tone x) (infix_sldt tone y).

Axiom inv_eqinf :
  forall (x:t) (y:t), (real_ x) -> (real_ y) ->
  ((infix_lsdt tzero x) /\ (infix_lseqdt x y)) ->
  infix_gteqdt (infix_sldt tone x) (infix_sldt tone y).

Axiom inv_eqsup :
  forall (x:t) (y:t), (real_ x) -> (real_ y) ->
  ((infix_gteqdt x y) /\ (infix_gtdt y tzero)) ->
  infix_lseqdt (infix_sldt tone x) (infix_sldt tone y).

Axiom inv_inf :
  forall (x:t) (y:t), (real_ x) -> (real_ y) ->
  ((infix_gtdt x y) /\ (infix_gtdt y tzero)) ->
  infix_lsdt (infix_sldt tone x) (infix_sldt tone y).

Axiom inv_neg :
  forall (x:t), (real_ x) -> (infix_gtdt tzero x) ->
  infix_lsdt (infix_sldt tone x) tzero.

Axiom lower_inv :
  forall (a:t) (b:t) (c:t), (infix_lsdt tzero b) -> (infix_lseqdt tzero a) ->
  (infix_lseqdt b c) -> infix_gteqdt (infix_sldt a b) (infix_sldt a c).

Axiom zero_add_t :
  forall (a1:t) (a2:t), (a1 = tzero) -> ((infix_pldt a1 a2) = a2).

Axiom add_zero_t :
  forall (a1:t) (a2:t), (a2 = tzero) -> ((infix_pldt a1 a2) = a1).

Axiom one_mult_t :
  forall (a1:t) (a2:t), (a1 = tone) -> ((infix_asdt a1 a2) = a2).

Axiom one_mult_t_const : forall (a:t), ((infix_asdt tone a) = a).

Axiom zero_mult_t_const : forall (a:t), ((infix_asdt tzero a) = tzero).

Axiom mult_zero_t_const : forall (a:t), ((infix_asdt a tzero) = tzero).

Axiom zero_mult_t :
  forall (a1:t) (a2:t), (a1 = tzero) -> ((infix_asdt a1 a2) = tzero).

Axiom mult_zero_t :
  forall (a1:t) (a2:t), (a1 = tzero) -> ((infix_asdt a2 a1) = tzero).

Axiom mult_one_t :
  forall (a1:t) (a2:t), (a2 = tone) -> ((infix_asdt a1 a2) = a1).

Axiom add_eq_t :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ((infix_pldt a1 b1) = (infix_pldt a2 b2)).

Axiom add_eq_t_rev :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ((infix_pldt a1 b1) = (infix_pldt b2 a2)).

Axiom subs_eq :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ((infix_mndt a1 b1) = (infix_mndt a2 b2)).

Axiom subst_itself :
  forall (a1:t) (a2:t), (a1 = a2) -> ((infix_mndt a1 a2) = tzero).

Axiom add_op :
  forall (a1:t) (a2:t), (a1 = (prefix_mndt a2)) ->
  ((infix_pldt a1 a2) = tzero).

Axiom mult_eq_t :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ((infix_asdt a1 b1) = (infix_asdt a2 b2)).

Axiom mult_eq_t_rev :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ((infix_asdt a1 b1) = (infix_asdt b2 a2)).

Axiom mult_comm : forall (a:t) (b:t), ((infix_asdt a b) = (infix_asdt b a)).

Axiom mult_assoc :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt (infix_asdt a b) c) = (infix_asdt a (infix_asdt b c))).

Axiom mult_assoc_rev :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt a (infix_asdt b c)) = (infix_asdt (infix_asdt a b) c)).

Axiom div_mult :
  forall (a:t) (b:t) (c:t), ~ (c = tzero) ->
  ((infix_asdt a (infix_sldt b c)) = (infix_sldt (infix_asdt a b) c)).

Axiom div_mult_rev :
  forall (a:t) (b:t) (c:t), ~ (c = tzero) ->
  ((infix_sldt (infix_asdt a b) c) = (infix_asdt a (infix_sldt b c))).

Axiom triang_p :
  forall (a:t) (b:t),
  ((infix_asdt (infix_pldt a b) (infix_pldt a b)) =
   (infix_pldt
    (infix_pldt (infix_asdt a a) (infix_asdt (infix_asdt ttwo a) b))
    (infix_asdt b b))).

Axiom triang_n :
  forall (a:t) (b:t),
  ((infix_asdt (infix_mndt a b) (infix_mndt a b)) =
   (infix_pldt
    (infix_mndt (infix_asdt a a) (infix_asdt (infix_asdt ttwo a) b))
    (infix_asdt b b))).

Axiom triang_s :
  forall (a:t) (b:t) (c:t) (d:t) (e:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c)
    (infix_pldt (infix_mndt d b) e))
   = (infix_pldt (infix_pldt a c) (infix_pldt d e))).

Axiom triang_t :
  forall (a:t) (b:t),
  ((infix_asdt (infix_pldt a b) (infix_mndt a b)) =
   (infix_mndt (infix_asdt a a) (infix_asdt b b))).

Axiom triang_sr :
  forall (a:t) (b:t) (c:t) (d:t) (e:t),
  ((infix_pldt (infix_pldt (infix_mndt a b) c)
    (infix_pldt (infix_pldt d b) e))
   = (infix_pldt (infix_pldt a c) (infix_pldt d e))).

Axiom add_pos :
  forall (x:t) (y:t), (infix_lseqdt tzero x) -> (infix_lseqdt tzero y) ->
  infix_lseqdt tzero (infix_pldt x y).

Axiom add_pos_strit_l :
  forall (x:t) (y:t), (infix_lsdt tzero x) -> (infix_lseqdt tzero y) ->
  infix_lsdt tzero (infix_pldt x y).

Axiom add_pos_strit_r :
  forall (x:t) (y:t), (infix_lseqdt tzero x) -> (infix_lsdt tzero y) ->
  infix_lsdt tzero (infix_pldt x y).

Axiom modulus_pre_pre :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_asdt a b) (infix_asdt c d))
    (infix_pldt (infix_asdt a d) (infix_asdt c b)))
   =
   (infix_pldt (infix_asdt a (infix_pldt b d))
    (infix_asdt c (infix_pldt b d)))).

Axiom modulus_pre_pre1 :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_asdt a b) (infix_asdt c d))
    (infix_pldt (infix_asdt a d) (infix_asdt c b)))
   = (infix_asdt (infix_pldt a c) (infix_pldt b d))).

Axiom modulus_pre :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt
    (infix_pldt (infix_asdt (infix_asdt a b) (infix_asdt a b))
     (infix_asdt (infix_asdt c d) (infix_asdt c d)))
    (infix_pldt (infix_asdt (infix_asdt a d) (infix_asdt a d))
     (infix_asdt (infix_asdt c b) (infix_asdt c b))))
   =
   (infix_asdt (infix_pldt (infix_asdt a a) (infix_asdt c c))
    (infix_pldt (infix_asdt b b) (infix_asdt d d)))).

Parameter real_sqrt: R -> R.

Axiom real_sqrt_spec : forall (x:R), ((real_sqrt x) = (Reals.R_sqrt.sqrt x)).

Parameter square_rt: t -> t.

Axiom square_rt_def :
  forall (x:t), (infix_lseqdt tzero x) ->
  ((square_rt x) = (r_to_t (real_sqrt (real_part x)))).

Axiom square_rt_spec :
  forall (x:t), (infix_lseqdt tzero x) ->
  ((infix_asdt (square_rt x) (square_rt x)) = x).

Axiom square_rt_spec1 :
  forall (x:t), (infix_lseqdt tzero x) -> infix_lseqdt tzero (square_rt x).

Axiom square_rt_eq :
  forall (a:t) (b:t), (a = b) -> ((square_rt a) = (square_rt b)).

Axiom real_square_rt :
  forall (x:t), (real_ x) -> (infix_lseqdt tzero x) -> real_ (square_rt x).

Axiom pos_square_rt :
  forall (x:t), (real_ x) -> (infix_lseqdt tzero x) ->
  infix_gteqdt (square_rt x) tzero.

Axiom square_rt_mult :
  forall (t1:t) (t':t), (real_ t1) -> (infix_lseqdt tzero t1) ->
  (real_ t') -> (infix_lseqdt tzero t') ->
  ((infix_asdt (square_rt t1) (square_rt t')) =
   (square_rt (infix_asdt t1 t'))).

Parameter modulus: t -> t.

Axiom modulus_def :
  forall (x:t),
  ((modulus x) =
   (square_rt
    (infix_pldt (infix_asdt (t_real_part x) (t_real_part x))
     (infix_asdt (t_im_part x) (t_im_part x))))).

Axiom modulus_spec : forall (x:t), infix_lseqdt tzero (modulus x).

Parameter tone_modulus: t -> Prop.

Axiom tone_modulus_def :
  forall (x:t), (tone_modulus x) <-> ((modulus x) = tone).

Axiom modulus_eq :
  forall (x:t) (y:t),
  ((infix_asdt (t_real_part x) (t_real_part x)) =
   (infix_asdt (t_real_part y) (t_real_part y))) ->
  ((infix_asdt (t_im_part x) (t_im_part x)) =
   (infix_asdt (t_im_part y) (t_im_part y))) ->
  ((modulus x) = (modulus y)).

Axiom modulus_itself :
  forall (x:t) (y:t), (x = y) -> ((modulus x) = (modulus y)).

Axiom modulus_real_pos :
  forall (x:t), (real_ x) -> (infix_lseqdt tzero x) -> ((modulus x) = x).

Axiom strict_positive_modulus :
  forall (x:t), ~ (x = tzero) -> infix_lsdt tzero (modulus x).

Axiom mult_modulus :
  forall (x:t) (y:t),
  ((modulus (infix_asdt x y)) = (infix_asdt (modulus x) (modulus y))).

Axiom mult_tone_modulus :
  forall (x:t) (y:t), (tone_modulus x) -> (tone_modulus y) ->
  tone_modulus (infix_asdt x y).

Axiom modulus_pos :
  forall (x:t), ~ (x = tzero) -> infix_lseqdt tzero (modulus x).

Axiom div_eq :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ~ (b1 = tzero) -> ((infix_sldt a1 b1) = (infix_sldt a2 b2)).

Axiom add_eq_inv_t :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ((infix_pldt a1 b1) = (infix_pldt b2 a2)).

Axiom mult_eq_inv_t :
  forall (a1:t) (a2:t) (b1:t) (b2:t), (a1 = a2) -> (b1 = b2) ->
  ((infix_asdt a1 b1) = (infix_asdt b2 a2)).

Axiom sum_frac :
  forall (a1:t) (a2:t) (b:t), ~ (b = tzero) ->
  ((infix_pldt (infix_sldt a1 b) (infix_sldt a2 b)) =
   (infix_sldt (infix_pldt a1 a2) b)).

Axiom sum_frac_rev :
  forall (a1:t) (a2:t) (b:t), ~ (b = tzero) ->
  ((infix_sldt (infix_pldt a1 a2) b) =
   (infix_pldt (infix_sldt a1 b) (infix_sldt a2 b))).

Parameter op: forall {im1:Type} {im1_WT:WhyType im1}, im1 -> im1 -> im1.

Parameter po: forall {im1:Type} {im1_WT:WhyType im1}, im1 -> im1 -> im1.

Parameter inver: forall {im1:Type} {im1_WT:WhyType im1}, im1 -> im1.

Parameter filter:
  forall {a:Type} {a_WT:WhyType a}, (a -> bool) -> (set a) -> set a.

Axiom filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), forall (x:a), (mem x (filter p u)) ->
  ((p x) = true).

Axiom filter_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), forall (x:a), (mem x (filter p u)) ->
  mem x u.

Axiom filter_def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), forall (x:a),
  (((p x) = true) /\ (mem x u)) -> mem x (filter p u).

Axiom filter_cardinal :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), ((cardinal (filter p u)) <= (cardinal u))%Z.

Parameter map:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> set b.

Axiom map_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (y:b), (mem y (map f u)) ->
  exists x:a, (mem x u) /\ (y = (f x)).

Axiom map_def11 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (y:b),
  (exists x:a, (mem x u) /\ (y = (f x))) -> mem y (map f u).

Axiom map_def2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (x:a), (mem x u) -> mem (f x) (map f u).

Axiom map_cardinal :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((cardinal (map f u)) <= (cardinal u))%Z.

Parameter eq_e: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom eq_e_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a), (eq_e a1 a') <-> (a1 = a').

Parameter fir:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a* b)%type ->
  a.

Parameter sec:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a* b)%type ->
  b.

Axiom projections :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (o:(a* b)%type), (o = (fir o, sec o)).

Axiom get_fir :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (b1:b), ((fir (a1, b1)) = a1).

Axiom get_sec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (b1:b), ((sec (a1, b1)) = b1).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

Parameter prefix_ex: forall {a:Type} {a_WT:WhyType a}, (ref a) -> a.

Axiom prefix_ex_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:ref a), ((prefix_ex r) = (contents r)).

Axiom set_equal :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (forall (e:a), (mem e s) -> mem e s') ->
  (forall (e:a), (mem e s') -> mem e s) -> (s = s').

Axiom union_exchange :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ~ (is_empty s') ->
  ((union (add (choose s') s) (remove (choose s') s')) = (union s s')).

Axiom get_filter :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (s:set a) (x:a), (mem x (filter p s)) ->
  ((p x) = true).

Axiom get_filter1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (s:set a) (x:a), (mem x (filter p s)) -> mem x s.

Axiom set_filter :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (s:set a) (x:a), ((p x) = true) -> (mem x s) ->
  mem x (filter p s).

Axiom inter_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s) -> is_empty (inter s s').

Axiom inter_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> is_empty (inter s s').

Axiom inter_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((inter s s') = (inter s' s)).

Axiom union_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((union s s') = (union s' s)).

Axiom union_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s) -> ((union s s') = s').

Axiom union_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> ((union s s') = s).

Axiom union_members :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), forall (a1:a), (mem a1 (union s s')) ->
  ~ (mem a1 s) -> mem a1 s'.

Axiom union_members1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), forall (a1:a), (mem a1 (union s s')) ->
  ~ (mem a1 s') -> mem a1 s.

Axiom union_alt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (e:a), (mem e (union s s')) -> ~ (mem e s) ->
  mem e s'.

Axiom union_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> ((union s s') = s).

Axiom set_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s':set a) (s:set a), (forall (e:a), (mem e s') -> mem e s) ->
  subset s' s.

Axiom set_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (e:a), ~ (mem e s)) -> (s = (empty : set a)).

Axiom set_empty1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (e:a), ~ (mem e s)) -> is_empty s.

Axiom get_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (s = (empty : set a)) -> forall (e:a), ~ (mem e s).

Axiom get_empty1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (s = (empty : set a)) -> is_empty s.

Axiom get_non_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> exists e:a, mem e s.

Axiom set_non_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (exists e:a, mem e s) -> ~ (is_empty s).

Axiom set_non_empty1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (exists e:a, mem e s) -> ((cardinal s) > 0%Z)%Z.

Axiom set_pos_card_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (mem a1 s) -> ((cardinal s) > 0%Z)%Z.

Axiom union_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((union s (add x s')) = (add x (union s s'))).

Axiom union_add_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a) (y:a), (mem x (add y (union s s'))) ->
  ~ (mem x s') -> ~ (mem x s) -> (x = y).

Axiom union_add_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((add x (union s s')) = (union s (add x s'))).

Axiom remove_add1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:a), ~ (mem x s) -> ((remove x (add x s)) = s).

Axiom add_remove1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:a), (mem x s) -> ((add x (remove x s)) = s).

Parameter p_injective:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> Prop.

Axiom p_injective_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a),
  (p_injective f s) <->
  forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
  ~ ((f e) = (f e')).

Axiom set_map_mem :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b),
  (exists a1:a, (mem a1 s) /\ (b1 = (f a1))) -> mem b1 (map f s).

Axiom map_add :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (x:a), ~ (mem x s) ->
  ((map f (add x s)) = (add (f x) (map f s))).

Axiom map_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b) (s:set a),
  (forall (e:a), (mem e s) -> ((f e) = (g e))) -> ((map f s) = (map g s)).

Axiom remove_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (e:a) (f:a), (mem e (remove f s)) -> mem e s.

Axiom injective_map_cardinal :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) ->
  ((cardinal (map f s)) = (cardinal s)).

Axiom set_map_mem_el :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b) (a1:a), (mem a1 s) -> (b1 = (f a1)) ->
  mem b1 (map f s).

Axiom set_map_mem_el_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b),
  (exists a1:a, (mem a1 s) /\ (b1 = (f a1))) -> mem b1 (map f s).

Axiom map_antec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b), (mem b1 (map f s)) ->
  exists a1:a, (mem a1 s) /\ (b1 = (f a1)).

Axiom map_antec_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), forall (b1:b), (mem b1 (map f s)) ->
  exists a1:a, (mem a1 s) /\ (b1 = (f a1)).

Axiom map_remove_choose :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b), (p_injective f s) ->
  ((map f (remove (choose s) s)) = (remove (f (choose s)) (map f s))).

Parameter antec_set:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (a -> b) -> b -> set a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  b -> a -> bool.

Axiom result_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (b1:b) (e:a),
  (((result f b1) e) = true) <-> (eq_e (f e) b1).

Axiom antec_set_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  ((antec_set s f b1) = (filter (result f b1) s)).

Parameter remove_s:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Parameter result1: forall {a:Type} {a_WT:WhyType a}, (set a) -> a -> bool.

Axiom result_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s':set a) (e:a), (((result1 s') e) = true) <-> ~ (mem e s').

Axiom remove_s_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (subset s' s) ->
  ((remove_s s s') = (filter (result1 s') s)).

Axiom remove_s_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (subset s' s) -> forall (e:a),
  (mem e (remove_s s s')) -> mem e s.

Axiom remove_s_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (subset s' s) -> forall (e:a),
  (mem e (remove_s s s')) -> ~ (mem e s').

Axiom remove_s_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (subset s' s) -> forall (e:a),
  ((mem e s) /\ ~ (mem e s')) -> mem e (remove_s s s').

Parameter remove_antecs:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (a -> b) -> b -> set a.

Axiom remove_antecs_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  ((remove_antecs s f b1) = (remove_s s (antec_set s f b1))).

Axiom remove_antecs_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) -> forall (e:a),
  (mem e (remove_antecs s f b1)) -> mem e s.

Axiom remove_antecs_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) -> forall (e:a),
  (mem e (remove_antecs s f b1)) -> ~ ((f e) = b1).

Axiom remove_antecs_spec2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) -> forall (e:a),
  ((mem e s) /\ ~ ((f e) = b1)) -> mem e (remove_antecs s f b1).

Axiom remove_antecs_spec3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  ((cardinal (remove_antecs s f b1)) < (cardinal s))%Z.

Axiom map_remove_antec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  ((map f (remove_antecs s f b1)) = (remove b1 (map f s))).

Axiom map_non_empty :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((cardinal s) > 0%Z)%Z ->
  ((cardinal (map f s)) > 0%Z)%Z.

Axiom non_empty_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((cardinal (map f s)) > 0%Z)%Z ->
  ((cardinal s) > 0%Z)%Z.

Parameter right_injections:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, a -> (set b) ->
  set (a* b)%type.

Axiom right_injections_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), (is_empty s) ->
  ((right_injections a1 s) = (empty : set (a* b)%type)).

Axiom right_injections_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), ~ (is_empty s) ->
  ((right_injections a1 s) =
   (add (a1, choose s) (right_injections a1 (remove (choose s) s)))).

Axiom right_injections_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((cardinal (right_injections a1 s)) = (cardinal s)).

Axiom right_injections_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), forall (a':a), forall (b1:b),
  (mem (a', b1) (right_injections a1 s)) -> (a' = a1).

Axiom right_injections_spec2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), forall (a':a), forall (b1:b),
  (mem (a', b1) (right_injections a1 s)) -> mem b1 s.

Axiom right_injections_spec3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), forall (a':a), forall (b1:b),
  ((a' = a1) /\ (mem b1 s)) -> mem (a', b1) (right_injections a1 s).

Axiom right_injections_spec4 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((right_injections a1 s) = (map (fun (b1:b) => (a1, b1)) s)).

Parameter left_injections:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) -> b ->
  set (a* b)%type.

Axiom left_injections_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), (is_empty s) ->
  ((left_injections s b1) = (empty : set (a* b)%type)).

Axiom left_injections_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), ~ (is_empty s) ->
  ((left_injections s b1) =
   (add (choose s, b1) (left_injections (remove (choose s) s) b1))).

Axiom left_injections_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), forall (a1:a), forall (b':b),
  (mem (a1, b') (left_injections s b1)) -> mem a1 s.

Axiom left_injections_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), forall (a1:a), forall (b':b),
  (mem (a1, b') (left_injections s b1)) -> (b' = b1).

Axiom left_injections_spec2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), forall (a1:a), forall (b':b),
  ((mem a1 s) /\ (b' = b1)) -> mem (a1, b') (left_injections s b1).

Axiom left_injections_spec3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), ((cardinal (left_injections s b1)) = (cardinal s)).

Axiom left_injections_spec4 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  ((left_injections s b1) = (map (fun (a1:a) => (a1, b1)) s)).

Axiom right_injections_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((cardinal (right_injections a1 s)) = (cardinal s)).

Axiom right_injections_l1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), forall (a':a), forall (b1:b),
  (mem (a', b1) (right_injections a1 s)) -> (a' = a1).

Axiom right_injections_l2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), forall (a':a), forall (b1:b),
  (mem (a', b1) (right_injections a1 s)) -> mem b1 s.

Axiom right_injections_l3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b), forall (a':a), forall (b1:b),
  ((a' = a1) /\ (mem b1 s)) -> mem (a', b1) (right_injections a1 s).

Axiom right_injections_l4 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((right_injections a1 s) = (map (fun (b1:b) => (a1, b1)) s)).

Axiom left_injections_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), forall (a1:a), forall (b':b),
  (mem (a1, b') (left_injections s b1)) -> mem a1 s.

Axiom left_injections_l1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), forall (a1:a), forall (b':b),
  (mem (a1, b') (left_injections s b1)) -> (b' = b1).

Axiom left_injections_l2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), forall (a1:a), forall (b':b),
  ((mem a1 s) /\ (b' = b1)) -> mem (a1, b') (left_injections s b1).

Axiom left_injections_l3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b), ((cardinal (left_injections s b1)) = (cardinal s)).

Axiom left_injections_l4 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  ((left_injections s b1) = (map (fun (a1:a) => (a1, b1)) s)).

Axiom disjoint_injections :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b) (c:b), ~ (b1 = c) ->
  is_empty (inter (right_injections b1 s) (right_injections c s)).

Axiom disjoint_injections1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b) (c:b), ~ (b1 = c) ->
  is_empty (inter (left_injections s b1) (left_injections s c)).

Axiom induction :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:(set a) -> bool) (t1:set a),
  (forall (s:set a), (is_empty s) -> ((p s) = true)) ->
  (forall (s:set a), ((p s) = true) -> forall (t2:a), ~ (mem t2 s) ->
   ((p (add t2 s)) = true)) ->
  ((p t1) = true).

Axiom cardinal_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a),
  ((cardinal (union s s')) =
   (((cardinal s) + (cardinal s'))%Z - (cardinal (inter s s')))%Z).

Axiom cardinal_sum_empty_inter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((inter s s') = (empty : set a)) ->
  ((cardinal (union s s')) = ((cardinal s) + (cardinal s'))%Z).

Parameter cartesian_product:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (set b) -> set (a* b)%type.

Axiom cartesian_product_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((cardinal (cartesian_product s1 s2)) = ((cardinal s1) * (cardinal s2))%Z).

Axiom cartesian_product_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (a1:a), forall (b1:b),
  (mem (a1, b1) (cartesian_product s1 s2)) -> mem a1 s1.

Axiom cartesian_product_spec2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (a1:a), forall (b1:b),
  (mem (a1, b1) (cartesian_product s1 s2)) -> mem b1 s2.

Axiom cartesian_product_spec3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (a1:a), forall (b1:b),
  ((mem a1 s1) /\ (mem b1 s2)) -> mem (a1, b1) (cartesian_product s1 s2).

Axiom cartesian_product_spec4 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type),
  (mem o (cartesian_product s1 s2)) -> mem (fir o) s1.

Axiom cartesian_product_spec5 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type),
  (mem o (cartesian_product s1 s2)) -> mem (sec o) s2.

Axiom cartesian_product_spec6 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type),
  ((mem (fir o) s1) /\ (mem (sec o) s2)) -> mem o (cartesian_product s1 s2).

Parameter commute:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a* b)%type ->
  (b* a)%type.

Axiom commute_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (o:(a* b)%type),
  match o with
  | (a1, b1) => ((commute o) = (b1, a1))
  end.

Axiom commute_inj :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b), ~ (a1 = a') ->
  ~ ((commute (a1, b1)) = (commute (a', b'))).

Axiom commute_inj1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b), ~ (b1 = b') ->
  ~ ((commute (a1, b1)) = (commute (a', b'))).

Axiom mem_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (a1:a) (b1:b), (mem a1 s1) -> (mem b1 s2) ->
  mem (a1, b1) (cartesian_product s1 s2).

Axiom commute_inj_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  p_injective (fun (y0:(a* b)%type) => (commute y0))
  (cartesian_product s1 s2).

Parameter commute_product:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (set b) -> set (b* a)%type.

Axiom commute_product_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((commute_product s1 s2) =
   (map (fun (y0:(a* b)%type) => (commute y0)) (cartesian_product s1 s2))).

Axiom commute_product_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((commute_product s1 s2) = (cartesian_product s2 s1)).

Parameter commute_product_el:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (set b) -> set (b* a)%type.

Axiom commute_product_el_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((commute_product_el s1 s2) =
   (map (fun (y0:(a* b)%type) => (commute y0)) (cartesian_product s1 s2))).

Axiom commute_product_el_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type), forall (x:a) (x1:b),
  (o = (x, x1)) -> (mem o (cartesian_product s1 s2)) -> mem x s1.

Axiom commute_product_el_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type), forall (x:a) (x1:b),
  (o = (x, x1)) -> (mem o (cartesian_product s1 s2)) -> mem x1 s2.

Axiom commute_product_el_spec2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type), forall (x:a) (x1:b),
  (o = (x, x1)) -> ((mem x s1) /\ (mem x1 s2)) ->
  mem o (cartesian_product s1 s2).

Axiom commute_product_el_spec3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type), forall (x:a) (x1:b),
  (o = (x, x1)) -> ((mem x s1) /\ (mem x1 s2)) ->
  mem (x1, x) (commute_product_el s1 s2).

Axiom commute_product_el_spec4 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type), forall (x:a) (x1:b),
  (o = (x, x1)) -> (mem (x1, x) (commute_product_el s1 s2)) -> mem x s1.

Axiom commute_product_el_spec5 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type), forall (x:a) (x1:b),
  (o = (x, x1)) -> (mem (x1, x) (commute_product_el s1 s2)) -> mem x1 s2.

Axiom cartesian_product_union :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (s3:set b),
  ((cartesian_product s1 (union s2 s3)) =
   (union (cartesian_product s1 s2) (cartesian_product s1 s3))).

Axiom cartesian_union_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set a) (s3:set b),
  ((cartesian_product (union s1 s2) s3) =
   (union (cartesian_product s1 s3) (cartesian_product s2 s3))).

Axiom cartesian_product_cardone_r :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s1) = 1%Z) ->
  infix_eqeq (cartesian_product s1 s2) (right_injections (choose s1) s2).

Axiom cartesian_product_cardone_r1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s1) = 1%Z) ->
  infix_eqeq (cartesian_product s1 s2)
  (map (fun (e2:b) => (choose s1, e2)) s2).

Axiom cartesian_product_cardone_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s2) = 1%Z) ->
  infix_eqeq (cartesian_product s1 s2) (left_injections s1 (choose s2)).

Axiom cartesian_product_cardone_l1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s2) = 1%Z) ->
  infix_eqeq (cartesian_product s1 s2)
  (map (fun (e1:a) => (e1, choose s2)) s1).

Axiom disjoint_cartesian_product_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set a) (s3:set b),
  ((inter s1 s2) = (empty : set a)) ->
  ((inter (cartesian_product s1 s3) (cartesian_product s2 s3)) =
   (empty : set (a* b)%type)).

Axiom disjoint_cartesian_product_r :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (s3:set b),
  ((inter s2 s3) = (empty : set b)) ->
  ((inter (cartesian_product s1 s2) (cartesian_product s1 s3)) =
   (empty : set (a* b)%type)).

Parameter iter_union:
  forall {a:Type} {a_WT:WhyType a}, (set (set a)) -> set a.

Axiom iter_union_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set (set a)), (is_empty s) -> ((iter_union s) = (empty : set a)).

Axiom iter_union_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set (set a)), ~ (is_empty s) ->
  ((iter_union s) = (union (choose s) (iter_union (remove (choose s) s)))).

Parameter op_neutral_left:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> im1 -> Prop.

Axiom op_neutral_left_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neutral:im1),
  (op_neutral_left op1 neutral) <-> forall (e:im1), (((op1 neutral) e) = e).

Parameter op_neutral_right:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> im1 -> Prop.

Axiom op_neutral_right_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neutral:im1),
  (op_neutral_right op1 neutral) <-> forall (e:im1), (((op1 e) neutral) = e).

Parameter op_assoc:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> Prop.

Axiom op_assoc_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1),
  (op_assoc op1) <->
  forall (a:im1) (b:im1) (c:im1),
  (((op1 ((op1 a) b)) c) = ((op1 a) ((op1 b) c))).

Parameter op_neutral_left_comm:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> im1 -> Prop.

Axiom op_neutral_left_comm_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neutral:im1),
  (op_neutral_left_comm op1 neutral) <->
  forall (a:im1), (forall (b:im1), (((op1 a) b) = b)) -> (a = neutral).

Parameter commut:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> Prop.

Axiom commut_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1),
  (commut op1) <-> forall (a:im1) (b:im1), (((op1 a) b) = ((op1 b) a)).

Parameter assoc:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> Prop.

Axiom assoc_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1),
  (assoc op1) <->
  forall (a:im1) (b:im1) (c:im1),
  (((op1 ((op1 a) b)) c) = ((op1 a) ((op1 b) c))).

Parameter opposite_n:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) ->
  (im1 -> im1 -> im1) -> im1 -> Prop.

Axiom opposite_n_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (neutral:im1),
  (opposite_n op1 po1 neutral) <-> forall (a:im1), (((po1 a) a) = neutral).

Parameter inverse:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) ->
  (im1 -> im1 -> im1) -> (im1 -> im1) -> Prop.

Axiom inverse_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (inver1:im1 -> im1),
  (inverse op1 po1 inver1) <->
  forall (a:im1) (b:im1), (((po1 a) b) = ((op1 a) (inver1 b))).

Parameter opposite1:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) ->
  (im1 -> im1 -> im1) -> Prop.

Axiom opposite_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1),
  (opposite1 op1 po1) <-> forall (a:im1) (b:im1), (((op1 ((po1 a) b)) b) = a).

Parameter opposite_com:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) ->
  (im1 -> im1 -> im1) -> Prop.

Axiom opposite_com_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1),
  (opposite_com op1 po1) <->
  forall (a:im1) (b:im1), (((po1 ((op1 a) b)) b) = a).

Axiom refl :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (a:im1) (b:im1), (commut op1) ->
  (((op1 a) b) = ((op1 b) a)).

Parameter neutral:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> im1 -> Prop.

Axiom neutral_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neut:im1),
  (neutral op1 neut) <->
  ((op_neutral_left op1 neut) /\
   ((op_neutral_right op1 neut) /\ (op_assoc op1))).

Axiom set_neutral :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neut:im1), (op_neutral_left op1 neut) ->
  (op_neutral_right op1 neut) -> (op_assoc op1) -> neutral op1 neut.

Parameter has_neutral:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> Prop.

Axiom has_neutral_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1),
  (has_neutral op1) <-> exists e:im1, neutral op1 e.

Parameter iterates:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> im1 -> Prop.

Axiom iterates_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neutral1:im1),
  (iterates op1 neutral1) <->
  ((op_neutral_left op1 neutral1) /\
   ((op_neutral_right op1 neutral1) /\ (op_assoc op1))).

Parameter iterable:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> Prop.

Axiom iterable_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1),
  (iterable op1) <-> exists e:im1, iterates op1 e.

Axiom iterates_ :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neutral1:im1),
  (op_neutral_left op1 neutral1) -> (op_neutral_right op1 neutral1) ->
  (op_assoc op1) -> iterates op1 neutral1.

Axiom iterates_1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (neutral1:im1),
  (op_neutral_left op1 neutral1) -> (op_neutral_right op1 neutral1) ->
  (op_assoc op1) -> iterable op1.

Parameter neutral_elt:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) -> im1.

Axiom neutral_elt_spec :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1), forall (e:im1), (neutral op1 e) ->
  ((neutral_elt op1) = e).

Axiom neutral_elt_spec1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1), forall (e:im1), ((neutral_elt op1) = e) ->
  neutral op1 e.

Parameter inverse_tuple:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) ->
  (im1 -> im1 -> im1) -> im1 -> Prop.

Axiom inverse_tuple_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (neutral1:im1),
  (inverse_tuple op1 po1 neutral1) <->
  ((opposite_n op1 po1 neutral1) /\
   ((opposite1 op1 po1) /\ (opposite_com op1 po1))).

Parameter iterate:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (set a) -> (a -> im1) -> im1.

Axiom Iterate_def_empty :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1), forall (s:set a), forall (f:a -> im1),
  (commut op1) -> (iterable op1) -> (is_empty s) ->
  ((iterate op1 (empty : set a) f) = (neutral_elt op1)).

Axiom Iterate_one :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1), forall (s:set a), forall (f:a -> im1),
  forall (x:a), (is_empty s) -> (commut op1) ->
  ((iterate op1 (add x s) f) = (f x)).

Axiom Iterate_add :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1), forall (s:set a), forall (f:a -> im1),
  forall (x:a), ((cardinal s) > 0%Z)%Z -> (commut op1) -> ~ (mem x s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom minus_zero :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (a:im1),
  (iterable op1) -> (inverse_tuple op1 po1 (neutral_elt op1)) ->
  (((po1 a) (neutral_elt op1)) = a).

Axiom unic :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (a:im1) (b:im1)
    (c:im1),
  (iterable op1) -> (commut op1) -> (((op1 a) b) = ((op1 a) c)) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) -> (b = c).

Axiom substract_comm :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (a:im1) (b:im1),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) -> (((po1 ((op1 a) b)) a) = b).

Axiom substract_comm1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (a:im1) (b:im1),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) -> (((po1 ((op1 b) a)) a) = b).

Axiom substract_comm2 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (a:im1) (b:im1)
    (c:im1),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  (((po1 a) ((po1 b) c)) = ((op1 ((po1 a) b)) c)).

Axiom substract_comm3 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (a:im1) (b:im1)
    (c:im1),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  (((po1 ((op1 a) b)) c) = ((op1 a) ((po1 b) c))).

Parameter int_iterate:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) ->
  (Z -> im1) -> Z -> Z -> im1.

Axiom int_iterate_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), ~ (j <= i)%Z ->
  (j <= i)%Z -> ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_def1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), ~ (j <= i)%Z ->
  ~ (j <= i)%Z -> (j = (i + 1%Z)%Z) -> ((int_iterate op1 f i j) = (f i)).

Axiom int_iterate_def2 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), ~ (j <= i)%Z ->
  ~ (j <= i)%Z -> ~ (j = (i + 1%Z)%Z) ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))).

Axiom int_iterate_def3 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (iterable op1) ->
  (j <= i)%Z -> ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_def4 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (iterable op1) ->
  ~ (j <= i)%Z -> (j = (i + 1%Z)%Z) -> ((int_iterate op1 f i j) = (f i)).

Axiom int_iterate_def5 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (iterable op1) ->
  ~ (j <= i)%Z -> ~ (j = (i + 1%Z)%Z) ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))).

Axiom int_iterate_spec :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), ~ (j <= i)%Z ->
  (j <= i)%Z -> ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_spec1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), ~ (j <= i)%Z ->
  (j = (i + 1%Z)%Z) ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (neutral_elt op1))).

Axiom int_iterate_spec2 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (iterable op1) ->
  (j <= i)%Z -> ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_spec3 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (iterable op1) ->
  (j = (i + 1%Z)%Z) ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (neutral_elt op1))).

Parameter int_int_iterate:
  forall {im1:Type} {im1_WT:WhyType im1}, (im1 -> im1 -> im1) ->
  (Z -> Z -> im1) -> Z -> Z -> Z -> Z -> im1.

Axiom int_int_iterate_def :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (iterable op1) -> (j <= i)%Z ->
  ((int_int_iterate op1 f i j k l) = (neutral_elt op1)).

Axiom int_int_iterate_def1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (iterable op1) -> ~ (j <= i)%Z ->
  ((int_int_iterate op1 f i j k l) =
   ((op1 (int_iterate op1 (f i) k l))
    (int_int_iterate op1 f (i + 1%Z)%Z j k l))).

Parameter element: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom element_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> ((element s) = (choose s)).

Axiom cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((cardinal s) > 0%Z)%Z -> ((cardinal s) = 1%Z).

Axiom cardone1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((cardinal s) > 0%Z)%Z -> ((element s) = a1).

Axiom set_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) > 0%Z)%Z ->
  (exists a1:a, forall (b:a), (mem b s) <-> (b = a1)) -> ((cardinal s) = 1%Z).

Axiom get_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) ->
  exists a1:a, forall (b:a), (mem b s) <-> (b = a1).

Axiom get_cardone_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (e:a), ((cardinal s) = 1%Z) -> (mem e s) ->
  (e = (element s)).

Axiom set_cardone_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((cardinal s) = 1%Z).

Axiom set_cardone_elt1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((element s) = a1).

Axiom set_cardone_elt_ :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((cardinal s) = 1%Z).

Axiom cardzero :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (b:a), ~ (mem b s)) -> ((cardinal s) = 0%Z).

Parameter to_set: forall {a:Type} {a_WT:WhyType a}, a -> set a.

Axiom to_set_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (e:a), ((to_set e) = (add e (empty : set a))).

Axiom to_set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (e:a), ((cardinal (to_set e)) = 1%Z).

Axiom to_set_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (e:a), forall (b:a), (mem b (to_set e)) -> (b = e).

Parameter to_fset: Z -> Z -> set Z.

Axiom to_fset_spec :
  forall (i:Z) (j:Z), (i < j)%Z -> ((cardinal (to_fset i j)) = (j - i)%Z).

Axiom to_fset_spec1 :
  forall (i:Z) (j:Z), (j <= i)%Z -> is_empty (to_fset i j).

Axiom to_fset_spec2 :
  forall (i:Z) (j:Z), forall (k:Z), (mem k (to_fset i j)) -> (i <= k)%Z.

Axiom to_fset_spec3 :
  forall (i:Z) (j:Z), forall (k:Z), (mem k (to_fset i j)) -> (k < j)%Z.

Axiom to_fset_spec4 :
  forall (i:Z) (j:Z), forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) ->
  mem k (to_fset i j).

Axiom to_fset_unit_ext :
  forall (i:Z) (j:Z), (i < j)%Z ->
  ((to_fset i j) = (add i (to_fset (i + 1%Z)%Z j))).

Axiom to_fset_ext :
  forall (i:Z) (i':Z) (j:Z), ((i <= i')%Z /\ (i' <= j)%Z) ->
  ((to_fset i j) = (union (to_fset i i') (to_fset i' j))).

Axiom card_fset :
  forall (n:Z), (0%Z <= n)%Z -> ((cardinal (to_fset 0%Z n)) = n).

Parameter p_injective_in:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> Prop.

Axiom p_injective_in_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (p_injective_in f s s') <->
  forall (e:a), (mem e s) ->
  (mem (f e) s') /\
  forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
  ~ ((f e1) = (f e')).

Parameter equal_func:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (a -> b) -> Prop.

Axiom equal_func_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b),
  (equal_func f g) <-> forall (e:a), ((f e) = (g e)).

Axiom set_equal_func :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b), (forall (e:a), ((f e) = (g e))) -> (f = g).

Axiom get_equal_func :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b), (equal_func f g) -> forall (e:a),
  ((f e) = (g e)).

Axiom set_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a),
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  p_injective f s.

Parameter image:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> set b.

Axiom image_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((image f s) = (map f s)).

Axiom image_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), forall (a1:b), (mem a1 (image f s)) ->
  exists antec_a:a, (mem antec_a s) /\ (a1 = (f antec_a)).

Axiom image_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), forall (a1:b),
  (exists antec_a:a, (mem antec_a s) /\ (a1 = (f antec_a))) ->
  mem a1 (image f s).

Axiom card_image :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((cardinal (image f s)) <= (cardinal s))%Z.

Axiom card_image_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) ->
  ((cardinal (image f s)) = (cardinal s)).

Axiom get_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) -> forall (e:a) (e':a),
  (mem e s) -> (mem e' s) -> ~ (e = e') -> ~ ((f e) = (f e')).

Axiom set_injective_in :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  p_injective f s.

Axiom get_injective_in :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_injective_in f s s') ->
  forall (e:a), (mem e s) -> mem (f e) s'.

Axiom get_injective_in1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_injective_in f s s') ->
  forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
  ~ ((f e) = (f e')).

Parameter p_surjective:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> Prop.

Axiom p_surjective_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (p_surjective f s s') <->
  ((forall (e:a), (mem e s) -> mem (f e) s') /\
   forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')).

Axiom set_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  p_surjective f s s'.

Axiom get_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_surjective f s s') ->
  forall (e:a), (mem e s) -> mem (f e) s'.

Axiom get_surjective1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_surjective f s s') ->
  forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e').

Axiom image_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_surjective f s s') ->
  ((image f s) = s').

Parameter p_bijective:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> Prop.

Axiom p_bijective_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (p_bijective f s s') <-> ((p_injective_in f s s') /\ (p_surjective f s s')).

Axiom bijective_is_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_injective f s.

Axiom bijective_is_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_surjective f s s'.

Axiom set_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  p_bijective f s s'.

Axiom set_bijective1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  ((map f s) = s').

Axiom bijectivity_is_transitive :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {c:Type} {c_WT:WhyType c},
  forall (f:a -> b) (g:b -> c) (s:set a) (s':set b) (s'':set c),
  (p_bijective f s s') -> (p_bijective g s' s'') ->
  p_bijective (fun (k:a) => (g (f k))) s s''.

Axiom bijective_image :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a) (s':set a), (p_bijective f s s') ->
  ((cardinal s) = (cardinal s')).

Axiom bijective_image1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a) (s':set a), (p_bijective f s s') ->
  (s' = (image f s)).

Axiom get_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  forall (e:a), (mem e s) -> mem (f e) s'.

Axiom get_bijective1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
  ~ ((f e) = (f e')).

Axiom get_bijective2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e').

Axiom get_bijective3 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  ((cardinal s) = (cardinal s')).

Axiom bijective_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  (forall (e:a), (mem e s) -> ((f e) = (g e))) -> p_bijective g s s'.

Axiom bijective_eq_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  forall (g:a -> b), (forall (e:a), (mem e s) -> ((f e) = (g e))) ->
  p_bijective g s s'.

Axiom bij_equal_card :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((cardinal s) = (cardinal (map f s))) ->
  p_bijective f s (map f s).

Axiom set_bijective_auto :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a), (forall (e:a), (mem e s) -> mem (f e) s) ->
  (forall (e':a), (mem e' s) -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  p_bijective f s s.

Parameter p_id: forall {a:Type} {a_WT:WhyType a}, a -> a.

Axiom p_id_def :
  forall {a:Type} {a_WT:WhyType a}, forall (a1:a), ((p_id a1) = a1).

Parameter const:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, a -> b -> a.

Axiom const_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (b1:b), ((const a1 b1) = a1).

Parameter constant_f:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  Prop.

Axiom constant_f_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b),
  (constant_f f) <->
  exists a1:b, (f = ((fun (y0:b) (y1:a) => (const y0 y1)) a1)).

Axiom iterate_empty :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (is_empty s) ->
  (commut op1) -> (iterable op1) -> ((iterate op1 s t1) = (neutral_elt op1)).

Axiom iterate_one :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1),
  ((cardinal s) = 1%Z) -> (commut op1) ->
  ((iterate op1 s t1) = (t1 (choose s))).

Axiom iterate_add :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1) (x:a),
  (commut op1) -> (iterable op1) -> ~ (mem x s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom iterate_add_ :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1) (x:a),
  (commut op1) -> ~ (mem x s) -> ~ (is_empty s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom iterate_remove :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1) (x:a),
  (commut op1) -> (iterable op1) ->
  (inverse_tuple op1 (fun (y0:im1) (y1:im1) => (po y0 y1)) (neutral_elt op1)) ->
  (mem x s) -> ((iterate op1 (remove x s) f) = (po (iterate op1 s f) (f x))).

Axiom iterate_def_choose :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1),
  ~ ((cardinal s) = 1%Z) -> (commut op1) -> ~ (is_empty s) ->
  ((iterate op1 s f) =
   ((op1 (f (choose s))) (iterate op1 (remove (choose s) s) f))).

Axiom iterate_def_choose1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1), (iterable op1) ->
  (commut op1) -> ~ (is_empty s) ->
  ((iterate op1 s f) =
   ((op1 (f (choose s))) (iterate op1 (remove (choose s) s) f))).

Axiom choose_any :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1) (t1:a),
  (iterable op1) -> (commut op1) -> (mem t1 s) ->
  ((iterate op1 s f) = ((op1 (f t1)) (iterate op1 (remove t1 s) f))).

Axiom iterate_comp_iterate :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (f:a -> im1) (g:a -> im1),
  (iterable op1) -> (commut op1) -> (assoc op1) ->
  ((iterate op1 s1 (fun (k:a) => ((op1 (f k)) (g k)))) =
   ((op1 (iterate op1 s1 (fun (k:a) => (f k))))
    (iterate op1 s1 (fun (k:a) => (g k))))).

Axiom iterate_comp_iterate_com :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (f:a -> im1) (g:a -> im1),
  (iterable op1) -> (commut op1) ->
  (((op1 (iterate op1 s1 (fun (k:a) => (f k))))
    (iterate op1 s1 (fun (k:a) => (g k))))
   = (iterate op1 s1 (fun (k:a) => ((op1 (f k)) (g k))))).

Axiom iterate_transitivity :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (po1:im1 -> im1 -> im1) (s1:set a)
    (s2:set a) (f:a -> im1),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  ((iterate op1 (union s1 s2) f) =
   ((po1 ((op1 (iterate op1 s1 f)) (iterate op1 s2 f)))
    (iterate op1 (inter s1 s2) f))).

Axiom iterate_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (s2:set a) (t1:a -> im1),
  (iterable op1) -> (commut op1) -> ((inter s1 s2) = (empty : set a)) ->
  ((iterate op1 (union s1 s2) t1) =
   ((op1 (iterate op1 s1 t1)) (iterate op1 s2 t1))).

Axiom iterate_eq :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1) (g:a -> im1),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> (commut op1) ->
  ~ (is_empty s) -> ((iterate op1 s f) = (iterate op1 s g)).

Axiom iterate_eq1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f:a -> im1) (g:a -> im1),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> (commut op1) ->
  (iterable op1) -> ((iterate op1 s f) = (iterate op1 s g)).

Axiom iterate_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set b) (f:b -> a) (t1:a -> im1),
  ~ (is_empty s) -> (commut op1) -> (p_injective f s) ->
  ((iterate op1 (map f s) t1) = (iterate op1 s (fun (b1:b) => (t1 (f b1))))).

Axiom iterate_map1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set b) (f:b -> a) (t1:a -> im1),
  (iterable op1) -> (commut op1) -> (p_injective f s) ->
  ((iterate op1 (map f s) t1) = (iterate op1 s (fun (b1:b) => (t1 (f b1))))).

Axiom iterate_cardone :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (iterable op1) ->
  (commut op1) -> ((cardinal s) = 1%Z) ->
  ((iterate op1 s t1) = (t1 (element s))).

Axiom iterate_cardzero :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (commut op1) ->
  (iterable op1) -> ((cardinal s) = 0%Z) ->
  ((iterate op1 s t1) = (neutral_elt op1)).

Axiom injec_iterate :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (a1:a) (s:set b) (f:a -> b -> im1),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s (f a1)) =
   (iterate op1 (cartesian_product (to_set a1) s)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (s2:set b) (f:a -> b -> im1),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s1 (fun (a1:a) => (iterate op1 s2 (f a1)))) =
   (iterate op1 (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_eq_func :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (f1:a -> im1) (f2:a -> im1),
  (commut op1) -> (iterable op1) -> (p_injective f1 s) ->
  (p_injective f2 s) -> ((map f1 s) = (map f2 s)) ->
  ((iterate op1 s f1) = (iterate op1 s f2)).

Axiom int_iterate_def_empty :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (j <= i)%Z ->
  (iterable op1) -> ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_def_plus_one :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (i < j)%Z ->
  ~ ((i + 1%Z)%Z = j) ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))).

Axiom int_iterate_def_plus_one1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (i < j)%Z ->
  (iterable op1) ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))).

Axiom int_iterate_cardone :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z),
  (j = (i + 1%Z)%Z) -> ((int_iterate op1 f i j) = (f i)).

Axiom int_iterate_def_plus_one_com :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (i < j)%Z ->
  ~ (j = (i + 1%Z)%Z) ->
  (((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j)) = (int_iterate op1 f i j)).

Axiom int_iterate_def_plus_one_com1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (i < j)%Z ->
  (iterable op1) ->
  (((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j)) = (int_iterate op1 f i j)).

Axiom int_iterate_to_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), ~ (j <= i)%Z ->
  (commut op1) -> ((int_iterate op1 f i j) = (iterate op1 (to_fset i j) f)).

Axiom int_iterate_to_iterate1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (iterable op1) ->
  (commut op1) -> ((int_iterate op1 f i j) = (iterate op1 (to_fset i j) f)).

Axiom int_iterate_right_extension :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (iterable op1) ->
  (i < j)%Z ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i (j - 1%Z)%Z)) (f (j - 1%Z)%Z))).

Axiom int_iterate_right_extension_ :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z), (assoc op1) ->
  ((i + 1%Z)%Z < j)%Z ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i (j - 1%Z)%Z)) (f (j - 1%Z)%Z))).

Axiom int_iterate_transitivity :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (k:Z) (j:Z),
  (iterable op1) -> (iterable op1) ->
  (op_neutral_left op1 (neutral_elt op1)) -> ((i <= k)%Z /\ (k <= j)%Z) ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i k)) (int_iterate op1 f k j))).

Axiom int_iterate_transitivity_ :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (k:Z) (j:Z),
  (op_neutral_left op1 (neutral_elt op1)) -> ((i < k)%Z /\ (k < j)%Z) ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i k)) (int_iterate op1 f k j))).

Axiom int_iterate_comp_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (g:Z -> im1) (i:Z) (j:Z),
  (iterable op1) -> (op_neutral_right op1 (neutral_elt op1)) ->
  (commut op1) ->
  ((int_iterate op1 (fun (k:Z) => ((op1 (f k)) (g k))) i j) =
   ((op1 (int_iterate op1 f i j)) (int_iterate op1 g i j))).

Axiom int_iterate_attr_no_f :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (t2:Z -> im2) (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (t2 x)) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (iterable op1) ->
  (iterable op2) -> (forall (i1:Z), ((f (t1 i1)) = (t2 i1))) ->
  ((int_iterate op2 t2 i j) = (f (int_iterate op1 t1 i j))).

Axiom int_iterate_attr :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t1 x))) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (iterable op1) ->
  (iterable op2) ->
  ((int_iterate op2 (fun (e:Z) => (f (t1 e))) i j) =
   (f (int_iterate op1 t1 i j))).

Axiom int_iterate_attr_comm :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t1 x))) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (iterable op1) ->
  (iterable op2) ->
  ((f (int_iterate op1 t1 i j)) =
   (int_iterate op2 (fun (e:Z) => (f (t1 e))) i j)).

Axiom int_iterate_eq :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (g:Z -> im1) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ~ (j <= i)%Z -> ((int_iterate op1 f i j) = (int_iterate op1 g i j)).

Axiom int_iterate_eq1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (g:Z -> im1) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  (iterable op1) -> ((int_iterate op1 f i j) = (int_iterate op1 g i j)).

Axiom int_iterate_left_right :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (l:Z) (k:Z) (h:Z),
  (iterable op1) -> (commut op1) -> ((l <= k)%Z /\ (k <= h)%Z) ->
  ((int_iterate op1 f l k) =
   (int_iterate op1 (fun (a:Z) => (f ((h - (a + 1%Z)%Z)%Z + l)%Z))
    ((h - k)%Z + l)%Z h)).

Axiom int_iterate_eq_func :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (i:Z) (j:Z) (f:Z -> im1) (g:Z -> im1),
  (iterable op1) -> (commut op1) -> (p_injective f (to_fset i j)) ->
  (p_injective g (to_fset i j)) ->
  ((map f (to_fset i j)) = (map g (to_fset i j))) ->
  ((int_iterate op1 f i j) = (int_iterate op1 g i j)).

Axiom int_iterate_map :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z)
    (t1:Z -> im1),
  ~ (j <= i)%Z -> (commut op1) ->
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((int_iterate op1 t1 k l) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Axiom int_iterate_map1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z)
    (t1:Z -> im1),
  (iterable op1) -> (commut op1) ->
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((int_iterate op1 t1 k l) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Axiom int_iterate_transl :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> im1) (i:Z) (j:Z) (k:Z),
  (iterable op1) ->
  ((int_iterate op1 f i j) =
   (int_iterate op1 (fun (b:Z) => (f (b + k)%Z)) (i - k)%Z (j - k)%Z)).

Axiom int_iterate_map_auto :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> im1),
  ~ (j <= i)%Z -> (commut op1) ->
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((int_iterate op1 t1 i j) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Axiom int_iterate_map_auto1 :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> im1),
  (iterable op1) -> (commut op1) ->
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((int_iterate op1 t1 i j) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Parameter nonn_part:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (set a) -> (a -> im1) -> set a.

Parameter result2:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def2 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t1:a -> im1) (e:a),
  (((result2 op1 t1) e) = true) <-> ~ (neutral op1 (t1 e)).

Axiom nonn_part_def :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1),
  ((nonn_part op1 s t1) = (filter (result2 op1 t1) s)).

Axiom nonn_part_spec :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (nonn_part op1 s t1)) -> mem e s.

Axiom nonn_part_spec1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (nonn_part op1 s t1)) -> ~ (neutral op1 (t1 e)).

Axiom nonn_part_spec2 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  ((mem e s) /\ ~ (neutral op1 (t1 e))) -> mem e (nonn_part op1 s t1).

Parameter n_part:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (set a) -> (a -> im1) -> set a.

Parameter result3:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def3 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t1:a -> im1) (e:a),
  (((result3 op1 t1) e) = true) <-> (neutral op1 (t1 e)).

Axiom n_part_def :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1),
  ((n_part op1 s t1) = (filter (result3 op1 t1) s)).

Axiom n_part_spec :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (n_part op1 s t1)) -> mem e s.

Axiom n_part_spec1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (n_part op1 s t1)) -> neutral op1 (t1 e).

Axiom n_part_spec2 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  ((mem e s) /\ (neutral op1 (t1 e))) -> mem e (n_part op1 s t1).

Axiom nullity_partition :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (commut op1) ->
  (s = (union (nonn_part op1 s t1) (n_part op1 s t1))).

Axiom nullity_partition1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (commut op1) ->
  ((inter (nonn_part op1 s t1) (n_part op1 s t1)) = (empty : set a)).

Axiom iterate_neutral :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (iterable op1) ->
  (commut op1) ->
  (forall (a1:a), (mem a1 s) -> ((t1 a1) = (neutral_elt op1))) ->
  ((iterate op1 s t1) = (neutral_elt op1)).

Axiom iterate_nullity_partition :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (iterable op1) ->
  (commut op1) ->
  ((iterate op1 s t1) = (iterate op1 (nonn_part op1 s t1) t1)).

Parameter couple:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  (a -> b -> im1) -> (a* b)%type -> im1.

Axiom couple_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (f:a -> b -> im1) (o:(a* b)%type),
  match o with
  | (a1, b1) => ((couple f o) = ((f a1) b1))
  end.

Axiom null_product :
  forall (a:t) (b:t), ((infix_asdt a b) = tzero) ->
  (a = tzero) \/ (b = tzero).

Axiom couple_value :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (f:a -> b -> im1) (o:(a* b)%type),
  ((couple f o) = ((f (fir o)) (sec o))).

Axiom couple_value_dev :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (f:a -> b -> im1) (o:(a* b)%type) (a1:a) (b1:b), (o = (a1, b1)) ->
  ((couple f o) = ((f a1) b1)).

Axiom neutral_tzero :
  neutral (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) tzero.

Axiom neutral_tzero1 : iterable (fun (y0:t) (y1:t) => (infix_pldt y0 y1)).

Parameter sum: forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> t) -> t.

Axiom sum_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  ((sum s t1) = (iterate (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) s t1)).

Parameter eq_t: t -> t -> Prop.

Axiom eq_t_def : forall (a:t) (a':t), (eq_t a a') <-> (a = a').

Axiom sum_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), (is_empty s) -> ((sum s t1) = tzero).

Axiom sum_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal s) = 1%Z) ->
  ((sum s t1) = (t1 (choose s))).

Axiom sum_add :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> t) (x:b), ~ (mem x s) ->
  ((sum (add x s) f) = (infix_pldt (f x) (sum s f))).

Axiom sum_plus_one :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> t), ((cardinal s) > 1%Z)%Z ->
  ((sum s f) = (infix_pldt (f (choose s)) (sum (remove (choose s) s) f))).

Axiom sum_real :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t), (forall (a1:a), (mem a1 s) -> real_ (f a1)) ->
  ((cardinal s) > 0%Z)%Z -> real_ (sum s f).

Axiom map_sum_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> a) (t1:a -> t), (p_injective f s) ->
  ((sum (map f s) t1) = (sum s (fun (b1:b) => (t1 (f b1))))).

Axiom sum_comp :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> t) (g:b -> t),
  ((sum s (fun (k:b) => (infix_pldt (f k) (g k)))) =
   (infix_pldt (sum s f) (sum s g))).

Axiom sum_iter_ :
  opposite_n (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
  (fun (y0:t) (y1:t) => (infix_mndt y0 y1)) tzero.

Axiom sum_iter_1 :
  opposite1 (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
  (fun (y0:t) (y1:t) => (infix_mndt y0 y1)).

Axiom sum_iter_2 :
  opposite_com (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
  (fun (y0:t) (y1:t) => (infix_mndt y0 y1)).

Axiom sum_iter_3 :
  inverse_tuple (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
  (fun (y0:t) (y1:t) => (infix_mndt y0 y1)) tzero.

Axiom neutral_zero :
  ((neutral_elt (fun (y0:t) (y1:t) => (infix_pldt y0 y1))) = tzero).

Axiom sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (g:a -> t),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> ((sum s f) = (sum s g)).

Axiom sum_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> t) (g:a -> t), (s = s') ->
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> ((sum s f) = (sum s' g)).

Axiom sum_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (t1:a -> t),
  ((inter s1 s2) = (empty : set a)) ->
  ((sum (union s1 s2) t1) = (infix_pldt (sum s1 t1) (sum s2 t1))).

Axiom sum_to_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (f:a -> b -> t),
  ((sum s1 (fun (a1:a) => (sum s2 (f a1)))) =
   (sum (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom sum_from_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (f:a -> b -> t),
  ((sum (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))
   = (sum s1 (fun (a1:a) => (sum s2 (f a1))))).

Parameter ind_sum: (Z -> t) -> Z -> Z -> t.

Axiom ind_sum_def :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((ind_sum f i j) =
   (int_iterate (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) f i j)).

Axiom ind_sum_to_int_iterate :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((ind_sum f i j) =
   (int_iterate (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) f i j)).

Axiom ind_sum_cardone :
  forall (f:Z -> t) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((ind_sum f i j) = (f i)).

Axiom ind_sum_right_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_sum f i j) = (infix_pldt (ind_sum f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom ind_sum_plus_one :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_sum f i j) = (infix_pldt (f i) (ind_sum f (i + 1%Z)%Z j))).

Axiom real_ind_sum :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> real_ (f k)) ->
  real_ (ind_sum f i j).

Axiom positive_ind_sum :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> infix_lseqdt tzero (f k)) ->
  infix_lseqdt tzero (ind_sum f i j).

Axiom ind_sum_eq :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_sum f i j) = (ind_sum g i j)).

Parameter fc: (Z -> t) -> t -> Z -> Z -> Z -> t.

Axiom fc_def :
  forall (f:Z -> t) (g:t) (i:Z) (j:Z) (k:Z),
  (((i <= k)%Z /\ (k < j)%Z) -> (((fc f g i j) k) = (f k))) /\
  (~ ((i <= k)%Z /\ (k < j)%Z) -> (((fc f g i j) k) = g)).

Axiom ind_sum_eq_del_bound :
  forall (f:Z -> t) (g:t) (i:Z) (j:Z),
  ((ind_sum (fc f g i j) i j) = (ind_sum f i j)).

Parameter fc1: (Z -> t) -> t -> Z -> Z -> Z -> t.

Axiom fc_def1 :
  forall (f:Z -> t) (g:t) (i:Z) (j:Z) (k:Z),
  (((i <= k)%Z /\ (k < j)%Z) -> (((fc1 f g i j) k) = (f k))) /\
  (~ ((i <= k)%Z /\ (k < j)%Z) -> (((fc1 f g i j) k) = g)).

Axiom ind_sum_eq_del_bound_rev :
  forall (f:Z -> t) (g:t) (i:Z) (j:Z),
  ((ind_sum f i j) = (ind_sum (fc1 f g i j) i j)).

Axiom ind_sum_eq_gen :
  forall (f:Z -> t) (g:Z -> t) (i1:Z) (j1:Z) (i2:Z) (j2:Z), (i1 = i2) ->
  (j1 = j2) ->
  (forall (k:Z), ((i1 <= k)%Z /\ (k < j1)%Z) -> ((f k) = (g k))) ->
  ((ind_sum f i1 j1) = (ind_sum g i2 j2)).

Axiom ind_sum_eq_bound :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z), (i = j) ->
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_sum f 0%Z i) = (ind_sum g 0%Z j)).

Axiom ind_sum_comp :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  ((ind_sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j) =
   (infix_pldt (ind_sum f i j) (ind_sum g i j))).

Axiom ind_sum_comp_rev :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (i':Z) (j:Z) (j':Z), (i = i') ->
  (j = j') ->
  ((infix_pldt (ind_sum f i j) (ind_sum g i' j')) =
   (ind_sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j)).

Axiom ind_sum_to_iterate :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((ind_sum f i j) =
   (iterate (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) (to_fset i j) f)).

Axiom ind_sum_to_sum :
  forall (f:Z -> t) (i:Z) (j:Z), ((ind_sum f i j) = (sum (to_fset i j) f)).

Axiom map_ind_sum_eq :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> t),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_sum t1 k l) = (ind_sum (fun (b:Z) => (t1 (f b))) i j)).

Axiom sum_scal :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> t) (s:set a) (c:t),
  ((sum s (fun (x:a) => (infix_asdt c (f x)))) = (infix_asdt c (sum s f))).

Axiom sum_scal_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> t) (s:set a) (c:t),
  ((sum s (fun (x:a) => (infix_asdt (f x) c))) = (infix_asdt (sum s f) c)).

Axiom sum_scal_rev_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> t) (s:set a) (c:t),
  ((infix_asdt (sum s f) c) = (sum s (fun (x:a) => (infix_asdt (f x) c)))).

Axiom sum_scal_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> t) (s:set a) (c:t),
  ((infix_asdt c (sum s f)) = (sum s (fun (x:a) => (infix_asdt c (f x))))).

Axiom ind_sum_scal :
  forall (f:Z -> t) (i:Z) (j:Z) (a:t),
  ((ind_sum (fun (i1:Z) => (infix_asdt a (f i1))) i j) =
   (infix_asdt a (ind_sum f i j))).

Axiom ind_sum_scal_rev :
  forall (f:Z -> t) (i:Z) (j:Z) (a:t),
  ((infix_asdt a (ind_sum f i j)) =
   (ind_sum (fun (i1:Z) => (infix_asdt a (f i1))) i j)).

Axiom scal_ind_sum :
  forall (f:Z -> t) (i:Z) (j:Z) (a:t),
  ((ind_sum (fun (i1:Z) => (infix_asdt (f i1) a)) i j) =
   (infix_asdt (ind_sum f i j) a)).

Axiom scal_ind_sum_rev :
  forall (f:Z -> t) (i:Z) (j:Z) (a:t),
  ((infix_asdt (ind_sum f i j) a) =
   (ind_sum (fun (i1:Z) => (infix_asdt (f i1) a)) i j)).

Axiom sum_scal_gen :
  forall (f:Z -> t) (s:set Z), forall (a:t),
  ((sum s (fun (i:Z) => (infix_asdt a (f i)))) = (infix_asdt a (sum s f))).

Axiom ind_sum_scal_gen :
  forall (f:Z -> t) (i:Z) (j:Z), forall (a:t),
  ((ind_sum (fun (i1:Z) => (infix_asdt a (f i1))) i j) =
   (infix_asdt a (ind_sum f i j))).

Axiom int_int_iterate_def_empty :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (j <= i)%Z -> (iterable op1) ->
  ((int_int_iterate op1 f i j k l) = (neutral_elt op1)).

Axiom int_int_iterate_def_plus_one :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i < j)%Z -> (iterable op1) ->
  ((int_int_iterate op1 f i j k l) =
   ((op1 (int_iterate op1 (fun (n:Z) => ((f i) n)) k l))
    (int_int_iterate op1 f (i + 1%Z)%Z j k l))).

Axiom int_int_iterate_to_int_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i <= j)%Z -> (iterable op1) ->
  ((int_int_iterate op1 f i j k l) =
   (int_iterate op1 (fun (a:Z) => (int_iterate op1 (f a) k l)) i j)).

Axiom int_iterate_to_int_int_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i <= j)%Z -> (iterable op1) ->
  ((int_iterate op1 (fun (a:Z) => (int_iterate op1 (f a) k l)) i j) =
   (int_int_iterate op1 f i j k l)).

Axiom int_int_iterate_to_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i <= j)%Z -> (iterable op1) -> (commut op1) ->
  ((int_int_iterate op1 f i j k l) =
   (iterate op1 (cartesian_product (to_fset i j) (to_fset k l))
    (fun (o:(Z* Z)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_commute :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (s2:set b) (f:a -> b -> im1),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))
   =
   (iterate op1 (cartesian_product s2 s1)
    (fun (o:(b* a)%type) => ((f (sec o)) (fir o))))).

Axiom iterate_commute_ :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (s2:set b) (f:a -> b -> im1),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s1
    (fun (a1:a) => (iterate op1 s2 (fun (a2:b) => ((f a1) a2)))))
   =
   (iterate op1 s2
    (fun (a2:b) => (iterate op1 s1 (fun (a1:a) => ((f a1) a2)))))).

Axiom int_int_iterate_commute :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (iterable op1) -> (commut op1) -> (i <= j)%Z -> (k <= l)%Z ->
  ((int_int_iterate op1 f i j k l) =
   (int_int_iterate op1 (fun (a:Z) (b:Z) => ((f b) a)) k l i j)).

Axiom int_iterate_commute :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (iterable op1) -> (commut op1) -> (i <= j)%Z -> (k <= l)%Z ->
  ((int_iterate op1 (fun (a:Z) => (int_iterate op1 (f a) k l)) i j) =
   (int_iterate op1
    (fun (a:Z) => (int_iterate op1 (fun (b:Z) => ((f b) a)) i j)) k l)).

Axiom ind_sum_commute :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z), (i <= j)%Z -> (k <= l)%Z ->
  ((ind_sum (fun (k1:Z) => (ind_sum (f k1) k l)) i j) =
   (ind_sum (fun (k1:Z) => (ind_sum (fun (k2:Z) => ((f k2) k1)) i j)) k l)).

Axiom sum_commute :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b -> t) (sa:set a) (sb:set b),
  ((sum sa (fun (a1:a) => (sum sb (f a1)))) =
   (sum sb (fun (b1:b) => (sum sa (fun (a1:a) => ((f a1) b1)))))).

Parameter non_tzero:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> t) -> set a.

Axiom non_tzero_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  ((non_tzero s t1) =
   (nonn_part (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) s t1)).

Axiom non_tzero_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (e:a), (mem e (non_tzero s t1)) ->
  mem e s.

Axiom non_tzero_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (e:a), (mem e (non_tzero s t1)) ->
  ~ ((t1 e) = tzero).

Axiom non_tzero_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (e:a),
  ((mem e s) /\ ~ ((t1 e) = tzero)) -> mem e (non_tzero s t1).

Axiom get_non_tzero_member :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (e:a), (mem e (non_tzero s t1)) -> mem e s.

Axiom get_non_tzero_member1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (e:a), (mem e (non_tzero s t1)) ->
  ~ ((t1 e) = tzero).

Axiom set_non_tzero_member :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (e:a), (mem e s) -> ~ ((t1 e) = tzero) ->
  mem e (non_tzero s t1).

Axiom set_non_tzero_member_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (e:a),
  ((mem e s) /\ ~ ((t1 e) = tzero)) -> mem e (non_tzero s t1).

Axiom set_non_tzero_member_gen_ :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (e:a),
  ((mem e s) /\ ~ ((t1 e) = tzero)) -> mem e (non_tzero s t1).

Axiom sum_nullity_partition :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((sum s t1) = (sum (non_tzero s t1) t1)).

Axiom non_null_map :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> a) (t1:a -> t),
  ((non_tzero (map f s) t1) =
   (map f (non_tzero s (fun (b:a) => (t1 (f b)))))).

Axiom map_sum_eq_nonnull :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> a) (t1:a -> t),
  (p_bijective f (non_tzero s (fun (b:a) => (t1 (f b))))
   (non_tzero (map f s) t1)) ->
  ((sum (non_tzero (map f s) t1) t1) =
   (sum (non_tzero s (fun (b:a) => (t1 (f b)))) (fun (b:a) => (t1 (f b))))).

Axiom sum_null_but_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal (non_tzero s t1)) = 1%Z) ->
  ((sum s t1) = (t1 (element (non_tzero s t1)))).

Axiom sum_null :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal (non_tzero s t1)) = 0%Z) ->
  ((sum s t1) = tzero).

Axiom sum_null_ :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  (forall (e:a), (mem e s) -> ((t1 e) = tzero)) -> ((sum s t1) = tzero).

Axiom sum_null_forall :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  (forall (e:a), (mem e s) -> ((t1 e) = tzero)) -> ((sum s t1) = tzero).

Axiom ind_sum_null :
  forall (t1:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((t1 k) = tzero)) ->
  ((ind_sum t1 i j) = tzero).

Axiom sum_null_but_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (elt:a),
  ((mem elt s) /\ ~ ((t1 elt) = tzero)) ->
  (forall (a1:a), (mem a1 s) -> ~ (a1 = elt) -> ((t1 a1) = tzero)) ->
  ((sum s t1) = (t1 elt)).

Axiom sum_null_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (t1:a -> t) (s:set a) (elt:a), (mem elt s) ->
  (forall (k:a), (mem k s) -> ~ (k = elt) -> ((t1 k) = tzero)) ->
  ((sum s t1) = (t1 elt)).

Axiom ind_sum_null_but_maybe_one_elt :
  forall (t1:Z -> t) (i:Z) (j:Z) (ind:Z), ((i <= ind)%Z /\ (ind < j)%Z) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ~ (k = ind) ->
   ((t1 k) = tzero)) ->
  ((ind_sum t1 i j) = (t1 ind)).

Axiom neutral_tone : neutral (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone.

Axiom neutral_tone1 : iterable (fun (y0:t) (y1:t) => (infix_asdt y0 y1)).

Axiom product_iter :
  op_neutral_left (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone.

Axiom product_iter1 :
  op_neutral_right (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone.

Axiom product_iter2 : op_assoc (fun (y0:t) (y1:t) => (infix_asdt y0 y1)).

Axiom product_iter3 : commut (fun (y0:t) (y1:t) => (infix_asdt y0 y1)).

Axiom product_iter4 :
  iterates (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone.

Parameter product:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> t) -> t.

Axiom product_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  ((product s t1) = (iterate (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) s t1)).

Axiom product_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (t':a -> t),
  (forall (e:a), (mem e s) -> ((t1 e) = (t' e))) ->
  ((product s t1) = (product s t')).

Axiom product_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (t1:a -> t) (t':a -> t), (s = s') ->
  (forall (e:a), (mem e s) -> ((t1 e) = (t' e))) ->
  ((product s t1) = (product s' t')).

Axiom product_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t), (is_empty s) -> ((product s f) = tone).

Axiom product_iter_ : iterable (fun (y0:t) (y1:t) => (infix_asdt y0 y1)).

Axiom add_product :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (x:a), ~ (mem x s) ->
  ((product (add x s) f) = (infix_asdt (f x) (product s f))).

Axiom product_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (x:a), ~ (mem x s) ->
  ((product (add x s) f) = (infix_asdt (product s f) (f x))).

Axiom neutral_one :
  ((neutral_elt (fun (y0:t) (y1:t) => (infix_asdt y0 y1))) = tone).

Parameter ind_product: (Z -> t) -> Z -> Z -> t.

Axiom ind_product_def :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((ind_product f i j) =
   (int_iterate (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) f i j)).

Axiom ind_product_eq :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_product f i j) = (ind_product g i j)).

Axiom ind_product_cardone :
  forall (f:Z -> t) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((ind_product f i j) = (f i)).

Axiom ind_product_eq_gen :
  forall (f:Z -> t) (g:Z -> t) (i1:Z) (j1:Z) (i2:Z) (j2:Z),
  (forall (k:Z), ((i1 <= k)%Z /\ (k < j1)%Z) -> ((f k) = (g k))) ->
  (i1 = i2) -> (j1 = j2) -> ((ind_product f i1 j1) = (ind_product g i2 j2)).

Axiom ind_product_right_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_product f i j) =
   (infix_asdt (ind_product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom ind_product_left_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_product f i j) = (infix_asdt (f i) (ind_product f (i + 1%Z)%Z j))).

Axiom ind_product_to_product :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((ind_product f i j) = (product (to_fset i j) f)).

Axiom map_product_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> a) (t1:a -> t), (p_injective f s) ->
  ((product (map f s) t1) = (product s (fun (b1:b) => (t1 (f b1))))).

Axiom map_ind_product_eq :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> t),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_product t1 k l) = (ind_product (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_product_right_extension_comm :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((infix_asdt (ind_product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z)) =
   (ind_product f i j)).

Axiom ind_product_eq_func :
  forall (i:Z) (j:Z) (f1:Z -> t) (f2:Z -> t),
  (p_injective f1 (to_fset i j)) -> (p_injective f2 (to_fset i j)) ->
  ((map f1 (to_fset i j)) = (map f2 (to_fset i j))) ->
  ((ind_product f1 i j) = (ind_product f2 i j)).

Axiom ind_product_trans :
  forall (f:Z -> t) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_product f i j) =
   (infix_asdt (ind_product f i k) (ind_product f k j))).

Axiom ind_product_zero_pre :
  forall (f:Z -> t) (i:Z) (t1:Z) (j:Z), ((i <= t1)%Z /\ (t1 < j)%Z) ->
  ((f t1) = tzero) -> ((ind_product f i j) = tzero).

Axiom ind_product_zero :
  forall (f:Z -> t) (i:Z) (j:Z), (i <= j)%Z ->
  (exists t1:Z, ((i <= t1)%Z /\ (t1 < j)%Z) /\ ((f t1) = tzero)) ->
  ((ind_product f i j) = tzero).

Axiom ind_product_zero_elt :
  forall (f:Z -> t) (i:Z) (j:Z) (t1:Z), (i <= j)%Z ->
  ((i <= t1)%Z /\ (t1 < j)%Z) -> ((f t1) = tzero) ->
  ((ind_product f i j) = tzero).

Axiom ind_product_const_tone :
  forall (f:Z -> t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (t1:Z), ((i <= t1)%Z /\ (t1 < j)%Z) -> ((f t1) = tone)) ->
  ((ind_product f i j) = tone).

Axiom div_plus_one :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (((int.EuclideanDivision.div i j) * j)%Z <= i)%Z.

Axiom div_plus_one1 :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i < (((int.EuclideanDivision.div i j) + 1%Z)%Z * j)%Z)%Z.

Axiom mod_is_inf :
  forall (i:Z) (j:Z), (0%Z < j)%Z -> ((int.EuclideanDivision.mod1 i j) < j)%Z.

Axiom zero_add : forall (a1:Z) (a2:Z), (a1 = 0%Z) -> ((a1 + a2)%Z = a2).

Axiom add_zero : forall (a1:Z) (a2:Z), (a2 = 0%Z) -> ((a1 + a2)%Z = a1).

Axiom one_mult : forall (a1:Z) (a2:Z), (a1 = 1%Z) -> ((a1 * a2)%Z = a2).

Axiom mult_one : forall (a1:Z) (a2:Z), (a2 = 1%Z) -> ((a1 * a2)%Z = a1).

Axiom add_eq :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 + b1)%Z = (a2 + b2)%Z).

Axiom mult_eq :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 * b1)%Z = (a2 * b2)%Z).

Axiom add_eq_inv :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 + b1)%Z = (b2 + a2)%Z).

Axiom mult_eq_inv :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 * b1)%Z = (b2 * a2)%Z).

Axiom bound_eq :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < j)%Z) ->
  (i = (int.EuclideanDivision.mod1 i j)).

Axiom bound_eq_rev :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < j)%Z) ->
  ((int.EuclideanDivision.mod1 i j) = i).

Axiom unicity_div_mod :
  forall (i:Z) (j:Z) (q:Z) (r:Z), (0%Z < j)%Z -> (i = ((q * j)%Z + r)%Z) ->
  ((0%Z <= r)%Z /\ (r < j)%Z) -> (q = (int.EuclideanDivision.div i j)).

Axiom unicity_div_mod1 :
  forall (i:Z) (j:Z) (q:Z) (r:Z), (0%Z < j)%Z -> (i = ((q * j)%Z + r)%Z) ->
  ((0%Z <= r)%Z /\ (r < j)%Z) -> (r = (int.EuclideanDivision.mod1 i j)).

Axiom unicity_div_gen :
  forall (j:Z) (q:Z), (0%Z <= q)%Z -> (0%Z < j)%Z -> forall (i:Z),
  (0%Z <= i)%Z ->
  ((0%Z <= (i - (q * j)%Z)%Z)%Z /\ ((i - (q * j)%Z)%Z < j)%Z) ->
  (q = (int.EuclideanDivision.div i j)).

Axiom unicity_div_gen1 :
  forall (j:Z) (q:Z), (0%Z <= q)%Z -> (0%Z < j)%Z -> forall (i:Z),
  (0%Z <= i)%Z ->
  ((0%Z <= (i - (q * j)%Z)%Z)%Z /\ ((i - (q * j)%Z)%Z < j)%Z) ->
  ((i - (j * q)%Z)%Z = (int.EuclideanDivision.mod1 i j)).

Axiom bound_mod :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (0%Z <= (int.EuclideanDivision.mod1 i j))%Z.

Axiom bound_mod1 :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) < j)%Z.

Axiom mod_eq :
  forall (a:Z) (b:Z) (d:Z), (a = b) ->
  ((int.EuclideanDivision.mod1 a d) = (int.EuclideanDivision.mod1 b d)).

Axiom e_div_eq :
  forall (a:Z) (b:Z) (d:Z), (a = b) ->
  ((int.EuclideanDivision.div a d) = (int.EuclideanDivision.div b d)).

Axiom decomp :
  forall (i:Z) (j:Z), ~ (0%Z = j) ->
  (i =
   ((j * (int.EuclideanDivision.div i j))%Z +
    (int.EuclideanDivision.mod1 i j))%Z).

Axiom div_mod_eq :
  forall (i:Z) (j:Z) (q:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z < q)%Z ->
  ((int.EuclideanDivision.div i q) = (int.EuclideanDivision.div j q)) ->
  ((int.EuclideanDivision.mod1 i q) = (int.EuclideanDivision.mod1 j q)) ->
  (i = j).

Axiom mod_zero :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) = 0%Z) ->
  (i = (j * (int.EuclideanDivision.div i j))%Z).

Axiom div_plus_quotient :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.div (i + j)%Z j) =
   ((int.EuclideanDivision.div i j) + 1%Z)%Z).

Axiom div_plus_fact_gen_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z < j)%Z ->
  ((int.EuclideanDivision.div (i + (k * j)%Z)%Z j) =
   ((int.EuclideanDivision.div i j) + k)%Z).

Axiom mod_plus_fact_gen_mod :
  forall (i:Z) (j:Z) (k:Z), (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 ((k * j)%Z + i)%Z j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom bound_div :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z -> (0%Z <= (int.EuclideanDivision.div i q))%Z.

Axiom bound_div1 :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z -> (0%Z <= ((int.EuclideanDivision.div i q) * q)%Z)%Z.

Axiom bound_div2 :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z -> (((int.EuclideanDivision.div i q) * q)%Z <= i)%Z.

Axiom bound_div3 :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z ->
  (i < (q * ((int.EuclideanDivision.div i q) + 1%Z)%Z)%Z)%Z.

Axiom bound_div4 :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z -> ((int.EuclideanDivision.div i q) < f)%Z.

Axiom mod_upper_bound :
  forall (i:Z) (q:Z), (0%Z < i)%Z -> (i = q) ->
  ((int.EuclideanDivision.mod1 i q) = 0%Z).

Axiom bound_div_gen :
  forall (q:Z) (f:Z), (0%Z < q)%Z -> (0%Z <= f)%Z -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (q * f)%Z)%Z) ->
  ((int.EuclideanDivision.div i q) < f)%Z.

Axiom mod_invariant :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1
    ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z +
     (int.EuclideanDivision.mod1 i (q * f)%Z))%Z
    q)
   = (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (q * f)%Z) q)).

Axiom mod_inf :
  forall (i:Z) (q:Z), ((0%Z <= i)%Z /\ (i < q)%Z) ->
  ((int.EuclideanDivision.mod1 i q) = i).

Axiom mod_mod_left :
  forall (i:Z) (j:Z) (f:Z), (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mod_mod_i :
  forall (i:Z) (j:Z), (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i j) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom binary_prod :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 i 2%Z) *
     (int.EuclideanDivision.mod1 j 2%Z))%Z
    2%Z)
   = (int.EuclideanDivision.mod1 (i * j)%Z 2%Z)).

Axiom add_mod :
  forall (a:Z) (b:Z) (c:Z), (c > 0%Z)%Z ->
  ((int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 a c) + (int.EuclideanDivision.mod1 b c))%Z
    c)
   = (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom add_mod_left :
  forall (a:Z) (b:Z) (c:Z), (c > 0%Z)%Z ->
  ((int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) + b)%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom add_mod_right :
  forall (a:Z) (b:Z) (c:Z), (c > 0%Z)%Z ->
  ((int.EuclideanDivision.mod1 (a + (int.EuclideanDivision.mod1 b c))%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom mult_mod :
  forall (a:Z) (b:Z) (c:Z), (c > 0%Z)%Z ->
  ((int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 a c) * (int.EuclideanDivision.mod1 b c))%Z
    c)
   = (int.EuclideanDivision.mod1 (a * b)%Z c)).

Axiom mult_mod_left :
  forall (a:Z) (b:Z) (c:Z), (c > 0%Z)%Z ->
  ((int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) * b)%Z c) =
   (int.EuclideanDivision.mod1 (a * b)%Z c)).

Axiom mult_mod_right :
  forall (a:Z) (b:Z) (c:Z), (c > 0%Z)%Z ->
  ((int.EuclideanDivision.mod1 (a * (int.EuclideanDivision.mod1 b c))%Z c) =
   (int.EuclideanDivision.mod1 (a * b)%Z c)).

Axiom mod_mod_right :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mod_mod_rev :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j)).

Axiom mod_mod_rev1 :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j)).

Axiom mod_mod_plus :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j + j)%Z) j)).

Axiom mod_mod_add_left :
  forall (a:Z) (b:Z) (c:Z), (0%Z <= c)%Z ->
  ((int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) + b)%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom mod_mod_add_right :
  forall (a:Z) (b:Z) (c:Z), (0%Z <= c)%Z ->
  ((int.EuclideanDivision.mod1 (a + (int.EuclideanDivision.mod1 b c))%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom mod_mod_add_left_rev :
  forall (a:Z) (b:Z) (c:Z), (0%Z <= c)%Z ->
  ((int.EuclideanDivision.mod1 (a + b)%Z c) =
   (int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) + b)%Z c)).

Axiom mod_mod_add_right_rev :
  forall (a:Z) (b:Z) (c:Z), (0%Z <= c)%Z ->
  ((int.EuclideanDivision.mod1 (a + b)%Z c) =
   (int.EuclideanDivision.mod1 (a + (int.EuclideanDivision.mod1 b c))%Z c)).

Axiom mult_assoc1 :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z =
   ((q * f)%Z * (int.EuclideanDivision.div i (q * f)%Z))%Z).

Axiom div_div1 :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (k * j)%Z)).

Axiom div_div2 :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (j * k)%Z)).

Axiom mod_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.mod1 i (j * k)%Z) j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.div i j) k)).

Axiom inf_mul :
  forall (ia:Z) (ib:Z) (a:Z) (b:Z), ((0%Z <= ia)%Z /\ (ia < a)%Z) ->
  ((0%Z <= ib)%Z /\ (ib < b)%Z) -> (((a * ib)%Z + ia)%Z < (a * b)%Z)%Z.

Axiom inf_mul1 :
  forall (ia:Z) (ib:Z) (a:Z) (b:Z), ((0%Z <= ia)%Z /\ (ia < a)%Z) ->
  ((0%Z <= ib)%Z /\ (ib < b)%Z) -> (((ib * a)%Z + ia)%Z < (b * a)%Z)%Z.

Axiom inf_mul_gen :
  forall (n:Z) (v:Z) (p:Z), ((0%Z <= p)%Z /\ (p < v)%Z) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < n)%Z) -> (((k * v)%Z + p)%Z < (n * v)%Z)%Z.

Axiom inf_mul_gen_b :
  forall (n:Z) (v:Z) (p:Z), ((0%Z <= p)%Z /\ (p < n)%Z) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < v)%Z) -> (((p * v)%Z + k)%Z < (n * v)%Z)%Z.

Axiom inf_mul_comm :
  forall (i:Z) (bi:Z) (quot:Z) (rest:Z), ((0%Z <= i)%Z /\ (i < bi)%Z) ->
  (0%Z < rest)%Z -> (0%Z < quot)%Z -> (bi = (quot * rest)%Z) ->
  ((int.EuclideanDivision.mod1 i rest) < rest)%Z.

Parameter nonn_part1:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (set a) -> (a -> im1) -> set a.

Parameter result4:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def4 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t1:a -> im1) (e:a),
  (((result4 op1 t1) e) = true) <-> ~ (neutral op1 (t1 e)).

Axiom nonn_part_def1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1),
  ((nonn_part1 op1 s t1) = (filter (result4 op1 t1) s)).

Axiom nonn_part_spec3 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (nonn_part1 op1 s t1)) -> mem e s.

Axiom nonn_part_spec4 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (nonn_part1 op1 s t1)) -> ~ (neutral op1 (t1 e)).

Axiom nonn_part_spec5 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  ((mem e s) /\ ~ (neutral op1 (t1 e))) -> mem e (nonn_part1 op1 s t1).

Parameter n_part1:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (set a) -> (a -> im1) -> set a.

Parameter result5:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def5 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t1:a -> im1) (e:a),
  (((result5 op1 t1) e) = true) <-> (neutral op1 (t1 e)).

Axiom n_part_def1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1),
  ((n_part1 op1 s t1) = (filter (result5 op1 t1) s)).

Axiom n_part_spec3 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (n_part1 op1 s t1)) -> mem e s.

Axiom n_part_spec4 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  (mem e (n_part1 op1 s t1)) -> neutral op1 (t1 e).

Axiom n_part_spec5 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), forall (e:a),
  ((mem e s) /\ (neutral op1 (t1 e))) -> mem e (n_part1 op1 s t1).

Axiom nullity_partition2 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (commut op1) ->
  (s = (union (nonn_part1 op1 s t1) (n_part1 op1 s t1))).

Axiom nullity_partition3 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (commut op1) ->
  ((inter (nonn_part1 op1 s t1) (n_part1 op1 s t1)) = (empty : set a)).

Axiom iterate_neutral1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (iterable op1) ->
  (commut op1) ->
  (forall (a1:a), (mem a1 s) -> ((t1 a1) = (neutral_elt op1))) ->
  ((iterate op1 s t1) = (neutral_elt op1)).

Axiom iterate_nullity_partition1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t1:a -> im1), (iterable op1) ->
  (commut op1) ->
  ((iterate op1 s t1) = (iterate op1 (nonn_part1 op1 s t1) t1)).

Parameter indic: forall {a:Type} {a_WT:WhyType a}, a -> a -> t.

Axiom indic_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((infix_eqeq a1 a') -> ((indic a1 a') = tone)) /\
  (~ (infix_eqeq a1 a') -> ((indic a1 a') = tzero)).

Axiom indic_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic a1 a') = tone)) /\
  (~ (a1 = a') -> ((indic a1 a') = tzero)).

Axiom get_indic :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic a1 a') = tone)) /\
  (~ (a1 = a') -> ((indic a1 a') = tzero)).

Parameter indic_bool: forall {a:Type} {a_WT:WhyType a}, a -> a -> bool.

Axiom indic_bool_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((infix_eqeq a1 a') -> ((indic_bool a1 a') = true)) /\
  (~ (infix_eqeq a1 a') -> ((indic_bool a1 a') = false)).

Axiom indic_bool_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic_bool a1 a') = true)) /\
  (~ (a1 = a') -> ((indic_bool a1 a') = false)).

Axiom indic_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a), ((indic a1 a') = (indic a' a1)).

Axiom indic_transl_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a) (c:a), (b = c) -> ((indic a1 b) = (indic a1 c)).

Axiom indic_transl_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a) (c:a), (b = c) -> ((indic b a1) = (indic c a1)).

Parameter indic_2:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, a -> a -> b ->
  b -> t.

Axiom indic_2_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((((indic_bool a1 a') = true) /\ ((indic_bool b1 b') = true)) ->
   ((indic_2 a1 a' b1 b') = tone)) /\
  (~ (((indic_bool a1 a') = true) /\ ((indic_bool b1 b') = true)) ->
   ((indic_2 a1 a' b1 b') = tzero)).

Axiom indic_2_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (infix_asdt (indic a1 a') (indic b1 b'))).

Axiom indic_2_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (indic (a1, b1) (a', b'))).

Axiom indic_2_if :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (i:a) (k:a) (j:b) (l:b),
  (((i = k) /\ (j = l)) -> ((indic_2 i k j l) = tone)) /\
  (~ ((i = k) /\ (j = l)) -> ((indic_2 i k j l) = tzero)).

Axiom indic_2_comm :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (indic_2 a' a1 b1 b')).

Axiom indic_2_comm1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (indic_2 a1 a' b' b1)).

Axiom indic_2_comm2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (indic_2 a' a1 b' b1)).

Parameter sum_indic:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> t) -> a -> t.

Axiom sum_indic_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (i:a),
  ((sum_indic s t1 i) =
   (sum s (fun (e:a) => (infix_asdt (t1 e) (indic i e))))).

Parameter bool_to_t: bool -> t.

Axiom bool_to_t_def :
  forall (a:bool),
  ((a = true) -> ((bool_to_t a) = tone)) /\
  (~ (a = true) -> ((bool_to_t a) = tzero)).

Parameter ind_sum_indic: (Z -> t) -> Z -> Z -> Z -> t.

Axiom ind_sum_indic_def :
  forall (t1:Z -> t) (l:Z) (h:Z) (i:Z), (l < h)%Z ->
  ((ind_sum_indic t1 l h i) =
   (ind_sum (fun (e:Z) => (infix_asdt (t1 e) (indic i e))) l h)).

Axiom ind_sum_indic_spec :
  forall (t1:Z -> t) (l:Z) (h:Z) (i:Z), (l < h)%Z ->
  ((ind_sum_indic t1 l h i) = (sum_indic (to_fset l h) t1 i)).

Axiom sum_indic_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (i:a), (mem i s) ->
  ((sum_indic s t1 i) = (t1 i)).

Axiom sum_indic_ts :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (i:a), (mem i s) ->
  ((sum s (fun (e:a) => (infix_asdt (t1 e) (indic i e)))) = (t1 i)).

Axiom ind_sum_indic_t :
  forall (t1:Z -> t) (l:Z) (h:Z) (i:Z), ((l <= i)%Z /\ (i < h)%Z) ->
  ((ind_sum_indic t1 l h i) = (t1 i)).

Axiom ind_sum_indic_t1 :
  forall (t1:Z -> t) (l:Z) (h:Z) (i:Z), ((l <= i)%Z /\ (i < h)%Z) ->
  ((ind_sum (fun (e:Z) => (infix_asdt (t1 e) (indic i e))) l h) = (t1 i)).

Axiom ind_sum_indic_t_quant :
  forall (t1:Z -> t) (l:Z) (h:Z), forall (i:Z), ((l <= i)%Z /\ (i < h)%Z) ->
  ((ind_sum (fun (e:Z) => (infix_asdt (t1 e) (indic i e))) l h) = (t1 i)).

Axiom indic_div_mod :
  forall (i:Z) (j:Z) (q:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z < q)%Z ->
  ((indic i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i q) (int.EuclideanDivision.mod1 j q))
    (indic (int.EuclideanDivision.div i q) (int.EuclideanDivision.div j q)))).

Axiom indic_div_mod_gen :
  forall (q:Z), (0%Z < q)%Z -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (0%Z <= j)%Z) ->
  ((indic i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i q) (int.EuclideanDivision.mod1 j q))
    (indic (int.EuclideanDivision.div i q) (int.EuclideanDivision.div j q)))).

Axiom set_inf : True.

Axiom set_infeq : True.

Axiom bounded_cycle :
  forall (a:Z) (b:Z) (c:Z) (d:Z), (0%Z <= a)%Z -> (0%Z < b)%Z ->
  ((0%Z <= d)%Z /\ (d < b)%Z) -> (0%Z < c)%Z ->
  ((int.EuclideanDivision.div ((a * b)%Z + d)%Z (b * c)%Z) =
   (int.EuclideanDivision.div a c)).

Axiom div_mod_minus :
  forall (a:Z) (b:Z), (0%Z < b)%Z -> ((0%Z < a)%Z /\ (a < b)%Z) ->
  ((int.EuclideanDivision.mod1 (-a)%Z b) =
   (b - (int.EuclideanDivision.mod1 a b))%Z).

Axiom leq_trans :
  forall (a:Z) (b:Z) (c:Z), (a <= b)%Z -> (b <= c)%Z -> (a <= c)%Z.

Axiom leq_trans_add :
  forall (a:Z) (b:Z) (c:Z) (d:Z), (a <= c)%Z -> (b <= d)%Z ->
  ((a + b)%Z <= (c + d)%Z)%Z.

Axiom leq_trans_mult :
  forall (a:Z) (b:Z) (c:Z), (0%Z <= c)%Z -> (a <= b)%Z ->
  ((a * c)%Z <= (b * c)%Z)%Z.

Axiom neutrals : (0%Z = (neutral_elt (fun (y0:Z) (y1:Z) => (y0 + y1)%Z))).

Axiom neutrals1 : (1%Z = (neutral_elt (fun (y0:Z) (y1:Z) => (y0 * y1)%Z))).

Axiom neutrals2 : iterable (fun (y0:Z) (y1:Z) => (y0 + y1)%Z).

Axiom neutrals3 : iterable (fun (y0:Z) (y1:Z) => (y0 * y1)%Z).

Parameter isum: forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z) -> Z.

Axiom isum_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> Z),
  ((isum s t1) = (iterate (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) s t1)).

Axiom isum_iter : iterates (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) 0%Z.

Axiom isum_iter__ : iterable (fun (y0:Z) (y1:Z) => (y0 + y1)%Z).

Axiom isum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> Z) (t':a -> Z),
  (forall (e:a), (mem e s) -> ((t1 e) = (t' e))) ->
  ((isum s t1) = (isum s t')).

Axiom isum_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (t1:a -> Z) (t':a -> Z), (s = s') ->
  (forall (e:a), (mem e s) -> ((t1 e) = (t' e))) ->
  ((isum s t1) = (isum s t')).

Axiom isum_add :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> Z) (x:b), ~ (mem x s) ->
  ((isum (add x s) f) = ((f x) + (isum s f))%Z).

Axiom mul_assoc :
  forall (a:Z) (b:Z) (c:Z), (((a * b)%Z * c)%Z = (a * (b * c)%Z)%Z).

Axiom ad_assoc :
  forall (a:Z) (b:Z) (c:Z), (((a + b)%Z + c)%Z = (a + (b + c)%Z)%Z).

Axiom ad_assoc_rev :
  forall (a:Z) (b:Z) (c:Z), ((a + (b + c)%Z)%Z = ((a + b)%Z + c)%Z).

Axiom mul_comm : forall (a:Z) (b:Z), ((a * b)%Z = (b * a)%Z).

Axiom add_eq_i :
  forall (a:Z) (a':Z) (b:Z) (b':Z), (a = a') -> (b = b') ->
  ((a + b)%Z = (a' + b')%Z).

Axiom mult_eq_i :
  forall (a:Z) (a':Z) (b:Z) (b':Z), (a = a') -> (b = b') ->
  ((a * b)%Z = (a' * b')%Z).

Axiom mul_assoc_rev :
  forall (a:Z) (b:Z) (c:Z), ((a * (b * c)%Z)%Z = ((a * b)%Z * c)%Z).

Axiom mult_add_distr :
  forall (a:Z) (b:Z) (c:Z) (d:Z),
  (((a + b)%Z * (c + d)%Z)%Z =
   ((((a * c)%Z + (a * d)%Z)%Z + (b * c)%Z)%Z + (b * d)%Z)%Z).

Axiom mult_add_right :
  forall (a:Z) (b:Z) (c:Z), (((a + b)%Z * c)%Z = ((a * c)%Z + (b * c)%Z)%Z).

Axiom mult_add_right_rev :
  forall (a:Z) (b:Z) (c:Z), (((a * c)%Z + (b * c)%Z)%Z = ((a + b)%Z * c)%Z).

Axiom mult_add_left :
  forall (a:Z) (b:Z) (c:Z), ((a * (b + c)%Z)%Z = ((a * b)%Z + (a * c)%Z)%Z).

Axiom mult_add_left_rev :
  forall (a:Z) (b:Z) (c:Z), (((a * b)%Z + (a * c)%Z)%Z = (a * (b + c)%Z)%Z).

Axiom mult_add_distr_rev :
  forall (a:Z) (b:Z) (c:Z) (d:Z),
  (((((a * c)%Z + (a * d)%Z)%Z + (b * c)%Z)%Z + (b * d)%Z)%Z =
   ((a + b)%Z * (c + d)%Z)%Z).

Axiom mul_assoc_comm :
  forall (a:Z) (b:Z) (c:Z), (((a * b)%Z * c)%Z = (b * (a * c)%Z)%Z).

Axiom mul_assoc_rev_comm :
  forall (a:Z) (b:Z) (c:Z), ((a * (b * c)%Z)%Z = ((a * c)%Z * b)%Z).

Axiom add_assoc :
  forall (a:Z) (b:Z) (c:Z), (((a + b)%Z + c)%Z = (a + (b + c)%Z)%Z).

Axiom add_assoc_rev :
  forall (a:Z) (b:Z) (c:Z), ((a + (b + c)%Z)%Z = ((a + b)%Z + c)%Z).

Axiom isum_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z), (is_empty s) -> ((isum s f) = 0%Z).

Axiom isum_iter_ :
  opposite_n (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
  (fun (y0:Z) (y1:Z) => (y0 - y1)%Z) 0%Z.

Axiom isum_iter_1 :
  opposite1 (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
  (fun (y0:Z) (y1:Z) => (y0 - y1)%Z).

Axiom isum_iter_2 :
  opposite_com (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
  (fun (y0:Z) (y1:Z) => (y0 - y1)%Z).

Axiom isum_iter_3 :
  inverse_tuple (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
  (fun (y0:Z) (y1:Z) => (y0 - y1)%Z) 0%Z.

Parameter ind_isum: (Z -> Z) -> Z -> Z -> Z.

Axiom ind_isum_def :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_isum f i j) = (int_iterate (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) f i j)).

Axiom ind_isum_empty :
  forall (f:Z -> Z) (i:Z) (j:Z), (j <= i)%Z -> ((ind_isum f i j) = 0%Z).

Axiom ind_isum_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((ind_isum f i j) = (f i)).

Axiom ind_isum_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum f i j) = ((f i) + (ind_isum f (i + 1%Z)%Z j))%Z).

Axiom ind_isum_to_isum :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum f i j) = (isum (to_fset i j) f)).

Axiom ind_isum_const :
  forall (k:Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum ((fun (y0:Z) (y1:Z) => (const y0 y1)) k) i j) =
   (k * (j - i)%Z)%Z).

Axiom ind_isum_null :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = 0%Z)) ->
  ((ind_isum f i j) = 0%Z).

Axiom ind_isum_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((ind_isum f i (j + 1%Z)%Z) = ((ind_isum f i j) + (f j))%Z).

Axiom ind_isum_re :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum f i j) = ((ind_isum f i (j - 1%Z)%Z) + (f (j - 1%Z)%Z))%Z).

Axiom ind_isum_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_isum f i j) = (ind_isum g i j)).

Parameter fc2: (Z -> Z) -> (Z -> Z) -> (Z -> bool) -> Z -> Z.

Axiom fc_def2 :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (k:Z),
  (((p k) = true) -> (((fc2 f g p) k) = (f k))) /\
  (~ ((p k) = true) -> (((fc2 f g p) k) = (g k))).

Axiom ind_isum_to_guard :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((p k) = true)) ->
  ((ind_isum (fc2 f g p) i j) = (ind_isum f i j)).

Parameter fc3: (Z -> Z) -> (Z -> Z) -> (Z -> bool) -> Z -> Z.

Axiom fc_def3 :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (k:Z),
  (((p k) = true) -> (((fc3 f g p) k) = (g k))) /\
  (~ ((p k) = true) -> (((fc3 f g p) k) = (f k))).

Axiom ind_isum_no_guard :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ~ ((p k) = true)) ->
  ((ind_isum (fc3 f g p) i j) = (ind_isum f i j)).

Axiom ind_isum_eq_gen :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (i1:Z) (j:Z) (j1:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) -> (i = i1) ->
  (j = j1) -> ((ind_isum f i j) = (ind_isum g i1 j1)).

Axiom ind_isum_func_const :
  forall (k:Z) (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (l:Z), ((i <= l)%Z /\ (l < j)%Z) -> ((f l) = k)) ->
  ((ind_isum f i j) = (k * (j - i)%Z)%Z).

Axiom ind_isum_pos :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) >= 0%Z)%Z) ->
  (0%Z <= (ind_isum f i j))%Z.

Parameter ind_iproduct: (Z -> Z) -> Z -> Z -> Z.

Axiom ind_iproduct_def :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_iproduct f i j) =
   (int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) f i j)).

Axiom ind_iproduct_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_iproduct f i j) = (ind_iproduct g i j)).

Axiom ind_iproduct_eq_gen :
  forall (f:Z -> Z) (g:Z -> Z) (i1:Z) (j1:Z) (i2:Z) (j2:Z),
  (forall (k:Z), ((i1 <= k)%Z /\ (k < j1)%Z) -> ((f k) = (g k))) ->
  (i1 = i2) -> (j1 = j2) -> ((ind_iproduct f i1 j1) = (ind_iproduct g i2 j2)).

Axiom mult_one_int : forall (a:Z) (b:Z), (b = 1%Z) -> ((a * b)%Z = a).

Axiom one_mult_int : forall (a:Z) (b:Z), (a = 1%Z) -> ((a * b)%Z = b).

Axiom mult_zero_int : forall (a:Z) (b:Z), (b = 0%Z) -> ((a * b)%Z = 0%Z).

Axiom zero_mult_int : forall (a:Z) (b:Z), (a = 0%Z) -> ((a * b)%Z = 0%Z).

Axiom iproduct_to_iterate :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_iproduct f i j) =
   (int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) f i j)).

Axiom ind_isum_map_auto :
  forall (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((ind_isum t1 i j) = (ind_isum (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_isum_map :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_isum t1 k l) = (ind_isum (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_isum_map_auto_bij :
  forall (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> Z),
  (forall (e:Z), ((i <= e)%Z /\ (e < j)%Z) ->
   (i <= (f e))%Z /\ ((f e) < j)%Z) ->
  (forall (e:Z) (e':Z), ((i <= e)%Z /\ (e < j)%Z) ->
   ((i <= e')%Z /\ (e' < j)%Z) -> ~ (e = e') -> ~ ((f e) = (f e'))) ->
  (forall (e':Z), ((i <= e')%Z /\ (e' < j)%Z) ->
   exists e:Z, ((i <= e)%Z /\ (e < j)%Z) /\ ((f e) = e')) ->
  ((ind_isum t1 i j) = (ind_isum (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_isum_map_bij :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> Z),
  (forall (e:Z), ((i <= e)%Z /\ (e < j)%Z) ->
   (k <= (f e))%Z /\ ((f e) < l)%Z) ->
  (forall (e:Z) (e':Z), ((i <= e)%Z /\ (e < j)%Z) ->
   ((i <= e')%Z /\ (e' < j)%Z) -> ~ (e = e') -> ~ ((f e) = (f e'))) ->
  (forall (e':Z), ((k <= e')%Z /\ (e' < l)%Z) ->
   exists e:Z, ((i <= e)%Z /\ (e < j)%Z) /\ ((f e) = e')) ->
  ((ind_isum t1 k l) = (ind_isum (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_iproduct_empty :
  forall (f:Z -> Z) (i:Z) (j:Z), (i >= j)%Z -> ((ind_iproduct f i j) = 1%Z).

Axiom ind_iproduct_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_iproduct f i j) = ((f i) * (ind_iproduct f (i + 1%Z)%Z j))%Z).

Axiom ind_iproduct_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_iproduct f i j) =
   ((ind_iproduct f i (j - 1%Z)%Z) * (f (j - 1%Z)%Z))%Z).

Axiom ind_iproduct_right_extension_comm :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (((ind_iproduct f i (j - 1%Z)%Z) * (f (j - 1%Z)%Z))%Z =
   (ind_iproduct f i j)).

Axiom ind_iproduct_one :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = 1%Z)) ->
  ((ind_iproduct f i j) = 1%Z).

Axiom positive_iproduct :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) > 0%Z)%Z) ->
  ((ind_iproduct f i j) > 0%Z)%Z.

Axiom ind_iproduct_pos :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z <= (f k))%Z) ->
  (0%Z <= (ind_iproduct f i j))%Z.

Axiom ind_iproduct_left_right :
  forall (f:Z -> Z) (l:Z) (k:Z) (h:Z), ((l <= k)%Z /\ (k <= h)%Z) ->
  ((ind_iproduct f l k) =
   (ind_iproduct (fun (a:Z) => (f ((h - (a + 1%Z)%Z)%Z + l)%Z))
    ((h - k)%Z + l)%Z h)).

Axiom iterable_imult : iterable (fun (y0:Z) (y1:Z) => (y0 * y1)%Z).

Axiom int_minus_distr :
  forall (a:Z) (b:Z), ((-(a + b)%Z)%Z = ((-a)%Z + (-b)%Z)%Z).

Axiom int_minus_eq : forall (a:Z) (b:Z), (a = b) -> ((-a)%Z = (-b)%Z).

Axiom ind_iproduct_map_auto :
  forall (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((ind_iproduct t1 i j) = (ind_iproduct (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_iproduct_map :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_iproduct t1 k l) = (ind_iproduct (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_iproduct_trans :
  forall (f:Z -> Z) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_iproduct f i j) = ((ind_iproduct f i k) * (ind_iproduct f k j))%Z).

Axiom ind_isum_transl :
  forall (f:Z -> Z) (i:Z) (j:Z) (k:Z),
  ((ind_isum f i j) =
   (ind_isum (fun (b:Z) => (f (b + k)%Z)) (i - k)%Z (j - k)%Z)).

Axiom ind_isum_transl_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_isum f i j) =
   (ind_isum (fun (b:Z) => (f (b - 1%Z)%Z)) (i + 1%Z)%Z (j + 1%Z)%Z)).

Axiom ind_isum_transl_minus_one :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_isum f i j) =
   (ind_isum (fun (b:Z) => (f (b + 1%Z)%Z)) (i - 1%Z)%Z (j - 1%Z)%Z)).

Axiom ind_isum_scal :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  ((ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j) = (a * (ind_isum f i j))%Z).

Axiom minus_ind_isum :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((-(ind_isum f i j))%Z = (ind_isum (fun (i1:Z) => (-(f i1))%Z) i j)).

Axiom minus_ind_isum_rev :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((ind_isum (fun (i1:Z) => (-(f i1))%Z) i j) = (-(ind_isum f i j))%Z).

Axiom ind_isum_scal_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  ((a * (ind_isum f i j))%Z = (ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j)).

Axiom ind_isum_scal_rev_right :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  (((ind_isum f i j) * a)%Z = (ind_isum (fun (i1:Z) => ((f i1) * a)%Z) i j)).

Axiom ind_isum_scal_right :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  ((ind_isum (fun (i1:Z) => ((f i1) * a)%Z) i j) = ((ind_isum f i j) * a)%Z).

Axiom ind_isum_bound :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) < (g k))%Z) ->
  ((ind_isum f i j) < (ind_isum g i j))%Z.

Axiom comp_trans_equal_strict :
  forall (a:Z) (b:Z) (c:Z), (a <= b)%Z -> (b < c)%Z -> (a < c)%Z.

Axiom compeq_trans_sum :
  forall (a:Z) (b:Z) (c:Z), (b <= c)%Z -> ((a + b)%Z <= (a + c)%Z)%Z.

Axiom compeq_trans_sum_zero :
  forall (a:Z) (b:Z), (0%Z <= b)%Z -> (a <= (a + b)%Z)%Z.

Axiom comp_trans_sum :
  forall (a:Z) (b:Z) (c:Z), (b < c)%Z -> ((a + b)%Z < (a + c)%Z)%Z.

Axiom ind_isum_bound_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) <= (g k))%Z) ->
  ((ind_isum f i j) <= (ind_isum g i j))%Z.

Axiom ind_isum_scal_gen :
  forall (f:Z -> Z) (i:Z) (j:Z), forall (a:Z), ((i <= a)%Z /\ (a < j)%Z) ->
  ((ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j) = (a * (ind_isum f i j))%Z).

Axiom ind_isum_trans :
  forall (f:Z -> Z) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_isum f i j) = ((ind_isum f i k) + (ind_isum f k j))%Z).

Parameter power: Z -> Z -> Z.

Axiom power_def :
  forall (e:Z) (i:Z), (i >= 0%Z)%Z -> (i = 0%Z) -> ((power e i) = 1%Z).

Axiom power_def1 :
  forall (e:Z) (i:Z), (i >= 0%Z)%Z -> ~ (i = 0%Z) ->
  ((power e i) = (e * (power e (i - 1%Z)%Z))%Z).

Axiom Power_zero : forall (i:Z), ((power i 0%Z) = 1%Z).

Axiom Power_one : forall (i:Z), ((power i 1%Z) = i).

Axiom Power_sum :
  forall (x:Z) (y:Z) (i:Z), (x >= 0%Z)%Z -> (y >= 0%Z)%Z ->
  ((power i (x + y)%Z) = ((power i x) * (power i y))%Z).

Axiom Power_mult :
  forall (x:Z) (y:Z) (i:Z), (x >= 0%Z)%Z -> (y >= 0%Z)%Z ->
  ((power i (x * y)%Z) = (power (power i x) y)).

Axiom power_plus_one :
  forall (e:Z) (i:Z), (i >= 0%Z)%Z ->
  ((power e (i + 1%Z)%Z) = (e * (power e i))%Z).

Axiom power_to_ind_iproduct :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) =
   (ind_iproduct ((fun (y0:Z) (y1:Z) => (const y0 y1)) e) 0%Z i)).

Axiom power_transl :
  forall (e:Z) (k:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) =
   (ind_iproduct ((fun (y0:Z) (y1:Z) => (const y0 y1)) e) k (k + i)%Z)).

Axiom ind_iproduct_to_power :
  forall (e:Z) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((ind_iproduct ((fun (y0:Z) (y1:Z) => (const y0 y1)) e) i j) =
   (power e (j - i)%Z)).

Axiom ind_iproduct_to_power_gen :
  forall (e:Z), forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((ind_iproduct ((fun (y0:Z) (y1:Z) => (const y0 y1)) e) i j) =
   (power e (j - i)%Z)).

Axiom power_sum :
  forall (x:Z) (n:Z) (m:Z), (n >= 0%Z)%Z -> (m >= 0%Z)%Z ->
  ((power x (n + m)%Z) = ((power x n) * (power x m))%Z).

Axiom power_sum_rev :
  forall (x:Z) (n:Z) (m:Z), (n >= 0%Z)%Z -> (m >= 0%Z)%Z ->
  (((power x n) * (power x m))%Z = (power x (n + m)%Z)).

Axiom power_eq :
  forall (x:Z) (n:Z) (m:Z), (n = m) -> ((power x n) = (power x m)).

Axiom power_eq_gen :
  forall (x:Z) (y:Z) (n:Z) (m:Z), (n = m) -> (x = y) ->
  ((power x n) = (power y m)).

Axiom power_decomp :
  forall (i:Z), (i >= 1%Z)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z (k + 1%Z)%Z)) 0%Z i) <
   (power 2%Z (i + 1%Z)%Z))%Z.

Parameter fc4: Z -> Z -> Z.

Axiom fc_def4 :
  forall (i:Z) (k:Z),
  (((1%Z <= k)%Z /\ (k < (i + 1%Z)%Z)%Z) ->
   (((fc4 i) k) = (power 2%Z (k - 1%Z)%Z))) /\
  (~ ((1%Z <= k)%Z /\ (k < (i + 1%Z)%Z)%Z) -> (((fc4 i) k) = 0%Z)).

Axiom power_decomp_minus_one :
  forall (i:Z), (i >= 1%Z)%Z ->
  ((ind_isum (fc4 i) 1%Z i) < (power 2%Z (i - 1%Z)%Z))%Z.

Axiom power_decomp_ :
  forall (i:Z), (i >= 1%Z)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z k)) 0%Z i) < (power 2%Z i))%Z.

Axiom power_decomp_one :
  forall (i:Z), (i >= 1%Z)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z (k + 1%Z)%Z)) 1%Z i) <
   (power 2%Z (i + 1%Z)%Z))%Z.

Axiom power_decomp_one_ :
  forall (i:Z), (i >= 1%Z)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z k)) 1%Z i) < (power 2%Z i))%Z.

Axiom growing_mult :
  forall (n:Z) (m:Z), (0%Z <= n)%Z -> (1%Z <= m)%Z -> ((n * m)%Z >= n)%Z.

Axiom strict_growing_mult :
  forall (n:Z) (m:Z), (1%Z < n)%Z -> (1%Z < m)%Z -> ((n * m)%Z > n)%Z.

Axiom init_exp : forall (k:Z), ((power k 0%Z) = 1%Z).

Axiom init_exp1 : forall (k:Z), ((power k 1%Z) = k).

Axiom init_exp2 : forall (k:Z), ((power k 2%Z) = (k * k)%Z).

Axiom positive_int_exp :
  forall (k:Z) (n:Z), (1%Z <= k)%Z -> (0%Z <= n)%Z -> ((power k n) >= 1%Z)%Z.

Axiom positive_int_exp1 :
  forall (k:Z) (n:Z), (1%Z <= k)%Z -> (0%Z <= n)%Z -> ((power k n) > 0%Z)%Z.

Axiom positive_int_exp2 :
  forall (k:Z) (n:Z), (1%Z <= k)%Z -> (0%Z <= n)%Z ->
  ((power k n) <= (power k (n + 1%Z)%Z))%Z.

Axiom strict_positive_int_exp :
  forall (k:Z) (n:Z), (1%Z < k)%Z -> (0%Z < n)%Z -> ((power k n) > 1%Z)%Z.

Axiom strict_positive_int_exp1 :
  forall (k:Z) (n:Z), (1%Z < k)%Z -> (0%Z < n)%Z ->
  ((power k (n - 1%Z)%Z) < (power k n))%Z.

Axiom strict_positive_int_exp2 :
  forall (k:Z) (n:Z), (1%Z < k)%Z -> (0%Z < n)%Z ->
  ((power k n) < (power k (n + 1%Z)%Z))%Z.

Axiom power_minus_one :
  forall (i:Z), (0%Z <= i)%Z -> ((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) ->
  ((power (-1%Z)%Z i) = 1%Z).

Axiom power_minus_one1 :
  forall (i:Z), (0%Z <= i)%Z -> ((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
  ((power (-1%Z)%Z i) = (-1%Z)%Z).

Axiom growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z <= k)%Z -> ((0%Z <= m)%Z /\ (m <= n)%Z) ->
  ((power k m) <= (power k n))%Z.

Axiom strict_growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> ((0%Z <= m)%Z /\ (m < n)%Z) ->
  ((power k m) < (power k n))%Z.

Axiom unicity_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((power k m) = (power k n)) -> (m = n).

Axiom unicity_exp1 :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  (m = n) -> ((power k m) = (power k n)).

Axiom bounded_sum_exp :
  forall (i:Z) (j:Z) (m:Z) (n:Z), (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  (((i * (power 2%Z n))%Z + j)%Z < (power 2%Z (m + n)%Z))%Z.

Axiom power_minus_one2 :
  forall (i:Z), (i >= 0%Z)%Z -> ((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) ->
  ((power (-1%Z)%Z i) = 1%Z).

Axiom power_minus_one3 :
  forall (i:Z), (i >= 0%Z)%Z -> ((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
  ((power (-1%Z)%Z i) = (-1%Z)%Z).

Parameter kth_right: Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom kth_right_def :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l < h)%Z) -> (0%Z < (f l))%Z) ->
  ((kth_right i k h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))
    (f (h - k)%Z))).

Axiom kth_right_spec :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l < h)%Z) -> (0%Z < (f l))%Z) ->
  (0%Z <= (kth_right i k h f))%Z.

Axiom kth_right_spec1 :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l < h)%Z) -> (0%Z < (f l))%Z) ->
  ((kth_right i k h f) < (f (h - k)%Z))%Z.

Axiom kth_right_eq :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z) (g:Z -> Z), (0%Z <= i)%Z ->
  (1%Z <= k)%Z ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l <= h)%Z) -> (0%Z < (f l))%Z) ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l <= h)%Z) -> ((f l) = (g l))) ->
  ((kth_right i k h f) = (kth_right i k h g)).

Axiom kth_right_trans :
  forall (i:Z) (k:Z) (h:Z) (t1:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (0%Z < (f l))%Z) -> (0%Z <= h)%Z -> (0%Z <= t1)%Z ->
  ((kth_right (int.EuclideanDivision.div i (ind_iproduct f h (h + t1)%Z)) k h
    f)
   = (kth_right i (k + t1)%Z (h + t1)%Z f)).

Parameter kth_left: Z -> Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom kth_left_def :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) = (kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h f)).

Axiom kth_left_spec :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f (l + k)%Z h))
    (f ((l + k)%Z - 1%Z)%Z))).

Axiom kth_left_spec1 :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  (0%Z <= (kth_left i k l h f))%Z.

Axiom kth_left_spec2 :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) < (f ((l + k)%Z - 1%Z)%Z))%Z.

Axiom kth_left_eq :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z) (g:Z -> Z), (0%Z <= i)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) -> (0%Z <= l)%Z ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) ->
   ((f ind) = (g ind)) /\ ((g ind) > 0%Z)%Z) ->
  ((kth_left i k l h f) = (kth_left i k l h g)).

Axiom kth_left_to_mod_div :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind <= h)%Z) -> ((f ind) > 0%Z)%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f (l + k)%Z h))
    (f ((l + k)%Z - 1%Z)%Z))).

Axiom kth_left_trans :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k < (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind <= h)%Z) -> ((f ind) > 0%Z)%Z) ->
  ((kth_left i k l h f) =
   (kth_left (int.EuclideanDivision.div i (f (h - 1%Z)%Z)) k l (h - 1%Z)%Z f)).

Axiom div_isum_exponents :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power k (n + m)%Z) = ((power k n) * (power k m))%Z).

Axiom div_isum_exponents1 :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power k (n + 1%Z)%Z) = ((power k n) * k)%Z).

Axiom div_isum_exponents2 :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z -> ((power k 1%Z) = k).

Axiom div_isum_exponents3 :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n))
    (power k m))
   = (int.EuclideanDivision.div i (power k (n + m)%Z))).

Axiom div_isum_exponents4 :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n)) k) =
   (int.EuclideanDivision.div i (power k (n + 1%Z)%Z))).

Parameter divp: Z -> Z -> Z.

Axiom divp_def :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((divp i j) = ((int.EuclideanDivision.div i j) * j)%Z).

Axiom divp_spec :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i = ((divp i j) + (int.EuclideanDivision.mod1 i j))%Z).

Axiom divp_spec1 :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> ((divp i j) <= i)%Z.

Axiom divp_spec2 :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i < (((divp i j) + 1%Z)%Z * j)%Z)%Z.

Axiom divp_spec3 :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (i > j)%Z ->
  ((divp i j) > 0%Z)%Z.

Axiom kth_right_div_mod :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((kth_right i k h f) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h))
    (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))).

Axiom kth_head :
  forall (i:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= h)%Z ->
  (forall (k:Z), (0%Z < (f k))%Z) ->
  ((kth_right i 1%Z h f) = (int.EuclideanDivision.mod1 i (f (h - 1%Z)%Z))).

Parameter weighted_kth_right: Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom weighted_kth_right_def :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) -> (1%Z <= k)%Z ->
  ((weighted_kth_right i k h f) =
   ((kth_right i k h f) * (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))%Z).

Axiom weighted_kth_right_ :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (1%Z <= k)%Z -> (0%Z <= i)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h)) =
   ((weighted_kth_right i k h f) +
    (int.EuclideanDivision.mod1 i (ind_iproduct f ((h - k)%Z + 1%Z)%Z h)))%Z).

Axiom kth_right_decomposition :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h)) =
   (ind_isum (fun (a:Z) => (weighted_kth_right i a h f)) 1%Z (k + 1%Z)%Z)).

Axiom kth_left_div_mod :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  ((0%Z <= l)%Z /\ (l <= h)%Z) -> ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h))
    (ind_iproduct f (l + k)%Z h))).

Parameter weighted_kth_left: Z -> Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom weighted_kth_left_def :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((weighted_kth_left i k l h f) =
   (weighted_kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h f)).

Axiom weighted_kth_left_ :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h)) =
   ((weighted_kth_left i k l h f) +
    (int.EuclideanDivision.mod1 i (ind_iproduct f (l + k)%Z h)))%Z).

Axiom bounded_kth_left_decomposition :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h)) =
   (ind_isum (fun (a:Z) => (weighted_kth_left i a l h f)) k
    ((h - l)%Z + 1%Z)%Z)).

Axiom kth_left_decomposition :
  forall (i:Z) (l:Z) (h:Z) (f:Z -> Z),
  ((0%Z <= i)%Z /\ (i < (ind_iproduct f l h))%Z) -> (l < h)%Z ->
  (forall (k:Z), (0%Z < (f k))%Z) ->
  (i =
   (ind_isum (fun (a:Z) => (weighted_kth_left i a l h f)) 1%Z
    ((h - l)%Z + 1%Z)%Z)).

Parameter binary: (Z -> Z) -> Prop.

Axiom binary_def :
  forall (t1:Z -> Z),
  (binary t1) <-> forall (k:Z), (0%Z <= (t1 k))%Z /\ ((t1 k) < 2%Z)%Z.

Axiom set_binary :
  forall (t1:Z -> Z),
  (forall (k:Z), (0%Z <= (t1 k))%Z /\ ((t1 k) < 2%Z)%Z) -> binary t1.

Axiom get_binary :
  forall (t1:Z -> Z), (binary t1) -> forall (k:Z), (0%Z <= (t1 k))%Z.

Axiom get_binary1 :
  forall (t1:Z -> Z), (binary t1) -> forall (k:Z), ((t1 k) < 2%Z)%Z.

Parameter shift: forall {a:Type} {a_WT:WhyType a}, (Z -> a) -> Z -> Z -> a.

Axiom shift_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (i:Z) (k:Z), ((shift f i k) = (f (k + i)%Z)).

Axiom shift_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (i:Z) (k:Z), ((shift f i k) = (f (k + i)%Z)).

Axiom shiftz :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z), ((shift f 0%Z k) = (f k)).

Axiom shiftz_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (i:Z) (k:Z), (i = 0%Z) -> ((shift f i k) = (f k)).

Axiom shiftz_quant :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a),
  ((((fun (y0:Z -> a) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) 0%Z) = f).

Axiom shiftz_quant_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a),
  (f = (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) 0%Z)).

Parameter concat_fun:
  forall {a:Type} {a_WT:WhyType a}, (Z -> a) -> (Z -> a) -> Z -> Z -> a.

Axiom concat_fun_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (g:Z -> a) (i:Z) (k:Z),
  ((k < i)%Z -> ((concat_fun f g i k) = (f k))) /\
  (~ (k < i)%Z -> ((concat_fun f g i k) = (g (k - i)%Z))).

Axiom shift_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (i:Z) (j:Z) (k:Z),
  ((shift (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) j) i k) =
   (shift f (i + j)%Z k)).

Axiom concat_fun_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (g:Z -> a) (i:Z) (k:Z),
  ((k < i)%Z -> ((concat_fun f g i k) = (f k))) /\
  (~ (k < i)%Z -> ((concat_fun f g i k) = (g (k - i)%Z))).

Axiom concat_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (f1:Z -> a) (g1:Z -> a) (f2:Z -> a) (g2:Z -> a) (i1:Z) (i2:Z) (k:Z),
  (forall (l:Z), (l < i1)%Z -> ((f1 l) = (f2 l))) ->
  (forall (l:Z), (l >= 0%Z)%Z -> ((g1 l) = (g2 l))) -> (i1 = i2) ->
  ((concat_fun f1 g1 i1 k) = (concat_fun f2 g2 i2 k)).

Parameter mod_func:
  forall {a:Type} {a_WT:WhyType a}, (Z -> a) -> Z -> Z -> a.

Axiom mod_func_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (k > 0%Z)%Z ->
  ((mod_func f k i) = (f (int.EuclideanDivision.mod1 i k))).

Axiom mod_func_inf :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < k)%Z) -> ((mod_func f k i) = (f i)).

Axiom shift_mod :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (k > 0%Z)%Z ->
  ((mod_func f k i) =
   (shift (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (mod_func y0 y1 y2)) f) k) k i)).

Axiom shift_mod_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (k > 0%Z)%Z ->
  ((shift (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (mod_func y0 y1 y2)) f) k) k i)
   = (mod_func f k i)).

Parameter head_bit: Z -> Z -> Z.

Axiom head_bit_def :
  forall (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((head_bit i k) = (int.EuclideanDivision.div i (power 2%Z (k - 1%Z)%Z))).

Axiom head_bit_spec :
  forall (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) -> (0%Z <= (head_bit i k))%Z.

Axiom head_bit_spec1 :
  forall (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) -> ((head_bit i k) <= 1%Z)%Z.

Parameter tail_bits: Z -> Z -> Z.

Axiom tail_bits_def :
  forall (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((tail_bits i k) = (int.EuclideanDivision.mod1 i (power 2%Z (k - 1%Z)%Z))).

Axiom tail_bits_spec :
  forall (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) -> (0%Z <= (tail_bits i k))%Z.

Axiom tail_bits_spec1 :
  forall (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((tail_bits i k) <= (power 2%Z (k - 1%Z)%Z))%Z.

Parameter ht_to_int: Z -> Z -> Z -> Z.

Axiom ht_to_int_def :
  forall (hi:Z) (ti:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= hi)%Z /\ (hi < 2%Z)%Z) ->
  ((0%Z <= ti)%Z /\ (ti < (power 2%Z (k - 1%Z)%Z))%Z) ->
  ((ht_to_int hi ti k) = ((hi * (power 2%Z (k - 1%Z)%Z))%Z + ti)%Z).

Axiom head_tail_inv :
  forall (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((ht_to_int (head_bit i k) (tail_bits i k) k) = i).

Axiom ht_to_int_head :
  forall (i:Z) (ti:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((0%Z <= ti)%Z /\ (ti < (power 2%Z (k - 1%Z)%Z))%Z) ->
  ((head_bit (ht_to_int (head_bit i k) ti k) k) = (head_bit i k)).

Axiom ht_to_int_tail :
  forall (hi:Z) (i:Z) (k:Z), (k > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((0%Z <= hi)%Z /\ (hi < 2%Z)%Z) ->
  ((tail_bits (ht_to_int hi (tail_bits i k) k) k) = (tail_bits i k)).

Axiom concat_fun_bin_i :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (k:Z), (binary f) -> (binary g) ->
  (0%Z <= (concat_fun f g i k))%Z.

Axiom concat_fun_bin_i1 :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (k:Z), (binary f) -> (binary g) ->
  ((concat_fun f g i k) < 2%Z)%Z.

Axiom shift_bin_i :
  forall (f:Z -> Z) (i:Z) (k:Z), (binary f) -> (0%Z <= (shift f i k))%Z.

Axiom shift_bin_i1 :
  forall (f:Z -> Z) (i:Z) (k:Z), (binary f) -> ((shift f i k) < 2%Z)%Z.

Axiom concat_fun_bin :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z), (binary f) -> (binary g) ->
  binary
  ((((fun (y0:Z -> Z) (y1:Z -> Z) (y2:Z) (y3:Z) => (concat_fun y0 y1 y2 y3))
     f)
    g)
   i).

Axiom mod_func_bin :
  forall (f:Z -> Z) (k:Z), (k > 0%Z)%Z -> (binary f) ->
  binary (((fun (y0:Z -> Z) (y1:Z) (y2:Z) => (mod_func y0 y1 y2)) f) k).

Axiom shift_bin :
  forall (f:Z -> Z) (i:Z), (binary f) ->
  binary (((fun (y0:Z -> Z) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) i).

Axiom binary_comp :
  forall (f:Z -> Z) (g:Z -> Z), (binary f) -> binary (fun (x:Z) => (f (g x))).

Axiom set_is_all_binary :
  forall (t1:Z -> Z),
  (forall (k:Z), (0%Z <= (t1 k))%Z /\ ((t1 k) < 2%Z)%Z) -> binary t1.

Parameter nary_length: Z -> Z -> Z.

Axiom nary_length_spec :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z -> (0%Z < i)%Z ->
  ((power n ((nary_length i n) - 1%Z)%Z) <= i)%Z.

Axiom nary_length_spec1 :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z -> (0%Z < i)%Z ->
  (i < (power n (nary_length i n)))%Z.

Axiom nary_length_spec2 :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z -> (i < n)%Z ->
  ((nary_length i n) = 1%Z).

Axiom nary_length_spec3 :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z ->
  ((nary_length i n) >= 1%Z)%Z.

Axiom nary_length_spec4 :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z ->
  (i = (int.EuclideanDivision.mod1 i (power n (nary_length i n)))).

Parameter binary_length: Z -> Z.

Axiom binary_length_def :
  forall (i:Z), (0%Z <= i)%Z -> ((binary_length i) = (nary_length i 2%Z)).

Axiom binary_length_spec :
  forall (i:Z), (0%Z <= i)%Z -> (0%Z < i)%Z ->
  ((power 2%Z ((binary_length i) - 1%Z)%Z) <= i)%Z.

Axiom binary_length_spec1 :
  forall (i:Z), (0%Z <= i)%Z -> (0%Z < i)%Z ->
  (i < (power 2%Z (binary_length i)))%Z.

Axiom binary_length_spec2 :
  forall (i:Z), (0%Z <= i)%Z -> (i < 2%Z)%Z -> ((binary_length i) = 1%Z).

Axiom binary_length_spec3 :
  forall (i:Z), (0%Z <= i)%Z -> ((binary_length i) >= 1%Z)%Z.

Axiom binary_length_spec4 :
  forall (i:Z), (0%Z <= i)%Z ->
  (i = (int.EuclideanDivision.mod1 i (power 2%Z (binary_length i)))).

Axiom set_binary_length :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z <= k)%Z -> ~ (0%Z < i)%Z ->
  ~ (i < 2%Z)%Z -> (k = (binary_length i)).

Axiom set_binary_length1 :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z <= k)%Z -> ~ (0%Z < i)%Z ->
  (k = 1%Z) -> (k = (binary_length i)).

Axiom set_binary_length2 :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z <= k)%Z ->
  (((power 2%Z (k - 1%Z)%Z) <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ~ (i < 2%Z)%Z -> (k = (binary_length i)).

Axiom set_binary_length3 :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z <= k)%Z ->
  (((power 2%Z (k - 1%Z)%Z) <= i)%Z /\ (i < (power 2%Z k))%Z) -> (k = 1%Z) ->
  (k = (binary_length i)).

Axiom set_binary_length_b :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < k)%Z -> (i < (power 2%Z k))%Z ->
  ((binary_length i) <= k)%Z.

Axiom real : forall (x:t), (real_ x) -> (x = (r_to_t (real_part x))).

Axiom pure_im :
  forall (x:t), (pure_im_ x) -> (x = (infix_asdt im (r_to_t (im_part x)))).

Axiom im_dec : ((real_part im) = 0%R).

Axiom im_dec1 : ((im_part im) = 1%R).

Axiom tone_dec : ((real_part tone) = 1%R).

Axiom tone_dec1 : ((im_part tone) = 0%R).

Axiom tzero_dec : ((real_part tzero) = 0%R).

Axiom tzero_dec1 : ((im_part tzero) = 0%R).

Axiom ttwo_dec : ((real_part ttwo) = 2%R).

Axiom ttwo_dec1 : ((im_part ttwo) = 0%R).

Parameter i_to_t: Z -> t.

Axiom i_to_t_def : forall (i:Z), ((i_to_t i) = (r_to_t (from_int i))).

Axiom i_to_t_spec : forall (i:Z), real_ (i_to_t i).

Axiom i_to_t_zero : ((i_to_t 0%Z) = tzero).

Axiom i_to_t_eq : forall (i:Z) (j:Z), (i = j) -> ((i_to_t i) = (i_to_t j)).

Axiom i_to_t_nzero : forall (i:Z), ~ (i = 0%Z) -> ~ ((i_to_t i) = tzero).

Axiom i_to_t_one : ((i_to_t 1%Z) = tone).

Axiom i_to_t_add :
  forall (i:Z) (j:Z),
  ((infix_pldt (i_to_t i) (i_to_t j)) = (i_to_t (i + j)%Z)).

Axiom i_to_t_add_rev :
  forall (i:Z) (j:Z),
  ((i_to_t (i + j)%Z) = (infix_pldt (i_to_t i) (i_to_t j))).

Axiom i_to_t_ttwo : ((i_to_t 2%Z) = ttwo).

Axiom i_to_t_mult_pos :
  forall (i:Z) (j:Z), (0%Z <= j)%Z ->
  ((infix_asdt (i_to_t i) (i_to_t j)) = (i_to_t (i * j)%Z)).

Axiom i_to_t_mult :
  forall (i:Z) (j:Z),
  ((infix_asdt (i_to_t i) (i_to_t j)) = (i_to_t (i * j)%Z)).

Axiom i_to_t_mult_rev :
  forall (i:Z) (j:Z),
  ((i_to_t (i * j)%Z) = (infix_asdt (i_to_t i) (i_to_t j))).

Axiom i_to_t_mult_assoc :
  forall (x:t) (i:Z) (j:Z),
  ((infix_asdt x (i_to_t (i * j)%Z)) =
   (infix_asdt (infix_asdt x (i_to_t i)) (i_to_t j))).

Axiom i_to_t_mult_assoc_rev :
  forall (x:t) (i:Z) (j:Z),
  ((infix_asdt (infix_asdt x (i_to_t i)) (i_to_t j)) =
   (infix_asdt x (i_to_t (i * j)%Z))).

Axiom i_to_t_sub :
  forall (i:Z) (j:Z),
  ((infix_mndt (i_to_t i) (i_to_t j)) = (i_to_t (i - j)%Z)).

Axiom i_to_t_opp :
  forall (i:Z), ((i_to_t (-i)%Z) = (prefix_mndt (i_to_t i))).

Axiom i_to_t_div :
  forall (i:Z) (j:Z), ~ (j = 0%Z) ->
  ((infix_sldt (i_to_t (i * j)%Z) (i_to_t j)) = (i_to_t i)).

Axiom i_to_t_minus_mult :
  forall (i:Z) (j:Z),
  ((infix_asdt (i_to_t (-i)%Z) (i_to_t j)) =
   (infix_asdt (i_to_t i) (i_to_t (-j)%Z))).

Axiom compat_i_to_t_infeq :
  forall (a:Z) (b:Z), (a <= b)%Z -> infix_lseqdt (i_to_t a) (i_to_t b).

Axiom compat_i_to_t_inf :
  forall (a:Z) (b:Z), (a < b)%Z -> infix_lsdt (i_to_t a) (i_to_t b).

Axiom compat_i_to_t_supeq :
  forall (a:Z) (b:Z), (a >= b)%Z -> infix_gteqdt (i_to_t a) (i_to_t b).

Axiom compat_i_to_t_sup :
  forall (a:Z) (b:Z), (a > b)%Z -> infix_gtdt (i_to_t a) (i_to_t b).

Axiom positive_int_squrt :
  forall (i:Z), (i > 0%Z)%Z -> infix_gtdt (square_rt (i_to_t i)) tzero.

Axiom non_null_int_squrt :
  forall (i:Z), (i > 0%Z)%Z -> ~ ((square_rt (i_to_t i)) = tzero).

Axiom abs_eqinf :
  forall (x:Z) (y:Z), ((x <= y)%Z /\ (y <= 0%Z)%Z) ->
  ((ZArith.BinInt.Z.abs x) >= (ZArith.BinInt.Z.abs y))%Z.

Axiom abs_inf :
  forall (x:Z) (y:Z), ((0%Z < x)%Z /\ ((x < y)%Z /\ (y <= 0%Z)%Z)) ->
  ((ZArith.BinInt.Z.abs x) > (ZArith.BinInt.Z.abs y))%Z.

Axiom abs_eqsup :
  forall (x:Z) (y:Z), ((0%Z >= x)%Z /\ (x >= y)%Z) ->
  ((ZArith.BinInt.Z.abs x) <= (ZArith.BinInt.Z.abs y))%Z.

Axiom abs_sup :
  forall (x:Z) (y:Z), ((0%Z >= x)%Z /\ (x > y)%Z) ->
  ((ZArith.BinInt.Z.abs x) < (ZArith.BinInt.Z.abs y))%Z.

Axiom inv_negeq :
  forall (x:Z), (0%Z >= x)%Z -> ((ZArith.BinInt.Z.abs x) >= 0%Z)%Z.

Axiom inv_neg1 :
  forall (x:Z), (0%Z > x)%Z -> ((ZArith.BinInt.Z.abs x) > 0%Z)%Z.

Parameter cpower: t -> Z -> t.

Axiom Cpower_zero : forall (i:t), ((cpower i 0%Z) = tone).

Axiom Cpower_one : forall (i:t), ((cpower i 1%Z) = i).

Axiom Cpower_sum :
  forall (i:t), forall (n:Z) (m:Z), ~ (i = tzero) ->
  ((cpower i (n + m)%Z) = (infix_asdt (cpower i n) (cpower i m))).

Axiom Cpower_sum1 :
  forall (i:t), forall (n:Z) (m:Z), ~ (n = (-m)%Z) ->
  ((cpower i (n + m)%Z) = (infix_asdt (cpower i n) (cpower i m))).

Axiom zero_poower : forall (e:Z), ~ (e = 0%Z) -> ((cpower tzero e) = tzero).

Parameter squarert_two: t.

Axiom squarert_two_def : (squarert_two = (square_rt ttwo)).

Axiom real_squarert_two : real_ squarert_two.

Axiom squarertTwo : ((cpower squarert_two 2%Z) = ttwo).

Axiom complete_rt_two :
  forall (a:t), (a = (infix_sldt squarert_two ttwo)) ->
  ((infix_asdt squarert_two a) = tone).

Axiom cpower_sum :
  forall (x:t) (n:Z) (m:Z), ~ (x = tzero) ->
  ((cpower x (n + m)%Z) = (infix_asdt (cpower x n) (cpower x m))).

Axiom cpower_sum1 :
  forall (x:t) (n:Z) (m:Z), ~ (n = (-m)%Z) ->
  ((cpower x (n + m)%Z) = (infix_asdt (cpower x n) (cpower x m))).

Axiom cpower_one : forall (x:t) (n:Z), (n = 1%Z) -> ((cpower x n) = x).

Axiom cpower_sum_rev :
  forall (x:t) (n:Z) (m:Z), ~ (x = tzero) ->
  ((infix_asdt (cpower x n) (cpower x m)) = (cpower x (n + m)%Z)).

Axiom cpower_sum_rev1 :
  forall (x:t) (n:Z) (m:Z), ~ (n = (-m)%Z) ->
  ((infix_asdt (cpower x n) (cpower x m)) = (cpower x (n + m)%Z)).

Axiom cpower_plus_one :
  forall (e:t) (i:Z), ~ (e = tzero) ->
  ((cpower e (i + 1%Z)%Z) = (infix_asdt (cpower e i) e)).

Axiom cpower_plus_one1 :
  forall (e:t) (i:Z), ~ (i = (-1%Z)%Z) ->
  ((cpower e (i + 1%Z)%Z) = (infix_asdt (cpower e i) e)).

Axiom cpower_zero : forall (e:t), ((cpower e 0%Z) = tone).

Axiom cpower_eq :
  forall (e:t) (e':t) (i:Z) (i':Z), (e = e') -> (i = i') ->
  ((cpower e i) = (cpower e' i')).

Axiom cpower_inv :
  forall (e:t) (i:Z), ~ (e = tzero) ->
  ((infix_asdt (cpower e i) (cpower e (-i)%Z)) = tone).

Axiom cpower_inv_rew :
  forall (e:t) (i:Z), ~ (e = tzero) ->
  ((cpower e i) = (infix_sldt tone (cpower e (-i)%Z))).

Axiom inv_cpower :
  forall (e:t) (i:Z), ~ ((cpower e i) = tzero) ->
  ((infix_sldt tone (cpower e i)) = (cpower e (-i)%Z)).

Axiom cpower_mult_split :
  forall (x:t) (y:t) (m:Z), (0%Z <= m)%Z ->
  ((cpower (infix_asdt x y) m) = (infix_asdt (cpower x m) (cpower y m))).

Axiom cpower_inv_out :
  forall (x:t) (y:t), ~ (y = tzero) ->
  ((infix_asdt (cpower (infix_asdt (infix_sldt tone (square_rt y)) x) 2%Z) y)
   = (cpower x 2%Z)).

Axiom cpower_tone_pos :
  forall (m:Z), (m >= 0%Z)%Z -> ((cpower tone m) = tone).

Axiom mult_cpower :
  forall (x:t) (x':t) (i:Z), (0%Z <= i)%Z ->
  ((infix_asdt (cpower x i) (cpower x' i)) = (cpower (infix_asdt x x') i)).

Axiom mult_cpower_rev :
  forall (x:t) (x':t) (i:Z), (0%Z <= i)%Z ->
  ((cpower (infix_asdt x x') i) = (infix_asdt (cpower x i) (cpower x' i))).

Axiom cpower_iterate :
  forall (e:t) (i:Z), (0%Z <= i)%Z ->
  ((cpower e i) =
   (int_iterate (fun (y0:t) (y1:t) => (infix_asdt y0 y1))
    ((fun (y0:t) (y1:Z) => (const y0 y1)) e) 0%Z i)).

Axiom cpower_modulus :
  forall (x:t) (n:Z), (0%Z <= n)%Z ->
  ((modulus (cpower x n)) = (cpower (modulus x) n)).

Axiom cpower_modulus1 :
  forall (x:t) (n:Z), (0%Z <= n)%Z -> (n > 0%Z)%Z ->
  (infix_lsdt (modulus x) tone) -> infix_lsdt (modulus (cpower x n)) tone.

Axiom cpower_modulus2 :
  forall (x:t) (n:Z), (0%Z <= n)%Z -> (n > 0%Z)%Z -> ((modulus x) = tone) ->
  ((modulus (cpower x n)) = tone).

Axiom cpower_modulus3 :
  forall (x:t) (n:Z), (0%Z <= n)%Z -> (n > 0%Z)%Z ->
  (infix_gtdt (modulus x) tone) -> infix_gtdt (modulus (cpower x n)) tone.

Axiom cpower_modulus4 :
  forall (x:t) (n:Z), (0%Z <= n)%Z -> (n > 0%Z)%Z ->
  (infix_lsdt (modulus (cpower x n)) tone) -> infix_lsdt (modulus x) tone.

Axiom cpower_modulus5 :
  forall (x:t) (n:Z), (0%Z <= n)%Z -> (n > 0%Z)%Z ->
  ((modulus (cpower x n)) = tone) -> ((modulus x) = tone).

Axiom cpower_modulus6 :
  forall (x:t) (n:Z), (0%Z <= n)%Z -> (n > 0%Z)%Z ->
  (infix_gtdt (modulus (cpower x n)) tone) -> infix_gtdt (modulus x) tone.

Axiom cpower_mult_pre :
  forall (x:t) (n:Z) (m:Z), (0%Z <= m)%Z ->
  ((cpower x (n * m)%Z) = (cpower (cpower x n) m)).

Axiom cpower_mult :
  forall (x:t) (n:Z) (m:Z), ((cpower x (n * m)%Z) = (cpower (cpower x n) m)).

Axiom non_zero_cpower_pos :
  forall (i:t) (n:Z), ~ (i = tzero) -> (n >= 0%Z)%Z ->
  ~ ((cpower i n) = tzero).

Axiom inv_cpower_ :
  forall (e:t) (i:Z), ~ (e = tzero) ->
  ((infix_sldt tone (cpower e i)) = (cpower e (-i)%Z)).

Axiom zero_cpower_pos :
  forall (n:Z), (n > 0%Z)%Z -> ((cpower tzero n) = tzero).

Axiom zero_cpower : forall (n:Z), ~ (n = 0%Z) -> ((cpower tzero n) = tzero).

Axiom non_zero_cpower :
  forall (i:t) (n:Z), ~ (i = tzero) -> ~ ((cpower i n) = tzero).

Axiom real_cpower_pos :
  forall (elt:t) (i:Z), (real_ elt) -> (0%Z <= i)%Z -> real_ (cpower elt i).

Axiom real_cpower :
  forall (elt:t) (i:Z), (real_ elt) -> real_ (cpower elt i).

Axiom real_cpower_is_pos :
  forall (elt:t) (i:Z), (real_ elt) -> (infix_lseqdt tzero elt) ->
  (0%Z <= i)%Z -> infix_lseqdt tzero (cpower elt i).

Axiom real_cpower_is_strict_pos :
  forall (elt:t) (i:Z), (real_ elt) -> (infix_lsdt tzero elt) ->
  (0%Z <= i)%Z -> infix_lsdt tzero (cpower elt i).

Axiom real_modulus_square :
  forall (x:t), (real_ x) -> ((cpower (modulus x) 2%Z) = (cpower x 2%Z)).

Axiom real_modulus_pos :
  forall (x:t), (real_ x) -> (infix_gteqdt x tzero) -> ((modulus x) = x).

Axiom square_frac_modulus :
  forall (x:t) (y:t),
  ((cpower (modulus (infix_sldt x y)) 2%Z) =
   (infix_sldt (cpower (modulus x) 2%Z) (cpower (modulus y) 2%Z))).

Axiom extract_2_sq_modulus :
  forall (x:t) (y:t) (a:t), ~ (a = tzero) -> ~ (y = tzero) ->
  ((infix_sldt (cpower (modulus x) 2%Z) (cpower (modulus y) 2%Z)) =
   (infix_sldt (infix_asdt a (cpower (modulus x) 2%Z))
    (infix_asdt a (cpower (modulus y) 2%Z)))).

Axiom cpower_2_modulus_simpl :
  forall (x:t) (y:t) (z:t), ~ (x = tzero) -> ~ (y = tzero) ->
  ~ (z = tzero) ->
  ((infix_sldt (cpower (modulus (infix_asdt x y)) 2%Z)
    (cpower (modulus (infix_asdt z y)) 2%Z))
   = (infix_sldt (cpower (modulus x) 2%Z) (cpower (modulus z) 2%Z))).

Axiom cpower_cpower :
  forall (x:t) (a:Z) (b:Z), ((cpower (cpower x a) b) = (cpower x (a * b)%Z)).

Axiom pre_cond_int_ :
  forall (a:t) (b:t) (c:t), (infix_lsdt a b) -> (infix_lsdt tzero c) ->
  infix_lsdt (infix_asdt a c) (infix_asdt b c).

Axiom growing_mult1 :
  forall (n:t) (m:t), (infix_lseqdt tzero n) -> (infix_lseqdt tone m) ->
  infix_lseqdt n (infix_asdt n m).

Axiom strict_growing_mult_pos :
  forall (n:t) (m:t), (infix_lsdt tone n) -> (infix_lsdt tone m) ->
  infix_lsdt n (infix_asdt n m).

Axiom init_exp3 : forall (k:t), ((cpower k 0%Z) = tone).

Axiom init_exp4 : forall (k:t), ((cpower k 1%Z) = k).

Axiom init_exp5 : forall (k:t), ((cpower k 2%Z) = (infix_asdt k k)).

Axiom int_exp_pos :
  forall (k:t) (n:Z), (infix_lseqdt tone k) -> (0%Z <= n)%Z ->
  infix_gteqdt (cpower k n) tone.

Axiom int_exp_pos1 :
  forall (k:t) (n:Z), (infix_lseqdt tone k) -> (0%Z <= n)%Z ->
  infix_gtdt (cpower k n) tzero.

Axiom int_exp_pos2 :
  forall (k:t) (n:Z), (infix_lseqdt tone k) -> (0%Z <= n)%Z ->
  infix_lseqdt (cpower k n) (cpower k (n + 1%Z)%Z).

Axiom strict_int_exp_pos :
  forall (k:t) (n:Z), (infix_lsdt tone k) -> (0%Z < n)%Z ->
  infix_gtdt (cpower k n) tone.

Axiom strict_int_exp_pos1 :
  forall (k:t) (n:Z), (infix_lsdt tone k) -> (0%Z < n)%Z ->
  infix_lsdt (cpower k (n - 1%Z)%Z) (cpower k n).

Axiom strict_int_exp_pos2 :
  forall (k:t) (n:Z), (infix_lsdt tone k) -> (0%Z < n)%Z ->
  infix_lsdt (cpower k n) (cpower k (n + 1%Z)%Z).

Axiom strict_int_exp_neg :
  forall (k:t) (n:Z), (infix_lsdt tone k) -> (n < 0%Z)%Z ->
  infix_lsdt (cpower k n) tone.

Axiom strict_int_exp_neg1 :
  forall (k:t) (n:Z), (infix_lsdt tone k) -> (n < 0%Z)%Z ->
  infix_lsdt (cpower k (n - 1%Z)%Z) (cpower k n).

Axiom strict_int_exp_neg2 :
  forall (k:t) (n:Z), (infix_lsdt tone k) -> (n < 0%Z)%Z ->
  infix_lsdt (cpower k n) (cpower k (n + 1%Z)%Z).

Axiom int_exp_neg :
  forall (k:t) (n:Z), (infix_lseqdt tone k) -> (n < 0%Z)%Z ->
  infix_lseqdt (cpower k n) tone.

Axiom int_exp_neg1 :
  forall (k:t) (n:Z), (infix_lseqdt tone k) -> (n < 0%Z)%Z ->
  infix_gtdt (cpower k n) tzero.

Axiom int_exp_neg2 :
  forall (k:t) (n:Z), (infix_lseqdt tone k) -> (n < 0%Z)%Z ->
  infix_lseqdt (cpower k n) (cpower k (n + 1%Z)%Z).

Axiom positive_exp :
  forall (k:t) (m:Z), (infix_lseqdt tone k) -> infix_lsdt tzero (cpower k m).

Axiom growing_exp_pos :
  forall (k:t) (m:Z) (n:Z), (infix_lseqdt tone k) ->
  ((0%Z <= m)%Z /\ (m <= n)%Z) -> infix_lseqdt (cpower k m) (cpower k n).

Axiom growing_exp1 :
  forall (k:t) (m:Z) (n:Z), (infix_lseqdt tone k) -> (m <= n)%Z ->
  infix_lseqdt (cpower k m) (cpower k n).

Axiom strict_growing_exp1 :
  forall (k:t) (m:Z) (n:Z), (infix_lsdt tone k) -> (m < n)%Z ->
  infix_lsdt (cpower k m) (cpower k n).

Axiom cpower_comm_pos :
  forall (x:t) (y:t) (n:Z), (infix_lseqdt tone x) -> (infix_lseqdt tone y) ->
  (0%Z <= n)%Z ->
  ((cpower (infix_asdt x y) n) = (infix_asdt (cpower x n) (cpower y n))).

Axiom cpower_comm :
  forall (x:t) (y:t) (n:Z), (infix_lseqdt tone x) -> (infix_lseqdt tone y) ->
  ((cpower (infix_asdt x y) n) = (infix_asdt (cpower x n) (cpower y n))).

Axiom unicity_exp2 :
  forall (k:t) (m:Z) (n:Z), (infix_lsdt tone k) ->
  ((cpower k m) = (cpower k n)) -> (m = n).

Axiom unicity_exp3 :
  forall (k:t) (m:Z) (n:Z), (infix_lsdt tone k) -> (m = n) ->
  ((cpower k m) = (cpower k n)).

Parameter power_: Z -> Z -> Z.

Axiom power__def :
  forall (e:Z) (i:Z),
  ((i >= 0%Z)%Z -> ((power_ e i) = (power e i))) /\
  (~ (i >= 0%Z)%Z -> ((power_ e i) = 0%Z)).

Axiom Power_zero_ : forall (i:Z), ((power_ i 0%Z) = 1%Z).

Axiom Power_one_ : forall (i:Z), ((power_ i 1%Z) = i).

Axiom Power_sum_ :
  forall (x:Z) (y:Z) (i:Z), (0%Z <= x)%Z -> (y >= 0%Z)%Z ->
  ((power_ i (x + y)%Z) = ((power_ i x) * (power_ i y))%Z).

Axiom Power_mult_ :
  forall (x:Z) (y:Z) (i:Z), (x >= 0%Z)%Z -> (y >= 0%Z)%Z ->
  ((power i (x * y)%Z) = (power (power i x) y)).

Axiom Power_pos_ : forall (i:Z), (i >= 0%Z)%Z -> ((power_ i 0%Z) > 0%Z)%Z.

Axiom Power_pos_gen_ :
  forall (i:Z) (j:Z), (i > 0%Z)%Z -> (j >= 0%Z)%Z -> (0%Z < (power_ i j))%Z.

Axiom power_two_ :
  forall (x:Z), (0%Z <= x)%Z -> ((power_ x 2%Z) = (x * x)%Z).

Axiom power_plus_one_two :
  forall (x:Z), (0%Z <= x)%Z ->
  ((power_ 2%Z (x + 1%Z)%Z) = ((power_ 2%Z x) + (power_ 2%Z x))%Z).

Parameter polysquare: Z -> Z -> Z -> Z -> Z.

Axiom polysquare_def :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z), (0%Z < n)%Z -> (0%Z <= a2)%Z ->
  (0%Z <= a1)%Z -> (0%Z <= a0)%Z ->
  ((polysquare n a2 a1 a0) =
   (((a2 * (power_ n 2%Z))%Z + (a1 * n)%Z)%Z + a0)%Z).

Axiom polysquare_spec :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z), (0%Z < n)%Z -> (0%Z <= a2)%Z ->
  (0%Z <= a1)%Z -> (0%Z <= a0)%Z -> (0%Z <= (polysquare n a2 a1 a0))%Z.

Axiom polysquare_leq_trans :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z) (b2:Z) (b1:Z) (b0:Z) (pa:Z) (pb:Z) (ps:Z),
  (0%Z < n)%Z -> (0%Z <= a2)%Z -> (0%Z <= a1)%Z -> (0%Z <= a0)%Z ->
  (0%Z <= b2)%Z -> (0%Z <= b1)%Z -> (0%Z <= b0)%Z ->
  (pa <= (polysquare n a2 a1 a0))%Z -> (pb <= (polysquare n b2 b1 b0))%Z ->
  (ps <= (pa + pb)%Z)%Z ->
  (ps <= (polysquare n (a2 + b2)%Z (a1 + b1)%Z (a0 + b0)%Z))%Z.

Axiom polysquare_leq_trans_sc :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z) (b2:Z) (b1:Z) (b0:Z) (pa:Z) (sc:Z) (ps:Z),
  (0%Z < n)%Z -> (0%Z <= a2)%Z -> (0%Z <= a1)%Z -> (0%Z <= a0)%Z ->
  (0%Z <= sc)%Z -> ((sc * a2)%Z <= b2)%Z -> ((sc * a1)%Z <= b1)%Z ->
  ((sc * a0)%Z <= b0)%Z -> (pa <= (polysquare n a2 a1 a0))%Z ->
  (ps <= (sc * pa)%Z)%Z -> (ps <= (polysquare n b2 b1 b0))%Z.

Axiom polysquare_update :
  forall (na:Z) (nb:Z) (a2:Z) (a1:Z) (a0:Z) (pa:Z),
  ((0%Z < na)%Z /\ (na <= nb)%Z) -> (0%Z <= a2)%Z -> (0%Z <= a1)%Z ->
  (0%Z <= a0)%Z -> (pa <= (polysquare na a2 a1 a0))%Z ->
  (pa <= (polysquare nb a2 a1 a0))%Z.

Axiom cpower_i_to_t :
  forall (a:Z) (b:Z), (0%Z <= b)%Z ->
  ((i_to_t (power_ a b)) = (cpower (i_to_t a) b)).

Axiom geometric_series :
  forall (a:t) (q:t) (n:Z), (n >= 1%Z)%Z ->
  ((sum (to_fset 0%Z n) (fun (i:Z) => (infix_asdt a (cpower q i)))) =
   (infix_sldt (infix_asdt a (infix_mndt tone (cpower q (n + 1%Z)%Z)))
    (infix_mndt tone q))).

Axiom geometric_series_init_one :
  forall (q:t) (n:Z), (n >= 1%Z)%Z ->
  ((sum (to_fset 0%Z n) (fun (i:Z) => (cpower q i))) =
   (infix_sldt (infix_mndt tone (cpower q (n + 1%Z)%Z)) (infix_mndt tone q))).

Axiom positive_cpower_2 :
  forall (x:t), ~ (tzero = x) -> infix_lsdt tzero (cpower x 2%Z).

Axiom positive_cpower_2_mod :
  forall (x:t), infix_lseqdt tzero (cpower (modulus x) 2%Z).

Axiom growing_cpower_2 :
  forall (x:t) (y:t), ((infix_lseqdt tzero x) /\ (infix_lseqdt x y)) ->
  infix_lseqdt (cpower x 2%Z) (cpower y 2%Z).

Axiom cpower_incr_power_2 :
  forall (k:Z), (0%Z <= k)%Z ->
  ((cpower (i_to_t (power 2%Z k)) 2%Z) = (i_to_t (power_ 2%Z (2%Z * k)%Z))).

Axiom cpower_modulus_incr_power_2 :
  forall (k:Z), (0%Z <= k)%Z ->
  ((cpower (modulus (i_to_t (power 2%Z k))) 2%Z) =
   (i_to_t (power_ 2%Z (2%Z * k)%Z))).

Axiom cpower_modulus_supeq :
  forall (x:t) (y:t) (i:Z), (i >= 1%Z)%Z ->
  (infix_gteqdt (modulus x) (modulus y)) ->
  infix_gteqdt (cpower (modulus x) i) (cpower (modulus y) i).

Axiom angle : Type.
Parameter angle_WhyType : WhyType angle.
Existing Instance angle_WhyType.

Parameter ang_inv: angle -> angle.

Parameter ang_add: angle -> angle -> angle.

Parameter ang_exp: angle -> t.

Axiom ang_exp_spec : forall (us:angle), ~ ((ang_exp us) = tzero).

Parameter arg: t -> angle.

Axiom arg_spec : forall (x:t), ((ang_exp (arg x)) = x).

Parameter ang_zero: angle.

Axiom Assoc2 :
  forall (x:angle) (y:angle) (z:angle),
  ((ang_add (ang_add x y) z) = (ang_add x (ang_add y z))).

Axiom Unit_def_l1 : forall (x:angle), ((ang_add ang_zero x) = x).

Axiom Unit_def_r1 : forall (x:angle), ((ang_add x ang_zero) = x).

Axiom Inv_def_l1 : forall (x:angle), ((ang_add (ang_inv x) x) = ang_zero).

Axiom Inv_def_r1 : forall (x:angle), ((ang_add x (ang_inv x)) = ang_zero).

Axiom Comm2 : forall (x:angle) (y:angle), ((ang_add x y) = (ang_add y x)).

Parameter exp: t -> t.

Parameter e: t.

Axiom e_def : (e = (exp tone)).

Axiom e_diff_tzero : forall (x:t), ~ ((exp x) = tzero).

Axiom Exp_one : real_ (exp tone).

Axiom Exp_zero : ((exp tzero) = tone).

Axiom Exp_sum :
  forall (x:t) (y:t), ((exp (infix_pldt x y)) = (infix_asdt (exp x) (exp y))).

Axiom exp_one : real_ e.

Axiom exp_sum :
  forall (x:t) (y:t), ((exp (infix_pldt x y)) = (infix_asdt (exp x) (exp y))).

Axiom exp_eq : forall (t1:t) (t2:t), (t1 = t2) -> ((exp t1) = (exp t2)).

Axiom exp_sum_rev :
  forall (x:t) (y:t), ((infix_asdt (exp x) (exp y)) = (exp (infix_pldt x y))).

Axiom exp_inv :
  forall (i:t), ~ ((exp i) = tzero) ->
  ((exp (prefix_mndt i)) = (infix_sldt tone (exp i))).

Axiom exp_inv_rev :
  forall (i:t), ~ ((exp i) = tzero) ->
  ((infix_sldt tone (exp i)) = (exp (prefix_mndt i))).

Axiom exp_mult_pre :
  forall (x:t) (y:Z), (y >= 0%Z)%Z ->
  ((exp (infix_asdt x (i_to_t y))) = (cpower (exp x) y)).

Axiom exp_mult :
  forall (x:t) (y:Z), ((exp (infix_asdt x (i_to_t y))) = (cpower (exp x) y)).

Axiom cpower_to_exp :
  forall (x:t) (y:Z), ((cpower (exp x) y) = (exp (infix_asdt x (i_to_t y)))).

Axiom Exp_quarter_pi :
  ((exp (infix_sldt (infix_asdt im pi) (i_to_t 4%Z))) =
   (infix_pldt (infix_sldt squarert_two ttwo)
    (infix_asdt im (infix_sldt squarert_two ttwo)))).

Axiom exp_h_pi : ((exp (infix_sldt (infix_asdt im pi) ttwo)) = im).

Parameter two_pi_i: t.

Axiom two_pi_i_def : (two_pi_i = (infix_asdt (infix_asdt im pi) ttwo)).

Axiom exp_pi : ((exp (infix_asdt im pi)) = (prefix_mndt tone)).

Axiom exp_two_pi : ((exp two_pi_i) = tone).

Axiom exp_two_pi_mul :
  forall (k:Z), ((exp (infix_asdt (i_to_t k) two_pi_i)) = tone).

Axiom exp_two_pi_mul_den :
  forall (k:Z) (l:Z), ~ (k = 0%Z) ->
  ((exp (infix_sldt (infix_asdt (i_to_t (k * l)%Z) two_pi_i) (i_to_t k))) =
   tone).

Axiom exp_two_pi_mul_den_add :
  forall (k:Z) (l:Z) (m:Z),
  ((exp (infix_asdt (i_to_t ((k * m)%Z + l)%Z) two_pi_i)) =
   (exp (infix_asdt (i_to_t l) two_pi_i))).

Parameter ang_mult_int: angle -> Z -> angle.

Axiom ang_mult_int_def :
  forall (theta:angle) (i:Z), (i = 0%Z) ->
  ((ang_mult_int theta i) = ang_zero).

Axiom ang_mult_int_def1 :
  forall (theta:angle) (i:Z), ~ (i = 0%Z) -> (i > 0%Z)%Z ->
  ((ang_mult_int theta i) = (ang_add (ang_mult_int theta (i - 1%Z)%Z) theta)).

Axiom ang_mult_int_def2 :
  forall (theta:angle) (i:Z), ~ (i = 0%Z) -> ~ (i > 0%Z)%Z ->
  ((ang_mult_int theta i) = (ang_inv (ang_mult_int theta (-i)%Z))).

Axiom add_im_re :
  forall (i:t) (j:t),
  ((infix_pldt i j) =
   (infix_pldt (infix_pldt (t_real_part i) (t_real_part j))
    (infix_asdt im (infix_pldt (t_im_part i) (t_im_part j))))).

Axiom add_im_re1 :
  forall (i:t) (j:t),
  ((t_real_part (infix_pldt i j)) =
   (infix_pldt (t_real_part i) (t_real_part j))).

Axiom add_im_re2 :
  forall (i:t) (j:t),
  ((t_im_part (infix_pldt i j)) = (infix_pldt (t_im_part i) (t_im_part j))).

Axiom add_real_part :
  forall (i:t) (j:t),
  ((infix_pldt (t_real_part i) (t_real_part j)) =
   (t_real_part (infix_pldt i j))).

Axiom add_im_part :
  forall (i:t) (j:t),
  ((infix_pldt (t_im_part i) (t_im_part j)) = (t_im_part (infix_pldt i j))).

Axiom add_real_part_rev :
  forall (i:t) (j:t),
  ((t_real_part (infix_pldt i j)) =
   (infix_pldt (t_real_part i) (t_real_part j))).

Axiom add_im_part_rev :
  forall (i:t) (j:t),
  ((t_im_part (infix_pldt i j)) = (infix_pldt (t_im_part i) (t_im_part j))).

Axiom mult_distr_add_r :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt a (infix_pldt b c)) =
   (infix_pldt (infix_asdt a b) (infix_asdt a c))).

Axiom mult_distr_minus :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt a (infix_mndt b c)) =
   (infix_mndt (infix_asdt a b) (infix_asdt a c))).

Axiom sum_constant :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (x:t),
  (forall (e1:a), (mem e1 s) -> ((t1 e1) = x)) ->
  ((sum s t1) = (infix_asdt (i_to_t (cardinal s)) x)).

Axiom sum_const_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  (forall (e1:a), (mem e1 s) -> ((t1 e1) = tone)) ->
  ((sum s t1) = (i_to_t (cardinal s))).

Axiom div_distr_add :
  forall (a:t) (b:t) (c:t), ~ (a = tzero) ->
  ((infix_sldt (infix_pldt b c) a) =
   (infix_pldt (infix_sldt b a) (infix_sldt c a))).

Axiom div_distr_minus :
  forall (a:t) (b:t) (c:t), ~ (a = tzero) ->
  ((infix_sldt (infix_mndt b c) a) =
   (infix_mndt (infix_sldt b a) (infix_sldt c a))).

Axiom div_distr_add_rev :
  forall (a:t) (b:t) (c:t), ~ (a = tzero) ->
  ((infix_pldt (infix_sldt b a) (infix_sldt c a)) =
   (infix_sldt (infix_pldt b c) a)).

Axiom div_distr_minus_rev :
  forall (a:t) (b:t) (c:t), ~ (a = tzero) ->
  ((infix_mndt (infix_sldt b a) (infix_sldt c a)) =
   (infix_sldt (infix_mndt b c) a)).

Axiom mult_distr_add_l :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt (infix_pldt b c) a) =
   (infix_pldt (infix_asdt a b) (infix_asdt a c))).

Axiom mult_distr_minus_r :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt a (infix_mndt b c)) =
   (infix_mndt (infix_asdt a b) (infix_asdt a c))).

Axiom minus_distr_op :
  forall (a:t) (b:t) (c:t),
  ((infix_mndt a (infix_pldt b c)) = (infix_mndt (infix_mndt a b) c)).

Axiom mult_distr_minus_l :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt (infix_mndt b c) a) =
   (infix_mndt (infix_asdt a b) (infix_asdt a c))).

Axiom assoc_right :
  forall (a:t) (b:t) (c:t),
  ((infix_pldt a (infix_pldt b c)) = (infix_pldt (infix_pldt a b) c)).

Axiom assoc_right_mult :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt a (infix_asdt b c)) = (infix_asdt (infix_asdt a b) c)).

Axiom minus_elim :
  forall (a:t) (b:t), ((infix_mndt a b) = (infix_pldt a (prefix_mndt b))).

Axiom minus_distr_elim :
  forall (a:t) (b:t) (c:t),
  ((infix_mndt a (infix_pldt b c)) =
   (infix_pldt (infix_pldt a (prefix_mndt b)) (prefix_mndt c))).

Axiom plus_minus_distr_elim :
  forall (a:t) (b:t) (c:t),
  ((infix_pldt a (prefix_mndt (infix_pldt b c))) =
   (infix_pldt (infix_pldt a (prefix_mndt b)) (prefix_mndt c))).

Axiom def_by_minus :
  forall (x:t) (y:t) (z:t), (x = (infix_mndt y z)) -> (y = (infix_pldt x z)).

Axiom switch :
  forall (a:t) (b:t) (c:t),
  ((infix_pldt (infix_pldt a b) c) = (infix_pldt (infix_pldt a c) b)).

Axiom meet_a_c :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a c) b) d)).

Axiom meet_a_d :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a d) b) c)).

Axiom meet_b_c :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b c) a) d)).

Axiom meet_b_d :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b d) a) c)).

Axiom meet_c_d :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt c d) a) b)).

Axiom inv_add :
  forall (a:t) (b:t), ((infix_pldt (infix_pldt a (prefix_mndt a)) b) = b).

Axiom switch_m :
  forall (a:t) (b:t) (c:t),
  ((infix_pldt (infix_pldt a b) c) = (infix_pldt (infix_pldt a c) b)).

Axiom meet_a_c_m :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a c) b) d)).

Axiom meet_a_d_m :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a d) b) c)).

Axiom meet_b_c_m :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b c) a) d)).

Axiom meet_b_d_m :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b d) a) c)).

Axiom meet_c_d_m :
  forall (a:t) (b:t) (c:t) (d:t),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt c d) a) b)).

Axiom t_real_part_add :
  forall (a:t) (b:t),
  ((t_real_part (infix_pldt a b)) =
   (infix_pldt (t_real_part a) (t_real_part b))).

Axiom t_real_part_subs :
  forall (a:t) (b:t),
  ((t_real_part (infix_mndt a b)) =
   (infix_mndt (t_real_part a) (t_real_part b))).

Axiom t_im_part_add :
  forall (a:t) (b:t),
  ((t_im_part (infix_pldt a b)) = (infix_pldt (t_im_part a) (t_im_part b))).

Axiom t_im_part_subs :
  forall (a:t) (b:t),
  ((t_im_part (infix_mndt a b)) = (infix_mndt (t_im_part a) (t_im_part b))).

Axiom t_real_part_real : forall (a:t), (real_ a) -> ((t_real_part a) = a).

Axiom t_real_part_im :
  forall (a:t), (pure_im_ a) -> ((t_real_part a) = tzero).

Axiom im_t_im_part_im :
  forall (a:t), (pure_im_ a) -> ((infix_asdt im (t_im_part a)) = a).

Axiom t_im_part_im :
  forall (a:t), (pure_im_ a) ->
  ((t_im_part a) = (infix_asdt (prefix_mndt im) a)).

Axiom t_im_part_real : forall (a:t), (real_ a) -> ((t_im_part a) = tzero).

Axiom a_div_b_mult_a :
  forall (a:t) (b:t) (c:t) (d:t), ~ (b = tzero) -> ~ (c = tzero) ->
  (d = (infix_sldt tone b)) -> (a = c) ->
  ((infix_asdt (infix_sldt a b) (infix_sldt tone c)) = d).

Parameter conjugate: t -> t.

Axiom conjugate_def :
  forall (i:t),
  ((conjugate i) =
   (infix_mndt (t_real_part i) (infix_asdt im (t_im_part i)))).

Axiom real_part_conjugate :
  forall (i:t), ((t_real_part (conjugate i)) = (t_real_part i)).

Axiom im_part_conjugate :
  forall (i:t), ((t_im_part (conjugate i)) = (prefix_mndt (t_im_part i))).

Axiom invol_conjugate : forall (i:t), ((conjugate (conjugate i)) = i).

Axiom add_conjugate :
  forall (i:t) (j:t),
  ((conjugate (infix_pldt i j)) = (infix_pldt (conjugate i) (conjugate j))).

Axiom add_own_conjugate :
  forall (i:t),
  ((infix_pldt i (conjugate i)) = (infix_asdt ttwo (t_real_part i))).

Axiom conjugate_to_modulus :
  forall (i:t), ((modulus i) = (square_rt (infix_asdt i (conjugate i)))).

Axiom sum_conjugate :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t),
  ((conjugate (sum s f)) = (sum s (fun (x:a) => (conjugate (f x))))).

Axiom conjugate_module_one :
  forall (i:t), ((modulus i) = tone) -> ((conjugate i) = (inv i)).

Axiom conjugate_module_one_rev :
  forall (i:t), ~ (i = tzero) -> ((conjugate i) = (inv i)) ->
  ((modulus i) = tone).

Axiom conjugate_real : forall (i:t), (real_ i) -> ((conjugate i) = i).

Axiom conjugate_real_gen : forall (i:t), (real_ i) -> ((conjugate i) = i).

Axiom conjugate_one : forall (x:t), (x = tone) -> ((conjugate x) = tone).

Axiom conjugate_tzero : forall (x:t), (x = tzero) -> ((conjugate x) = tzero).

Axiom conjugate_indic :
  forall {a:Type} {a_WT:WhyType a},
  forall (i:a) (j:a), ((conjugate (indic i j)) = (indic i j)).

Axiom conjugate_indic_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (i:a) (j:a), ((indic i j) = (conjugate (indic i j))).

Axiom conjugate_indic_gen_int :
  forall (i:Z) (j:Z), ((conjugate (indic i j)) = (indic i j)).

Axiom conjugate_pure_im :
  forall (i:t), (pure_im_ i) -> ((conjugate i) = (prefix_mndt i)).

Axiom conjugate_im : ((conjugate im) = (prefix_mndt im)).

Axiom conjugate_value :
  forall (c:t) (a:t) (b:t), (real_ a) -> (real_ b) ->
  (c = (infix_pldt a (infix_asdt im b))) ->
  ((conjugate c) = (infix_mndt a (infix_asdt im b))).

Axiom conjugate_minus_value :
  forall (c:t) (a:t) (b:t), (real_ a) -> (real_ b) ->
  (c = (infix_mndt a (infix_asdt im b))) ->
  ((conjugate c) = (infix_pldt a (infix_asdt im b))).

Axiom prod_conjugate :
  forall (a:t) (b:t),
  ((infix_asdt a (conjugate b)) =
   (infix_pldt
    (infix_pldt (infix_asdt (t_real_part a) (t_real_part b))
     (infix_asdt (t_im_part a) (t_im_part b)))
    (infix_asdt im
     (infix_mndt (infix_asdt (t_real_part b) (t_im_part a))
      (infix_asdt (t_im_part b) (t_real_part a)))))).

Axiom mult_conjugate :
  forall (a:t) (b:t),
  ((conjugate (infix_asdt a b)) = (infix_asdt (conjugate a) (conjugate b))).

Axiom conjugate_prod :
  forall (a:t) (b:t),
  ((infix_asdt (conjugate a) b) =
   (infix_pldt
    (infix_pldt (infix_asdt (t_real_part a) (t_real_part b))
     (infix_asdt (t_im_part a) (t_im_part b)))
    (infix_asdt im
     (infix_mndt (infix_asdt (t_real_part a) (t_im_part b))
      (infix_asdt (t_real_part b) (t_im_part a)))))).

Axiom conj_conj_prod :
  forall (a:t) (b:t),
  ((conjugate (infix_asdt (conjugate a) b)) = (infix_asdt a (conjugate b))).

Axiom conj_prod_conj :
  forall (a:t) (b:t),
  ((conjugate (infix_asdt a (conjugate b))) = (infix_asdt (conjugate a) b)).

Axiom itself_prod_conjugate_modulus_one :
  forall (a:t), ((modulus a) = tone) -> ((infix_asdt a (conjugate a)) = tone).

Axiom conjugate_prod_itself_modulus_one :
  forall (a:t), ((modulus a) = tone) -> ((infix_asdt a (conjugate a)) = tone).

Axiom modulus_opposite :
  forall (a:t), (real_ a) -> (infix_lseqdt tzero a) ->
  ((modulus a) = (modulus (prefix_mndt a))).

Axiom modulus_pos1 :
  forall (a:t), (real_ a) -> (infix_lseqdt tzero a) -> ((modulus a) = a).

Axiom modulus_neg :
  forall (a:t), (real_ a) -> (infix_lseqdt a tzero) ->
  ((modulus a) = (prefix_mndt a)).

Parameter real_to_ang: t -> angle.

Axiom real_to_ang_eq :
  forall (phi:t) (phi':t), (real_ phi) -> (phi = phi') ->
  ((real_to_ang phi) = (real_to_ang phi')).

Axiom Real_To_Ang_value :
  forall (phi:t), (real_ phi) ->
  ((ang_exp (real_to_ang phi)) = (exp (infix_asdt two_pi_i phi))).

Axiom Real_To_Ang_inv :
  forall (phi:t), ~ (phi = tzero) -> (real_ phi) ->
  ((ang_inv (real_to_ang phi)) = (real_to_ang (prefix_mndt phi))).

Axiom Real_To_Ang_add :
  forall (phi:t) (phi':t), (real_ phi) -> (real_ phi') ->
  ((ang_add (real_to_ang phi) (real_to_ang phi')) =
   (real_to_ang (infix_pldt phi phi'))).

Parameter int_to_ang: Z -> Z -> angle.

Axiom int_to_ang_def :
  forall (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((int_to_ang k n) =
   (real_to_ang (infix_sldt (i_to_t k) (i_to_t (power 2%Z n))))).

Axiom real_to_ang_tone : ((real_to_ang tone) = ang_zero).

Axiom Real_To_Ang_inv_add :
  forall (phi:t), (real_ phi) ->
  ((ang_add (real_to_ang phi) (real_to_ang (prefix_mndt phi))) = ang_zero).

Axiom Real_To_Ang_up :
  forall (phi:t), (real_ phi) ->
  ((real_to_ang phi) = (real_to_ang (infix_pldt tone phi))).

Axiom real_To_Ang_cyclic_pos :
  forall (phi:t) (k:Z), (real_ phi) -> (0%Z <= k)%Z ->
  ((real_to_ang phi) = (real_to_ang (infix_pldt (i_to_t k) phi))).

Axiom Real_zero_n : ((real_to_ang tzero) = ang_zero).

Axiom Real_ang_mult :
  forall (phi:t), forall (i:Z),
  ((ang_mult_int (real_to_ang phi) i) =
   (real_to_ang (infix_asdt phi (i_to_t i)))).

Axiom real_to_ang_down_cucles :
  forall (phi:t) (x:t), (real_ phi) -> (x = tone) ->
  ((real_to_ang (infix_mndt phi x)) = (real_to_ang phi)).

Parameter odd: Z -> bool.

Axiom odd_def :
  forall (n:Z),
  (((int.EuclideanDivision.mod1 n 2%Z) = 1%Z) -> ((odd n) = true)) /\
  (~ ((int.EuclideanDivision.mod1 n 2%Z) = 1%Z) -> ((odd n) = false)).

Axiom odd_spec :
  forall (n:Z), ((odd n) = true) ->
  (n = ((2%Z * (int.EuclideanDivision.div n 2%Z))%Z + 1%Z)%Z).

Axiom odd_spec1 :
  forall (n:Z), ((odd n) = false) ->
  (n = (2%Z * (int.EuclideanDivision.div n 2%Z))%Z).

Parameter even: Z -> bool.

Axiom even_def :
  forall (n:Z),
  (((int.EuclideanDivision.mod1 n 2%Z) = 0%Z) -> ((even n) = true)) /\
  (~ ((int.EuclideanDivision.mod1 n 2%Z) = 0%Z) -> ((even n) = false)).

Axiom even_spec : forall (n:Z), ((even n) = true) -> ~ ((odd n) = true).

Axiom even_spec1 : forall (n:Z), ~ ((odd n) = true) -> ((even n) = true).

Axiom even_to_mod :
  forall (n:Z), ((even n) = true) ->
  ((int.EuclideanDivision.mod1 n 2%Z) = 0%Z).

Axiom even_minus_one :
  forall (n:Z), (0%Z < n)%Z -> ((even n) = true) ->
  ((odd (n - 1%Z)%Z) = true).

Axiom odd_minus_one :
  forall (n:Z), (0%Z < n)%Z -> ((odd n) = true) ->
  ((even (n - 1%Z)%Z) = true).

Axiom odd_to_mod :
  forall (n:Z), ((odd n) = true) ->
  ((int.EuclideanDivision.mod1 n 2%Z) = 1%Z).

Axiom even_or_odd : forall (n:Z), ((even n) = true) \/ ((odd n) = true).

Axiom cpower_minus_tone :
  forall (n:Z), (0%Z <= n)%Z -> ((even n) = true) ->
  ((cpower (prefix_mndt tone) n) = tone).

Axiom cpower_minus_tone1 :
  forall (n:Z), (0%Z <= n)%Z -> ((odd n) = true) ->
  ((cpower (prefix_mndt tone) n) = (prefix_mndt tone)).

Axiom cpower_minus_tone_even :
  forall (n:Z), (0%Z <= n)%Z -> ((even n) = true) ->
  ((cpower (prefix_mndt tone) n) = tone).

Axiom cpower_minus_tone_odd :
  forall (n:Z), (0%Z <= n)%Z -> ((odd n) = true) ->
  ((cpower (prefix_mndt tone) n) = (prefix_mndt tone)).

Axiom not_null_powers_squarert_two :
  forall (i:Z), (0%Z <= i)%Z -> ~ ((cpower squarert_two i) = tzero).

Parameter pos_coeff: t.

Axiom pos_coeff_def : (pos_coeff = (infix_sldt tone squarert_two)).

Axiom real_pos_coeff : real_ pos_coeff.

Parameter neg_coeff: t.

Axiom neg_coeff_def :
  (neg_coeff = (infix_sldt (prefix_mndt tone) squarert_two)).

Axiom coeffs : (neg_coeff = (prefix_mndt pos_coeff)).

Parameter mop: Z -> t.

Axiom mop_def :
  forall (i:Z), (0%Z <= i)%Z -> ((mop i) = (cpower (prefix_mndt tone) i)).

Axiom minus_one_power_values :
  forall (i:Z), (0%Z <= i)%Z -> ((even i) = true) -> ((mop i) = tone).

Axiom minus_one_power_values1 :
  forall (i:Z), (0%Z <= i)%Z -> ((odd i) = true) ->
  ((mop i) = (prefix_mndt tone)).

Axiom factors_mop :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((mop (i + j)%Z) = (infix_asdt (mop i) (mop j))).

Axiom factors_mop_rev :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((infix_asdt (mop i) (mop j)) = (mop (i + j)%Z)).

Parameter pow_inv_sqrt_2: Z -> t.

Axiom pow_inv_sqrt_2_def :
  forall (i:Z), (0%Z <= i)%Z -> ((pow_inv_sqrt_2 i) = (cpower pos_coeff i)).

Axiom pow_inv_sqrt_2_spec :
  forall (i:Z), (0%Z <= i)%Z -> real_ (pow_inv_sqrt_2 i).

Axiom pow_inv_sqrt_2_spec1 :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_sqrt_2 i) = (infix_sldt tone (square_rt (i_to_t (power 2%Z i))))).

Axiom pow_inv_sqrt_2_add :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((pow_inv_sqrt_2 (i + j)%Z) =
   (infix_asdt (pow_inv_sqrt_2 i) (pow_inv_sqrt_2 j))).

Parameter pow_inv_2: Z -> t.

Axiom pow_inv_2_def :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (infix_sldt tone (i_to_t (power 2%Z i)))).

Axiom pow_inv_2_spec : forall (i:Z), (0%Z <= i)%Z -> real_ (pow_inv_2 i).

Axiom pow_inv_2_spec1 :
  forall (i:Z), (0%Z <= i)%Z -> infix_gtdt (pow_inv_2 i) tzero.

Axiom pow_inv_2_spec2 :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (pow_inv_sqrt_2 (2%Z * i)%Z)).

Axiom pow_inv_2_spec3 :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (infix_asdt (pow_inv_sqrt_2 i) (pow_inv_sqrt_2 i))).

Axiom pow_inv_2_subst :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((infix_asdt (pow_inv_2 i) (cpower ttwo j)) = (cpower ttwo (j - i)%Z)).

Axiom matrix : forall (a:Type), Type.
Parameter matrix_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (matrix a).
Existing Instance matrix_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z -> Z -> a.

Parameter rows: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z.

Parameter columns: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z.

Axiom matrix'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:matrix a), (0%Z < (rows self))%Z.

Axiom matrix'invariant1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:matrix a), (0%Z < (columns self))%Z.

Parameter valid_index:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z -> Z -> Prop.

Axiom valid_index_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z),
  (valid_index a1 r c) <->
  (((0%Z <= r)%Z /\ (r < (rows a1))%Z) /\
   ((0%Z <= c)%Z /\ (c < (columns a1))%Z)).

Parameter equal_size:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> (matrix a) -> Prop.

Axiom equal_size_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (b:matrix a),
  (equal_size a1 b) <->
  (((rows a1) = (rows b)) /\ ((columns a1) = (columns b))).

Parameter get: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z -> Z -> a.

Axiom get_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((get a1 r c) = (((elts a1) r) c)).

Axiom get_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((get a1 r c) = (((elts a1) r) c)).

Parameter make: forall {a:Type} {a_WT:WhyType a}, Z -> Z -> a -> matrix a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (v:a), ((r > 0%Z)%Z /\ (c > 0%Z)%Z) ->
  ((rows (make r c v)) = r).

Axiom make_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (v:a), ((r > 0%Z)%Z /\ (c > 0%Z)%Z) ->
  ((columns (make r c v)) = c).

Axiom make_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (v:a), ((r > 0%Z)%Z /\ (c > 0%Z)%Z) ->
  forall (i:Z) (j:Z),
  (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
  ((get (make r c v) i j) = v).

Axiom equality :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (m = n) -> ((rows m) = (rows n)).

Axiom equality1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (m = n) -> ((columns m) = (columns n)).

Axiom equality2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (m = n) -> forall (i:Z) (j:Z),
  (valid_index m i j) -> ((get m i j) = (get n i j)).

Axiom equality3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a),
  ((((rows m) = (rows n)) /\ ((columns m) = (columns n))) /\
   forall (i:Z) (j:Z), (valid_index m i j) -> ((get m i j) = (get n i j))) ->
  (m = n).

Axiom make_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (i:Z) (j:Z) (v:a), ((r > 0%Z)%Z /\ (c > 0%Z)%Z) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((get (make r c v) i j) = v).

Parameter mat_indices:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> set (Z* Z)%type.

Axiom mat_indices_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a),
  ((mat_indices m) =
   (cartesian_product (to_fset 0%Z (rows m)) (to_fset 0%Z (columns m)))).

Axiom mat_indices_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a), forall (i:Z) (j:Z), (valid_index m i j) ->
  mem (i, j) (mat_indices m).

Axiom mat_indices_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a), forall (i:Z) (j:Z), (mem (i, j) (mat_indices m)) ->
  valid_index m i j.

Parameter set1:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z -> Z -> a -> matrix a.

Axiom set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((rows (set1 a1 r c v)) = (rows a1)).

Axiom set_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((columns (set1 a1 r c v)) = (columns a1)).

Axiom set_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  forall (i:Z) (j:Z), (valid_index a1 i j) ->
  (((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = v)) /\
  (~ ((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = (get a1 i j))).

Axiom set_spec3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((get (set1 a1 r c v) r c) = v).

Axiom set_spec4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (i = r) ->
  ((get (set1 a1 r c v) i j) = (get a1 i j)).

Axiom set_spec5 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (j = c) ->
  ((get (set1 a1 r c v) i j) = (get a1 i j)).

Axiom set_valid_index :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows a1))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns a1))%Z) -> valid_index a1 i j.

Axiom get_valid_index :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((rows a1) = r) -> ((columns a1) = c) ->
  forall (i:Z) (j:Z), (valid_index a1 i j) -> (0%Z <= i)%Z.

Axiom get_valid_index1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((rows a1) = r) -> ((columns a1) = c) ->
  forall (i:Z) (j:Z), (valid_index a1 i j) -> (i < r)%Z.

Axiom get_valid_index2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((rows a1) = r) -> ((columns a1) = c) ->
  forall (i:Z) (j:Z), (valid_index a1 i j) -> (0%Z <= j)%Z.

Axiom get_valid_index3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((rows a1) = r) -> ((columns a1) = c) ->
  forall (i:Z) (j:Z), (valid_index a1 i j) -> (j < c)%Z.

Axiom get_valid_index_params :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (i:Z) (j:Z), ((rows a1) = r) ->
  ((columns a1) = c) -> (valid_index a1 i j) -> (0%Z <= i)%Z.

Axiom get_valid_index_params1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (i:Z) (j:Z), ((rows a1) = r) ->
  ((columns a1) = c) -> (valid_index a1 i j) -> (i < r)%Z.

Axiom get_valid_index_params2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (i:Z) (j:Z), ((rows a1) = r) ->
  ((columns a1) = c) -> (valid_index a1 i j) -> (0%Z <= j)%Z.

Axiom get_valid_index_params3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (i:Z) (j:Z), ((rows a1) = r) ->
  ((columns a1) = c) -> (valid_index a1 i j) -> (j < c)%Z.

Axiom set_values :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  forall (i:Z) (j:Z), (valid_index a1 i j) ->
  (((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = v)) /\
  (~ ((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = (get a1 i j))).

Axiom set_rows :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((rows (set1 a1 r c v)) = (rows a1)).

Axiom set_columns :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((columns (set1 a1 r c v)) = (columns a1)).

Parameter make_f:
  forall {a:Type} {a_WT:WhyType a}, Z -> Z -> (Z -> Z -> a) -> matrix a.

Axiom make_f_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (r > 0%Z)%Z -> (c > 0%Z)%Z ->
  ((rows (make_f r c f)) = r).

Axiom make_f_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (r > 0%Z)%Z -> (c > 0%Z)%Z ->
  ((columns (make_f r c f)) = c).

Axiom make_f_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (r > 0%Z)%Z -> (c > 0%Z)%Z ->
  forall (i:Z) (j:Z), ((get (make_f r c f) i j) = ((f i) j)).

Axiom assert_make :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((get (make_f r c f) i j) = ((f i) j)).

Axiom assert_make_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((rows (make_f r c f)) = r).

Axiom assert_make_c :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((columns (make_f r c f)) = c).

Parameter to_indexes:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> set (Z* Z)%type.

Axiom to_indexes_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a),
  ((to_indexes m) =
   (cartesian_product (to_fset 0%Z (rows m)) (to_fset 0%Z (columns m)))).

Axiom to_indexes_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a),
  ((cardinal (to_indexes m)) = ((rows m) * (columns m))%Z).

Axiom set_to_indexes_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) -> mem (i, j) (to_indexes m).

Axiom get_to_indexes_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (o:(Z* Z)%type), (mem o (to_indexes m)) ->
  (0%Z <= (fir o))%Z.

Axiom get_to_indexes_mem1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (o:(Z* Z)%type), (mem o (to_indexes m)) ->
  ((fir o) < (rows m))%Z.

Axiom get_to_indexes_mem2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (o:(Z* Z)%type), (mem o (to_indexes m)) ->
  (0%Z <= (sec o))%Z.

Axiom get_to_indexes_mem3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (o:(Z* Z)%type), (mem o (to_indexes m)) ->
  ((sec o) < (columns m))%Z.

Parameter equal:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> (matrix a) -> Prop.

Axiom equal_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (equal m n) <-> (infix_eqeq m n).

Axiom mat_equality :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (forall (i:Z) (j:Z), (valid_index m i j) -> ((get m i j) = (get n i j))) ->
  equal m n.

Parameter square: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Prop.

Axiom square_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a), (square m) <-> ((rows m) = (columns m)).

Axiom equal_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (equal m n) -> equal n m.

Axiom equal_sym1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (equal n m) -> equal m n.

Axiom equal_rex :
  forall {a:Type} {a_WT:WhyType a}, forall (m:matrix a), equal m m.

Axiom equal_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a) (o:matrix a), (equal m n) ->
  (equal n o) -> equal m o.

Axiom set_equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (forall (i:Z) (j:Z), (valid_index m i j) -> ((get m i j) = (get n i j))) ->
  (m = n).

Axiom set_equal_mat_make :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (g:Z -> Z -> a), (0%Z < r)%Z ->
  (0%Z < c)%Z ->
  (forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
   ((0%Z <= j)%Z /\ (j < c)%Z) -> (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r c g)).

Axiom set_equal_mat_make_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (r':Z) (c:Z) (c':Z) (f:Z -> Z -> a) (g:Z -> Z -> a),
  (0%Z < r)%Z -> (0%Z < c)%Z -> (r = r') -> (c = c') ->
  (forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
   ((0%Z <= j)%Z /\ (j < c)%Z) -> (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r' c' g)).

Axiom get_equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (m = n) -> ((rows m) = (rows n)).

Axiom get_equal_mat1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (m = n) -> ((columns m) = (columns n)).

Axiom get_equal_mat2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (m = n) -> forall (i:Z) (j:Z),
  (valid_index m i j) -> ((get m i j) = (get n i j)).

Axiom equal_functions :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (g:Z -> Z -> a), (0%Z < r)%Z ->
  (0%Z < c)%Z ->
  (forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
   (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r c g)).

Axiom equal_functions_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> Z -> a) (m:matrix a),
  (forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < (rows m))%Z) /\
    ((0%Z <= j)%Z /\ (j < (columns m))%Z)) ->
   (((f i) j) = (get m i j))) ->
  (m = (make_f (rows m) (columns m) f)).

Parameter null_mat: (matrix t) -> Prop.

Axiom null_mat_def :
  forall (a:matrix t),
  (null_mat a) <->
  forall (i:Z) (j:Z), (valid_index a i j) -> ((get a i j) = tzero).

Axiom set_null_mat :
  forall (a:matrix t),
  (forall (i:Z) (j:Z), (valid_index a i j) -> ((get a i j) = tzero)) ->
  null_mat a.

Axiom get_null_mat :
  forall (a:matrix t), (null_mat a) -> forall (i:Z) (j:Z),
  (valid_index a i j) -> ((get a i j) = tzero).

Parameter kronecker_neutral: matrix t.

Axiom kronecker_neutral_def : (kronecker_neutral = (make 1%Z 1%Z tone)).

Parameter identity: Z -> matrix t.

Parameter result6: Z -> Z -> t.

Axiom result_def6 :
  forall (i:Z) (j:Z),
  ((i = j) -> (((result6 i) j) = tone)) /\
  (~ (i = j) -> (((result6 i) j) = tzero)).

Axiom identity_def :
  forall (n:Z), (0%Z <= n)%Z ->
  ((identity n) = (make_f (power 2%Z n) (power 2%Z n) result6)).

Axiom identity_spec :
  forall (n:Z), (0%Z <= n)%Z -> ((rows (identity n)) = (power 2%Z n)).

Axiom identity_spec1 :
  forall (n:Z), (0%Z <= n)%Z -> ((columns (identity n)) = (power 2%Z n)).

Axiom identity_spec2 :
  forall (n:Z), (0%Z <= n)%Z -> forall (i:Z) (j:Z),
  (valid_index (identity n) i j) ->
  ((i = j) -> ((get (identity n) i j) = tone)) /\
  (~ (i = j) -> ((get (identity n) i j) = tzero)).

Axiom identity_rows :
  forall (n:Z), (0%Z <= n)%Z -> ((rows (identity n)) = (power 2%Z n)).

Axiom identity_columns :
  forall (n:Z), (0%Z <= n)%Z -> ((columns (identity n)) = (power 2%Z n)).

Axiom identity_values :
  forall (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((i = j) -> ((get (identity n) i j) = tone)) /\
  (~ (i = j) -> ((get (identity n) i j) = tzero)).

Parameter kronecker: (matrix t) -> (matrix t) -> matrix t.

Axiom kronecker_def :
  forall (m:matrix t) (n:matrix t),
  ((kronecker m n) =
   (make_f ((rows m) * (rows n))%Z ((columns m) * (columns n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (get m (int.EuclideanDivision.div i (rows n))
       (int.EuclideanDivision.div j (columns n)))
      (get n (int.EuclideanDivision.mod1 i (rows n))
       (int.EuclideanDivision.mod1 j (columns n))))))).

Axiom kronecker_spec :
  forall (m:matrix t) (n:matrix t),
  ((rows (kronecker m n)) = ((rows m) * (rows n))%Z).

Axiom kronecker_spec1 :
  forall (m:matrix t) (n:matrix t),
  ((columns (kronecker m n)) = ((columns m) * (columns n))%Z).

Axiom kronecker_spec2 :
  forall (m:matrix t) (n:matrix t), forall (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((get (kronecker m n) i j) =
   (infix_asdt
    (get m (int.EuclideanDivision.div i (rows n))
     (int.EuclideanDivision.div j (columns n)))
    (get n (int.EuclideanDivision.mod1 i (rows n))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_eq :
  forall (m1:matrix t) (n1:matrix t) (m2:matrix t) (n2:matrix t),
  (m1 = m2) -> (n1 = n2) -> ((kronecker m1 n1) = (kronecker m2 n2)).

Axiom get_kronecker :
  forall (m:matrix t) (n:matrix t),
  ((kronecker m n) =
   (make_f ((rows m) * (rows n))%Z ((columns m) * (columns n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (get m (int.EuclideanDivision.div i (rows n))
       (int.EuclideanDivision.div j (columns n)))
      (get n (int.EuclideanDivision.mod1 i (rows n))
       (int.EuclideanDivision.mod1 j (columns n))))))).

Axiom kronecker_values :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((get (kronecker m n) i j) =
   (infix_asdt
    (get m (int.EuclideanDivision.div i (rows n))
     (int.EuclideanDivision.div j (columns n)))
    (get n (int.EuclideanDivision.mod1 i (rows n))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_rows :
  forall (m:matrix t) (n:matrix t),
  ((rows (kronecker m n)) = ((rows m) * (rows n))%Z).

Axiom kronecker_columns :
  forall (m:matrix t) (n:matrix t),
  ((columns (kronecker m n)) = ((columns m) * (columns n))%Z).

Axiom kronecker_values_gen :
  forall (m:matrix t) (n:matrix t), forall (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((get (kronecker m n) i j) =
   (infix_asdt
    (get m (int.EuclideanDivision.div i (rows n))
     (int.EuclideanDivision.div j (columns n)))
    (get n (int.EuclideanDivision.mod1 i (rows n))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_mod_values :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((get (kronecker m n) i j) =
   (infix_asdt
    (get m
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i (rows (kronecker m n))) (rows n))
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 j (columns (kronecker m n))) (columns n)))
    (get n
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.mod1 i (rows (kronecker m n))) (rows n))
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.mod1 j (columns (kronecker m n))) (columns n))))).

Axiom kronecker_indexes :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z) (k:Z) (l:Z),
  (valid_index m i j) -> (valid_index n k l) ->
  valid_index (kronecker m n) ((i * (rows n))%Z + k)%Z
  ((j * (columns n))%Z + l)%Z.

Axiom kronecker_indexes_com :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  valid_index m (int.EuclideanDivision.div i (rows n))
  (int.EuclideanDivision.div j (columns n)).

Axiom kronecker_indexes_com1 :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  valid_index n (int.EuclideanDivision.mod1 i (rows n))
  (int.EuclideanDivision.mod1 j (columns n)).

Axiom kronecker_assoc_pre :
  forall (m:matrix t) (n:matrix t) (o:matrix t) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (((rows m) * (rows n))%Z * (rows o))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < (((columns m) * (columns n))%Z * (columns o))%Z)%Z) ->
  ((get (kronecker (kronecker m n) o) i j) =
   (get (kronecker m (kronecker n o)) i j)).

Axiom kronecker_assoc :
  op_assoc (fun (y0:matrix t) (y1:matrix t) => (kronecker y0 y1)).

Axiom neutral_ : forall (m:matrix t), ((kronecker m kronecker_neutral) = m).

Axiom neutral_1 : forall (m:matrix t), ((kronecker kronecker_neutral m) = m).

Axiom neutral1 :
  (kronecker_neutral =
   (neutral_elt (fun (y0:matrix t) (y1:matrix t) => (kronecker y0 y1)))).

Axiom neutral2 :
  has_neutral (fun (y0:matrix t) (y1:matrix t) => (kronecker y0 y1)).

Axiom neutral3 :
  iterable (fun (y0:matrix t) (y1:matrix t) => (kronecker y0 y1)).

Axiom kronecker_equal :
  forall (m:matrix t) (ml:matrix t) (n:matrix t) (nl:matrix t),
  (equal m ml) -> (equal n nl) -> equal (kronecker m n) (kronecker ml nl).

Axiom kron_id :
  forall (m:Z) (n:Z), (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((kronecker (identity m) (identity n)) = (identity (m + n)%Z)).

Parameter frows: (Z -> matrix t) -> Z -> Z.

Axiom frows_def :
  forall (f:Z -> matrix t) (k:Z), ((frows f k) = (rows (f k))).

Axiom frows_spec : forall (f:Z -> matrix t) (k:Z), ((frows f k) > 0%Z)%Z.

Parameter fcolumns: (Z -> matrix t) -> Z -> Z.

Axiom fcolumns_def :
  forall (f:Z -> matrix t) (k:Z), ((fcolumns f k) = (columns (f k))).

Axiom fcolumns_spec :
  forall (f:Z -> matrix t) (k:Z), ((fcolumns f k) > 0%Z)%Z.

Axiom const_fcol :
  forall (m:matrix t) (k:Z),
  ((fcolumns ((fun (y0:matrix t) (y1:Z) => (const y0 y1)) m) k) =
   (columns m)).

Axiom const_frows :
  forall (m:matrix t) (k:Z),
  ((frows ((fun (y0:matrix t) (y1:Z) => (const y0 y1)) m) k) = (rows m)).

Parameter mat_mult_no_bound: (matrix t) -> (matrix t) -> matrix t.

Axiom mat_mult_no_bound_def :
  forall (m:matrix t) (n:matrix t),
  (((columns m) = (rows n)) ->
   ((mat_mult_no_bound m n) =
    (make_f (rows m) (columns n)
     (fun (i:Z) (j:Z) =>
      (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
       (columns m)))))) /\
  (~ ((columns m) = (rows n)) ->
   ((mat_mult_no_bound m n) = (make_f 1%Z 1%Z (fun (i:Z) (j:Z) => tzero)))).

Axiom mat_mult_no_bound_spec :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  ((rows (mat_mult_no_bound m n)) = (rows m)).

Axiom mat_mult_no_bound_spec1 :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  ((columns (mat_mult_no_bound m n)) = (columns n)).

Axiom mat_mult_no_bound_spec2 :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  forall (i:Z) (j:Z), (valid_index (mat_mult_no_bound m n) i j) ->
  ((get (mat_mult_no_bound m n) i j) =
   (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
    (columns m))).

Parameter mat_mult: (matrix t) -> (matrix t) -> matrix t.

Axiom mat_mult_def :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  ((mat_mult m n) = (mat_mult_no_bound m n)).

Axiom mat_mult_spec :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  ((rows (mat_mult m n)) = (rows m)).

Axiom mat_mult_spec1 :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  ((columns (mat_mult m n)) = (columns n)).

Axiom mat_mult_spec2 :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  forall (i:Z) (j:Z), (valid_index (mat_mult m n) i j) ->
  ((get (mat_mult m n) i j) =
   (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
    (columns m))).

Axiom mat_mult_values :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z), ((columns m) = (rows n)) ->
  (valid_index (mat_mult m n) i j) ->
  ((get (mat_mult m n) i j) =
   (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
    (columns m))).

Axiom mat_mult_columns :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  ((columns (mat_mult m n)) = (columns n)).

Axiom mat_mult_rows :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  ((rows (mat_mult m n)) = (rows m)).

Axiom mat_mult_values_quant :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  forall (i:Z) (j:Z), (valid_index (mat_mult m n) i j) ->
  ((get (mat_mult m n) i j) =
   (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
    (columns m))).

Parameter int_mat_prod: (Z -> matrix t) -> Z -> Z -> matrix t.

Axiom int_mat_prod_def :
  forall (f:Z -> matrix t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((j - i)%Z = 0%Z) -> ((int_mat_prod f i j) = (f i)).

Axiom int_mat_prod_def1 :
  forall (f:Z -> matrix t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ~ ((j - i)%Z = 0%Z) ->
  ((int_mat_prod f i j) =
   (mat_mult_no_bound (int_mat_prod f i (j - 1%Z)%Z) (f j))).

Axiom int_mat_prod_spec :
  forall (f:Z -> matrix t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((rows (int_mat_prod f i j)) = (rows (f i))).

Axiom int_mat_prod_spec1 :
  forall (f:Z -> matrix t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((columns (int_mat_prod f i j)) = (columns (f i))).

Axiom int_mat_prod_spec2 :
  forall (f:Z -> matrix t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((columns (int_mat_prod f i j)) = (rows (f i))).

Axiom int_mat_prod_zero :
  forall (f:Z -> matrix t) (i:Z) (j:Z), ((rows (f i)) = (columns (f i))) ->
  (i = j) -> ((int_mat_prod f i j) = (f i)).

Parameter int_mat_prod_plus_one: (Z -> matrix t) -> Z -> Z -> unit.

Axiom int_mat_prod_plus_one_def :
  forall (f:Z -> matrix t) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((int_mat_prod_plus_one f i j) = tt).

Axiom int_mat_prod_plus_one_spec :
  forall (f:Z -> matrix t) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((int_mat_prod f i j) = (mat_mult (int_mat_prod f i (j - 1%Z)%Z) (f j))).

Axiom int_mat_prod_eq :
  forall (f:Z -> matrix t) (g:Z -> matrix t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z), ((i <= k)%Z /\ (k <= j)%Z) ->
   ((i <= k')%Z /\ (k' <= j)%Z) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  (forall (k:Z), ((i <= k)%Z /\ (k <= j)%Z) -> ((f k) = (g k))) ->
  ((int_mat_prod f i j) = (int_mat_prod g i j)).

Axiom mat_mult_id :
  forall (n:Z) (m:matrix t), (n >= 0%Z)%Z -> ((columns m) = (power 2%Z n)) ->
  ((mat_mult m (identity n)) = m).

Axiom id_mat_mult :
  forall (n:Z) (m:matrix t), (n >= 0%Z)%Z -> ((rows m) = (power 2%Z n)) ->
  ((mat_mult (identity n) m) = m).

Axiom mat_mult_eq :
  forall (m:matrix t) (n:matrix t) (m':matrix t) (n':matrix t), (m = m') ->
  (n = n') -> ((columns m) = (rows n)) -> ((mat_mult m n) = (mat_mult m' n')).

Parameter add_mat: (matrix t) -> (matrix t) -> matrix t.

Axiom add_mat_def :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((add_mat m n) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_pldt (get m i j) (get n i j))))).

Axiom add_mat_spec :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((columns (add_mat m n)) = (columns m)).

Axiom add_mat_spec1 : True.

Axiom add_mat_spec2 :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((rows (add_mat m n)) = (rows m)).

Axiom add_mat_spec3 :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((rows m) = (rows n)).

Axiom add_mat_spec4 :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> forall (i:Z) (j:Z),
  ((get (add_mat m n) i j) = (infix_pldt (get m i j) (get n i j))).

Axiom add_mat_equal :
  forall (m:matrix t) (n:matrix t) (m':matrix t) (n':matrix t),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> (m = m') ->
  (n = n') -> ((add_mat m n) = (add_mat m' n')).

Axiom add_value :
  forall (m:matrix t) (n:matrix t), ((columns m) = (columns n)) ->
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((get (add_mat m n) i j) = (infix_pldt (get m i j) (get n i j))).

Axiom add_values :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  ((columns m) = (columns n)) -> ((rows m) = (rows n)) ->
  ((get (add_mat m n) i j) = (infix_pldt (get m i j) (get n i j))).

Axiom add_mat_null_left :
  forall (m:matrix t) (n:matrix t), ((columns m) = (columns n)) ->
  ((rows m) = (rows n)) -> (null_mat m) -> ((add_mat m n) = n).

Axiom add_mat_null_right :
  forall (m:matrix t) (n:matrix t), ((columns m) = (columns n)) ->
  ((rows m) = (rows n)) -> (null_mat n) -> ((add_mat m n) = m).

Axiom set_equal_columns_elt :
  forall (m:matrix t) (n:matrix t) (i:Z),
  (((columns m) = (columns n)) /\ ((columns n) = i)) ->
  ((columns m) = (columns n)).

Axiom set_equal_rows_elt :
  forall (m:matrix t) (n:matrix t) (i:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) -> ((rows m) = (rows n)).

Axiom add_columns :
  forall (m:matrix t) (n:matrix t), ((columns m) = (columns n)) ->
  ((rows m) = (rows n)) -> ((columns (add_mat m n)) = (columns m)).

Axiom add_rows :
  forall (m:matrix t) (n:matrix t), ((columns m) = (columns n)) ->
  ((rows m) = (rows n)) -> ((rows (add_mat m n)) = (rows m)).

Axiom set_equal_dim_elt :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) ->
  (((columns m) = (columns n)) /\ ((columns n) = j)) ->
  ((columns m) = (columns n)).

Axiom set_equal_dim_elt1 :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) ->
  (((columns m) = (columns n)) /\ ((columns n) = j)) -> ((rows m) = (rows n)).

Axiom set_dim_add :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) ->
  (((columns m) = (columns n)) /\ ((columns n) = j)) ->
  ((rows (add_mat m n)) = i).

Axiom set_dim_add1 :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) ->
  (((columns m) = (columns n)) /\ ((columns n) = j)) ->
  ((columns (add_mat m n)) = j).

Axiom add_mat_eq :
  forall (m:matrix t) (m1:matrix t) (n:matrix t) (n1:matrix t),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> (m = m1) ->
  (n = n1) -> ((add_mat m n) = (add_mat m1 n1)).

Axiom add_mat_comm :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((add_mat m n) = (add_mat n m)).

Parameter add_neutral: unit -> matrix t.

Axiom add_neutral_spec :
  forall (us:unit), forall (i:Z) (j:Z), (valid_index (add_neutral us) i j) ->
  ((get (add_neutral us) i j) = tzero).

Axiom add_neutral_spec1 :
  forall (us:unit), ((rows (add_neutral us)) > 0%Z)%Z.

Axiom add_neutral_spec2 :
  forall (us:unit), ((columns (add_neutral us)) > 0%Z)%Z.

Axiom distr_1_pre :
  forall (m:matrix t) (n:matrix t) (o:matrix t) (i:Z) (j:Z),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns o))%Z) ->
  ((get (mat_mult (add_mat m n) o) i j) =
   (get (add_mat (mat_mult m o) (mat_mult n o)) i j)).

Axiom distr_l :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((columns m) = (rows o)) ->
  ((mat_mult (add_mat m n) o) = (add_mat (mat_mult m o) (mat_mult n o))).

Axiom distr_2_pre :
  forall (m:matrix t) (n:matrix t) (o:matrix t) (i:Z) (j:Z),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  valid_index (mat_mult m (add_mat n o)) i j.

Axiom distr_2_pre1 :
  forall (m:matrix t) (n:matrix t) (o:matrix t) (i:Z) (j:Z),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  ((get (mat_mult m (add_mat n o)) i j) =
   (get (add_mat (mat_mult m n) (mat_mult m o)) i j)).

Axiom distr_r :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows n) = (rows o)) ->
  ((columns n) = (columns o)) -> ((columns m) = (rows n)) ->
  ((mat_mult m (add_mat n o)) = (add_mat (mat_mult m n) (mat_mult m o))).

Parameter infix_asdtdt: t -> (matrix t) -> matrix t.

Axiom infix_asdtdt_def :
  forall (s:t) (m:matrix t),
  ((infix_asdtdt s m) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_asdt s (get m i j))))).

Axiom infix_asdtdt_spec :
  forall (s:t) (m:matrix t), ((columns (infix_asdtdt s m)) = (columns m)).

Axiom infix_asdtdt_spec1 :
  forall (s:t) (m:matrix t), ((rows (infix_asdtdt s m)) = (rows m)).

Axiom infix_asdtdt_spec2 :
  forall (s:t) (m:matrix t), forall (i:Z) (j:Z),
  (valid_index (infix_asdtdt s m) i j) ->
  ((get (infix_asdtdt s m) i j) = (infix_asdt s (get m i j))).

Axiom infix_asdtdt_spec3 :
  forall (s:t) (m:matrix t), forall (i:Z) (j:Z),
  (valid_index (infix_asdtdt s m) i j) -> valid_index m i j.

Axiom infix_asdtdt_spec4 :
  forall (s:t) (m:matrix t), forall (i:Z) (j:Z), (valid_index m i j) ->
  valid_index (infix_asdtdt s m) i j.

Axiom scalar_columns :
  forall (m:matrix t) (a:t), ((columns (infix_asdtdt a m)) = (columns m)).

Axiom scalar_values :
  forall (m:matrix t) (a:t) (i:Z) (j:Z),
  ((get (infix_asdtdt a m) i j) = (infix_asdt a (get m i j))).

Axiom scalar_rows :
  forall (m:matrix t) (a:t), ((rows (infix_asdtdt a m)) = (rows m)).

Axiom scalar_null : forall (m:matrix t), null_mat (infix_asdtdt tzero m).

Axiom scalar_tone : forall (m:matrix t), ((infix_asdtdt tone m) = m).

Axiom scalar_tone_gen :
  forall (m:matrix t) (a:t), (a = tone) -> ((infix_asdtdt a m) = m).

Axiom scalar_null_gen :
  forall (m:matrix t) (a:t), (a = tzero) -> null_mat (infix_asdtdt a m).

Axiom scalar_plus :
  forall (m:matrix t) (a:t) (b:t),
  ((infix_asdtdt (infix_pldt a b) m) =
   (add_mat (infix_asdtdt a m) (infix_asdtdt b m))).

Axiom scalar_plus_rev :
  forall (m:matrix t) (a:t) (b:t),
  ((add_mat (infix_asdtdt a m) (infix_asdtdt b m)) =
   (infix_asdtdt (infix_pldt a b) m)).

Axiom add_scal :
  forall (m:matrix t) (n:matrix t) (a:t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((infix_asdtdt a (add_mat m n)) =
   (add_mat (infix_asdtdt a m) (infix_asdtdt a n))).

Axiom mat_mult_scal_values_l :
  forall (m:matrix t) (n:matrix t) (a:t) (i:Z) (j:Z),
  ((rows n) = (columns m)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  ((infix_asdt a (get (mat_mult m n) i j)) =
   (ind_sum
    (fun (k:Z) => (infix_asdt (infix_asdt a (get m i k)) (get n k j))) 0%Z
    (columns m))).

Axiom mat_mult_scal_values_r :
  forall (m:matrix t) (n:matrix t) (a:t) (i:Z) (j:Z),
  ((rows n) = (columns m)) -> ((rows m) = (columns n)) ->
  ((columns m) = (columns n)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  ((infix_asdt (get (mat_mult m n) i j) a) =
   (ind_sum
    (fun (k:Z) => (infix_asdt (infix_asdt a (get m i k)) (get n k j))) 0%Z
    (columns m))).

Axiom mat_mut_scal :
  forall (m:matrix t) (n:matrix t) (a:t), ((rows n) = (columns m)) ->
  ((mat_mult m (infix_asdtdt a n)) = (infix_asdtdt a (mat_mult m n))).

Axiom scal_mat_mut :
  forall (m:matrix t) (n:matrix t) (a:t), ((rows n) = (columns m)) ->
  ((mat_mult (infix_asdtdt a m) n) = (infix_asdtdt a (mat_mult m n))).

Axiom ind_sum_commute_scal_r :
  forall (f:Z -> Z -> t) (g:Z -> t) (i:Z) (j:Z) (k:Z) (l:Z), (i <= j)%Z ->
  (k <= l)%Z ->
  ((ind_sum (fun (k1:Z) => (infix_asdt (ind_sum (f k1) k l) (g k1))) i j) =
   (ind_sum
    (fun (k1:Z) =>
     (ind_sum (fun (k2:Z) => (infix_asdt ((f k2) k1) (g k2))) i j))
    k l)).

Axiom mat_mult_assoc_pre :
  forall (m:matrix t) (n:matrix t) (o:matrix t) (i:Z) (j:Z),
  ((columns m) = (rows n)) -> ((columns n) = (rows o)) ->
  ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns o))%Z) ->
  ((get (mat_mult (mat_mult m n) o) i j) =
   (get (mat_mult m (mat_mult n o)) i j)).

Axiom mat_mult_assoc :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((columns m) = (rows n)) ->
  ((columns n) = (rows o)) ->
  ((mat_mult (mat_mult m n) o) = (mat_mult m (mat_mult n o))).

Axiom mat_mult_assoc_quant :
  forall (m:matrix t) (n:matrix t), ((columns m) = (rows n)) ->
  forall (o:matrix t), ((columns n) = (rows o)) ->
  ((mat_mult (mat_mult m n) o) = (mat_mult m (mat_mult n o))).

Axiom mat_mult_assoc_comm :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((columns m) = (rows n)) ->
  ((columns n) = (rows o)) ->
  ((mat_mult m (mat_mult n o)) = (mat_mult (mat_mult m n) o)).

Axiom scalar_eq :
  forall (m:matrix t) (n:matrix t) (a:t), (m = n) ->
  ((infix_asdtdt a m) = (infix_asdtdt a n)).

Axiom scalar_eq_gen :
  forall (m:matrix t) (n:matrix t) (a:t) (b:t), (m = n) -> (a = b) ->
  ((infix_asdtdt a m) = (infix_asdtdt b n)).

Axiom scalar_add :
  forall (m:matrix t) (a:t) (b:t),
  ((infix_asdtdt (infix_pldt a b) m) =
   (add_mat (infix_asdtdt a m) (infix_asdtdt b m))).

Axiom scalar_assoc :
  forall (m:matrix t) (a:t) (b:t),
  ((infix_asdtdt a (infix_asdtdt b m)) = (infix_asdtdt (infix_asdt a b) m)).

Axiom scalar_assoc_rev :
  forall (m:matrix t) (a:t) (b:t),
  ((infix_asdtdt (infix_asdt a b) m) = (infix_asdtdt a (infix_asdtdt b m))).

Axiom eq_scalar :
  forall (m:matrix t) (a:t) (b:t),
  (exists i:Z, exists j:Z, (valid_index m i j) /\ ~ ((get m i j) = tzero)) ->
  ((infix_asdtdt a m) = (infix_asdtdt b m)) -> (a = b).

Parameter mat_substr: (matrix t) -> (matrix t) -> matrix t.

Axiom mat_substr_def :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((mat_substr m n) = (add_mat m (infix_asdtdt (prefix_mndt tone) n))).

Axiom mat_substr_spec :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((rows (mat_substr m n)) = (rows m)).

Axiom mat_substr_spec1 :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((columns (mat_substr m n)) = (columns m)).

Axiom mat_substr_spec2 :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((get (mat_substr m n) i j) = (infix_mndt (get m i j) (get n i j))).

Axiom substr_rows :
  forall (m:matrix t) (n:matrix t) (r:Z),
  (((rows m) = (rows n)) /\ ((rows n) = r)) -> ((columns m) = (columns n)) ->
  ((rows (mat_substr m n)) = r).

Axiom substr_columns :
  forall (m:matrix t) (n:matrix t) (c:Z), ((rows m) = (rows n)) ->
  (((columns m) = (columns n)) /\ ((columns n) = c)) ->
  ((columns (mat_substr m n)) = c).

Axiom substr_value :
  forall (m:matrix t) (n:matrix t) (i:Z) (j:Z), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((get (mat_substr m n) i j) = (infix_mndt (get m i j) (get n i j))).

Axiom distr_l_substr :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((columns m) = (rows o)) ->
  ((mat_mult (mat_substr m n) o) =
   (mat_substr (mat_mult m o) (mat_mult n o))).

Axiom distr_r_substr :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows n) = (rows o)) ->
  ((columns n) = (columns o)) -> ((columns m) = (rows o)) ->
  ((mat_mult m (mat_substr n o)) =
   (mat_substr (mat_mult m n) (mat_mult m o))).

Axiom mat_substr_eq :
  forall (m:matrix t) (m':matrix t) (n:matrix t) (n':matrix t),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> (m = m') ->
  (n = n') -> ((mat_substr m n) = (mat_substr m' n')).

Axiom substr_decomp :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> (m = (add_mat n (mat_substr m n))).

Axiom get_equal_mat_to_substr :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> (m = n) ->
  ((mat_substr m n) = (make (rows m) (columns m) tzero)).

Axiom set_inequal_mat_by_substr :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ~ (m = n) ->
  ~ ((mat_substr m n) = (make (rows m) (columns m) tzero)).

Axiom set_inequal_mat_by_substr1 :
  forall (m:matrix t) (n:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ~ ((mat_substr m n) = (make (rows m) (columns m) tzero)) -> ~ (m = n).

Axiom pow_inv_2_scal :
  forall (i:Z) (x:matrix t), (0%Z <= i)%Z ->
  ((infix_asdtdt (pow_inv_2 i) x) =
   (infix_asdtdt (pow_inv_sqrt_2 i) (infix_asdtdt (pow_inv_sqrt_2 i) x))).

Axiom pow_inv_2_from_int :
  forall (n:Z), (0%Z <= n)%Z ->
  ((pow_inv_2 n) = (infix_sldt tone (i_to_t (power 2%Z n)))).

Axiom pow_inv_2_sq_rt :
  forall (n:Z), (0%Z <= n)%Z ->
  ((square_rt (pow_inv_2 n)) = (pow_inv_sqrt_2 n)).

Axiom pos_pow_inv_2 :
  forall (i:Z), (0%Z <= i)%Z -> infix_lseqdt tzero (pow_inv_2 i).

Axiom strict_pos_pow_inv_2 :
  forall (i:Z), (0%Z <= i)%Z -> infix_lsdt tzero (pow_inv_2 i).

Axiom pow_inv_2_add :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((pow_inv_2 (i + j)%Z) = (infix_asdt (pow_inv_2 i) (pow_inv_2 j))).

Axiom pow_inv_2_with_ :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (infix_sldt tone (i_to_t (power_ 2%Z i)))).

Axiom pow_inv_2_to_one :
  forall (i:Z), (0%Z <= i)%Z ->
  ((infix_asdt (i_to_t (power_ 2%Z i)) (pow_inv_2 i)) = tone).

Axiom pow_inv_2_one :
  forall (i:Z), (i = 1%Z) ->
  ((i_to_t (power_ 2%Z i)) = (infix_sldt tone ttwo)).

Axiom pow_inv_2_to_one_gen :
  forall (i:Z) (x:t), (0%Z <= i)%Z -> (x = (i_to_t (power_ 2%Z i))) ->
  ((infix_asdt (pow_inv_2 i) x) = tone).

Axiom pow_inv_to_pow_2 :
  forall (k:Z) (l:Z), (0%Z <= l)%Z -> (k >= l)%Z ->
  ((infix_asdt (pow_inv_2 k) (i_to_t (power_ 2%Z l))) =
   (pow_inv_2 (k - l)%Z)).

Parameter neg_pow_inv_sqrt_2: Z -> t.

Axiom neg_pow_inv_sqrt_2_def :
  forall (i:Z), (0%Z <= i)%Z ->
  ((neg_pow_inv_sqrt_2 i) = (cpower neg_coeff i)).

Axiom inv_pow_inv_sqrt_2 :
  ((infix_asdt (pow_inv_sqrt_2 1%Z) squarert_two) = tone).

Axiom pow_inv_sqrt_2_values :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_sqrt_2 i) = (infix_sldt tone (cpower squarert_two i))).

Axiom neg_pow_inv_sqrt_2_values :
  forall (i:Z), (0%Z <= i)%Z ->
  ((neg_pow_inv_sqrt_2 i) =
   (infix_asdt (mop i) (infix_sldt tone (cpower squarert_two i)))).

Axiom ppos_neg_coeff_values :
  forall (i:Z), (0%Z <= i)%Z -> ((even i) = true) ->
  ((pow_inv_sqrt_2 i) = (neg_pow_inv_sqrt_2 i)).

Axiom ppos_neg_coeff_values1 :
  forall (i:Z), (0%Z <= i)%Z -> ((odd i) = true) ->
  ((pow_inv_sqrt_2 i) = (prefix_mndt (neg_pow_inv_sqrt_2 i))).

Axiom ppos_neg_coeff_values2 :
  forall (i:Z), (0%Z <= i)%Z ->
  ((neg_pow_inv_sqrt_2 i) = (infix_asdt (mop i) (pow_inv_sqrt_2 i))).

Parameter pow_inv_sqrt_2_neg: Z -> t.

Axiom pow_inv_sqrt_2_neg_def :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_sqrt_2_neg i) = (prefix_mndt (pow_inv_sqrt_2 i))).

Parameter min_set: (set Z) -> Z.

Axiom min_set_def :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> ((cardinal s) = 1%Z) ->
  ((min_set s) = (choose s)).

Axiom min_set_def1 :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> ~ ((cardinal s) = 1%Z) ->
  ((min_set s) =
   (ZArith.BinInt.Z.min (choose s) (min_set (remove (choose s) s)))).

Axiom min_set_spec :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> mem (min_set s) s.

Axiom min_set_spec1 :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> forall (e1:Z), (mem e1 s) ->
  (e1 >= (min_set s))%Z.

Parameter max_set: (set Z) -> Z.

Axiom max_set_def :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> ((cardinal s) = 1%Z) ->
  ((max_set s) = (choose s)).

Axiom max_set_def1 :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> ~ ((cardinal s) = 1%Z) ->
  ((max_set s) =
   (ZArith.BinInt.Z.max (choose s) (max_set (remove (choose s) s)))).

Axiom max_set_spec :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> mem (max_set s) s.

Axiom max_set_spec1 :
  forall (s:set Z), ((cardinal s) > 0%Z)%Z -> forall (e1:Z), (mem e1 s) ->
  (e1 <= (max_set s))%Z.

Parameter max3: Z -> Z -> Z -> Z.

Axiom max3_def :
  forall (a:Z) (b:Z) (c:Z),
  ((max3 a b c) = (ZArith.BinInt.Z.max (ZArith.BinInt.Z.max a b) c)).

Axiom max3_spec :
  forall (a:Z) (b:Z) (c:Z),
  ((max3 a b c) = (ZArith.BinInt.Z.max a (ZArith.BinInt.Z.max b c))).

Parameter min_filter: (set Z) -> (Z -> bool) -> Z.

Axiom min_filter_def :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) -> ((p (min_set s)) = true) ->
  ((min_filter s p) = (min_set s)).

Axiom min_filter_def1 :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) ->
  ~ ((p (min_set s)) = true) ->
  ((min_filter s p) = (min_filter (remove (min_set s) s) p)).

Axiom min_filter_spec :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) ->
  ((p (min_filter s p)) = true).

Axiom min_filter_spec1 :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) -> mem (min_filter s p) s.

Axiom min_filter_spec2 :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) -> forall (e1:Z),
  (mem e1 s) -> ((p e1) = true) -> (e1 >= (min_filter s p))%Z.

Parameter max_filter: (set Z) -> (Z -> bool) -> Z.

Axiom max_filter_def :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) -> ((p (max_set s)) = true) ->
  ((max_filter s p) = (max_set s)).

Axiom max_filter_def1 :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) ->
  ~ ((p (max_set s)) = true) ->
  ((max_filter s p) = (max_filter (remove (max_set s) s) p)).

Axiom max_filter_spec :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) ->
  ((p (max_filter s p)) = true).

Axiom max_filter_spec1 :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) -> mem (max_filter s p) s.

Axiom max_filter_spec2 :
  forall (s:set Z) (p:Z -> bool),
  (exists e1:Z, (mem e1 s) /\ ((p e1) = true)) -> forall (e1:Z),
  (mem e1 s) -> ((p e1) = true) -> (e1 <= (max_filter s p))%Z.

Axiom appr :
  forall (theta:t) (n:Z), (0%Z < n)%Z -> (real_ theta) ->
  ((infix_lseqdt tzero theta) /\ (infix_lsdt theta tone)) ->
  exists k:Z,
  (mem k (to_fset 0%Z (n + 1%Z)%Z)) /\
  (infix_lseqdt
   (modulus (infix_mndt theta (infix_sldt (i_to_t k) (i_to_t n))))
   (infix_sldt tone (i_to_t (n * 2%Z)%Z))).

Parameter max_dyadic: Z -> t -> Z.

Parameter result7: Z -> t -> Z -> bool.

Axiom result_def7 :
  forall (n:Z) (p:t) (x:Z),
  (((result7 n p) x) = true) <->
  (infix_lseqdt (infix_asdt (i_to_t x) (pow_inv_2 n)) p).

Axiom max_dyadic_def :
  forall (n:Z) (p:t), ((infix_lseqdt tzero p) /\ (infix_lsdt p tone)) ->
  ((max_dyadic n p) =
   (max_filter (to_fset 0%Z (power_ 2%Z n)) (result7 n p))).

Axiom max_dyadic_spec :
  forall (n:Z) (p:t), ((infix_lseqdt tzero p) /\ (infix_lsdt p tone)) ->
  (0%Z <= (max_dyadic n p))%Z.

Axiom max_dyadic_spec1 :
  forall (n:Z) (p:t), ((infix_lseqdt tzero p) /\ (infix_lsdt p tone)) ->
  ((max_dyadic n p) < (power_ 2%Z n))%Z.

Axiom max_dyadic_spec2 :
  forall (n:Z) (p:t), ((infix_lseqdt tzero p) /\ (infix_lsdt p tone)) ->
  infix_lseqdt (infix_asdt (i_to_t (max_dyadic n p)) (pow_inv_2 n)) p.

Axiom max_dyadic_spec3 :
  forall (n:Z) (p:t), ((infix_lseqdt tzero p) /\ (infix_lsdt p tone)) ->
  infix_gteqdt (infix_asdt (i_to_t ((max_dyadic n p) + 1%Z)%Z) (pow_inv_2 n))
  p.

Axiom max_dyadic_spec4 :
  forall (n:Z) (p:t), ((infix_lseqdt tzero p) /\ (infix_lsdt p tone)) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  (infix_lseqdt (infix_asdt (i_to_t i) (pow_inv_2 n)) p) ->
  (i <= (max_dyadic n p))%Z.

Axiom int_to_ang_to_real_to_ang :
  forall (theta:angle) (k:Z) (n:Z), (n >= 0%Z)%Z ->
  (theta = (int_to_ang k n)) ->
  (theta = (real_to_ang (infix_asdt (i_to_t k) (pow_inv_2 n)))).

Axiom real_to_ang_to_int_to_ang :
  forall (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((real_to_ang (infix_asdt (i_to_t k) (pow_inv_2 n))) = (int_to_ang k n)).

Axiom real_to_ang_to_int_to_ang_add :
  forall (k:Z) (k':Z) (n:Z), (n >= 0%Z)%Z ->
  ((real_to_ang
    (infix_asdt (infix_pldt (i_to_t k) (i_to_t k')) (pow_inv_2 n)))
   = (int_to_ang (k + k')%Z n)).

Axiom int_to_ang_to_real_to_ang_gen :
  forall (k:Z) (n:Z) (kx:t), (n >= 0%Z)%Z -> (kx = (i_to_t k)) ->
  ((int_to_ang k n) = (real_to_ang (infix_asdt kx (pow_inv_2 n)))).

Axiom Equal_angle :
  forall (o:angle) (o':angle), ((ang_exp o) = (ang_exp o')) -> (o = o').

Axiom Equal_angle1 :
  forall (o:angle) (o':angle), (o = o') -> ((ang_exp o) = (ang_exp o')).

Axiom Int_To_Ang_inv :
  forall (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((ang_inv (int_to_ang k n)) = (int_to_ang (-k)%Z n)).

Axiom Int_To_Ang_inv_add :
  forall (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((ang_add (int_to_ang k n) (int_to_ang (-k)%Z n)) = ang_zero).

Axiom Int_To_Ang_add :
  forall (k:Z) (k':Z) (n:Z), (n >= 0%Z)%Z ->
  ((ang_add (int_to_ang k n) (int_to_ang k' n)) = (int_to_ang (k + k')%Z n)).

Axiom Int_To_Ang_up :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) = (int_to_ang (2%Z * k)%Z (n + 1%Z)%Z)).

Axiom Int_To_Ang_cyclic :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) = (int_to_ang (k + (power 2%Z n))%Z n)).

Axiom Zero_n : forall (n:Z), (n >= 0%Z)%Z -> ((int_to_ang 0%Z n) = ang_zero).

Parameter ang_minus_one: angle.

Axiom ang_minus_one_def : (ang_minus_one = (int_to_ang 1%Z 1%Z)).

Axiom set_ang_minus_one_by_int :
  forall (a:Z) (b:Z), (a = 1%Z) -> (b = 1%Z) ->
  ((int_to_ang a b) = ang_minus_one).

Axiom ang_minus_one_from_real :
  (ang_minus_one = (real_to_ang (infix_sldt tone ttwo))).

Axiom ang_exp_minus_one : ((ang_exp ang_minus_one) = (prefix_mndt tone)).

Axiom set_ang_zero_by_int :
  forall (a:Z) (b:Z), (a = 0%Z) -> (0%Z <= b)%Z ->
  ((int_to_ang a b) = ang_zero).

Axiom ang_minus_one_twice :
  forall (a1:angle) (a2:angle), (a1 = ang_minus_one) ->
  (a2 = ang_minus_one) -> ((ang_add a1 a2) = ang_zero).

Parameter div_two_: angle -> angle.

Axiom Div_two : forall (d:angle), ((ang_add (div_two_ d) (div_two_ d)) = d).

Axiom Div_two_int_to_ang :
  forall (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < (power 2%Z n))%Z) ->
  ((div_two_ (int_to_ang k n)) = (int_to_ang k (n + 1%Z)%Z)).

Axiom Add1 :
  forall (d:angle) (d':angle),
  ((ang_exp (ang_add d d')) = (infix_asdt (ang_exp d) (ang_exp d'))).

Axiom ang_exp_mult :
  forall (x:angle) (x':angle),
  ((infix_asdt (ang_exp x) (ang_exp x')) = (ang_exp (ang_add x x'))).

Parameter k_int_to_ang: Z -> angle.

Axiom k_int_to_ang_def :
  forall (k:Z), (0%Z <= k)%Z -> ((k_int_to_ang k) = (int_to_ang 1%Z k)).

Axiom K_int_to_angplus_one :
  forall (k:Z), (k > 0%Z)%Z ->
  ((ang_add (k_int_to_ang k) (k_int_to_ang k)) = (k_int_to_ang (k - 1%Z)%Z)).

Parameter phase_inv_: Z -> angle -> angle.

Axiom Even_phase_inv :
  forall (d:angle), forall (i:Z),
  ((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) -> ((phase_inv_ i d) = d).

Axiom Odd_phase_inv :
  forall (d:angle), forall (i:Z),
  ((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
  ((phase_inv_ i d) = (ang_inv d)).

Axiom Gen_phase_inv :
  forall (k:Z) (n:Z) (i:Z), (n >= 0%Z)%Z -> (i >= 0%Z)%Z ->
  ((phase_inv_ i (int_to_ang k n)) =
   (int_to_ang ((power (-1%Z)%Z i) * k)%Z n)).

Axiom Gen_phase_inv_neg :
  forall (k:Z) (n:Z) (i:Z), (n >= 0%Z)%Z -> (i < 0%Z)%Z ->
  ((phase_inv_ i (int_to_ang k n)) =
   (int_to_ang ((power (-1%Z)%Z (-i)%Z) * k)%Z n)).

Axiom Ang_exp_inv :
  forall (o:angle), ((ang_exp (ang_inv o)) = (infix_sldt tone (ang_exp o))).

Axiom ang_inv_to_conjugate :
  forall (o:angle), ((ang_exp (ang_inv o)) = (conjugate (ang_exp o))).

Axiom conjugate_to_ang_inv :
  forall (o:angle), ((conjugate (ang_exp o)) = (ang_exp (ang_inv o))).

Axiom ang_exp_zero_ : ((ang_exp ang_zero) = tone).

Axiom ang_mult_int_in :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((ang_mult_int (int_to_ang k n) i) = (int_to_ang (i * k)%Z n)).

Axiom ang_mult_int_out :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang (i * k)%Z n) = (ang_mult_int (int_to_ang k n) i)).

Axiom int_to_ang_cycles :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  ((int_to_ang (k + (i * (power 2%Z n))%Z)%Z n) = (int_to_ang k n)).

Axiom int_to_ang_bin_rev :
  forall (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  (j = (n - 1%Z)%Z) ->
  ((int_to_ang (-(i * (power 2%Z j))%Z)%Z n) =
   (int_to_ang (i * (power 2%Z (n - 1%Z)%Z))%Z n)).

Axiom int_to_ang_bin_rev_ :
  forall (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  (j = (n - 1%Z)%Z) ->
  ((int_to_ang (-(i * (power_ 2%Z j))%Z)%Z n) =
   (int_to_ang (i * (power_ 2%Z (n - 1%Z)%Z))%Z n)).

Axiom int_to_ang_add_rev :
  forall (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang (i + j)%Z n) = (ang_add (int_to_ang i n) (int_to_ang j n))).

Axiom int_to_ang_ind_isum_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (f i) n) (int_to_ang (ind_isum f (i + 1%Z)%Z j) n))).

Axiom int_to_ang_ind_isum_plus_one_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (ind_isum f (i + 1%Z)%Z j) n) (int_to_ang (f i) n))).

Axiom int_to_ang_ind_isum_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (ind_isum f i (j - 1%Z)%Z) n)
    (int_to_ang (f (j - 1%Z)%Z) n))).

Axiom int_to_ang_ind_isum_right_extension_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (f (j - 1%Z)%Z) n)
    (int_to_ang (ind_isum f i (j - 1%Z)%Z) n))).

Axiom minus_int_to_ang_ind_isum_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(f i))%Z n)
    (int_to_ang (-(ind_isum f (i + 1%Z)%Z j))%Z n))).

Axiom minus_int_to_ang_ind_isum_plus_one_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(ind_isum f (i + 1%Z)%Z j))%Z n)
    (int_to_ang (-(f i))%Z n))).

Axiom minus_int_to_ang_ind_isum_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(ind_isum f i (j - 1%Z)%Z))%Z n)
    (int_to_ang (-(f (j - 1%Z)%Z))%Z n))).

Axiom minus_int_to_ang_ind_isum_right_extension_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(f (j - 1%Z)%Z))%Z n)
    (int_to_ang (-(ind_isum f i (j - 1%Z)%Z))%Z n))).

Axiom real_to_ang_add_rev :
  forall (i:t) (j:t), (real_ i) -> (real_ j) ->
  ((real_to_ang (infix_pldt i j)) =
   (ang_add (real_to_ang i) (real_to_ang j))).

Axiom int_to_ang_cycles_neg :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z -> (0%Z >= i)%Z ->
  ((int_to_ang (k + (i * (power 2%Z n))%Z)%Z n) = (int_to_ang k n)).

Axiom int_to_ang_cycles_gen :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((int_to_ang (k + (i * (power 2%Z n))%Z)%Z n) = (int_to_ang k n)).

Axiom int_to_ang_cycles_zero :
  forall (n':Z) (n:Z), ((0%Z <= n)%Z /\ (n <= n')%Z) ->
  ((int_to_ang (power 2%Z n') n) = ang_zero).

Axiom int_to_ang_cycles_zero_mult :
  forall (k:Z) (n':Z) (n:Z), ((0%Z <= n)%Z /\ (n <= n')%Z) ->
  ((int_to_ang (k * (power 2%Z n'))%Z n) = ang_zero).

Axiom int_to_ang_cycles_zero_mult_ :
  forall (k:Z) (n':Z) (n:Z), ((0%Z <= n)%Z /\ (n <= n')%Z) ->
  ((int_to_ang (k * (power_ 2%Z n'))%Z n) = ang_zero).

Axiom int_to_ang_eq :
  forall (k1:Z) (k2:Z) (n1:Z) (n2:Z), (k1 = k2) -> (n1 = n2) ->
  ((int_to_ang k1 n1) = (int_to_ang k2 n2)).

Axiom int_to_ang_mod :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) =
   (int_to_ang (int.EuclideanDivision.mod1 k (power 2%Z n)) n)).

Axiom int_to_ang_equiv :
  forall (k1:Z) (k2:Z) (n1:Z) (n2:Z),
  ((int.EuclideanDivision.mod1 k1 (power_ 2%Z n1)) =
   (int.EuclideanDivision.mod1 k2 (power_ 2%Z n1))) ->
  (n1 = n2) -> ((int_to_ang k1 n1) = (int_to_ang k2 n2)).

Axiom int_to_ang_red :
  forall (k:Z) (n:Z), (1%Z <= n)%Z -> ~ (0%Z = k) ->
  ((int.EuclideanDivision.mod1 k 2%Z) = 0%Z) ->
  ((int_to_ang k n) =
   (int_to_ang (int.EuclideanDivision.div k 2%Z) (n - 1%Z)%Z)).

Axiom int_to_ang_up :
  forall (k:Z) (n:Z) (n':Z), (0%Z <= n)%Z -> (0%Z <= n')%Z ->
  ((int_to_ang (k * (power 2%Z n'))%Z (n + n')%Z) = (int_to_ang k n)).

Axiom int_to_ang_simpl :
  forall (k:Z) (n1:Z) (n2:Z), (n1 >= 0%Z)%Z -> (n2 >= 0%Z)%Z ->
  ((int_to_ang (k * (power 2%Z n1))%Z (n2 + n1)%Z) = (int_to_ang k n2)).

Axiom ang_add_eq :
  forall (d1:angle) (d2:angle) (e1:angle) (e2:angle), (d1 = e1) ->
  (d2 = e2) -> ((ang_add d1 d2) = (ang_add e1 e2)).

Axiom ang_add_comm :
  forall (d1:angle) (d2:angle), ((ang_add d1 d2) = (ang_add d2 d1)).

Axiom ang_add_eq_comm :
  forall (d1:angle) (d2:angle) (d3:angle) (d4:angle), (d1 = d3) ->
  (d2 = d4) -> ((ang_add d1 d2) = (ang_add d4 d3)).

Axiom ang_mult_int_zero :
  forall (theta:angle), ((ang_mult_int theta 0%Z) = ang_zero).

Axiom ang_div :
  forall (k:Z) (n:Z) (i:Z), (n >= 0%Z)%Z -> (i >= 0%Z)%Z ->
  ((int_to_ang k n) = (ang_mult_int (int_to_ang k (n + i)%Z) (power 2%Z i))).

Axiom ang_zero_add :
  forall (d':angle) (d:angle), (d' = ang_zero) -> ((ang_add d' d) = d).

Axiom int_to_ang_rev :
  forall (k:Z) (l:Z) (n:Z) (m:Z), (0%Z < n)%Z -> (0%Z <= k)%Z ->
  (n = (m + 1%Z)%Z) ->
  ((int_to_ang (((-k)%Z * l)%Z * (power 2%Z m))%Z n) =
   (int_to_ang ((k * l)%Z * (power 2%Z m))%Z n)).

Axiom int_to_ang_rev_ :
  forall (k:Z) (l:Z) (n:Z) (m:Z), (0%Z < n)%Z -> (0%Z <= k)%Z ->
  (0%Z <= l)%Z -> (n = (m + 1%Z)%Z) ->
  ((int_to_ang (((-k)%Z * l)%Z * (power_ 2%Z m))%Z n) =
   (int_to_ang ((k * l)%Z * (power_ 2%Z m))%Z n)).

Axiom ang_add_zero_d :
  forall (d':angle) (d:angle), (d' = ang_zero) -> ((ang_add d d') = d).

Parameter ang_sum: (Z -> angle) -> Z -> Z -> angle.

Axiom ang_sum_def :
  forall (f:Z -> angle) (i:Z) (j:Z),
  ((j <= i)%Z -> ((ang_sum f i j) = ang_zero)) /\
  (~ (j <= i)%Z ->
   ((ang_sum f i j) =
    (int_iterate (fun (y0:angle) (y1:angle) => (ang_add y0 y1)) f i j))).

Axiom ang_sumto_int_iterate :
  forall (f:Z -> angle) (i:Z) (j:Z), (i < j)%Z ->
  ((ang_sum f i j) =
   (int_iterate (fun (y0:angle) (y1:angle) => (ang_add y0 y1)) f i j)).

Axiom ang_sum_plus_one :
  forall (f:Z -> angle) (i:Z) (j:Z), ((i + 1%Z)%Z < j)%Z ->
  ((ang_sum f i j) = (ang_add (f i) (ang_sum f (i + 1%Z)%Z j))).

Axiom ang_sum_cardone :
  forall (f:Z -> angle) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((ang_sum f i j) = (f i)).

Axiom ang_sum_cardone_p :
  forall (f:Z -> angle) (i:Z) (j:Z) (r:angle), (j = (i + 1%Z)%Z) ->
  ((f i) = r) -> (r = (ang_sum f i j)).

Axiom ang_sum_neutral :
  forall (f:Z -> angle) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = ang_zero)) ->
  ((ang_sum f i j) = ang_zero).

Axiom ang_sum_def_plus_one_com :
  forall (f:Z -> angle) (i:Z) (j:Z), ((i + 1%Z)%Z < j)%Z ->
  ((ang_add (f i) (ang_sum f (i + 1%Z)%Z j)) = (ang_sum f i j)).

Axiom ang_sum_right_extension :
  forall (f:Z -> angle) (i:Z) (j:Z), ((i + 1%Z)%Z < j)%Z ->
  ((ang_sum f i j) = (ang_add (ang_sum f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom ang_sum_transitivity :
  forall (f:Z -> angle) (i:Z) (k:Z) (j:Z), ((i < k)%Z /\ (k < j)%Z) ->
  ((ang_sum f i j) = (ang_add (ang_sum f i k) (ang_sum f k j))).

Axiom ang_sum_eq :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ang_sum f i j) = (ang_sum g i j)).

Axiom ang_sum_int_to_ang :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  (exists n:Z,
   forall (k:Z),
   exists j1:Z, exists j':Z,
   ((f k) = (int_to_ang j1 n)) /\ (((g k) = (int_to_ang j' n)) /\ (j1 = j'))) ->
  ((ang_sum f i j) = (ang_sum g i j)).

Axiom vang_sum_eq :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ang_exp (ang_sum f i j)) = (ang_exp (ang_sum g i j))).

Axiom vang_sum_scal_eq :
  forall (f:Z -> angle) (g:Z -> angle) (m:matrix t) (n:matrix t) (i:Z) (j:Z),
  (i < j)%Z -> (m = n) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((infix_asdtdt (ang_exp (ang_sum f i j)) m) =
   (infix_asdtdt (ang_exp (ang_sum g i j)) n)).

Axiom ang_sum_plus_one_p :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (l:Z) (m:Z) (r:angle),
  ((i + 1%Z)%Z < j)%Z -> (l = (i + 1%Z)%Z) -> (m = j) -> ((g i) = r) ->
  (forall (k:Z), (((i + 1%Z)%Z <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ang_add r (ang_sum f l m)) = (ang_sum g i j)).

Axiom vang_sum_plus_one_p :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (l:Z) (m:Z) (r:angle),
  ((i + 1%Z)%Z < j)%Z -> (l = (i + 1%Z)%Z) -> (m = j) -> ((g i) = r) ->
  (forall (k:Z), (((i + 1%Z)%Z <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((infix_asdt (ang_exp r) (ang_exp (ang_sum f l m))) =
   (ang_exp (ang_sum g i j))).

Axiom vang_sum_plus_one_rev :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (l:Z) (m:Z) (r:angle),
  ((i + 1%Z)%Z < j)%Z -> (l = (i + 1%Z)%Z) -> (m = j) -> ((g i) = r) ->
  (forall (k:Z), (((i + 1%Z)%Z <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ang_exp (ang_sum g i j)) =
   (infix_asdt (ang_exp r) (ang_exp (ang_sum f l m)))).

Axiom ang_sum_right_extension_p :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (l:Z) (m:Z) (r:angle),
  ((i + 1%Z)%Z < j)%Z -> (m = (j - 1%Z)%Z) -> (l = i) ->
  ((g (j - 1%Z)%Z) = r) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < (j - 1%Z)%Z)%Z) -> ((f k) = (g k))) ->
  ((ang_add (ang_sum f l m) r) = (ang_sum g i j)).

Axiom vang_sum_right_extension_p :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (l:Z) (m:Z) (r:angle),
  ((i + 1%Z)%Z < j)%Z -> (m = (j - 1%Z)%Z) -> (l = i) ->
  ((g (j - 1%Z)%Z) = r) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < (j - 1%Z)%Z)%Z) -> ((f k) = (g k))) ->
  ((infix_asdt (ang_exp (ang_sum f l m)) (ang_exp r)) =
   (ang_exp (ang_sum g i j))).

Axiom vang_sum_right_extension_rev :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (l:Z) (m:Z) (r:angle),
  ((i + 1%Z)%Z < j)%Z -> (m = (j - 1%Z)%Z) -> (l = i) ->
  ((g (j - 1%Z)%Z) = r) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < (j - 1%Z)%Z)%Z) -> ((f k) = (g k))) ->
  ((ang_exp (ang_sum g i j)) =
   (infix_asdt (ang_exp (ang_sum f l m)) (ang_exp r))).

Axiom ang_sum_cardzero :
  forall (f:Z -> angle) (i:Z) (j:Z), (j <= i)%Z ->
  ((ang_sum f i j) = ang_zero).

Axiom ang_sum_eq_gen :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (i':Z) (j':Z),
  (i < j)%Z -> (i = i') -> (j = j') ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ang_sum f i j) = (ang_sum g i' j')).

Axiom ang_sum_sum_eq_vl :
  forall (f:Z -> Z -> angle) (g:Z -> Z -> angle) (i:Z) (j:Z) (i':Z) (j':Z)
    (l:Z) (l':Z),
  (i < j)%Z -> (j <= l)%Z -> (i = i') -> (j = j') -> (l = l') ->
  (forall (x:Z) (x':Z), ((i <= x)%Z /\ (x < j)%Z) ->
   ((x <= x')%Z /\ (x' < l)%Z) -> (((f x) x') = ((g x) x'))) ->
  ((ang_sum (fun (x:Z) => (ang_sum (f x) x l)) i j) =
   (ang_sum (fun (x:Z) => (ang_sum (g x) x l')) i' j')).

Axiom ang_sum_minus :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (n >= 0%Z)%Z -> (i < j)%Z ->
  ((ang_sum (fun (k:Z) => (int_to_ang (-(f k))%Z n)) i j) =
   (int_to_ang (-(ind_isum f i j))%Z n)).

Parameter constant_size:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix t) -> Prop.

Axiom constant_size_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t),
  (constant_size s f) <->
  forall (e1:a), (mem e1 s) ->
  ((rows (f e1)) = (rows (f (choose s)))) /\
  ((columns (f e1)) = (columns (f (choose s)))).

Axiom set_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t),
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) ->
   ((rows (f e1)) = (rows (f e')))) ->
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) ->
   ((columns (f e1)) = (columns (f e')))) ->
  constant_size s f.

Axiom set_constant_size_exists :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t),
  (exists r:Z, forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (exists c:Z, forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  constant_size s f.

Axiom set_constant_size_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z),
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) -> constant_size s f.

Parameter fc5:
  forall {a:Type} {a_WT:WhyType a}, (a -> matrix t) -> (a -> bool) ->
  (matrix t) -> a -> matrix t.

Axiom fc_def5 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (p:a -> bool) (m:matrix t) (j:a),
  (((p j) = true) -> (((fc5 f p m) j) = (f j))) /\
  (~ ((p j) = true) -> (((fc5 f p m) j) = m)).

Axiom guarded_set_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (p:a -> bool) (m:matrix t),
  (constant_size s f) -> (forall (e1:a), (mem e1 s) -> ((p e1) = true)) ->
  constant_size s (fc5 f p m).

Axiom set_constant_size_set :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (m:matrix t) (i:Z) (j:Z),
  (valid_index m i j) -> constant_size s (fun (e1:a) => (set1 m i j (f e1))).

Axiom get_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) ->
  ((rows (f e1)) = (rows (f e'))).

Axiom get_constant_size1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) ->
  ((columns (f e1)) = (columns (f e'))).

Parameter s_rows:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix t) -> Z.

Axiom s_rows_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((s_rows s f) = (rows (f (choose s)))).

Axiom s_rows_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  (0%Z < (s_rows s f))%Z.

Axiom s_rows_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) -> forall (e1:a),
  (mem e1 s) -> ((rows (f e1)) = (s_rows s f)).

Axiom s_rows_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) ->
  ((rows (f e1)) = (rows (f e'))).

Parameter s_columns:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix t) -> Z.

Axiom s_columns_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((s_columns s f) = (columns (f (choose s)))).

Axiom s_columns_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  (0%Z < (s_columns s f))%Z.

Axiom s_columns_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) -> forall (e1:a),
  (mem e1 s) -> ((columns (f e1)) = (s_columns s f)).

Axiom s_columns_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) ->
  ((columns (f e1)) = (columns (f e'))).

Axiom set_s_rows :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z), (constant_size s f) ->
  ((rows (f (choose s))) = r) -> ((s_rows s f) = r).

Axiom set_s_rows_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (elt:a), (constant_size s f) ->
  (mem elt s) -> ((s_rows s f) = (rows (f elt))).

Axiom set_s_columns :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z), (constant_size s f) ->
  ((columns (f (choose s))) = r) -> ((s_columns s f) = r).

Axiom set_s_columns_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (elt:a), (constant_size s f) ->
  (mem elt s) -> ((s_columns s f) = (columns (f elt))).

Axiom s_rows_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (g:a -> matrix t),
  (constant_size s f) -> ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((f e1) = (g e1))) ->
  ((s_rows s f) = (s_rows s g)).

Axiom set_constant_size_give :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) -> constant_size s f.

Axiom set_constant_size_give1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) -> forall (e1:a),
  (mem e1 s) -> ((rows (f e1)) = r).

Axiom set_constant_size_give2 : True.

Axiom set_constant_size_give3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) -> ((s_rows s f) = r).

Axiom set_constant_size_give4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((s_columns s f) = c).

Axiom s_columns_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (g:a -> matrix t),
  (constant_size s f) -> ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((f e1) = (g e1))) ->
  ((s_columns s f) = (s_columns s g)).

Axiom subset_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix t), (constant_size s f) ->
  ~ (is_empty s') -> (subset s' s) -> constant_size s' f.

Axiom subset_constant_size1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix t), (constant_size s f) ->
  ~ (is_empty s') -> (subset s' s) -> ((s_rows s' f) = (s_rows s f)).

Axiom subset_constant_size2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix t), (constant_size s f) ->
  ~ (is_empty s') -> (subset s' s) -> ((s_columns s' f) = (s_columns s f)).

Axiom set_s_rows_rem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 1%Z)%Z ->
  (constant_size s f) -> constant_size (remove (choose s) s) f.

Axiom set_s_rows_rem1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 1%Z)%Z ->
  (constant_size s f) ->
  ((s_rows (remove (choose s) s) f) = (rows (f (choose s)))).

Axiom set_s_columns_rem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 1%Z)%Z ->
  (constant_size s f) -> constant_size (remove (choose s) s) f.

Axiom set_s_columns_rem1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 1%Z)%Z ->
  (constant_size s f) ->
  ((s_columns (remove (choose s) s) f) = (columns (f (choose s)))).

Axiom set_s_rows_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (x:a), ((cardinal s) > 0%Z)%Z ->
  (constant_size s f) -> ((columns (f x)) = (s_columns s f)) ->
  ((rows (f x)) = (s_rows s f)) -> ((s_rows (add x s) f) = (s_rows s f)).

Axiom set_s_columns_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (x:a), ((cardinal s) > 0%Z)%Z ->
  (constant_size s f) -> ((columns (f x)) = (s_columns s f)) ->
  ((rows (f x)) = (s_rows s f)) ->
  ((s_columns (add x s) f) = (s_columns s f)).

Axiom set_s_rows_columns_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (x:a), ((cardinal s) > 0%Z)%Z ->
  (constant_size s f) -> ((columns (f x)) = (s_columns s f)) ->
  ((rows (f x)) = (s_rows s f)) ->
  ((s_columns (add x s) f) = (s_columns s f)).

Axiom set_s_rows_columns_add1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (x:a), ((cardinal s) > 0%Z)%Z ->
  (constant_size s f) -> ((columns (f x)) = (s_columns s f)) ->
  ((rows (f x)) = (s_rows s f)) -> ((s_rows (add x s) f) = (s_rows s f)).

Parameter mat_sum:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix t) -> matrix t.

Axiom mat_sum_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z -> ((cardinal s) = 1%Z) ->
  ((mat_sum s f) = (f (element s))).

Axiom mat_sum_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z -> ~ ((cardinal s) = 1%Z) ->
  ((mat_sum s f) =
   (add_mat (f (choose s)) (mat_sum (remove (choose s) s) f))).

Axiom mat_sum_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z -> ((rows (mat_sum s f)) = (s_rows s f)).

Axiom mat_sum_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z -> ((columns (mat_sum s f)) = (s_columns s f)).

Axiom mat_sum_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z -> forall (e1:a), (mem e1 s) ->
  ((rows (f e1)) = (s_rows s f)).

Axiom mat_sum_spec3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z -> forall (e1:a), (mem e1 s) ->
  ((columns (f e1)) = (s_columns s f)).

Axiom columns_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (n:Z), ~ ((cardinal s) = 0%Z) ->
  (constant_size s f) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = n)) ->
  ((columns (mat_sum s f)) = n).

Axiom rows_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (n:Z), ~ ((cardinal s) = 0%Z) ->
  (constant_size s f) ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = n)) ->
  ((rows (mat_sum s f)) = n).

Axiom mat_sum_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) = 1%Z) ->
  ((mat_sum s f) = (f (element s))).

Axiom mat_sum_to_sum_pre :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (i:Z) (j:Z), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z -> ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
  ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
  ((get (mat_sum s f) i j) = (sum s (fun (e1:a) => (get (f e1) i j)))).

Axiom mat_sum_to_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s f) =
   (make_f (s_rows s f) (s_columns s f)
    (fun (i:Z) (j:Z) => (sum s (fun (e1:a) => (get (f e1) i j)))))).

Axiom mat_sum_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s f) =
   (make_f (s_rows s f) (s_columns s f)
    (fun (i:Z) (j:Z) => (sum s (fun (e1:a) => (get (f e1) i j)))))).

Axiom mat_sum_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (x:a), ((cardinal s) > 0%Z)%Z ->
  (constant_size s f) -> ((rows (f x)) = (s_rows s f)) ->
  ((columns (f x)) = (s_columns s f)) -> ~ (mem x s) ->
  ((mat_sum (add x s) f) = (add_mat (f x) (mat_sum s f))).

Axiom mat_sum_plus_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 1%Z)%Z ->
  (constant_size s f) ->
  ((mat_sum s f) =
   (add_mat (f (choose s)) (mat_sum (remove (choose s) s) f))).

Axiom mat_sum_comp_pre :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix t) (g:b -> matrix t) (i:Z) (j:Z),
  (constant_size s f) -> (constant_size s g) ->
  ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
  ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
  ((s_rows s f) = (s_rows s g)) -> ((s_columns s f) = (s_columns s g)) ->
  ((cardinal s) > 0%Z)%Z ->
  ((get (mat_sum s (fun (k:b) => (add_mat (f k) (g k)))) i j) =
   (get (add_mat (mat_sum s f) (mat_sum s g)) i j)).

Axiom mat_sum_comp :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix t) (g:b -> matrix t),
  (constant_size s f) -> (constant_size s g) ->
  ((s_rows s f) = (s_rows s g)) -> ((s_columns s f) = (s_columns s g)) ->
  ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s (fun (k:b) => (add_mat (f k) (g k)))) =
   (add_mat (mat_sum s f) (mat_sum s g))).

Axiom mat_sum_comp_rec :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix t) (g:b -> matrix t),
  (constant_size s f) -> (constant_size s g) ->
  ((s_rows s f) = (s_rows s g)) -> ((s_columns s f) = (s_columns s g)) ->
  ((cardinal s) > 0%Z)%Z ->
  ((add_mat (mat_sum s f) (mat_sum s g)) =
   (mat_sum s (fun (k:b) => (add_mat (f k) (g k))))).

Axiom mat_sum_to_sum_fun :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (s':set b) (f:a -> b -> matrix t) (r:Z) (c:Z) (i:Z) (j:Z),
  ((cardinal s) > 0%Z)%Z -> ((cardinal s') > 0%Z)%Z ->
  (forall (e1:a), forall (e11:b), (mem e1 s) -> (mem e11 s') ->
   ((rows ((f e1) e11)) = r)) ->
  (forall (e1:a), forall (e11:b), (mem e1 s) -> (mem e11 s') ->
   ((columns ((f e1) e11)) = c)) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((sum s (fun (e1:a) => (get (mat_sum s' (f e1)) i j))) =
   (sum s (fun (e1:a) => (sum s' (fun (e11:b) => (get ((f e1) e11) i j)))))).

Axiom mat_sum_to_sum_double_pre :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (s':set b) (f:a -> b -> matrix t) (r:Z) (c:Z) (i:Z) (j:Z),
  (forall (e1:a) (e':b), (mem e1 s) -> (mem e' s') ->
   ((rows ((f e1) e')) = r)) ->
  (forall (e1:a) (e':b), (mem e1 s) -> (mem e' s') ->
   ((columns ((f e1) e')) = c)) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((cardinal s) > 0%Z)%Z -> ((cardinal s') > 0%Z)%Z ->
  ((get (mat_sum s (fun (e1:a) => (mat_sum s' (f e1)))) i j) =
   (sum s (fun (e1:a) => (sum s' (fun (e':b) => (get ((f e1) e') i j)))))).

Axiom mat_mult_sum_out_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (n:matrix t), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = (rows n))) ->
  (exists r:Z, forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  ((mat_mult (mat_sum s f) n) =
   (mat_sum s (fun (e1:a) => (mat_mult (f e1) n)))).

Parameter mat_sum_dim:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix t) -> Z -> 
  Z -> matrix t.

Axiom mat_sum_dim_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((cardinal s) = 0%Z) -> ((mat_sum_dim s f r c) = (make r c tzero)).

Axiom mat_sum_dim_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ~ ((cardinal s) = 0%Z) -> ((mat_sum_dim s f r c) = (mat_sum s f)).

Axiom mat_sum_dim_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((cardinal s) > 0%Z)%Z -> ((mat_sum_dim s f r c) = (mat_sum s f)).

Axiom mat_sum_dim_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((cardinal s) = 0%Z) -> ((mat_sum_dim s f r c) = (make r c tzero)).

Axiom mat_sum_dim_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((rows (mat_sum_dim s f r c)) = r).

Axiom mat_sum_dim_spec3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((columns (mat_sum_dim s f r c)) = c).

Axiom mat_sum_dim_to_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), ((cardinal s) > 0%Z)%Z ->
  (0%Z < r)%Z -> (0%Z < c)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((mat_sum_dim s f r c) = (mat_sum s f)).

Axiom mat_sum_dim_to_make_zero :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (r:Z) (c:Z), ((cardinal s) = 0%Z) ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) -> (0%Z < r)%Z ->
  (0%Z < c)%Z -> ((mat_sum_dim s f r c) = (make r c tzero)).

Axiom mat_sum_dim_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (x:a) (r:Z) (c:Z),
  ((cardinal s) >= 0%Z)%Z -> ~ (mem x s) ->
  (forall (e1:a), (mem e1 (add x s)) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 (add x s)) -> ((columns (f e1)) = c)) ->
  (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((mat_sum_dim (add x s) f r c) = (add_mat (f x) (mat_sum_dim s f r c))).

Axiom mat_sum_scalar :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (a1:t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s (fun (k:a) => (infix_asdtdt a1 (f k)))) =
   (infix_asdtdt a1 (mat_sum s f))).

Axiom mat_sum_scalar_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (a1:t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((infix_asdtdt a1 (mat_sum s f)) =
   (mat_sum s (fun (k:a) => (infix_asdtdt a1 (f k))))).

Axiom mat_sum_const :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:matrix t), ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s (fun (us:a) => x)) = (infix_asdtdt (i_to_t (cardinal s)) x)).

Axiom mat_sum_quot :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:matrix t), ((cardinal s) > 0%Z)%Z ->
  (x =
   (infix_asdtdt (infix_sldt tone (i_to_t (cardinal s)))
    (mat_sum s (fun (us:a) => x)))).

Axiom mat_sum_scalar_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (i:Z) (j:Z),
  (constant_size s f) -> ((cardinal s) > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
  ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
  ((infix_asdtdt (get (mat_sum s f) i j) m) =
   (mat_sum s (fun (k:a) => (infix_asdtdt (get (f k) i j) m)))).

Axiom mat_sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (g:a -> matrix t),
  ((cardinal s) > 0%Z)%Z -> (constant_size s f) ->
  (forall (a1:a), (mem a1 s) -> ((f a1) = (g a1))) ->
  ((mat_sum s f) = (mat_sum s g)).

Axiom mat_sum_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix t) (g:a -> matrix t),
  ((cardinal s) > 0%Z)%Z -> (s = s') -> (constant_size s f) ->
  (forall (a1:a), (mem a1 s) -> ((f a1) = (g a1))) ->
  ((mat_sum s f) = (mat_sum s' g)).

Axiom mat_sum_eq_gen_int :
  forall (i1:Z) (i2:Z) (o1:Z) (o2:Z) (f:Z -> matrix t) (g:Z -> matrix t),
  (i1 < o1)%Z -> (i1 = o1) -> (i2 = o2) ->
  (constant_size (to_fset i1 o1) f) ->
  (forall (a:Z), (mem a (to_fset i1 o1)) -> ((f a) = (g a))) ->
  ((mat_sum (to_fset i1 o1) f) = (mat_sum (to_fset i2 o2) g)).

Axiom mat_sum_comp_eq :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix t) (g:b -> matrix t) (h:b -> matrix t),
  (constant_size s f) -> (constant_size s g) -> (constant_size s h) ->
  (((s_rows s f) = (s_rows s g)) /\ ((s_rows s g) = (s_rows s h))) ->
  (((s_columns s f) = (s_columns s g)) /\
   ((s_columns s g) = (s_columns s h))) ->
  ((cardinal s) > 0%Z)%Z ->
  (forall (e1:b), forall (i:Z) (j:Z), (mem e1 s) ->
   ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
   ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
   ((infix_pldt (get (f e1) i j) (get (g e1) i j)) = (get (h e1) i j))) ->
  ((add_mat (mat_sum s f) (mat_sum s g)) = (mat_sum s h)).

Axiom mat_sum_dim_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (g:a -> matrix t) (r:Z) (c:Z),
  (0%Z < r)%Z -> (0%Z < c)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  (forall (e1:a), (mem e1 s) -> ((f e1) = (g e1))) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim s g r c)).

Axiom constant_size_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> matrix t) (s:set a) (t1:a -> b),
  (constant_size s (fun (a1:a) => (f (t1 a1)))) -> constant_size (map t1 s) f.

Axiom map_mat_sum :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> matrix t) (s:set a) (t1:a -> b), ((cardinal s) > 0%Z)%Z ->
  (constant_size s (fun (a1:a) => (f (t1 a1)))) -> (p_injective t1 s) ->
  ((mat_sum (map t1 s) f) = (mat_sum s (fun (a1:a) => (f (t1 a1))))).

Axiom map_mat_sum_rec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> matrix t) (s:set a) (t1:a -> b), ((cardinal s) > 0%Z)%Z ->
  (constant_size s (fun (a1:a) => (f (t1 a1)))) -> (p_injective t1 s) ->
  ((mat_sum s (fun (a1:a) => (f (t1 a1)))) = (mat_sum (map t1 s) f)).

Axiom mat_sum_id :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), ((cardinal s) > 0%Z)%Z ->
  (constant_size s f) ->
  (constant_size (map f s) (fun (y0:matrix t) => (p_id y0))) ->
  (p_injective f s) ->
  ((mat_sum (map f s) (fun (y0:matrix t) => (p_id y0))) = (mat_sum s f)).

Parameter nonn_mat_subset:
  forall {a:Type} {a_WT:WhyType a}, (a -> matrix t) -> (set a) -> set a.

Parameter result8:
  forall {a:Type} {a_WT:WhyType a}, (a -> matrix t) -> (set a) -> a -> bool.

Axiom result_def8 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (e1:a),
  (((result8 f s) e1) = true) <->
  ~ (equal (f e1) (make (s_rows s f) (s_columns s f) tzero)).

Axiom nonn_mat_subset_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) ->
  ((nonn_mat_subset f s) = (filter (result8 f s) s)).

Axiom nonn_mat_subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) ->
  subset (nonn_mat_subset f s) s.

Axiom nonn_mat_subset_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) -> forall (e1:a),
  (mem e1 (nonn_mat_subset f s)) -> mem e1 s.

Axiom nonn_mat_subset_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) ->
  constant_size (nonn_mat_subset f s) f.

Axiom nonn_mat_subset_spec3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) ->
  ~ ((nonn_mat_subset f s) = (empty : set a)) ->
  ((s_rows (nonn_mat_subset f s) f) = (s_rows s f)).

Axiom nonn_mat_subset_spec4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) ->
  ~ ((nonn_mat_subset f s) = (empty : set a)) ->
  ((s_columns (nonn_mat_subset f s) f) = (s_columns s f)).

Axiom mat_subset_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) -> forall (e1:a),
  (mem e1 (nonn_mat_subset f s)) -> mem e1 s.

Axiom mat_subset_nonn_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), (constant_size s f) -> forall (e1:a),
  (mem e1 (nonn_mat_subset f s)) ->
  ~ ((f e1) = (make (s_rows s f) (s_columns s f) tzero)).

Axiom nonn_mat_sum_cardzero :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (r:Z) (c:Z), ((cardinal s) = 0%Z) ->
  (r > 0%Z)%Z -> (c > 0%Z)%Z ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom nonn_mat_sum_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (r:Z) (c:Z), ((cardinal s) = 1%Z) ->
  (r > 0%Z)%Z -> (c > 0%Z)%Z -> ((rows (f (choose s))) = r) ->
  ((columns (f (choose s))) = c) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom mat_sum_null_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (e1:a), ((cardinal s) > 1%Z)%Z ->
  (constant_size s f) -> (mem e1 s) ->
  (forall (e':a), (mem e' s) -> ~ (e1 = e') -> null_mat (f e')) ->
  ((mat_sum s f) = (f e1)).

Axiom nonn_mat_sum_plus_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (r:Z) (c:Z), ((cardinal s) > 1%Z)%Z ->
  (r > 0%Z)%Z -> (c > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((mat_sum_dim (remove (choose s) s) f r c) =
   (mat_sum_dim (nonn_mat_subset f (remove (choose s) s)) f r c)) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom nonn_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (r:Z) (c:Z), (r > 0%Z)%Z ->
  (c > 0%Z)%Z -> (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom mat_sum_map_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {c:Type} {c_WT:WhyType c},
  forall (s1:set a) (s2:set b) (t1:a -> c) (t2:b -> c) (f:c -> matrix t),
  ((cardinal s1) > 0%Z)%Z -> (p_injective t1 s1) ->
  (constant_size s1 (fun (a1:a) => (f (t1 a1)))) ->
  ((cardinal s2) > 0%Z)%Z -> (p_injective t2 s2) ->
  (constant_size s2 (fun (a1:b) => (f (t2 a1)))) ->
  ((map t1 s1) = (map t2 s2)) ->
  ((mat_sum (map t1 s1) f) = (mat_sum (map t2 s2) f)).

Axiom mat_sum_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s1:set a) (s2:set a) (f:a -> matrix t),
  (constant_size s f) -> ((inter s1 s2) = (empty : set a)) ->
  ((union s1 s2) = s) -> ((cardinal s1) > 0%Z)%Z ->
  ((cardinal s2) > 0%Z)%Z ->
  ((add_mat (mat_sum s1 f) (mat_sum s2 f)) = (mat_sum s f)).

Axiom mat_sum_null :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a), ((cardinal s) > 1%Z)%Z ->
  (constant_size s f) ->
  (forall (e1:a), (mem e1 s) -> forall (i:Z) (j:Z),
   (valid_index (f e1) i j) -> ((get (f e1) i j) = tzero)) ->
  forall (i:Z) (j:Z), (valid_index (mat_sum s f) i j) ->
  ((get (mat_sum s f) i j) = tzero).

Axiom mat_sum_null_b :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (r:Z) (c:Z), ((cardinal s) > 1%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> ((rows (f e1)) = r)) ->
  (forall (e1:a), (mem e1 s) -> ((columns (f e1)) = c)) ->
  (forall (e1:a), (mem e1 s) -> forall (i:Z) (j:Z),
   (valid_index (f e1) i j) -> ((get (f e1) i j) = tzero)) ->
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> ((get (mat_sum s f) i j) = tzero).

Axiom map_add_mat_sum_t :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (s':set b) (f:b -> matrix t) (injz:a -> b) (injo:a -> b),
  (constant_size s' f) -> ((cardinal s) > 0%Z)%Z ->
  ((inter (map injz s) (map injo s)) = (empty : set b)) ->
  ((union (map injz s) (map injo s)) = s') -> (p_injective injo s) ->
  (p_injective injz s) ->
  ((mat_sum s (fun (e1:a) => (add_mat (f (injz e1)) (f (injo e1))))) =
   (mat_sum s' f)).

Axiom map_add_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s1:set a) (s2:set a) (s':set a) (f:a -> matrix t)
    (g:a -> matrix t) (h:a -> matrix t),
  (constant_size s' h) -> (constant_size s f) -> (constant_size s g) ->
  (((s_rows s' h) = (s_rows s f)) /\ ((s_rows s f) = (s_rows s g))) ->
  (((s_columns s' h) = (s_columns s f)) /\
   ((s_columns s f) = (s_columns s g))) ->
  ((cardinal s) > 0%Z)%Z -> (p_injective f s) -> (p_injective g s) ->
  (p_injective h s') -> ((map f s) = (map h s1)) ->
  ((map g s) = (map h s2)) -> ((inter s1 s2) = (empty : set a)) ->
  ((union s1 s2) = s') ->
  ((mat_sum s (fun (e1:a) => (add_mat (f e1) (g e1)))) =
   (mat_sum s' (fun (e1:a) => (h e1)))).

Parameter inv_func:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv_func_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e':b), (p_bijective f s s') ->
  (mem e' s') ->
  ((inv_func f s s' e') =
   (element (filter (fun (e1:a) => (indic_bool (f e1) e')) s))).

Axiom inv_func_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e':b), (p_bijective f s s') ->
  (mem e' s') -> mem (inv_func f s s' e') s.

Axiom inv_func_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e':b), (p_bijective f s s') ->
  (mem e' s') -> ((f (inv_func f s s' e')) = e').

Axiom inv_rec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e1:a), (p_bijective f s s') ->
  (mem e1 s) -> ((inv_func f s s' (f e1)) = e1).

Parameter inv_:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv__def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e1:b), (p_bijective f s s') ->
  (mem e1 s') -> ((inv_ f s s' e1) = (inv_func f s s' e1)).

Axiom inv__spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e1:b), (p_bijective f s s') ->
  (mem e1 s') -> mem (inv_ f s s' e1) s.

Axiom inv__spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e1:b), (p_bijective f s s') ->
  (mem e1 s') -> ((f (inv_ f s s' e1)) = e1).

Axiom inv_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_bijective
  ((((fun (y0:a -> b) (y1:set a) (y2:set b) (y3:b) => (inv_ y0 y1 y2 y3)) f)
    s)
   s')
  s' s.

Axiom set_bijective_inv :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a) (b1:b), (mem b1 (map f s)) ->
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
   ~ ((f e1) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  p_bijective f s (map f s).

Axiom set_bijective_inv1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a) (b1:b), (mem b1 (map f s)) ->
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
   ~ ((f e1) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  ((inv_func f s (map f s) b1) = (g b1)).

Axiom set_bij_inv :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a),
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
   ~ ((f e1) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  p_bijective f s (map f s).

Axiom set_bij_inv1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a),
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
   ~ ((f e1) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  p_bijective g (map f s) s.

Axiom set_bij_inv2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a),
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
   ~ ((f e1) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  forall (b1:b), (mem b1 (map f s)) -> ((inv_func f s (map f s) b1) = (g b1)).

Parameter inv_f:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv_f_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  forall (e1:b), (mem e1 s') -> mem ((inv_f f s s') e1) s.

Axiom inv_f_spec1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  forall (e1:b), (mem e1 s') -> ((f ((inv_f f s s') e1)) = e1).

Axiom inv_f_spec2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_bijective (inv_f f s s') s' s.

Axiom bitvec : Type.
Parameter bitvec_WhyType : WhyType bitvec.
Existing Instance bitvec_WhyType.

Parameter value: bitvec -> Z -> Z.

Parameter length: bitvec -> Z.

Axiom bitvec'invariant : forall (self:bitvec), (0%Z <= (length self))%Z.

Axiom bitvec'invariant1 :
  forall (self:bitvec), forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (length self))%Z) -> (0%Z <= ((value self) i))%Z.

Axiom bitvec'invariant2 :
  forall (self:bitvec), forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (length self))%Z) -> (((value self) i) < 2%Z)%Z.

Axiom bitvec'invariant3 :
  forall (self:bitvec), forall (i:Z), ~ (0%Z <= i)%Z ->
  (((value self) i) = 0%Z).

Axiom bitvec'invariant4 :
  forall (self:bitvec), forall (i:Z), ~ (i < (length self))%Z ->
  (((value self) i) = 0%Z).

Parameter bvlength: (Z -> Z) -> Z -> Prop.

Axiom bvlength_def :
  forall (f:Z -> Z) (i:Z),
  (bvlength f i) <->
  forall (k:Z), ((0%Z <= k)%Z /\ (k < i)%Z) ->
  (0%Z <= (f k))%Z /\ ((f k) < 2%Z)%Z.

Axiom binary_mult :
  forall (a:Z) (b:Z),
  ((int.EuclideanDivision.mod1 (a * b)%Z 2%Z) =
   ((int.EuclideanDivision.mod1 a 2%Z) *
    (int.EuclideanDivision.mod1 b 2%Z))%Z).

Parameter getbv: bitvec -> Z -> Z.

Axiom getbv_def : forall (a:bitvec), ((getbv a) = (value a)).

Axiom getbv_spec : forall (a:bitvec), binary (getbv a).

Axiom getbv_spec1 :
  forall (a:bitvec), forall (i:Z), (((getbv a) i) = ((value a) i)).

Parameter to_bool: Z -> bool.

Axiom to_bool_def :
  forall (i:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) -> ~ (i = 0%Z) ->
  ((to_bool i) = true).

Axiom to_bool_def1 :
  forall (i:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) -> (i = 0%Z) ->
  ((to_bool i) = false).

Axiom getbv_bound : forall (bv:bitvec) (i:Z), (0%Z <= ((getbv bv) i))%Z.

Axiom getbv_bound1 : forall (bv:bitvec) (i:Z), (((getbv bv) i) < 2%Z)%Z.

Axiom getbv_eq :
  forall (bvx:bitvec) (bvy:bitvec) (i:Z), (bvx = bvy) ->
  (((getbv bvx) i) = ((getbv bvy) i)).

Axiom getbv_eq_gen :
  forall (bvx:bitvec) (bvy:bitvec) (i:Z) (j:Z), (bvx = bvy) -> (i = j) ->
  (((getbv bvx) i) = ((getbv bvy) j)).

Parameter setbv: (Z -> Z) -> Z -> Z -> Z -> Z.

Axiom setbv_def :
  forall (bv:Z -> Z) (i:Z) (j:Z),
  let result9 := setbv bv i j in
  forall (k:Z),
  ((k = i) -> ((result9 k) = j)) /\ (~ (k = i) -> ((result9 k) = (bv k))).

Axiom setbv_spec :
  forall (bv:Z -> Z) (i:Z) (j:Z), forall (k:Z), ~ (k = i) ->
  (((setbv bv i j) k) = (bv k)).

Axiom setbv_spec1 : forall (bv:Z -> Z) (i:Z) (j:Z), (((setbv bv i j) i) = j).

Parameter setbv_int: (Z -> Z) -> (Z -> Z) -> Z -> Z -> Z -> Z.

Axiom setbv_int_def :
  forall (bv1:Z -> Z) (bv2:Z -> Z) (i:Z) (j:Z),
  let result9 := setbv_int bv1 bv2 i j in
  forall (k:Z),
  (((i < k)%Z /\ (k <= j)%Z) -> ((result9 k) = (bv2 (k - i)%Z))) /\
  (~ ((i < k)%Z /\ (k <= j)%Z) -> ((result9 k) = (bv1 k))).

Axiom setbv_int_spec :
  forall (bv1:Z -> Z) (bv2:Z -> Z) (i:Z) (j:Z), forall (k:Z),
  ((i < k)%Z /\ (k <= j)%Z) ->
  (((setbv_int bv1 bv2 i j) k) = (bv2 (k - i)%Z)).

Axiom setbv_int_spec1 :
  forall (bv1:Z -> Z) (bv2:Z -> Z) (i:Z) (j:Z), forall (k:Z), (k <= i)%Z ->
  (((setbv_int bv1 bv2 i j) k) = (bv1 k)).

Axiom setbv_int_spec2 :
  forall (bv1:Z -> Z) (bv2:Z -> Z) (i:Z) (j:Z), forall (k:Z), (j < k)%Z ->
  (((setbv_int bv1 bv2 i j) k) = (bv1 k)).

Axiom set_bvlength :
  forall (bv:bitvec) (i:Z),
  (forall (k:Z), ((1%Z <= k)%Z /\ (k < i)%Z) ->
   (0%Z <= ((getbv bv) k))%Z /\ (((getbv bv) k) < 2%Z)%Z) ->
  bvlength (getbv bv) i.

Axiom null_product_bitvec :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 1%Z)) ->
  ((ind_iproduct (getbv x) 0%Z n) = 1%Z).

Axiom non_null_product_bitvec :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 1%Z)) ->
  ((ind_iproduct (getbv x) 0%Z n) = 0%Z).

Axiom null_product_bitvec_inv :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 0%Z)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((getbv x) i))%Z) 0%Z n) = 1%Z).

Axiom non_null_product_bitvec_inv :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 0%Z)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((getbv x) i))%Z) 0%Z n) = 0%Z).

Axiom null_product_bitvec_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (getbv x) 0%Z n) = 1%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 1%Z).

Axiom non_null_product_bitvec_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (getbv x) 0%Z n) = 0%Z) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 1%Z)).

Axiom null_product_bitvec_inv_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((getbv x) i))%Z) 0%Z n) = 1%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 0%Z).

Axiom non_null_product_bitvec_inv_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((getbv x) i))%Z) 0%Z n) = 0%Z) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 0%Z)).

Axiom set_flength :
  forall (f:Z -> Z) (i:Z),
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < i)%Z) ->
   (0%Z <= (f k))%Z /\ ((f k) < 2%Z)%Z) ->
  bvlength f i.

Axiom get_bvlength :
  forall (f:Z -> Z) (i:Z), (bvlength f i) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < i)%Z) -> (0%Z <= (f k))%Z.

Axiom get_bvlength1 :
  forall (f:Z -> Z) (i:Z), (bvlength f i) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < i)%Z) -> ((f k) < 2%Z)%Z.

Axiom set_bv_to :
  forall (f:Z -> Z) (i:Z), (0%Z < i)%Z ->
  (forall (j:Z), ((0%Z <= j)%Z /\ (j < i)%Z) ->
   (0%Z <= (f j))%Z /\ ((f j) <= 1%Z)%Z) ->
  bvlength f i.

Axiom set_in_range_val :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  (0%Z <= ((getbv bv) i))%Z.

Axiom set_in_range_val1 :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  (((getbv bv) i) < 2%Z)%Z.

Axiom bvlengthm :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  bvlength (getbv bv) i.

Parameter in_range: bitvec -> Z -> Prop.

Axiom in_range_def :
  forall (bv:bitvec) (r:Z),
  (in_range bv r) <-> ((0%Z <= r)%Z /\ (r < (length bv))%Z).

Axiom binary_bv :
  forall (bv:bitvec) (i:Z), (in_range bv i) -> (0%Z <= ((getbv bv) i))%Z.

Axiom binary_bv1 :
  forall (bv:bitvec) (i:Z), (in_range bv i) -> (((getbv bv) i) <= 1%Z)%Z.

Axiom equal_bv :
  forall (m:bitvec) (n:bitvec), (m = n) -> ((length m) = (length n)).

Axiom equal_bv1 :
  forall (m:bitvec) (n:bitvec), (m = n) -> forall (i:Z), (in_range m i) ->
  (((getbv m) i) = ((getbv n) i)).

Axiom equal_bv2 :
  forall (m:bitvec) (n:bitvec),
  (((length m) = (length n)) /\
   forall (i:Z), (in_range m i) -> (((getbv m) i) = ((getbv n) i))) ->
  (m = n).

Axiom set_equal_bv :
  forall (bv:bitvec) (bv':bitvec), ((length bv) = (length bv')) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
   (((getbv bv) i) = ((getbv bv') i))) ->
  (bv = bv').

Axiom get_equal_bv :
  forall (bv:bitvec) (bv':bitvec), (bv = bv') -> ((length bv) = (length bv')).

Axiom get_equal_bv1 :
  forall (bv:bitvec) (bv':bitvec), (bv = bv') -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv))%Z) -> (((getbv bv) i) = ((getbv bv') i)).

Parameter make_bv: (Z -> Z) -> Z -> bitvec.

Axiom make_bv_spec :
  forall (f:Z -> Z) (s:Z),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (s >= 0%Z)%Z -> ((length (make_bv f s)) = s).

Axiom make_bv_spec1 :
  forall (f:Z -> Z) (s:Z),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (s >= 0%Z)%Z -> forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
  (((getbv (make_bv f s)) i) = (f i)).

Axiom make_bv_spec2 :
  forall (f:Z -> Z) (s:Z),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (s >= 0%Z)%Z -> forall (i:Z), ~ (0%Z <= i)%Z ->
  (((getbv (make_bv f s)) i) = 0%Z).

Axiom make_bv_spec3 :
  forall (f:Z -> Z) (s:Z),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (s >= 0%Z)%Z -> forall (i:Z), ~ (i < s)%Z ->
  (((getbv (make_bv f s)) i) = 0%Z).

Parameter make_bv_m: (Z -> Z) -> Z -> bitvec.

Axiom make_bv_m_def :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z ->
  ((make_bv_m f s) =
   (make_bv (fun (k:Z) => (int.EuclideanDivision.mod1 (f k) 2%Z)) s)).

Axiom make_bv_m_spec :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> ((length (make_bv_m f s)) = s).

Axiom make_bv_m_spec1 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> forall (i:Z),
  bvlength (getbv (make_bv_m f s)) i.

Axiom make_bv_m_spec2 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < s)%Z) ->
  (((getbv (make_bv_m f s)) k) = (int.EuclideanDivision.mod1 (f k) 2%Z)).

Axiom make_bv_m_spec3 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> forall (k:Z), ~ (0%Z <= k)%Z ->
  (((getbv (make_bv_m f s)) k) = 0%Z).

Axiom make_bv_m_spec4 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> forall (k:Z), ~ (k < s)%Z ->
  (((getbv (make_bv_m f s)) k) = 0%Z).

Parameter bitvec_null: bitvec.

Axiom bitvec_null_def : (bitvec_null = (make_bv (fun (i:Z) => 0%Z) 0%Z)).

Axiom assert_make_bv_no_bound :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  ((1%Z <= i)%Z /\ (i <= s)%Z) -> (((getbv (make_bv f 0%Z)) i) = 0%Z).

Axiom make_bv_length :
  forall (f:Z -> Z) (s:Z),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (s >= 0%Z)%Z -> ((length (make_bv f s)) = s).

Axiom assert_make_bv :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z ->
  (((0%Z <= i)%Z /\ (i < s)%Z) -> (((getbv (make_bv f s)) i) = (f i))) /\
  (~ ((0%Z <= i)%Z /\ (i < s)%Z) -> (((getbv (make_bv f s)) i) = 0%Z)).

Axiom assert_make_m :
  forall (f:Z -> Z) (s:Z) (i:Z), (s >= 0%Z)%Z ->
  (((0%Z <= i)%Z /\ (i < s)%Z) ->
   (((getbv (make_bv_m f s)) i) = (int.EuclideanDivision.mod1 (f i) 2%Z))) /\
  (~ ((0%Z <= i)%Z /\ (i < s)%Z) -> (((getbv (make_bv_m f s)) i) = 0%Z)).

Axiom make_bv_eq :
  forall (f:Z -> Z) (f':Z -> Z) (n:Z) (n':Z), (n >= 0%Z)%Z -> (n = n') ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ((f i) = (f' i))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  ((make_bv f n) = (make_bv f' n')).

Axiom assert_make_bv_b :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  ((0%Z <= i)%Z /\ (i < s)%Z) -> (((getbv (make_bv f s)) i) = (f i)).

Axiom assert_make_m_b :
  forall (f:Z -> Z) (s:Z) (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
  (s >= 0%Z)%Z ->
  (((getbv (make_bv_m f s)) i) = (int.EuclideanDivision.mod1 (f i) 2%Z)).

Axiom make_m_bv_length :
  forall (f:Z -> Z) (s:Z) (i:Z), (s >= 0%Z)%Z ->
  bvlength (getbv (make_bv_m f s)) i.

Axiom make_m_length :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> ((length (make_bv_m f s)) = s).

Axiom set_equal_bv_make :
  forall (f:Z -> Z) (g:Z -> Z) (s:Z),
  (forall (i:Z), (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) -> (s >= 0%Z)%Z ->
  (forall (i:Z), ((f i) = (g i))) -> ((make_bv f s) = (make_bv g s)).

Axiom set_equal_bv_m_make :
  forall (f:Z -> Z) (g:Z -> Z) (s:Z), (s >= 0%Z)%Z ->
  (forall (i:Z),
   ((int.EuclideanDivision.mod1 (f i) 2%Z) =
    (int.EuclideanDivision.mod1 (g i) 2%Z))) ->
  ((make_bv_m f s) = (make_bv_m g s)).

Axiom make_bv_itself :
  forall (x:bitvec) (n:Z), ((length x) = n) ->
  ((make_bv (fun (i:Z) => ((getbv x) i)) n) = x).

Parameter head: bitvec -> Z.

Axiom head_def :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  ((head bv) = ((getbv bv) 0%Z)).

Axiom head_spec :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z -> (0%Z <= (head bv))%Z.

Axiom head_spec1 :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z -> ((head bv) <= 1%Z)%Z.

Parameter makes_bv: (Z -> Z) -> Z -> bitvec.

Parameter result9: (Z -> Z) -> Z -> Z.

Axiom result_def9 :
  forall (f:Z -> Z) (i:Z),
  (((0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) -> (((result9 f) i) = (f i))) /\
  (~ ((0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) -> (((result9 f) i) = 0%Z)).

Axiom makes_bv_def :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z ->
  ((makes_bv f s) = (make_bv (result9 f) s)).

Axiom makes_bv_spec :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> ((length (makes_bv f s)) = s).

Axiom makes_bv_spec1 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < s)%Z) -> ((0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (((getbv (makes_bv f s)) i) = (f i)).

Axiom makes_bv_spec2 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  ((makes_bv f s) = (make_bv f s)).

Axiom makes_bv_spec3 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> forall (i:Z), ~ (0%Z <= i)%Z ->
  (((getbv (makes_bv f s)) i) = 0%Z).

Axiom makes_bv_spec4 :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> forall (i:Z), ~ (i < s)%Z ->
  (((getbv (makes_bv f s)) i) = 0%Z).

Axiom assert_makes_bv_c :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z ->
  (((0%Z <= i)%Z /\ (i < s)%Z) -> (((getbv (makes_bv f s)) i) = (f i))) /\
  (~ ((0%Z <= i)%Z /\ (i < s)%Z) -> (((getbv (makes_bv f s)) i) = 0%Z)).

Axiom assert_makes_bv_b :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z -> ((0%Z <= i)%Z /\ (i < s)%Z) ->
  (((getbv (makes_bv f s)) i) = (f i)).

Axiom assert_makes_bv :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z ->
  ((((0%Z <= i)%Z /\ (i < s)%Z) /\ (0%Z <= (f i))%Z) ->
   (((getbv (makes_bv f s)) i) = (f i))) /\
  (~ (((0%Z <= i)%Z /\ (i < s)%Z) /\ (0%Z <= (f i))%Z) ->
   (((getbv (makes_bv f s)) i) = 0%Z)).

Axiom makes_bv_length :
  forall (f:Z -> Z) (s:Z), (s >= 0%Z)%Z -> ((length (makes_bv f s)) = s).

Parameter tail: bitvec -> bitvec.

Axiom tail_def :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  ((tail bv) =
   (make_bv (fun (i:Z) => ((getbv bv) (i + 1%Z)%Z)) ((length bv) - 1%Z)%Z)).

Axiom tail_spec :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  ((length (tail bv)) = ((length bv) - 1%Z)%Z).

Axiom tail_spec1 :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z -> forall (i:Z),
  (in_range (tail bv) i) ->
  (((getbv (tail bv)) i) = ((getbv bv) (i + 1%Z)%Z)).

Parameter concat_l: bitvec -> Z -> bitvec.

Parameter result10: bitvec -> Z -> Z -> Z.

Axiom result_def10 :
  forall (bv:bitvec) (i:Z) (k:Z),
  ((k = 0%Z) -> (((result10 bv i) k) = i)) /\
  (~ (k = 0%Z) -> (((result10 bv i) k) = ((getbv bv) (k - 1%Z)%Z))).

Axiom concat_l_def :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((concat_l bv i) = (make_bv (result10 bv i) ((length bv) + 1%Z)%Z)).

Axiom concat_l_spec :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((length (concat_l bv i)) = ((length bv) + 1%Z)%Z).

Axiom concat_l_spec1 :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  (((getbv (concat_l bv i)) 0%Z) = i).

Axiom concat_l_spec2 :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) -> forall (j:Z),
  (in_range bv j) -> (((getbv (concat_l bv i)) (j + 1%Z)%Z) = ((getbv bv) j)).

Axiom concat_l_value :
  forall (bv:bitvec) (i:Z) (k:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((k = 0%Z) -> (((getbv (concat_l bv i)) k) = i)) /\
  (~ (k = 0%Z) ->
   (((0%Z < k)%Z /\ (k <= ((length bv) + 1%Z)%Z)%Z) ->
    (((getbv (concat_l bv i)) k) = ((getbv bv) (k - 1%Z)%Z))) /\
   (~ ((0%Z < k)%Z /\ (k <= ((length bv) + 1%Z)%Z)%Z) ->
    (((getbv (concat_l bv i)) k) = 0%Z))).

Axiom concat_l_value_b :
  forall (bv:bitvec) (i:Z) (k:Z),
  ((0%Z <= k)%Z /\ (k < ((length bv) + 1%Z)%Z)%Z) ->
  ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((k = 0%Z) -> (((getbv (concat_l bv i)) k) = i)) /\
  (~ (k = 0%Z) -> (((getbv (concat_l bv i)) k) = ((getbv bv) (k - 1%Z)%Z))).

Axiom concat_ht :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  (bv = (concat_l (tail bv) (head bv))).

Axiom concat_ht_union :
  forall (bv:bitvec), ((length bv) >= 2%Z)%Z ->
  ~ (bv = (concat_l (tail bv) 0%Z)) -> (bv = (concat_l (tail bv) 1%Z)).

Parameter bv_to_int: bitvec -> Z.

Parameter result11: bitvec -> Z -> Z.

Axiom result_def11 :
  forall (bv:bitvec) (k:Z),
  ((in_range bv k) ->
   (((result11 bv) k) =
    (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)) /\
  (~ (in_range bv k) -> (((result11 bv) k) = 1%Z)).

Axiom bv_to_int_def :
  forall (bv:bitvec),
  ((bv_to_int bv) = (ind_isum (result11 bv) 0%Z (length bv))).

Axiom bv_to_int_spec :
  forall (bv:bitvec),
  ((bv_to_int bv) =
   (ind_isum
    (fun (k:Z) =>
     (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))).

Axiom bv_to_int_spec1 : forall (bv:bitvec), (0%Z <= (bv_to_int bv))%Z.

Axiom bv_to_int_eq :
  forall (bv1:bitvec) (bv2:bitvec), (bv1 = bv2) ->
  ((bv_to_int bv1) = (bv_to_int bv2)).

Axiom bv_to_int_sum :
  forall (bv:bitvec),
  ((bv_to_int bv) =
   (ind_isum
    (fun (k:Z) =>
     (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))).

Axiom bv_to_int_sum_opp :
  forall (bv:bitvec),
  ((-(bv_to_int bv))%Z =
   (ind_isum
    (fun (k:Z) =>
     ((-((getbv bv) k))%Z * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))).

Axiom bv_to_int_onebit :
  forall (bv:bitvec), ((length bv) = 1%Z) ->
  ((bv_to_int bv) = ((getbv bv) 0%Z)).

Axiom ind_isum_bv_rev :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    i (length bv))
   =
   (ind_isum
    (fun (l:Z) =>
     (((getbv bv) (((length bv) - 1%Z)%Z - l)%Z) * (power 2%Z l))%Z)
    0%Z ((length bv) - i)%Z)).

Axiom ind_isum_bin_rev :
  forall (f:Z -> Z) (n:Z) (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (binary f) ->
  ((ind_isum (fun (l:Z) => ((f l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z) i n)
   =
   (ind_isum (fun (l:Z) => ((f ((n - 1%Z)%Z - l)%Z) * (power 2%Z l))%Z) 0%Z
    (n - i)%Z)).

Axiom ind_isum_bin_rev_z :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  ((ind_isum (fun (l:Z) => ((f l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z) 0%Z
    n)
   =
   (ind_isum (fun (l:Z) => ((f ((n - 1%Z)%Z - l)%Z) * (power 2%Z l))%Z) 0%Z
    n)).

Axiom bv_to_int_sum_rev :
  forall (bv:bitvec),
  ((ind_isum
    (fun (k:Z) =>
     (((getbv bv) (((length bv) - 1%Z)%Z - k)%Z) * (power 2%Z k))%Z)
    0%Z (length bv))
   = (bv_to_int bv)).

Axiom ind_isum_bv_bound_growing :
  forall (bv:bitvec) (i:Z), ((0%Z < i)%Z /\ (i < (length bv))%Z) ->
  ((ind_isum (fun (l:Z) => (((getbv bv) l) * (power 2%Z l))%Z) 0%Z i) <
   (power 2%Z i))%Z.

Axiom ind_isum_bv_bound :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    i (length bv))
   < (power 2%Z ((length bv) - i)%Z))%Z.

Axiom ind_isum_bin_bound :
  forall (f:Z -> Z) (n:Z) (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (binary f) ->
  ((ind_isum (fun (l:Z) => ((f l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z) i n)
   < (power 2%Z (n - i)%Z))%Z.

Axiom bv_to_int_bound :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  ((bv_to_int bv) < (power 2%Z (length bv)))%Z.

Axiom multiple_control_as_ang_sum :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  ((forall (j:Z), ((0%Z <= j)%Z /\ (j < n)%Z) -> (((getbv x) j) = 1%Z)) ->
   (ang_minus_one =
    (ang_mult_int ang_minus_one (ind_iproduct (getbv x) 0%Z n)))) /\
  (~ (forall (j:Z), ((0%Z <= j)%Z /\ (j < n)%Z) -> (((getbv x) j) = 1%Z)) ->
   (ang_zero = (ang_mult_int ang_minus_one (ind_iproduct (getbv x) 0%Z n)))).

Axiom multiple_control_as_ang_sum_rev :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  ((forall (j:Z), ((0%Z <= j)%Z /\ (j < n)%Z) -> (((getbv x) j) = 1%Z)) ->
   ((ang_mult_int ang_minus_one (ind_iproduct (getbv x) 0%Z n)) =
    ang_minus_one)) /\
  (~ (forall (j:Z), ((0%Z <= j)%Z /\ (j < n)%Z) -> (((getbv x) j) = 1%Z)) ->
   ((ang_mult_int ang_minus_one (ind_iproduct (getbv x) 0%Z n)) = ang_zero)).

Axiom ang_sum_map :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> angle), (i < j)%Z ->
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ang_sum t1 k l) = (ang_sum (fun (b:Z) => (t1 (f b))) i j)).

Axiom ang_sum_break :
  forall (f:Z -> angle) (i:Z) (j:Z) (y:Z), ((i <= y)%Z /\ (y <= j)%Z) ->
  ((ang_sum f i j) = (ang_add (ang_sum f i y) (ang_sum f y j))).

Axiom ang_sum_break_zero_l :
  forall (f:Z -> angle) (i:Z) (j:Z) (y:Z), ((i <= y)%Z /\ (y <= j)%Z) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < y)%Z) -> ((f k) = ang_zero)) ->
  ((ang_sum f y j) = (ang_sum f i j)).

Axiom ang_sum_break_zero_lg :
  forall (f:Z -> angle) (g:Z -> angle) (i:Z) (j:Z) (y:Z),
  ((i <= y)%Z /\ (y <= j)%Z) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < y)%Z) -> ((f k) = ang_zero)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ang_sum f y j) = (ang_sum g i j)).

Axiom ang_sum_break_zero_lg_params :
  forall (f:bitvec -> bitvec -> Z -> Z -> angle)
    (g:bitvec -> bitvec -> Z -> Z -> angle) (i:Z) (j:Z) (s:Z) (r:Z),
  (s >= 0%Z)%Z -> (r >= 0%Z)%Z ->
  (forall (x:bitvec) (z:bitvec), forall (a:Z) (k:Z), ((length x) = s) ->
   ((length z) = r) -> ((i <= a)%Z /\ (a < j)%Z) ->
   ((i <= k)%Z /\ (k < a)%Z) -> (((((g x) z) a) k) = ang_zero)) ->
  (forall (x:bitvec) (z:bitvec), forall (a:Z) (k:Z), ((length x) = s) ->
   ((length z) = r) -> ((i <= a)%Z /\ (a < j)%Z) ->
   ((a <= k)%Z /\ (k < j)%Z) -> (((((f x) z) a) k) = ((((g x) z) a) k))) ->
  forall (x:bitvec) (z:bitvec), forall (a:Z), ((length x) = s) ->
  ((length z) = r) -> ((i <= a)%Z /\ (a < j)%Z) ->
  ((ang_sum (fun (k:Z) => ((((f x) z) a) k)) a j) =
   (ang_sum (fun (k:Z) => ((((g x) z) a) k)) i j)).

Axiom ang_sum_break_zero_l_params :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a -> Z -> angle) (g:a -> a -> Z -> angle) (i:Z) (j:Z) (l:Z),
  ((i <= l)%Z /\ (l <= j)%Z) -> forall (x:a) (y:a),
  (forall (k:Z), ((i <= k)%Z /\ (k < l)%Z) -> ((((f x) y) k) = ang_zero)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) ->
   ((((f x) y) k) = (((g x) y) k))) ->
  ((ang_sum ((g x) y) i j) = (ang_sum ((f x) y) l j)).

Axiom ang_sum_break_param :
  forall (f:Z -> Z -> angle) (i:Z) (j:Z), (i < j)%Z -> forall (y:Z),
  ((i <= y)%Z /\ (y < j)%Z) ->
  ((ang_sum (f y) i j) = (ang_add (ang_sum (f y) i y) (ang_sum (f y) y j))).

Axiom ang_sum_neutral_param_r :
  forall (f:Z -> Z -> angle) (i:Z) (j:Z), (i < j)%Z -> forall (y:Z),
  ((i <= y)%Z /\ (y < j)%Z) ->
  (forall (k:Z), ((y <= k)%Z /\ (k < j)%Z) -> (((f y) k) = ang_zero)) ->
  ((ang_sum (f y) y j) = ang_zero).

Axiom ang_sum_neutral_param_l :
  forall (f:Z -> Z -> angle) (i:Z) (j:Z), (i < j)%Z -> forall (y:Z),
  ((i <= y)%Z /\ (y < j)%Z) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < y)%Z) -> (((f y) k) = ang_zero)) ->
  ((ang_sum (f y) i y) = ang_zero).

Axiom ang_sum_transl :
  forall (f:Z -> angle) (i:Z) (j:Z) (k:Z), (i < j)%Z ->
  ((ang_sum f i j) =
   (ang_sum (fun (b:Z) => (f (b + k)%Z)) (i - k)%Z (j - k)%Z)).

Axiom ang_sum_transl_one :
  forall (f:Z -> angle) (i:Z) (j:Z), (i < j)%Z ->
  ((ang_sum f i j) =
   (ang_sum (fun (b:Z) => (f (b - 1%Z)%Z)) (i + 1%Z)%Z (j + 1%Z)%Z)).

Axiom ang_exp_eq :
  forall (o:angle) (o':angle), (o = o') -> ((ang_exp o) = (ang_exp o')).

Axiom ang_sum_to_ind_isum :
  forall (f:Z -> Z) (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (i < j)%Z ->
  ((ang_sum (fun (k:Z) => (int_to_ang (f k) n)) i j) =
   (int_to_ang (ind_isum f i j) n)).

Axiom ind_isum_to_d_sum :
  forall (f:Z -> Z) (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (i < j)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_sum (fun (k:Z) => (int_to_ang (f k) n)) i j)).

Axiom ind_isum_mod_div :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((int.EuclideanDivision.mod1
    (ind_isum
     (fun (k:Z) =>
      (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
     0%Z (length bv))
    (power 2%Z ((length bv) - i)%Z))
   =
   (ind_isum
    (fun (k:Z) =>
     (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    i (length bv))).

Axiom ind_isum_mod_div1 :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((int.EuclideanDivision.div
    (ind_isum
     (fun (k:Z) =>
      (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
     0%Z (length bv))
    (power 2%Z ((length bv) - i)%Z))
   =
   (ind_isum
    (fun (k:Z) => (((getbv bv) k) * (power 2%Z ((i - 1%Z)%Z - k)%Z))%Z) 0%Z
    i)).

Axiom mod_ind_isum :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power 2%Z i))
   =
   (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z)
    (l - i)%Z l)).

Axiom mod_ind_isum_z :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power 2%Z i))
   =
   (ind_isum
    (fun (k:Z) =>
     ((f ((k + l)%Z - i)%Z) * (power 2%Z ((i - 1%Z)%Z - k)%Z))%Z)
    0%Z i)).

Axiom div_ind_isum :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.div
    (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power 2%Z i))
   =
   (ind_isum
    (fun (k:Z) => ((f k) * (power 2%Z (((l - 1%Z)%Z - k)%Z - i)%Z))%Z) 0%Z
    (l - i)%Z)).

Axiom ind_isum_mod :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (l:Z) => (((getbv bv) l) * (power 2%Z (i - l)%Z))%Z) 0%Z
     (i + 1%Z)%Z)
    2%Z)
   = ((getbv bv) i)).

Axiom bv_to_int_kth_pre :
  forall (bv:bitvec) (k:Z),
  ((0%Z <= k)%Z /\ (k < ((length bv) - 1%Z)%Z)%Z) ->
  (((getbv bv) k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div
     (ind_isum
      (fun (l:Z) =>
       (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
      0%Z (length bv))
     (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))
    2%Z)).

Axiom bv_to_int_kth_pre1 :
  forall (bv:bitvec) (k:Z),
  ((0%Z <= k)%Z /\ (k < ((length bv) - 1%Z)%Z)%Z) ->
  (((getbv bv) k) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1
     (ind_isum
      (fun (l:Z) =>
       (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
      0%Z (length bv))
     (power 2%Z ((length bv) - k)%Z))
    (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))).

Parameter int_to_bv: Z -> Z -> bitvec.

Parameter result12: Z -> Z -> Z -> Z.

Axiom result_def12 :
  forall (i:Z) (n:Z) (k:Z),
  (((0%Z <= k)%Z /\ (k < n)%Z) ->
   (((result12 i n) k) =
    (int.EuclideanDivision.div
     (int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z))
     (power 2%Z ((n - k)%Z - 1%Z)%Z)))) /\
  (~ ((0%Z <= k)%Z /\ (k < n)%Z) -> (((result12 i n) k) = 0%Z)).

Axiom int_to_bv_def :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((int_to_bv i n) = (make_bv (result12 i n) n)).

Axiom int_to_bv_spec :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z -> ((length (int_to_bv i n)) = n).

Axiom int_to_bv_spec1 :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((int_to_bv i n) =
   (make_bv
    (fun (k:Z) =>
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z))
      (power 2%Z ((n - k)%Z - 1%Z)%Z)))
    n)).

Axiom int_to_bv_sum_pre :
  forall (i:Z) (n:Z) (k:Z), ((n >= k)%Z /\ (k >= 0%Z)%Z) ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((getbv (int_to_bv i n)) l) * (power 2%Z ((n - l)%Z - 1%Z)%Z))%Z)
    (n - k)%Z n)).

Axiom int_to_bv_sum :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (i =
   (ind_isum
    (fun (k:Z) =>
     (((getbv (int_to_bv i n)) k) * (power 2%Z ((n - 1%Z)%Z - k)%Z))%Z)
    0%Z n)).

Axiom int_to_bv_sum_rev :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((ind_isum
    (fun (k:Z) =>
     (((getbv (int_to_bv i n)) k) * (power_ 2%Z ((n - k)%Z - 1%Z)%Z))%Z)
    0%Z n)
   = i).

Axiom product_int_to_bv_inv :
  forall (n:Z) (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((i = 0%Z) ->
   ((ind_iproduct (fun (j:Z) => (1%Z - ((getbv (int_to_bv i n)) j))%Z) 0%Z n)
    = 1%Z)) /\
  (~ (i = 0%Z) ->
   ((ind_iproduct (fun (j:Z) => (1%Z - ((getbv (int_to_bv i n)) j))%Z) 0%Z n)
    = 0%Z)).

Axiom int_to_bv_mod_div :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_bv i n) =
   (make_bv
    (fun (k:Z) =>
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.div i (power 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z))
    n)).

Axiom mod_isum :
  forall (i:Z) (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((getbv (int_to_bv i n)) l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z)
    (n - k)%Z n)).

Axiom mod_isum_z :
  forall (i:Z) (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((getbv (int_to_bv i n)) (l + (n - k)%Z)%Z) *
      (power 2%Z ((k - l)%Z - 1%Z)%Z))%Z)
    0%Z k)).

Axiom div_isum :
  forall (i:Z) (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.div i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((getbv (int_to_bv i n)) l) *
      (power 2%Z (((n - 1%Z)%Z - k)%Z - l)%Z))%Z)
    0%Z (n - k)%Z)).

Axiom int_to_bv_div_mod :
  forall (i:Z) (k:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int_to_bv i n) =
   (make_bv
    (fun (k1:Z) =>
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i (power 2%Z (n - k1)%Z))
      (power 2%Z ((n - k1)%Z - 1%Z)%Z)))
    n)).

Axiom int_to_bv_value :
  forall (i:Z) (n:Z) (k:Z), (n > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (((getbv (int_to_bv i n)) k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z)).

Axiom int_to_bv_value_zero :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((i < (power 2%Z (n - 1%Z)%Z))%Z -> (((getbv (int_to_bv i n)) 0%Z) = 0%Z)) /\
  (~ (i < (power 2%Z (n - 1%Z)%Z))%Z ->
   (((getbv (int_to_bv i n)) 0%Z) = 1%Z)).

Axiom int_to_bv_zero :
  forall (n:Z), forall (k:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (((getbv (int_to_bv 0%Z n)) k) = 0%Z).

Axiom int_to_sum :
  forall (i:Z) (n:Z), (n > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (i =
   (ind_isum
    (fun (k:Z) =>
     (((getbv (int_to_bv i n)) k) * (power 2%Z ((n - k)%Z - 1%Z)%Z))%Z)
    0%Z n)).

Axiom int_to_bv_transl :
  forall (i:Z) (k:Z) (n:Z) (t1:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= k)%Z /\ (k < (n - t1)%Z)%Z) -> ((0%Z < t1)%Z /\ (t1 <= n)%Z) ->
  (((getbv
     (int_to_bv (int.EuclideanDivision.mod1 i (power 2%Z (n - t1)%Z))
      (n - t1)%Z))
    k)
   = ((getbv (int_to_bv i n)) (k + t1)%Z)).

Parameter bin_to_int: (Z -> Z) -> Z -> Z.

Axiom bin_to_int_def :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  ((bin_to_int f n) = (bv_to_int (make_bv f n))).

Axiom bin_to_int_spec :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  ((bin_to_int f n) =
   (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((n - 1%Z)%Z - k)%Z))%Z) 0%Z
    n)).

Axiom bin_to_int_spec1 :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  (0%Z <= (bin_to_int f n))%Z.

Parameter int_to_bin: Z -> Z -> Z -> Z.

Axiom int_to_bin_def :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_bin i n) = (getbv (int_to_bv i n))).

Axiom int_to_bin_spec :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (i =
   (ind_isum
    (fun (k:Z) => (((int_to_bin i n) k) * (power 2%Z ((n - 1%Z)%Z - k)%Z))%Z)
    0%Z n)).

Axiom int_to_bin_spec1 :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> binary (int_to_bin i n).

Axiom int_to_bin_spec2 :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (((int_to_bin i n) k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z)).

Axiom int_to_bv_tail :
  forall (i:Z) (n:Z), (n > 1%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_bv (tail_bits i n) (n - 1%Z)%Z) = (tail (int_to_bv i n))).

Axiom bound_sum_dec :
  forall (bv:bitvec) (i:Z), ((1%Z <= i)%Z /\ (i <= (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) => (((getbv bv) l) * (power 2%Z ((length bv) - l)%Z))%Z) i
    ((length bv) + 1%Z)%Z)
   < (power 2%Z (((length bv) - i)%Z + 1%Z)%Z))%Z.

Axiom bv_to_int_to_bv :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((bv_to_int (int_to_bv i n)) = i).

Axiom tail_bits_sum :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((tail_bits i n) =
   (ind_isum
    (fun (l:Z) =>
     (((getbv (int_to_bv i n)) l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z)
    1%Z n)).

Axiom int_to_bv_to_int :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  ((int_to_bv (bv_to_int bv) (length bv)) = bv).

Axiom concat_to_int :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((bv_to_int (concat_l bv i)) =
   ((bv_to_int bv) + (i * (power 2%Z (length bv)))%Z)%Z).

Axiom bounded_to_int :
  forall (bv:bitvec), ((bv_to_int bv) < (power 2%Z (length bv)))%Z.

Axiom int_to_bv_to_int_value :
  forall (bv:bitvec) (i:Z), (1%Z <= (length bv))%Z ->
  (((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
   (((getbv (int_to_bv (bv_to_int bv) (length bv))) i) = ((getbv bv) i))) /\
  (~ ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
   (((getbv (int_to_bv (bv_to_int bv) (length bv))) i) = 0%Z)).

Axiom int_to_bv_to_int_gen :
  forall (bv:bitvec) (n:Z), (1%Z <= (length bv))%Z -> (n = (length bv)) ->
  ((int_to_bv (bv_to_int bv) n) = bv).

Axiom bv_to_int_mod :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  ((int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - k)%Z))
   =
   (ind_isum
    (fun (l:Z) =>
     (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    k (length bv))).

Axiom bv_to_int_mod_rev :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    k (length bv))
   =
   (int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - k)%Z))).

Axiom bv_to_int_mod_gen :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) -> forall (bv:bitvec),
  ((length bv) = n) ->
  ((int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - k)%Z))
   =
   (ind_isum
    (fun (l:Z) =>
     (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    k (length bv))).

Axiom to_int_head_tail :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  ((bv_to_int bv) =
   ((bv_to_int (tail bv)) +
    ((head bv) * (power 2%Z ((length bv) - 1%Z)%Z))%Z)%Z).

Axiom to_int_head_tail1 :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  ((bv_to_int (tail bv)) =
   (int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - 1%Z)%Z))).

Axiom not_disj :
  forall (a:bool) (b:bool), ~ (a = true) -> ~ (b = true) -> ~ (a = true).

Axiom not_disj1 : True.

Parameter my_map:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> set b.

Axiom my_map_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((cardinal u) = 0%Z) ->
  ((my_map f u) = (empty : set b)).

Axiom my_map_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ~ ((cardinal u) = 0%Z) ->
  ((my_map f u) = (add (f (choose u)) (my_map f (remove (choose u) u)))).

Axiom my_map_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((my_map f u) = (map f u)).

Axiom my_map_to_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((my_map f u) = (map f u)).

Axiom map_to_my_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((map f u) = (my_map f u)).

Parameter n_bvs: Z -> set bitvec.

Axiom n_bvs_def :
  forall (n:Z), (0%Z <= n)%Z -> (n = 0%Z) ->
  ((n_bvs n) = (to_set (make_bv (fun (i:Z) => 0%Z) 0%Z))).

Axiom n_bvs_def1 :
  forall (n:Z), (0%Z <= n)%Z -> ~ (n = 0%Z) ->
  ((n_bvs n) =
   (union (my_map (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs (n - 1%Z)%Z))
    (my_map (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs (n - 1%Z)%Z)))).

Axiom n_bvs_spec :
  forall (n:Z), (0%Z <= n)%Z -> forall (f:bitvec), (mem f (n_bvs n)) ->
  ((length f) = n).

Axiom n_bvs_spec1 :
  forall (n:Z), (0%Z <= n)%Z -> forall (f:bitvec), (mem f (n_bvs n)) ->
  ((length f) = n).

Axiom n_bvs_spec2 :
  forall (n:Z), (0%Z <= n)%Z -> forall (f:bitvec), ((length f) = n) ->
  mem f (n_bvs n).

Axiom n_bvs_spec3 :
  forall (n:Z), (0%Z <= n)%Z -> ((cardinal (n_bvs n)) > 0%Z)%Z.

Axiom n_bvs_node :
  forall (n:Z), (0%Z < n)%Z ->
  ((inter (map (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs (n - 1%Z)%Z))
    (map (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs (n - 1%Z)%Z)))
   = (empty : set bitvec)).

Axiom n_bvs_node1 :
  forall (n:Z), (0%Z < n)%Z ->
  ((union (map (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs (n - 1%Z)%Z))
    (map (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs (n - 1%Z)%Z)))
   = (n_bvs n)).

Axiom injective_node :
  forall (n:Z), (0%Z <= n)%Z ->
  p_injective (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs n).

Axiom injective_node1 :
  forall (n:Z), (0%Z <= n)%Z ->
  p_injective (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs n).

Axiom mat_sum_n_bvs_pos :
  forall (n:Z) (f:bitvec -> matrix t), (0%Z < n)%Z ->
  (constant_size (n_bvs n) f) ->
  ((mat_sum (n_bvs n) f) =
   (add_mat
    (mat_sum (n_bvs (n - 1%Z)%Z) (fun (bv:bitvec) => (f (concat_l bv 0%Z))))
    (mat_sum (n_bvs (n - 1%Z)%Z) (fun (bv:bitvec) => (f (concat_l bv 1%Z)))))).

Axiom mat_sum_n_bvs_null :
  forall (f:bitvec -> matrix t),
  ((mat_sum (n_bvs 0%Z) f) =
   (f (make_bv ((fun (y0:Z) (y1:Z) => (const y0 y1)) 0%Z) 0%Z))).

Axiom mat_sum_n_bvs_null_eq :
  forall (f:bitvec -> matrix t) (x:matrix t),
  (x = (f (make_bv ((fun (y0:Z) (y1:Z) => (const y0 y1)) 0%Z) 0%Z))) ->
  ((mat_sum (n_bvs 0%Z) f) = x).

Axiom get_n_bvs : forall (bv:bitvec), mem bv (n_bvs (length bv)).

Axiom get_n_bvs_gen :
  forall (bv:bitvec) (l:Z), (l = (length bv)) -> mem bv (n_bvs l).

Axiom set_n_bvs :
  forall (bv:bitvec), (mem bv (n_bvs (length bv))) -> forall (i:Z),
  ~ (0%Z <= i)%Z -> (((getbv bv) i) = 0%Z).

Axiom set_n_bvs1 :
  forall (bv:bitvec), (mem bv (n_bvs (length bv))) -> forall (i:Z),
  ~ (i < (length bv))%Z -> (((getbv bv) i) = 0%Z).

Axiom int_to_bv_n_bvs :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> mem (int_to_bv i n) (n_bvs n).

Axiom n_bvs_def_pos :
  forall (n:Z), (0%Z < n)%Z ->
  ((n_bvs n) =
   (union (map (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs (n - 1%Z)%Z))
    (map (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs (n - 1%Z)%Z)))).

Axiom map_n_bvs :
  forall (n:Z), (0%Z < n)%Z ->
  ((to_fset 0%Z (power 2%Z n)) =
   (map (fun (y0:bitvec) => (bv_to_int y0)) (n_bvs n))).

Parameter first_div: bitvec -> bitvec -> Z.

Axiom first_div_spec :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) -> forall (j:Z),
  ((0%Z <= j)%Z /\ (j < (first_div bv1 bv2))%Z) ->
  (((getbv bv1) j) = ((getbv bv2) j)).

Axiom first_div_spec1 :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) -> ((first_div bv1 bv2) < (length bv1))%Z ->
  ~ (((getbv bv1) (first_div bv1 bv2)) = ((getbv bv2) (first_div bv1 bv2))).

Axiom first_div_spec2 :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) -> (0%Z <= (first_div bv1 bv2))%Z.

Axiom first_div_spec3 :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) -> ((first_div bv1 bv2) < (length bv1))%Z.

Axiom injective_concat :
  forall (i:Z) (n:Z), (0%Z <= n)%Z -> ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  p_injective (fun (bv:bitvec) => (concat_l bv i)) (n_bvs n).

Axiom inf_first_div :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) -> forall (j:Z), (1%Z <= j)%Z ->
  ~ (((getbv bv1) j) = ((getbv bv2) j)) -> ((first_div bv1 bv2) <= j)%Z.

Axiom first_div_diff :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) ->
  ~ (((getbv bv1) (first_div bv1 bv2)) = ((getbv bv2) (first_div bv1 bv2))).

Axiom exists_first_div :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) ->
  exists i:Z,
  ((0%Z <= i)%Z /\ (i < (length bv1))%Z) /\ (i = (first_div bv1 bv2)).

Axiom set_diff_length :
  forall (bv1:bitvec) (bv2:bitvec), ~ ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2).

Axiom set_diff_val :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z), ((length bv1) = (length bv2)) ->
  ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
  ~ (((getbv bv1) i) = ((getbv bv2) i)) -> ~ (bv1 = bv2).

Parameter fc6: bitvec -> Z -> Z.

Parameter fc7: bitvec -> Z -> Z.

Axiom fc_def6 :
  forall (bv:bitvec) (l:Z),
  ((l < (length bv))%Z ->
   (((fc6 bv) l) =
    (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)) /\
  (~ (l < (length bv))%Z -> (((fc6 bv) l) = 0%Z)).

Axiom fc_def7 :
  forall (bv:bitvec) (l:Z),
  ((l < (length bv))%Z ->
   (((fc7 bv) l) =
    (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)) /\
  (~ (l < (length bv))%Z -> (((fc7 bv) l) = 0%Z)).

Axiom kth_decomp :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  ((bv_to_int bv) =
   (((ind_isum (fc6 bv) 0%Z k) +
     (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)%Z
    + (ind_isum (fc7 bv) (k + 1%Z)%Z (length bv)))%Z).

Axiom kth_decomp1 :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  ((bv_to_int bv) =
   (((ind_isum
      (fun (l:Z) =>
       (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
      0%Z k)
     + (((getbv bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)%Z
    +
    (ind_isum
     (fun (l:Z) =>
      (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
     (k + 1%Z)%Z (length bv)))%Z).

Axiom int_to_bv_prod :
  forall (i:Z) (j:Z) (n:Z), (n > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((ind_product
    (fun (k:Z) =>
     (indic ((getbv (int_to_bv i n)) k) ((getbv (int_to_bv j n)) k)))
    0%Z n)
   = (indic i j)).

Axiom int_to_bv_prod_gen :
  forall (i:Z) (n:Z), (n > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> forall (j:Z),
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((ind_product
    (fun (k:Z) =>
     (indic ((getbv (int_to_bv i n)) k) ((getbv (int_to_bv j n)) k)))
    0%Z n)
   = (indic i j)).

Axiom kth_decomp_bound_zero :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  (((getbv bv) k) = 0%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    0%Z k)
   <= (bv_to_int bv))%Z.

Axiom kth_decomp_bound_zero1 :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  (((getbv bv) k) = 0%Z) ->
  ((bv_to_int bv) <
   ((ind_isum
     (fun (l:Z) =>
      (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
     0%Z k)
    + (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))%Z)%Z.

Axiom kth_decomp_bound_one :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  (((getbv bv) k) = 1%Z) ->
  (((ind_isum
     (fun (l:Z) =>
      (((getbv bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
     0%Z k)
    + (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))%Z
   <= (bv_to_int bv))%Z.

Axiom kth_decomp_bound_one1 :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  (((getbv bv) k) = 1%Z) ->
  ((bv_to_int bv) <
   ((ind_isum
     (fun (l:Z) =>
      (((getbv bv) l) * (power 2%Z (((length bv) - l)%Z - 1%Z)%Z))%Z)
     0%Z k)
    + (power 2%Z ((length bv) - k)%Z))%Z)%Z.

Axiom ang_sum_int_decomp :
  forall (bvx:Z -> Z) (k:Z) (n:Z), (0%Z < n)%Z -> (binary bvx) ->
  ((ang_sum
    (fun (x:Z) =>
     (int_to_ang (((bvx x) * (power 2%Z ((n - x)%Z - 1%Z)%Z))%Z * k)%Z n))
    0%Z n)
   = (int_to_ang ((bin_to_int bvx n) * k)%Z n)).

Axiom ang_sum_int_decomp_gen :
  forall (bvx:Z -> Z) (n:Z), (0%Z < n)%Z -> (binary bvx) -> forall (k:Z),
  ((ang_sum
    (fun (x:Z) =>
     (int_to_ang (((bvx x) * (power 2%Z ((n - x)%Z - 1%Z)%Z))%Z * k)%Z n))
    0%Z n)
   = (int_to_ang ((bin_to_int bvx n) * k)%Z n)).

Axiom ang_sum_bv_to_int :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), forall (k:Z),
  ((length x) = n) ->
  ((ang_sum
    (fun (i:Z) =>
     (int_to_ang ((((getbv x) i) * (power 2%Z ((n - i)%Z - 1%Z)%Z))%Z * k)%Z
      n))
    0%Z n)
   = (int_to_ang ((bv_to_int x) * k)%Z n)).

Axiom ang_sum_bv_to_int_ :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), forall (k:Z),
  ((length x) = n) ->
  ((ang_sum
    (fun (i:Z) =>
     (int_to_ang ((((getbv x) i) * (power_ 2%Z ((n - i)%Z - 1%Z)%Z))%Z * k)%Z
      n))
    0%Z n)
   = (int_to_ang ((bv_to_int x) * k)%Z n)).

Parameter bv_inversion: bitvec -> bitvec.

Axiom bv_inversion_def :
  forall (bv:bitvec),
  ((bv_inversion bv) =
   (make_bv (fun (k:Z) => ((getbv bv) (((length bv) - k)%Z - 1%Z)%Z))
    (length bv))).

Axiom bv_inversion_spec :
  forall (bv:bitvec), ((length (bv_inversion bv)) = (length bv)).

Axiom bv_inversion_spec1 :
  forall (bv:bitvec), forall (k:Z), (in_range (bv_inversion bv) k) ->
  (((getbv (bv_inversion bv)) k) =
   ((getbv bv) (((length bv) - k)%Z - 1%Z)%Z)).

Axiom bv_inversion_value :
  forall (bv:bitvec) (i:Z),
  (((getbv (bv_inversion bv)) i) =
   ((getbv bv) (((length bv) - i)%Z - 1%Z)%Z)).

Axiom bv_inversion_invol :
  forall (bv:bitvec), ((bv_inversion (bv_inversion bv)) = bv).

Parameter int_bit_inversion: Z -> Z -> Z.

Axiom int_bit_inversion_def :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_bit_inversion i n) = (bv_to_int (bv_inversion (int_to_bv i n)))).

Axiom int_bit_inversion_spec :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (0%Z <= (int_bit_inversion i n))%Z.

Axiom int_bit_inversion_spec1 :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_bit_inversion i n) < (power 2%Z n))%Z.

Axiom int_bit_inversion_invol :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_bit_inversion (int_bit_inversion i n) n) = i).

Axiom int_bit_inversion_onebit :
  forall (i:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((int_bit_inversion i 1%Z) = i).

Axiom int_bit_inversion_zero :
  forall (i:Z) (n:Z), (0%Z < n)%Z -> (0%Z = i) ->
  ((int_bit_inversion i n) = 0%Z).

Axiom bv_to_int_sum_inversion :
  forall (bv:bitvec), ((length bv) > 0%Z)%Z ->
  ((int_bit_inversion (bv_to_int bv) (length bv)) =
   (ind_isum
    (fun (k:Z) =>
     (((getbv bv) (((length bv) - k)%Z - 1%Z)%Z) *
      (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))).

Axiom bv_to_int_sum_inversion_inc :
  forall (bv:bitvec), ((length bv) > 0%Z)%Z ->
  ((int_bit_inversion (bv_to_int bv) (length bv)) =
   (ind_isum (fun (k:Z) => (((getbv bv) k) * (power 2%Z k))%Z) 0%Z
    (length bv))).

Axiom inversion_to_int_comm :
  forall (bv:bitvec), ((length bv) > 0%Z)%Z ->
  ((int_to_bv (int_bit_inversion (bv_to_int bv) (length bv)) (length bv)) =
   (bv_inversion bv)).

Axiom bv_inversion_sum :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_bit_inversion i n) =
   (ind_isum
    (fun (k:Z) =>
     (((getbv (int_to_bv i n)) ((n - k)%Z - 1%Z)%Z) *
      (power 2%Z ((n - 1%Z)%Z - k)%Z))%Z)
    0%Z n)).

Axiom bv_to_int_inversion_sum :
  forall (bv:bitvec),
  ((bv_to_int (bv_inversion bv)) =
   (ind_isum
    (fun (k:Z) =>
     (((getbv bv) (((length bv) - k)%Z - 1%Z)%Z) *
      (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))).

Axiom bv_to_int_bit_inversion :
  forall (bv:bitvec), ((length bv) > 0%Z)%Z ->
  ((bv_to_int (bv_inversion bv)) =
   (int_bit_inversion (bv_to_int bv) (length bv))).

Axiom bv_to_int_inversion_sum_inc :
  forall (bv:bitvec), ((length bv) > 0%Z)%Z ->
  ((bv_to_int (bv_inversion bv)) =
   (ind_isum (fun (k:Z) => (((getbv bv) k) * (power 2%Z k))%Z) 0%Z
    (length bv))).

Axiom bv_m_to_int_bit_inversion :
  forall (f:Z -> Z) (n:Z), (0%Z < n)%Z ->
  ((bv_to_int (bv_inversion (make_bv_m f n))) =
   (int_bit_inversion (bv_to_int (make_bv_m f n)) n)).

Axiom int_bit_inversion_tail_bits :
  forall (i:Z) (n:Z), (1%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_bit_inversion (tail_bits i n) (n - 1%Z)%Z) =
   (ind_isum
    (fun (k:Z) =>
     (((getbv (int_to_bv i n)) (n - k)%Z) *
      (power 2%Z ((n - k)%Z - 1%Z)%Z))%Z)
    1%Z n)).

Axiom tail_bits_int_bit_inversion :
  forall (bv:Z -> Z) (n:Z), (1%Z < n)%Z ->
  ((tail_bits (int_bit_inversion (bv_to_int (make_bv_m bv n)) n) n) =
   (ind_isum
    (fun (k:Z) =>
     ((int.EuclideanDivision.mod1 (bv ((n - 1%Z)%Z - k)%Z) 2%Z) *
      (power 2%Z ((n - k)%Z - 1%Z)%Z))%Z)
    1%Z n)).

Axiom int_bit_inversion_ht :
  forall (i:Z) (n:Z), (1%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_bit_inversion i n) =
   ((2%Z * (int_bit_inversion (tail_bits i n) (n - 1%Z)%Z))%Z +
    (head_bit i n))%Z).

Axiom bv_inversion_ht :
  forall (f:Z -> Z) (n:Z), (1%Z < n)%Z ->
  ((bv_to_int (bv_inversion (make_bv_m f n))) =
   ((head (make_bv_m f n)) +
    (2%Z * (bv_to_int (bv_inversion (tail (make_bv_m f n)))))%Z)%Z).

Axiom bv_inversion_ht_bv :
  forall (bv:bitvec), (1%Z < (length bv))%Z ->
  ((bv_to_int (bv_inversion bv)) =
   ((head bv) + (2%Z * (bv_to_int (bv_inversion (tail bv))))%Z)%Z).

Axiom bv_to_int_ht :
  forall (f:Z -> Z) (n:Z), (1%Z < n)%Z ->
  ((bv_to_int (make_bv_m f n)) =
   (((power 2%Z (n - 1%Z)%Z) * (head (make_bv_m f n)))%Z +
    (bv_to_int (tail (make_bv_m f n))))%Z).

Axiom bv_inversion_mult_ht :
  forall (fx:Z -> Z) (fy:Z -> Z) (n:Z), (1%Z < n)%Z ->
  (((bv_to_int (make_bv_m fx n)) *
    (bv_to_int (bv_inversion (make_bv_m fy n))))%Z
   =
   ((((head (make_bv_m fy n)) * (bv_to_int (make_bv_m fx n)))%Z +
     ((bv_to_int (tail (make_bv_m fx n))) *
      (2%Z * (bv_to_int (bv_inversion (tail (make_bv_m fy n)))))%Z)%Z)%Z
    +
    ((power 2%Z n) *
     ((head (make_bv_m fx n)) *
      (bv_to_int (bv_inversion (tail (make_bv_m fy n)))))%Z)%Z)%Z).

Axiom bv_inversion_mult_ht_bv :
  forall (bvx:bitvec) (bvy:bitvec), (1%Z < (length bvx))%Z ->
  ((length bvx) = (length bvy)) ->
  (((bv_to_int bvx) * (bv_to_int (bv_inversion bvy)))%Z =
   ((((head bvy) * (bv_to_int bvx))%Z +
     ((bv_to_int (tail bvx)) *
      (2%Z * (bv_to_int (bv_inversion (tail bvy))))%Z)%Z)%Z
    +
    ((power 2%Z (length bvx)) *
     ((head bvx) * (bv_to_int (bv_inversion (tail bvy))))%Z)%Z)%Z).

Axiom real_to_ang_distr_minus :
  forall (x:t) (z:t) (t1:t), forall (y:Z), (real_ x) -> (real_ z) ->
  (real_ t1) ->
  ((ang_add (real_to_ang (infix_asdt x (i_to_t y)))
    (real_to_ang (infix_asdt (infix_asdt (i_to_t y) (prefix_mndt z)) t1)))
   = (ang_mult_int (real_to_ang (infix_mndt x (infix_asdt z t1))) y)).

Axiom ang_sum_int_decomp_gen_rev :
  forall (bvx:Z -> Z) (n:Z), (0%Z < n)%Z -> (binary bvx) -> forall (k:Z),
  ((int_to_ang ((bin_to_int bvx n) * k)%Z n) =
   (ang_sum
    (fun (x:Z) =>
     (int_to_ang (((bvx x) * (power 2%Z ((n - x)%Z - 1%Z)%Z))%Z * k)%Z n))
    0%Z n)).

Axiom Ang_mult_int_exp :
  forall (o:angle), forall (i:Z),
  ((ang_exp (ang_mult_int o i)) = (cpower (ang_exp o) i)).

Axiom ang_mult_int_exp_rev :
  forall (o:angle) (i:Z),
  ((cpower (ang_exp o) i) = (ang_exp (ang_mult_int o i))).

Axiom ang_mult_int_add :
  forall (o:angle) (i:Z) (i':Z),
  ((ang_mult_int o (i + i')%Z) =
   (ang_add (ang_mult_int o i) (ang_mult_int o i'))).

Axiom ang_mult_int_plus_one :
  forall (o:angle) (i:Z),
  ((ang_add o (ang_mult_int o i)) = (ang_mult_int o (i + 1%Z)%Z)).

Axiom ang_mult_int_plus_one_rev :
  forall (o:angle) (i:Z),
  ((ang_mult_int o (1%Z + i)%Z) = (ang_add o (ang_mult_int o i))).

Axiom sum_ang_mult_int_e :
  forall (o:angle) (f:Z -> Z) (l:Z) (h:Z), (l < h)%Z ->
  ((ang_sum (fun (i:Z) => (ang_mult_int o (f i))) l h) =
   (ang_mult_int o (ind_isum f l h))).

Axiom real_to_ang_sum :
  forall (phi:Z -> t) (l:Z) (h:Z), (l < h)%Z ->
  (forall (i:Z), ((l <= i)%Z /\ (i < h)%Z) -> real_ (phi i)) ->
  ((ang_sum (fun (i:Z) => (real_to_ang (phi i))) l h) =
   (real_to_ang (ind_sum phi l h))).

Axiom real_to_ang_sum_int :
  forall (f:Z -> Z) (l:Z) (h:Z) (x:t), (l < h)%Z -> (real_ x) ->
  ((ang_sum (fun (i:Z) => (real_to_ang (infix_asdt x (i_to_t (f i))))) l h) =
   (real_to_ang (infix_asdt x (i_to_t (ind_isum f l h))))).

Axiom real_to_ang_sum_int_gen :
  forall (f:Z -> Z) (l:Z) (h:Z), (l < h)%Z -> forall (x:t), (real_ x) ->
  ((ang_sum (fun (i:Z) => (real_to_ang (infix_asdt x (i_to_t (f i))))) l h) =
   (real_to_ang (infix_asdt x (i_to_t (ind_isum f l h))))).

Axiom real_to_ang_bv_inversion :
  forall (ft:Z) (x:t) (y:bitvec), (0%Z < ft)%Z -> (real_ x) ->
  ((length y) = ft) ->
  ((ang_sum
    (fun (i:Z) =>
     (real_to_ang
      (infix_asdt (infix_asdt x (i_to_t (power_ 2%Z i)))
       (i_to_t ((getbv y) i)))))
    0%Z ft)
   = (real_to_ang (infix_asdt x (i_to_t (bv_to_int (bv_inversion y)))))).

Axiom ang_mult_int_double :
  forall (o:angle) (i:Z),
  ((ang_mult_int o (2%Z * i)%Z) =
   (ang_add (ang_mult_int o i) (ang_mult_int o i))).

Axiom ang_mult_int_inv :
  forall (o:angle), ((ang_mult_int o (-1%Z)%Z) = (ang_inv o)).

Axiom ang_mult_int_one :
  forall (o:angle) (n:Z), (n = 1%Z) -> ((ang_mult_int o n) = o).

Axiom ang_mult_int_inv_rev :
  forall (o:angle), ((ang_inv o) = (ang_mult_int o (-1%Z)%Z)).

Axiom ang_mult_int_comp :
  forall (o:angle) (i:Z) (j:Z),
  ((ang_mult_int (ang_mult_int o i) j) = (ang_mult_int o (i * j)%Z)).

Axiom ang_mult_int_comp_rev :
  forall (o:angle) (i:Z) (j:Z),
  ((ang_mult_int o (i * j)%Z) = (ang_mult_int (ang_mult_int o i) j)).

Axiom add_ang_mult_int :
  forall (o:angle) (o':angle) (i:Z),
  ((ang_add (ang_mult_int o i) (ang_mult_int o' i)) =
   (ang_mult_int (ang_add o o') i)).

Axiom sum_ang_mult_int :
  forall (f:Z -> angle) (i:Z) (l:Z) (h:Z), (l < h)%Z ->
  ((ang_sum (fun (x:Z) => (ang_mult_int (f x) i)) l h) =
   (ang_mult_int (ang_sum f l h) i)).

Axiom ang_sum_bv_to_int_inversion_pre :
  forall (n:Z) (x:bitvec), (0%Z < n)%Z -> ((length x) = n) ->
  forall (theta:t), (real_ theta) ->
  ((real_to_ang (infix_asdt theta (i_to_t (bv_to_int (bv_inversion x))))) =
   (ang_sum
    (fun (i:Z) =>
     (real_to_ang
      (infix_asdt (infix_asdt theta (i_to_t (power_ 2%Z i)))
       (i_to_t ((getbv x) i)))))
    0%Z n)).

Axiom ang_sum_bv_to_int_inversion :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), forall (theta:t),
  ((length x) = n) -> (real_ theta) ->
  ((real_to_ang (infix_asdt theta (i_to_t (bv_to_int (bv_inversion x))))) =
   (ang_sum
    (fun (i:Z) =>
     (real_to_ang
      (infix_asdt (infix_asdt theta (i_to_t (power_ 2%Z i)))
       (i_to_t ((getbv x) i)))))
    0%Z n)).

Axiom ang_sum_bv_to_int_opp_pre :
  forall (n:Z) (x:bitvec), (0%Z < n)%Z -> ((length x) = n) ->
  forall (theta:t), (real_ theta) ->
  ((real_to_ang (infix_asdt theta (i_to_t (-(bv_to_int x))%Z))) =
   (ang_sum
    (fun (i:Z) =>
     (real_to_ang
      (infix_asdt
       (infix_asdt theta (i_to_t (power_ 2%Z ((n - i)%Z - 1%Z)%Z)))
       (i_to_t (-((getbv x) i))%Z))))
    0%Z n)).

Axiom ang_sum_bv_to_int_opp :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), forall (theta:t),
  ((length x) = n) -> (real_ theta) ->
  ((real_to_ang (infix_asdt theta (i_to_t (-(bv_to_int x))%Z))) =
   (ang_sum
    (fun (i:Z) =>
     (real_to_ang
      (infix_asdt
       (infix_asdt theta (i_to_t (power_ 2%Z ((n - i)%Z - 1%Z)%Z)))
       (i_to_t (-((getbv x) i))%Z))))
    0%Z n)).

Axiom ang_sum_bv_to_int_mult_pre :
  forall (n:Z) (x:bitvec), (0%Z < n)%Z -> ((length x) = n) ->
  forall (theta:t), (real_ theta) ->
  ((real_to_ang (infix_asdt theta (i_to_t (bv_to_int x)))) =
   (ang_sum
    (fun (i:Z) =>
     (real_to_ang
      (infix_asdt
       (infix_asdt theta (i_to_t (power_ 2%Z ((n - i)%Z - 1%Z)%Z)))
       (i_to_t ((getbv x) i)))))
    0%Z n)).

Axiom ang_sum_bv_to_int_mult :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), forall (theta:t),
  ((length x) = n) -> (real_ theta) ->
  ((real_to_ang (infix_asdt theta (i_to_t (bv_to_int x)))) =
   (ang_sum
    (fun (i:Z) =>
     (real_to_ang
      (infix_asdt
       (infix_asdt theta (i_to_t (power_ 2%Z ((n - i)%Z - 1%Z)%Z)))
       (i_to_t ((getbv x) i)))))
    0%Z n)).

Axiom rewrite_ang_sum_sum_to_bv_and_inversion :
  forall (n:Z) (x:bitvec) (y:bitvec), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) ->
  ((ang_sum
    (fun (j:Z) =>
     (ang_sum
      (fun (i:Z) =>
       (int_to_ang
        (((-((getbv x) i))%Z * ((getbv y) j))%Z *
         (power_ 2%Z (((n - i)%Z - 1%Z)%Z + j)%Z))%Z
        n))
      j n))
    0%Z n)
   =
   (real_to_ang
    (infix_sldt
     (infix_asdt (i_to_t (-(bv_to_int x))%Z)
      (i_to_t (bv_to_int (bv_inversion y))))
     (i_to_t (power_ 2%Z n))))).

Axiom rewrite_ang_sum_sum_to_bv_and_inversion_gen :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((ang_sum
    (fun (j:Z) =>
     (ang_sum
      (fun (i:Z) =>
       (int_to_ang
        (((-((getbv x) i))%Z * ((getbv y) j))%Z *
         (power_ 2%Z (((n - i)%Z - 1%Z)%Z + j)%Z))%Z
        n))
      j n))
    0%Z n)
   =
   (real_to_ang
    (infix_asdt
     (infix_asdt (i_to_t (-(bv_to_int x))%Z)
      (i_to_t (bv_to_int (bv_inversion y))))
     (pow_inv_2 n)))).

Axiom int_to_ang_by_sum_mult_break :
  forall (n:Z) (x:bitvec) (y:bitvec), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) ->
  ((int_to_ang
    (ind_isum
     (fun (j:Z) =>
      (ind_isum
       (fun (i:Z) =>
        ((((getbv x) i) * ((getbv y) j))%Z *
         (power_ 2%Z (((n - i)%Z - 1%Z)%Z + j)%Z))%Z)
       j n))
     0%Z n)
    n)
   = (int_to_ang ((bv_to_int x) * (bv_to_int (bv_inversion y)))%Z n)).

Axiom int_to_ang_by_sum_mult_break_gen :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((int_to_ang
    (ind_isum
     (fun (j:Z) =>
      (ind_isum
       (fun (i:Z) =>
        ((((getbv x) i) * ((getbv y) j))%Z *
         (power_ 2%Z (((n - i)%Z - 1%Z)%Z + j)%Z))%Z)
       j n))
     0%Z n)
    n)
   = (int_to_ang ((bv_to_int x) * (bv_to_int (bv_inversion y)))%Z n)).

Parameter ang_substr: angle -> angle -> angle.

Axiom ang_substr_def :
  forall (o:angle) (o':angle), ((ang_substr o o') = (ang_add o (ang_inv o'))).

Axiom ang_substr_inv :
  forall (o:angle) (o':angle),
  ((ang_substr o (ang_mult_int o' (-1%Z)%Z)) = (ang_add o o')).

Axiom ang_mult_int_distr :
  forall (o:angle) (o':angle) (n:Z),
  ((ang_mult_int (ang_add o o') n) =
   (ang_add (ang_mult_int o n) (ang_mult_int o' n))).

Axiom ang_mult_int_distr_rev :
  forall (o:angle) (o':angle) (n1:Z) (n2:Z),
  ((ang_add (ang_mult_int o n1) (ang_mult_int o' n2)) =
   (ang_mult_int o (n1 + n2)%Z)).

Axiom ang_add_assoc :
  forall (o:angle) (o':angle) (o'':angle),
  ((ang_add o (ang_add o' o'')) = (ang_add (ang_add o o') o'')).

Axiom ang_add_assoc_rev :
  forall (o:angle) (o':angle) (o'':angle),
  ((ang_add (ang_add o o') o'') = (ang_add o (ang_add o' o''))).

Axiom ang_add_own_inv :
  forall (o:angle), ((ang_add (ang_mult_int o (-1%Z)%Z) o) = ang_zero).

Parameter concat: bitvec -> bitvec -> bitvec.

Parameter result13: bitvec -> bitvec -> Z -> Z.

Axiom result_def13 :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z),
  ((((length bv1) <= i)%Z /\ (i < ((length bv1) + (length bv2))%Z)%Z) ->
   (((result13 bv1 bv2) i) = ((getbv bv2) (i - (length bv1))%Z))) /\
  (~ (((length bv1) <= i)%Z /\ (i < ((length bv1) + (length bv2))%Z)%Z) ->
   (((result13 bv1 bv2) i) = ((getbv bv1) i))).

Axiom concat_def :
  forall (bv1:bitvec) (bv2:bitvec),
  ((concat bv1 bv2) =
   (make_bv (result13 bv1 bv2) ((length bv1) + (length bv2))%Z)).

Axiom concat_spec :
  forall (bv1:bitvec) (bv2:bitvec),
  ((length (concat bv1 bv2)) = ((length bv1) + (length bv2))%Z).

Axiom concat_spec1 :
  forall (bv1:bitvec) (bv2:bitvec), forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv1) i)).

Axiom concat_spec2 :
  forall (bv1:bitvec) (bv2:bitvec), forall (i:Z),
  ((length (concat bv1 bv2)) <= i)%Z ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv1) i)).

Axiom concat_spec3 :
  forall (bv1:bitvec) (bv2:bitvec), forall (i:Z),
  (((length bv1) <= i)%Z /\ (i < (length (concat bv1 bv2)))%Z) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv2) (i - (length bv1))%Z)).

Axiom concat_length :
  forall (bv1:bitvec) (bv2:bitvec),
  ((length (concat bv1 bv2)) = ((length bv1) + (length bv2))%Z).

Parameter hpart: bitvec -> Z -> bitvec.

Axiom hpart_def :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z ->
  ((hpart bv m) = (make_bv (getbv bv) m)).

Axiom hpart_spec :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> ((length (hpart bv m)) = m).

Axiom hpart_spec1 :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> ((length bv) = m) ->
  ((hpart bv m) = bv).

Axiom hpart_spec2 :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < m)%Z) -> (((getbv (hpart bv m)) k) = ((getbv bv) k)).

Axiom hpart_spec3 :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> forall (k:Z), ~ (0%Z <= k)%Z ->
  (((getbv (hpart bv m)) k) = 0%Z).

Axiom hpart_spec4 :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> forall (k:Z), ~ (k < m)%Z ->
  (((getbv (hpart bv m)) k) = 0%Z).

Axiom hpart_value :
  forall (bv:bitvec) (m:Z) (i:Z), (0%Z <= m)%Z ->
  (((0%Z <= i)%Z /\ (i < m)%Z) ->
   (((getbv (hpart bv m)) i) = ((getbv bv) i))) /\
  (~ ((0%Z <= i)%Z /\ (i < m)%Z) -> (((getbv (hpart bv m)) i) = 0%Z)).

Axiom hpart_value_b :
  forall (bv:bitvec) (m:Z) (i:Z), ((0%Z <= i)%Z /\ (i < m)%Z) ->
  (((getbv (hpart bv m)) i) = ((getbv bv) i)).

Parameter tpart: bitvec -> Z -> bitvec.

Axiom tpart_def :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> ((length bv) >= m)%Z ->
  ((tpart bv m) =
   (make_bv (fun (k:Z) => ((getbv bv) (k + m)%Z)) ((length bv) - m)%Z)).

Axiom tpart_def1 :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> ~ ((length bv) >= m)%Z ->
  ((tpart bv m) = (make_bv (fun (k:Z) => ((getbv bv) (k + m)%Z)) 0%Z)).

Axiom tpart_spec :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> ((length bv) >= m)%Z ->
  ((length (tpart bv m)) = ((length bv) - m)%Z).

Axiom tpart_spec1 :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> ((length bv) < m)%Z ->
  ((length (tpart bv m)) = 0%Z).

Axiom tpart_spec2 :
  forall (bv:bitvec) (m:Z), (0%Z <= m)%Z -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < (length (tpart bv m)))%Z) ->
  (((getbv (tpart bv m)) k) = ((getbv bv) (k + m)%Z)).

Parameter bv_tail: bitvec -> Z -> bitvec.

Axiom bv_tail_def :
  forall (bv:bitvec) (m:Z), ((0%Z <= m)%Z /\ (m <= ((length bv) - m)%Z)%Z) ->
  ((bv_tail bv m) = (tpart bv ((length bv) - m)%Z)).

Axiom bv_tail_spec :
  forall (bv:bitvec) (m:Z), ((0%Z <= m)%Z /\ (m <= ((length bv) - m)%Z)%Z) ->
  ((length (bv_tail bv m)) = m).

Axiom bv_tail_spec1 :
  forall (bv:bitvec) (m:Z), ((0%Z <= m)%Z /\ (m <= ((length bv) - m)%Z)%Z) ->
  forall (k:Z), ((0%Z <= k)%Z /\ (k < (length (bv_tail bv m)))%Z) ->
  (((getbv (bv_tail bv m)) k) = ((getbv bv) (k + ((length bv) - m)%Z)%Z)).

Parameter last: bitvec -> Z.

Axiom last_def :
  forall (bv:bitvec), ((length bv) >= 1%Z)%Z ->
  ((last bv) = ((getbv bv) ((length bv) - 1%Z)%Z)).

Parameter bv_head: bitvec -> Z -> bitvec.

Axiom bv_head_def :
  forall (bv:bitvec) (m:Z), ((0%Z <= m)%Z /\ (m <= (length bv))%Z) ->
  ((bv_head bv m) = (hpart bv ((length bv) - m)%Z)).

Axiom bv_head_spec :
  forall (bv:bitvec) (m:Z), ((0%Z <= m)%Z /\ (m <= (length bv))%Z) ->
  ((length (bv_head bv m)) = ((length bv) - m)%Z).

Axiom bv_head_spec1 :
  forall (bv:bitvec) (m:Z), ((0%Z <= m)%Z /\ (m <= (length bv))%Z) ->
  forall (k:Z), ((0%Z <= k)%Z /\ (k < (length (bv_head bv m)))%Z) ->
  (((getbv (bv_head bv m)) k) = ((getbv bv) k)).

Parameter htpart: bitvec -> Z -> Z -> bitvec.

Axiom htpart_def :
  forall (bv:bitvec) (k:Z) (n:Z), (0%Z <= k)%Z -> (0%Z <= n)%Z ->
  ((htpart bv k n) = (make_bv (fun (i:Z) => ((getbv bv) (k + i)%Z)) n)).

Axiom htpart_spec :
  forall (bv:bitvec) (k:Z) (n:Z), (0%Z <= k)%Z -> (0%Z <= n)%Z ->
  ((length (htpart bv k n)) = n).

Axiom htpart_spec1 :
  forall (bv:bitvec) (k:Z) (n:Z), (0%Z <= k)%Z -> (0%Z <= n)%Z ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((getbv (htpart bv k n)) i) = ((getbv bv) (k + i)%Z)).

Axiom tpart_value :
  forall (bv:bitvec) (m:Z) (i:Z), (0%Z <= m)%Z ->
  (((0%Z <= i)%Z /\ (i < ((length bv) - m)%Z)%Z) ->
   (((getbv (tpart bv m)) i) = ((getbv bv) (i + m)%Z))) /\
  (~ ((0%Z <= i)%Z /\ (i < ((length bv) - m)%Z)%Z) ->
   (((getbv (tpart bv m)) i) = 0%Z)).

Axiom tpart_value_b :
  forall (bv:bitvec) (m:Z) (i:Z), (0%Z <= m)%Z ->
  ((0%Z <= i)%Z /\ (i < ((length bv) - m)%Z)%Z) ->
  (((getbv (tpart bv m)) i) = ((getbv bv) (i + m)%Z)).

Axiom tpart_length :
  forall (bv:bitvec) (m:Z), ((0%Z <= m)%Z /\ (m <= (length bv))%Z) ->
  ((length (tpart bv m)) = ((length bv) - m)%Z).

Axiom htpart_value :
  forall (bv:bitvec) (k:Z) (n:Z) (i:Z), (0%Z <= k)%Z -> (0%Z <= n)%Z ->
  (((0%Z <= i)%Z /\ (i < n)%Z) ->
   (((getbv (htpart bv k n)) i) = ((getbv bv) (k + i)%Z))) /\
  (~ ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv (htpart bv k n)) i) = 0%Z)).

Axiom htpart_value_b :
  forall (bv:bitvec) (k:Z) (n:Z) (i:Z), (0%Z <= k)%Z -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((getbv (htpart bv k n)) i) = ((getbv bv) (k + i)%Z)).

Axiom htpart_product_ :
  forall (x:bitvec) (k:Z) (n:Z) (n':Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (n' = (n - k)%Z) ->
  ((ind_iproduct (getbv (htpart x k n')) 0%Z (n - k)%Z) =
   (ind_iproduct (getbv x) k n)).

Axiom htpart_product_one :
  forall (x:bitvec) (k:Z) (n:Z) (n':Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((length x) = n) -> (n' = (n - k)%Z) ->
  ((ind_iproduct (getbv x) 0%Z n) = 1%Z) ->
  ((ind_iproduct (getbv (htpart x k n')) 0%Z (n - k)%Z) = 1%Z).

Axiom htpart_product_zero :
  forall (x:bitvec) (k:Z) (n:Z) (n':Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((length x) = n) -> (n' = (n - k)%Z) ->
  (exists j:Z, ((k <= j)%Z /\ (j < n)%Z) /\ ~ (((getbv x) j) = 1%Z)) ->
  ((ind_iproduct (getbv (htpart x k n')) 0%Z (n - k)%Z) = 0%Z).

Axiom htpart_product :
  forall (x:bitvec) (k:Z) (n:Z) (n':Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((length x) = n) -> (n' = (n - k)%Z) ->
  ((forall (j:Z), ((k <= j)%Z /\ (j < n)%Z) -> (((getbv x) j) = 1%Z)) ->
   ((ind_iproduct (getbv (htpart x k n')) 0%Z (n - k)%Z) = 1%Z)) /\
  (~ (forall (j:Z), ((k <= j)%Z /\ (j < n)%Z) -> (((getbv x) j) = 1%Z)) ->
   ((ind_iproduct (getbv (htpart x k n')) 0%Z (n - k)%Z) = 0%Z)).

Axiom htpart_length :
  forall (bv:bitvec) (k:Z) (n:Z), (0%Z <= k)%Z -> (0%Z <= n)%Z ->
  ((length (htpart bv k n)) = n).

Axiom tpart_length_gen :
  forall (bv:bitvec) (m:Z) (l:Z), ((0%Z <= m)%Z /\ (m <= (length bv))%Z) ->
  (l = ((length bv) - m)%Z) -> ((length (tpart bv m)) = l).

Axiom concat_value_left :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv1) i)).

Axiom concat_value :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z),
  ((((length bv1) <= i)%Z /\ (i < ((length bv1) + (length bv2))%Z)%Z) ->
   (((getbv (concat bv1 bv2)) i) = ((getbv bv2) (i - (length bv1))%Z))) /\
  (~ (((length bv1) <= i)%Z /\ (i < ((length bv1) + (length bv2))%Z)%Z) ->
   (((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
    (((getbv (concat bv1 bv2)) i) = ((getbv bv1) i))) /\
   (~ ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
    (((getbv (concat bv1 bv2)) i) = 0%Z))).

Axiom concat_value_right :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z),
  (((length bv1) <= i)%Z /\ (i < ((length bv1) + (length bv2))%Z)%Z) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv2) (i - (length bv1))%Z)).

Axiom concat_value_out :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z),
  (((length bv1) + (length bv2))%Z < i)%Z ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv1) i)).

Axiom concat_value_tpart :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z),
  (((length bv1) <= i)%Z /\ (i < (length bv2))%Z) ->
  (((getbv (concat bv1 (tpart bv2 (length bv1)))) i) = ((getbv bv2) i)).

Axiom concat_value_ht :
  forall (bv1:bitvec) (bv2:bitvec) (bv3:bitvec) (bv4:bitvec) (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv3))%Z) -> ~ (0%Z <= i)%Z ->
  ~ ((length bv1) <= i)%Z -> (bv2 = (tpart bv3 (length bv1))) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv4) i)).

Axiom concat_value_ht1 :
  forall (bv1:bitvec) (bv2:bitvec) (bv3:bitvec) (bv4:bitvec) (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv3))%Z) -> ~ (0%Z <= i)%Z ->
  (((getbv bv3) i) = ((getbv bv4) i)) -> (bv2 = (tpart bv3 (length bv1))) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv4) i)).

Axiom concat_value_ht2 :
  forall (bv1:bitvec) (bv2:bitvec) (bv3:bitvec) (bv4:bitvec) (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv3))%Z) -> ~ (i < (length bv1))%Z ->
  ~ ((length bv1) <= i)%Z -> (bv2 = (tpart bv3 (length bv1))) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv4) i)).

Axiom concat_value_ht3 :
  forall (bv1:bitvec) (bv2:bitvec) (bv3:bitvec) (bv4:bitvec) (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv3))%Z) -> ~ (i < (length bv1))%Z ->
  (((getbv bv3) i) = ((getbv bv4) i)) -> (bv2 = (tpart bv3 (length bv1))) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv4) i)).

Axiom concat_value_ht4 :
  forall (bv1:bitvec) (bv2:bitvec) (bv3:bitvec) (bv4:bitvec) (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv3))%Z) ->
  (((getbv bv1) i) = ((getbv bv4) i)) -> ~ ((length bv1) <= i)%Z ->
  (bv2 = (tpart bv3 (length bv1))) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv4) i)).

Axiom concat_value_ht5 :
  forall (bv1:bitvec) (bv2:bitvec) (bv3:bitvec) (bv4:bitvec) (i:Z),
  ((0%Z <= i)%Z /\ (i < (length bv3))%Z) ->
  (((getbv bv1) i) = ((getbv bv4) i)) ->
  (((getbv bv3) i) = ((getbv bv4) i)) -> (bv2 = (tpart bv3 (length bv1))) ->
  (((getbv (concat bv1 bv2)) i) = ((getbv bv4) i)).

Axiom concat_ht1 :
  forall (bv1:bitvec) (bv2:bitvec) (bv3:bitvec) (bv4:bitvec),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
   (((getbv bv1) i) = ((getbv bv4) i))) ->
  (forall (i:Z), ((length bv1) <= i)%Z ->
   (((getbv bv3) i) = ((getbv bv4) i))) ->
  ((length bv4) = ((length bv1) + (length bv2))%Z) ->
  ((length bv3) >= ((length bv1) + (length bv2))%Z)%Z ->
  (bv2 = (tpart bv3 (length bv1))) -> ((concat bv1 bv2) = bv4).

Axiom set_concat :
  forall (bv1:bitvec) (bv2:bitvec) (bv4:bitvec),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
   (((getbv bv1) i) = ((getbv bv4) i))) ->
  (forall (i:Z), ((length bv1) <= i)%Z ->
   (((getbv bv2) (i - (length bv1))%Z) = ((getbv bv4) i))) ->
  ((length bv4) = ((length bv1) + (length bv2))%Z) ->
  ((concat bv1 bv2) = bv4).

Axiom concat_m :
  forall (bv1:bitvec) (bv2:bitvec) (i1:Z) (i2:Z), (i1 > 0%Z)%Z ->
  (i2 > 0%Z)%Z -> ((length bv1) = i1) -> ((length bv2) = i2) ->
  ((concat (make_bv_m (getbv bv1) i1) (make_bv_m (getbv bv2) i2)) =
   (make_bv_m (getbv (concat bv1 bv2)) (i1 + i2)%Z)).

Axiom concat_comm :
  forall (bv1:bitvec) (bv2:bitvec),
  ((hpart (concat bv1 bv2) (length bv1)) = bv1).

Axiom concat_comm1 :
  forall (bv1:bitvec) (bv2:bitvec),
  ((tpart (concat bv1 bv2) (length bv1)) = bv2).

Axiom concat_and_rec :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= (length bv))%Z) ->
  ((concat (hpart bv i) (tpart bv i)) = bv).

Parameter concat_int_bv: bitvec -> Z -> Z -> bitvec.

Axiom concat_int_bv_def :
  forall (bv:bitvec) (i:Z) (n:Z), (n > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((concat_int_bv bv i n) = (concat bv (int_to_bv i n))).

Axiom concat_int_to_bv_value :
  forall (bv:bitvec) (i:Z) (n:Z) (j:Z), (n > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (length (concat_int_bv bv i n)))%Z) ->
  (j < (length bv))%Z ->
  (((getbv (concat_int_bv bv i n)) j) = ((getbv bv) j)).

Axiom bv_to_int_concat :
  forall (bvx:bitvec) (bvy:bitvec),
  ((bv_to_int (concat bvx bvy)) =
   (((power 2%Z (length bvy)) * (bv_to_int bvx))%Z + (bv_to_int bvy))%Z).

Axiom concat_fin :
  forall (f1:Z -> Z) (f2:Z -> Z) (l1:Z) (l2:Z), (l1 >= 0%Z)%Z ->
  (l2 >= 0%Z)%Z -> (binary f1) -> (binary f2) ->
  ((make_bv
    ((((fun (y0:Z -> Z) (y1:Z -> Z) (y2:Z) (y3:Z) =>
        (concat_fun y0 y1 y2 y3))
       f1)
      f2)
     l1)
    (l1 + l2)%Z)
   = (concat (make_bv f1 l1) (make_bv f2 l2))).

Axiom bin_to_int_concat :
  forall (f1:Z -> Z) (f2:Z -> Z) (l1:Z) (l2:Z), (l1 >= 0%Z)%Z ->
  (l2 >= 0%Z)%Z -> (binary f1) -> (binary f2) ->
  ((bin_to_int
    ((((fun (y0:Z -> Z) (y1:Z -> Z) (y2:Z) (y3:Z) =>
        (concat_fun y0 y1 y2 y3))
       f1)
      f2)
     l1)
    (l1 + l2)%Z)
   = (((power 2%Z l2) * (bin_to_int f1 l1))%Z + (bin_to_int f2 l2))%Z).

Axiom bijective_concat :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  p_bijective (fun (o:(bitvec* bitvec)%type) => (concat (fir o) (sec o)))
  (cartesian_product (n_bvs i) (n_bvs j)) (n_bvs (i + j)%Z).

Axiom bijective_concat1 :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  p_bijective (fun (x:bitvec) => (hpart x i, tpart x i)) (n_bvs (i + j)%Z)
  (cartesian_product (n_bvs i) (n_bvs j)).

Axiom bv_to_int_hpart :
  forall (bv:bitvec) (l:Z), ((0%Z <= l)%Z /\ (l <= (length bv))%Z) ->
  ((bv_to_int (hpart bv l)) =
   (int.EuclideanDivision.div (bv_to_int bv) (power 2%Z ((length bv) - l)%Z))).

Axiom bv_to_int_tpart :
  forall (bv:bitvec) (l:Z), ((0%Z <= l)%Z /\ (l <= (length bv))%Z) ->
  ((bv_to_int (tpart bv l)) =
   (int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - l)%Z))).

Parameter iter_concat:
  forall {xi:Type} {xi_WT:WhyType xi} {xi1:Type} {xi1_WT:WhyType xi1},
  (xi -> xi -> xi) -> (Z -> bitvec) -> (set xi1) -> (xi1 -> xi) -> xi.

Axiom iter_concat_def :
  forall {xi:Type} {xi_WT:WhyType xi} {xi1:Type} {xi1_WT:WhyType xi1},
  forall (concat1:xi -> xi -> xi) (f:Z -> bitvec) (i:set xi1) (j:xi1 -> xi),
  ((iter_concat concat1 f i j) = (iterate concat1 i j)).

Parameter is_a_ket: (matrix t) -> Prop.

Axiom Is_a_ket : forall (m:matrix t), (is_a_ket m) -> ((columns m) = 1%Z).

Axiom Is_a_ket1 :
  forall (m:matrix t), (is_a_ket m) ->
  exists s:Z, (s >= 0%Z)%Z /\ ((rows m) = (power 2%Z s)).

Axiom Is_a_ket2 :
  forall (m:matrix t),
  (((columns m) = 1%Z) /\
   exists s:Z, (s >= 0%Z)%Z /\ ((rows m) = (power 2%Z s))) ->
  is_a_ket m.

Parameter xor_i: Z -> Z -> Z.

Axiom xor_i_def :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) -> (i = 0%Z) -> ((xor_i i i') = i').

Axiom xor_i_def1 :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) -> ~ (i = 0%Z) ->
  ((xor_i i i') = (1%Z - i')%Z).

Axiom xor_i_spec :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) -> (i = 0%Z) -> (i' = 0%Z) ->
  ((xor_i i i') = 0%Z).

Axiom xor_i_spec1 :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) -> (i = 0%Z) -> (i' = 1%Z) ->
  ((xor_i i i') = 1%Z).

Axiom xor_i_spec2 :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) -> (i = 1%Z) -> (i' = 0%Z) ->
  ((xor_i i i') = 1%Z).

Axiom xor_i_spec3 :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) -> (i = 1%Z) -> (i' = 1%Z) ->
  ((xor_i i i') = 0%Z).

Parameter is_a_ket_l: (matrix t) -> Z -> Prop.

Axiom is_a_ket_l_def :
  forall (m:matrix t) (l:Z),
  (is_a_ket_l m l) <->
  ((l >= 0%Z)%Z /\ (((columns m) = 1%Z) /\ ((rows m) = (power 2%Z l)))).

Axiom ket_l_rows :
  forall (m:matrix t) (l:Z), (is_a_ket_l m l) -> ((rows m) = (power 2%Z l)).

Axiom ket_l_columns :
  forall (m:matrix t), (exists l:Z, is_a_ket_l m l) -> ((columns m) = 1%Z).

Parameter ket_valid_index: (matrix t) -> Z -> Prop.

Axiom ket_valid_index_def :
  forall (m:matrix t) (i:Z), (ket_valid_index m i) <-> (valid_index m i 0%Z).

Parameter ket_length: (matrix t) -> Z.

Axiom ket_length_def :
  forall (m:matrix t), (is_a_ket m) ->
  ((ket_length m) = ((binary_length (rows m)) - 1%Z)%Z).

Axiom ket_length_spec :
  forall (m:matrix t), (is_a_ket m) -> (0%Z <= (ket_length m))%Z.

Axiom ket_length_spec1 :
  forall (m:matrix t), (is_a_ket m) ->
  ((rows m) = (power 2%Z (ket_length m))).

Parameter get_ket: (matrix t) -> Z -> t.

Axiom get_ket_def :
  forall (m:matrix t) (i:Z), ((get_ket m i) = (get m i 0%Z)).

Parameter get_ket_bv: (matrix t) -> bitvec -> t.

Axiom get_ket_bv_def :
  forall (x:matrix t) (bv:bitvec), (is_a_ket_l x (length bv)) ->
  ((get_ket_bv x bv) = (get_ket x (bv_to_int bv))).

Axiom assert_make_ket :
  forall (r:Z) (c:Z) (f:Z -> Z -> t) (i:Z), (c = 1%Z) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((get_ket (make_f r c f) i) = ((f i) 0%Z)).

Axiom mat_mult_ket_l :
  forall (m:matrix t) (k:matrix t) (n:Z), (is_a_ket_l k n) ->
  ((rows m) = (power 2%Z n)) -> ((columns m) = (power 2%Z n)) ->
  is_a_ket_l (mat_mult m k) n.

Axiom ket_kronecker_values :
  forall (m:matrix t) (n:matrix t) (i:Z), (is_a_ket m) -> (is_a_ket n) ->
  ((0%Z <= i)%Z /\ (i < ((rows m) * (rows n))%Z)%Z) ->
  ((get_ket (kronecker m n) i) =
   (infix_asdt (get_ket m (int.EuclideanDivision.div i (rows n)))
    (get_ket n (int.EuclideanDivision.mod1 i (rows n))))).

Axiom ket_l_to_ket :
  forall (m:matrix t) (l:Z), (is_a_ket_l m l) -> is_a_ket m.

Axiom ket_l_to_ket1 :
  forall (m:matrix t) (l:Z), (is_a_ket_l m l) -> ((ket_length m) = l).

Axiom ket_l_to_ket_gen :
  forall (m:matrix t), (exists l:Z, is_a_ket_l m l) -> is_a_ket m.

Axiom ket_to_ket_l :
  forall (m:matrix t), (is_a_ket m) -> is_a_ket_l m (ket_length m).

Axiom set_ket_valid_index :
  forall (m:matrix t) (i:Z), (is_a_ket m) ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) -> ket_valid_index m i.

Axiom ket_to_ket_l_l :
  forall (m:matrix t) (i:Z), (is_a_ket m) -> ((ket_length m) = i) ->
  is_a_ket_l m i.

Axiom set_constant_size_ket :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t),
  (forall (e1:a), (mem e1 s) -> is_a_ket (f e1)) ->
  (forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) ->
   ((ket_length (f e1)) = (ket_length (f e')))) ->
  constant_size s f.

Parameter ket_norm_l: (matrix t) -> Z -> t.

Axiom ket_norm_l_def :
  forall (x:matrix t) (n:Z), (is_a_ket_l x n) ->
  ((ket_norm_l x n) =
   (square_rt
    (sum (to_fset 0%Z (power 2%Z n))
     (fun (k:Z) =>
      (infix_asdt (modulus (get x k 0%Z)) (modulus (get x k 0%Z))))))).

Axiom ind_sum_ket_norm_l :
  forall (x:matrix t) (n:Z), (is_a_ket_l x n) ->
  ((ket_norm_l x n) =
   (square_rt
    (ind_sum
     (fun (k:Z) =>
      (infix_asdt (modulus (get x k 0%Z)) (modulus (get x k 0%Z))))
     0%Z (power 2%Z n)))).

Axiom ket_norm_one :
  forall (x:matrix t) (n:Z), (n = 1%Z) -> (is_a_ket_l x n) ->
  ((ket_norm_l x n) =
   (square_rt
    (infix_pldt
     (infix_asdt (modulus (get x 0%Z 0%Z)) (modulus (get x 0%Z 0%Z)))
     (infix_asdt (modulus (get x 1%Z 0%Z)) (modulus (get x 1%Z 0%Z)))))).

Axiom ket_norm_one_tone :
  forall (x:matrix t) (n:Z), (n = 1%Z) -> (is_a_ket_l x n) ->
  ((infix_pldt
    (infix_asdt (modulus (get x 0%Z 0%Z)) (modulus (get x 0%Z 0%Z)))
    (infix_asdt (modulus (get x 1%Z 0%Z)) (modulus (get x 1%Z 0%Z))))
   = tone) ->
  ((ket_norm_l x n) = tone).

Axiom scalar_ket_norm_l :
  forall (x:matrix t) (a:t) (n:Z), (is_a_ket_l x n) ->
  ((ket_norm_l (infix_asdtdt a x) n) = (infix_asdt a (ket_norm_l x n))).

Axiom zero_ket_norm_l :
  forall (x:matrix t) (n:Z), (is_a_ket_l x n) ->
  ((ket_norm_l x n) = tzero) -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (j = 0%Z) ->
  ((get x i j) = tzero).

Parameter normalized_l: (matrix t) -> Z -> matrix t.

Axiom normalized_l_def :
  forall (x:matrix t) (n:Z), (is_a_ket_l x n) ->
  ((normalized_l x n) = (infix_asdtdt (infix_sldt tone (ket_norm_l x n)) x)).

Axiom normalized_l_spec :
  forall (x:matrix t) (n:Z), (is_a_ket_l x n) ->
  is_a_ket_l (normalized_l x n) n.

Parameter add_ket: (matrix t) -> (matrix t) -> matrix t.

Axiom add_ket_def :
  forall (m:matrix t) (n:matrix t), (is_a_ket m) -> (is_a_ket n) ->
  ((ket_length m) = (ket_length n)) -> ((add_ket m n) = (add_mat m n)).

Axiom add_ket_spec :
  forall (m:matrix t) (n:matrix t), (is_a_ket m) -> (is_a_ket n) ->
  ((ket_length m) = (ket_length n)) -> is_a_ket (add_ket m n).

Axiom add_ket_spec1 :
  forall (m:matrix t) (n:matrix t), (is_a_ket m) -> (is_a_ket n) ->
  ((ket_length m) = (ket_length n)) ->
  ((ket_length (add_ket m n)) = (ket_length m)).

Axiom add_ket_spec2 :
  forall (m:matrix t) (n:matrix t), (is_a_ket m) -> (is_a_ket n) ->
  ((ket_length m) = (ket_length n)) -> forall (i:Z),
  (ket_valid_index (add_ket m n) i) ->
  ((get_ket (add_ket m n) i) = (infix_pldt (get_ket m i) (get_ket n i))).

Parameter add_ket_l: (matrix t) -> (matrix t) -> Z -> matrix t.

Axiom add_ket_l_def :
  forall (m:matrix t) (n:matrix t) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) -> ((add_ket_l m n l) = (add_ket m n)).

Axiom add_ket_l_spec :
  forall (m:matrix t) (n:matrix t) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) -> is_a_ket_l (add_ket_l m n l) l.

Axiom add_ket_l_spec1 :
  forall (m:matrix t) (n:matrix t) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) -> ((ket_length (add_ket_l m n l)) = l).

Axiom add_ket_l_spec2 :
  forall (m:matrix t) (n:matrix t) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length (add_ket_l m n l))))%Z) ->
  ((get_ket (add_ket_l m n l) i) = (infix_pldt (get_ket m i) (get_ket n i))).

Parameter add_ket_l_eq:
  (matrix t) -> (matrix t) -> (matrix t) -> (matrix t) -> Z -> unit.

Axiom add_ket_l_eq_def :
  forall (m:matrix t) (m':matrix t) (n:matrix t) (n':matrix t) (l:Z),
  (is_a_ket_l m l) -> (is_a_ket_l n l) -> (m = m') -> (n = n') ->
  ((add_ket_l_eq m m' n n' l) = tt).

Axiom add_ket_l_eq_spec :
  forall (m:matrix t) (m':matrix t) (n:matrix t) (n':matrix t) (l:Z),
  (is_a_ket_l m l) -> (is_a_ket_l n l) -> (m = m') -> (n = n') ->
  ((((fun (y0:matrix t) (y1:matrix t) (y2:Z) => (add_ket_l y0 y1 y2)) m) n) =
   (((fun (y0:matrix t) (y1:matrix t) (y2:Z) => (add_ket_l y0 y1 y2)) m') n')).

Axiom add_ket_l_value :
  forall (m:matrix t) (n:matrix t) (l:Z) (i:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) -> ((0%Z <= i)%Z /\ (i < (power 2%Z l))%Z) ->
  ((get_ket (add_ket_l m n l) i) = (infix_pldt (get_ket m i) (get_ket n i))).

Axiom set_equal_ket :
  forall (m:matrix t) (n:matrix t), (is_a_ket m) -> (is_a_ket n) ->
  ((ket_length m) = (ket_length n)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) ->
   ((get_ket m i) = (get_ket n i))) ->
  (m = n).

Axiom set_equal_ket_l :
  forall (m:matrix t) (n:matrix t),
  (exists l:Z, (is_a_ket_l m l) /\ (is_a_ket_l n l)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) ->
   ((get_ket m i) = (get_ket n i))) ->
  (m = n).

Axiom get_ket_length :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((rows m) = (power 2%Z n)) -> ((ket_length m) = n).

Axiom set_ket_length :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((ket_length m) = n) -> ((rows m) = (power 2%Z n)).

Axiom scalar_ket :
  forall (x:matrix t) (a:t), (is_a_ket x) -> is_a_ket (infix_asdtdt a x).

Axiom scalar_ket_length :
  forall (m:matrix t) (a:t), (is_a_ket m) ->
  ((ket_length (infix_asdtdt a m)) = (ket_length m)).

Axiom scalar_ket_valid_index :
  forall (m:matrix t) (a:t) (i:Z), (ket_valid_index m i) -> (is_a_ket m) ->
  ket_valid_index (infix_asdtdt a m) i.

Axiom scalar_ket_l :
  forall (x:matrix t) (l:Z) (a:t), (is_a_ket_l x l) ->
  is_a_ket_l (infix_asdtdt a x) l.

Axiom scalar_ket_value :
  forall (x:matrix t) (i:Z) (a:t), (is_a_ket x) -> (ket_valid_index x i) ->
  ((get_ket (infix_asdtdt a x) i) = (infix_asdt a (get_ket x i))).

Axiom scalar_ket_value_rev :
  forall (x:matrix t) (i:Z) (a:t), (is_a_ket x) -> (ket_valid_index x i) ->
  ((infix_asdt a (get_ket x i)) = (get_ket (infix_asdtdt a x) i)).

Axiom add_ket_is_a_ket :
  forall (x:matrix t) (y:matrix t), (is_a_ket x) -> (is_a_ket y) ->
  ((ket_length x) = (ket_length y)) -> is_a_ket (add_mat x y).

Axiom set_ket_length_gen :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((power 2%Z (ket_length m)) = n) -> ((rows m) = n).

Axiom set_is_a_ket :
  forall (m:matrix t), ((columns m) = 1%Z) ->
  (exists s:Z, (s >= 0%Z)%Z /\ ((rows m) = (power 2%Z s))) -> is_a_ket m.

Axiom set_is_a_ket_l :
  forall (m:matrix t) (l:Z), (l >= 0%Z)%Z -> ((columns m) = 1%Z) ->
  ((rows m) = (power 2%Z l)) -> is_a_ket_l m l.

Axiom set_is_a_ket_p :
  forall (m:matrix t) (l:Z), (l >= 0%Z)%Z -> ((columns m) = 1%Z) ->
  ((rows m) = (power 2%Z l)) -> is_a_ket m.

Axiom get_is_a_ket :
  forall (m:matrix t), (is_a_ket m) -> ((columns m) = 1%Z).

Axiom get_is_a_ket1 :
  forall (m:matrix t), (is_a_ket m) ->
  ((rows m) = (power 2%Z (ket_length m))).

Axiom get_ket_columns :
  forall (m:matrix t), (is_a_ket m) -> ((columns m) = 1%Z).

Axiom get_ket_rows :
  forall (m:matrix t), (is_a_ket m) ->
  ((rows m) = (power 2%Z (ket_length m))).

Axiom get_ket_rows_gen :
  forall (m:matrix t) (i:Z), (is_a_ket m) ->
  (i = (power 2%Z (ket_length m))) -> ((rows m) = i).

Axiom get_ket_rows_length :
  forall (m:matrix t) (l:Z), (is_a_ket m) -> ((ket_length m) = l) ->
  ((rows m) = (power 2%Z l)).

Axiom ket_kronecker :
  forall (m:matrix t) (n:matrix t), (is_a_ket m) -> (is_a_ket n) ->
  is_a_ket (kronecker m n).

Axiom ket_kronecker1 :
  forall (m:matrix t) (n:matrix t), (is_a_ket m) -> (is_a_ket n) ->
  ((ket_length (kronecker m n)) = ((ket_length m) + (ket_length n))%Z).

Axiom ket_kronecker_l :
  forall (m:matrix t) (n:matrix t) (l:Z) (l':Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l') -> is_a_ket_l (kronecker m n) (l + l')%Z.

Axiom set_ket_kron_l :
  forall (m:matrix t) (n:matrix t) (l:Z) (l':Z) (l'':Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l') -> (l'' = (l + l')%Z) -> is_a_ket_l (kronecker m n) l''.

Parameter ket: Z -> Z -> matrix t.

Axiom ket_def :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((ket n i) = (set1 (make (power 2%Z n) 1%Z tzero) i 0%Z tone)).

Axiom ket_def1 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z -> ~ (0%Z <= i)%Z ->
  ((ket n i) = (make (power 2%Z n) 1%Z tzero)).

Axiom ket_def2 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z -> ~ (i < (power 2%Z n))%Z ->
  ((ket n i) = (make (power 2%Z n) 1%Z tzero)).

Axiom ket_spec : forall (n:Z) (i:Z), (0%Z <= n)%Z -> is_a_ket (ket n i).

Axiom ket_spec1 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z -> ((ket_length (ket n i)) = n).

Axiom ket_spec2 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z -> ((columns (ket n i)) = 1%Z).

Axiom ket_spec3 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z -> ((rows (ket n i)) = (power 2%Z n)).

Axiom ket_spec4 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> forall (j:Z),
  (valid_index (ket n i) j 0%Z) -> ((get (ket n i) j 0%Z) = (indic j i)).

Axiom ket_spec5 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z -> forall (j:Z),
  (valid_index (ket n i) j 0%Z) -> ~ (i = j) ->
  ((get (ket n i) j 0%Z) = tzero).

Axiom ket_spec6 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((get (ket n i) i 0%Z) = tone).

Parameter scal_ket_zero: matrix t.

Axiom scal_ket_zero_def : (scal_ket_zero = (ket 0%Z 0%Z)).

Parameter scal_ket_one: matrix t.

Axiom scal_ket_one_def : (scal_ket_one = (ket 0%Z 1%Z)).

Parameter make_ket: Z -> (Z -> t) -> matrix t.

Axiom make_ket_def :
  forall (n:Z) (f:Z -> t), (n >= 0%Z)%Z ->
  ((make_ket n f) = (make_f (power 2%Z n) 1%Z (fun (x:Z) (us:Z) => (f x)))).

Axiom make_ket_spec :
  forall (n:Z) (f:Z -> t), (n >= 0%Z)%Z -> is_a_ket_l (make_ket n f) n.

Axiom make_ket_spec1 :
  forall (n:Z) (f:Z -> t), (n >= 0%Z)%Z -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((get_ket (make_ket n f) i) = (f i)).

Axiom make_ket_spec2 :
  forall (n:Z) (f:Z -> t), (n >= 0%Z)%Z -> forall (i:Z) (j:Z),
  (valid_index (make_ket n f) i j) -> ((get (make_ket n f) i j) = (f i)).

Axiom ket_l :
  forall (n:Z) (m:Z) (i:Z), (0%Z <= n)%Z -> (n = m) -> is_a_ket_l (ket n i) m.

Axiom ket_eq :
  forall (n1:Z) (n2:Z) (i1:Z) (i2:Z), (0%Z <= n1)%Z -> (n1 = n2) ->
  (i1 = i2) -> ((ket n1 i1) = (ket n2 i2)).

Axiom ket_rows :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((rows (ket n i)) = (power 2%Z n)).

Axiom ket_columns :
  forall (n:Z) (i:Z), (0%Z <= n)%Z -> ((columns (ket n i)) = 1%Z).

Axiom ket_value :
  forall (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((i = j) -> ((get (ket n i) j 0%Z) = tone)) /\
  (~ (i = j) -> ((get (ket n i) j 0%Z) = tzero)).

Axiom norm_ket_basis :
  forall (n:Z) (i:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((ket_norm_l (ket n i) n) = tone).

Axiom get_ket_ :
  forall (m:matrix t) (i:Z) (n:Z), (m = (ket n i)) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> is_a_ket m.

Axiom get_ket_1 :
  forall (m:matrix t) (i:Z) (n:Z), (m = (ket n i)) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((ket_length m) = n).

Axiom get_ket_2 :
  forall (m:matrix t) (i:Z) (n:Z), (m = (ket n i)) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((columns m) = 1%Z).

Axiom get_ket_3 :
  forall (m:matrix t) (i:Z) (n:Z), (m = (ket n i)) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((rows m) = (power 2%Z n)).

Axiom get_ket_4 :
  forall (m:matrix t) (i:Z) (n:Z), (m = (ket n i)) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> forall (j:Z),
  (valid_index m j 0%Z) -> ((get m j 0%Z) = (indic j i)).

Axiom get_ket_5 :
  forall (m:matrix t) (i:Z) (n:Z), (m = (ket n i)) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> forall (j:Z),
  (valid_index m j 0%Z) -> ~ (i = j) -> ((get m j 0%Z) = tzero).

Axiom get_ket_6 :
  forall (m:matrix t) (i:Z) (n:Z), (m = (ket n i)) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((get m i 0%Z) = tone).

Axiom get_ket_value :
  forall (i:Z) (n:Z) (j:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((get (ket n i) j 0%Z) = (indic j i)).

Axiom get_ket_values :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> forall (j:Z),
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((get (ket n i) j 0%Z) = (indic j i)).

Axiom get_ket_value_z :
  forall (i:Z) (n:Z) (j:Z) (z:Z), (z = 0%Z) -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((get (ket n i) j z) = (indic j i)).

Axiom get__ket_value :
  forall (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((get_ket (ket n i) j) = (indic j i)).

Axiom set_ket :
  forall (m:matrix t) (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((columns m) = 1%Z) ->
  ((rows m) = (power 2%Z n)) ->
  (forall (j:Z), (valid_index m j 0%Z) -> ((get m j 0%Z) = (indic j i))) ->
  (m = (ket n i)).

Axiom kronecker_kets :
  forall (i1:Z) (i2:Z) (n1:Z) (n2:Z), (0%Z <= n1)%Z -> (0%Z <= n2)%Z ->
  ((0%Z <= i1)%Z /\ (i1 < (power 2%Z n1))%Z) ->
  ((0%Z <= i2)%Z /\ (i2 < (power 2%Z n2))%Z) ->
  ((kronecker (ket n1 i1) (ket n2 i2)) =
   (ket (n1 + n2)%Z ((i1 * (power 2%Z n2))%Z + i2)%Z)).

Axiom kronecker_kets_bin_to_int :
  forall (f1:Z -> Z) (f2:Z -> Z) (n1:Z) (n2:Z), (binary f1) -> (binary f2) ->
  (0%Z <= n1)%Z -> (0%Z <= n2)%Z ->
  ((kronecker (ket n1 (bin_to_int f1 n1)) (ket n2 (bin_to_int f2 n2))) =
   (ket (n1 + n2)%Z
    (((bin_to_int f1 n1) * (power 2%Z n2))%Z + (bin_to_int f2 n2))%Z)).

Parameter ind_basis_mat: Z -> Z -> Z -> Z -> matrix t.

Axiom ind_basis_mat_def :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((ind_basis_mat i j r c) =
   (make_f r c (fun (k:Z) (l:Z) => (indic_2 k i l j)))).

Axiom ind_basis_mat_spec :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> ((rows (ind_basis_mat i j r c)) = r).

Axiom ind_basis_mat_spec1 :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> ((columns (ind_basis_mat i j r c)) = c).

Axiom ind_basis_mat_spec2 :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> forall (k:Z) (l:Z),
  (valid_index (ind_basis_mat i j r c) k l) ->
  ((get (ind_basis_mat i j r c) k l) = (indic_2 k i l j)).

Axiom ind_basis_mat_spec3 :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> forall (o:(Z* Z)%type),
  (mem o (mat_indices (ind_basis_mat i j r c))) ->
  ((get (ind_basis_mat i j r c) (fir o) (sec o)) = tone) -> ((fir o) = i).

Axiom ind_basis_mat_spec4 :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> forall (o:(Z* Z)%type),
  (mem o (mat_indices (ind_basis_mat i j r c))) ->
  ((get (ind_basis_mat i j r c) (fir o) (sec o)) = tone) -> ((sec o) = j).

Axiom ind_basis_mat_spec5 :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> forall (o:(Z* Z)%type),
  (mem o (mat_indices (ind_basis_mat i j r c))) ->
  (((fir o) = i) /\ ((sec o) = j)) ->
  ((get (ind_basis_mat i j r c) (fir o) (sec o)) = tone).

Axiom ind_basis_mat_values :
  forall (i:Z) (j:Z) (r:Z) (c:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> forall (i1:Z) (j1:Z),
  ((0%Z <= i1)%Z /\ (i1 < r)%Z) -> ((0%Z <= j1)%Z /\ (j1 < c)%Z) ->
  ((get (ind_basis_mat i j r c) i1 j1) = (indic_2 i i1 j j1)).

Axiom unic_ind_basis_mat :
  forall (i1:Z) (j1:Z) (i2:Z) (j2:Z) (r:Z) (c:Z),
  ((0%Z <= i1)%Z /\ (i1 < r)%Z) -> ((0%Z <= j1)%Z /\ (j1 < c)%Z) ->
  ((0%Z <= i2)%Z /\ (i2 < r)%Z) -> ((0%Z <= j2)%Z /\ (j2 < c)%Z) ->
  ((ind_basis_mat i1 j1 r c) = (ind_basis_mat i2 j2 r c)) ->
  ((i1, j1) = (i2, j2)).

Parameter basis_mat: Z -> Z -> set (matrix t).

Parameter result14: Z -> Z -> (Z* Z)%type -> matrix t.

Axiom result_def14 :
  forall (r:Z) (c:Z) (o:(Z* Z)%type),
  match o with
  | (i, j) =>
      ((((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
       (((result14 r c) o) = (ind_basis_mat i j r c))) /\
      (~ (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
       (((result14 r c) o) = (make r c tzero)))
  end.

Axiom basis_mat_def :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((basis_mat r c) =
   (map (result14 r c) (cartesian_product (to_fset 0%Z r) (to_fset 0%Z c)))).

Axiom basis_mat_spec :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z -> forall (m:matrix t),
  (mem m (basis_mat r c)) ->
  exists i:Z, exists j:Z,
  ((0%Z <= i)%Z /\ (i < r)%Z) /\
  (((0%Z <= j)%Z /\ (j < c)%Z) /\ (m = (ind_basis_mat i j r c))).

Axiom basis_mat_spec1 :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z -> forall (m:matrix t),
  (exists i:Z, exists j:Z,
   ((0%Z <= i)%Z /\ (i < r)%Z) /\
   (((0%Z <= j)%Z /\ (j < c)%Z) /\ (m = (ind_basis_mat i j r c)))) ->
  mem m (basis_mat r c).

Axiom basis_mat_spec2 :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((basis_mat r c) =
   (map (fun (o:(Z* Z)%type) => (ind_basis_mat (fir o) (sec o) r c))
    (cartesian_product (to_fset 0%Z r) (to_fset 0%Z c)))).

Axiom basis_mat_spec3 :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z ->
  constant_size (basis_mat r c) (fun (y0:matrix t) => (p_id y0)).

Axiom basis_mat_spec4 :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((s_columns (basis_mat r c) (fun (y0:matrix t) => (p_id y0))) = c).

Axiom basis_mat_spec5 :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((s_rows (basis_mat r c) (fun (y0:matrix t) => (p_id y0))) = r).

Parameter fc8: (matrix t) -> (Z* Z)%type -> bool.

Axiom fc_def8 :
  forall (m:matrix t) (x:(Z* Z)%type),
  (((fc8 m) x) = true) <-> (eq_t (get m (fir x) (sec x)) tone).

Axiom basis_mat_spec6 :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z -> forall (m:matrix t),
  (mem m (basis_mat r c)) ->
  ((cardinal (filter (fc8 m) (mat_indices m))) = 1%Z).

Parameter basis_mat_indexes: (matrix t) -> (Z* Z)%type.

Parameter result15: (matrix t) -> (Z* Z)%type -> bool.

Axiom result_def15 :
  forall (m:matrix t) (x:(Z* Z)%type),
  (((result15 m) x) = true) <->
  ((mem x (mat_indices m)) /\
   (equal m (ind_basis_mat (fir x) (sec x) (rows m) (columns m)))).

Axiom basis_mat_indexes_def :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  ((basis_mat_indexes m) = (element (filter (result15 m) (mat_indices m)))).

Axiom basis_mat_indexes_spec :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  (m =
   (ind_basis_mat (fir (basis_mat_indexes m)) (sec (basis_mat_indexes m))
    (rows m) (columns m))).

Axiom basis_mat_indexes_spec1 :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  (m =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) =>
     (indic_2 (fir (basis_mat_indexes m)) i (sec (basis_mat_indexes m)) j)))).

Axiom basis_mat_indexes_spec2 :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  ((get m (fir (basis_mat_indexes m)) (sec (basis_mat_indexes m))) = tone).

Axiom basis_mat_indexes_spec3 :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  forall (i:Z) (j:Z), (valid_index m i j) ->
  (i = (fir (basis_mat_indexes m))) -> ~ (j = (sec (basis_mat_indexes m))) ->
  ((get m i j) = tzero).

Axiom basis_mat_indexes_spec4 :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  valid_index m (fir (basis_mat_indexes m)) (sec (basis_mat_indexes m)).

Axiom get_basis_mat_indexes :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  (m =
   (ind_basis_mat (fir (basis_mat_indexes m)) (sec (basis_mat_indexes m))
    (rows m) (columns m))).

Axiom get_basis_mat_indexes1 :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  (m =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) =>
     (indic_2 (fir (basis_mat_indexes m)) i (sec (basis_mat_indexes m)) j)))).

Axiom get_basis_mat_indexes2 :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  ((get m (fir (basis_mat_indexes m)) (sec (basis_mat_indexes m))) = tone).

Axiom get_basis_mat_indexes3 :
  forall (m:matrix t), (mem m (basis_mat (rows m) (columns m))) ->
  forall (i:Z) (j:Z), (valid_index m i j) ->
  ~ ((basis_mat_indexes m) = (i, j)) -> ((get m i j) = tzero).

Axiom set_basis_mat_indexes :
  forall (m:matrix t) (i:Z) (j:Z), (valid_index m i j) ->
  (mem m (basis_mat (rows m) (columns m))) -> ((get m i j) = tone) ->
  ((basis_mat_indexes m) = (i, j)).

Axiom set_basis_mat_indexes1 :
  forall (m:matrix t) (i:Z) (j:Z), (valid_index m i j) ->
  (mem m (basis_mat (rows m) (columns m))) -> ((get m i j) = tone) ->
  (m = (ind_basis_mat i j (rows m) (columns m))).

Axiom set_basis_mat_indexes2 :
  forall (m:matrix t) (i:Z) (j:Z), (valid_index m i j) ->
  (mem m (basis_mat (rows m) (columns m))) -> ((get m i j) = tone) ->
  (m =
   (make_f (rows m) (columns m) (fun (i1:Z) (j1:Z) => (indic_2 i i1 j j1)))).

Axiom set_basis_mat_indexes3 :
  forall (m:matrix t) (i:Z) (j:Z), (valid_index m i j) ->
  (mem m (basis_mat (rows m) (columns m))) -> ((get m i j) = tone) ->
  forall (i1:Z) (j1:Z), (valid_index m i1 j1) -> (i1 = i) -> ~ (j1 = j) ->
  ((get m i1 j1) = tzero).

Parameter basis_projection: (matrix t) -> Z -> Z -> matrix t.

Axiom basis_projection_def :
  forall (m:matrix t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((basis_projection m i j) =
   (infix_asdtdt (get m i j) (ind_basis_mat i j (rows m) (columns m)))).

Axiom basis_projection_spec :
  forall (m:matrix t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((rows (basis_projection m i j)) = (rows m)).

Axiom basis_projection_spec1 :
  forall (m:matrix t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((columns (basis_projection m i j)) = (columns m)).

Axiom basis_projection_spec2 :
  forall (m:matrix t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((basis_projection m i j) =
   (make_f (rows m) (columns m)
    (fun (k:Z) (l:Z) => (infix_asdt (get m i j) (indic_2 k i l j))))).

Axiom basis_projection_spec3 :
  forall (m:matrix t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((get (basis_projection m i j) i j) = (get m i j)).

Axiom basis_projection_spec4 :
  forall (m:matrix t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) -> forall (i':Z) (j':Z),
  (valid_index (basis_projection m i j) i' j') -> ~ (i' = i) ->
  ((get (basis_projection m i j) i' j') = tzero).

Axiom basis_projection_spec5 :
  forall (m:matrix t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) -> forall (i':Z) (j':Z),
  (valid_index (basis_projection m i j) i' j') -> ~ (j' = j) ->
  ((get (basis_projection m i j) i' j') = tzero).

Axiom basis_projection_null :
  forall (m:matrix t) (i:Z) (j:Z) (k:Z) (l:Z), (valid_index m i j) ->
  (valid_index m k l) -> ~ (i = k) ->
  ((get (basis_projection m i j) k l) = tzero).

Axiom basis_projection_null1 :
  forall (m:matrix t) (i:Z) (j:Z) (k:Z) (l:Z), (valid_index m i j) ->
  (valid_index m k l) -> ~ (j = l) ->
  ((get (basis_projection m i j) k l) = tzero).

Parameter basis_projections: (matrix t) -> set (matrix t).

Parameter result16: (matrix t) -> (Z* Z)%type -> matrix t.

Axiom result_def16 :
  forall (m:matrix t) (o:(Z* Z)%type),
  ((valid_index m (fir o) (sec o)) ->
   (((result16 m) o) = (basis_projection m (fir o) (sec o)))) /\
  (~ (valid_index m (fir o) (sec o)) -> (((result16 m) o) = m)).

Axiom basis_projections_def :
  forall (m:matrix t),
  ((basis_projections m) = (map (result16 m) (to_indexes m))).

Axiom basis_projections_spec :
  forall (m:matrix t),
  ((basis_projections m) =
   (map
    ((fun (y0:Z -> Z -> matrix t) (y1:(Z* Z)%type) => (couple y0 y1))
     ((fun (y0:matrix t) (y1:Z) (y2:Z) => (basis_projection y0 y1 y2)) m))
    (to_indexes m))).

Axiom basis_projections_spec1 :
  forall (m:matrix t), forall (e1:matrix t),
  (mem e1 (basis_projections m)) -> ((rows e1) = (rows m)).

Axiom basis_projections_spec2 :
  forall (m:matrix t), forall (e1:matrix t),
  (mem e1 (basis_projections m)) -> ((columns e1) = (columns m)).

Axiom basis_projections_spec3 :
  forall (m:matrix t),
  constant_size (basis_projections m) (fun (y0:matrix t) => (p_id y0)).

Parameter fc9: (matrix t) -> (Z* Z)%type -> matrix t.

Axiom fc_def9 :
  forall (m:matrix t) (o:(Z* Z)%type),
  ((valid_index m (fir o) (sec o)) ->
   (((fc9 m) o) = (basis_projection m (fir o) (sec o)))) /\
  (~ (valid_index m (fir o) (sec o)) -> (((fc9 m) o) = m)).

Axiom rewrite_basis_projections :
  forall (m:matrix t), ((basis_projections m) = (map (fc9 m) (to_indexes m))).

Parameter indexes_decomp: (matrix t) -> matrix t.

Parameter result17: (matrix t) -> (Z* Z)%type -> matrix t.

Axiom result_def17 :
  forall (m:matrix t) (o:(Z* Z)%type),
  ((mem o (to_indexes m)) ->
   (((result17 m) o) = (basis_projection m (fir o) (sec o)))) /\
  (~ (mem o (to_indexes m)) -> (((result17 m) o) = m)).

Axiom indexes_decomp_def :
  forall (m:matrix t),
  ((indexes_decomp m) = (mat_sum (to_indexes m) (result17 m))).

Axiom indexes_decomp_spec :
  forall (m:matrix t), ((rows (indexes_decomp m)) = (rows m)).

Axiom indexes_decomp_spec1 :
  forall (m:matrix t), ((columns (indexes_decomp m)) = (columns m)).

Axiom rewrite_indexes_decomp :
  forall (m:matrix t),
  ((indexes_decomp m) =
   (mat_sum (to_indexes m)
    (fun (o:(Z* Z)%type) => (basis_projection m (fir o) (sec o))))).

Axiom indexes_decomp_pre :
  forall (m:matrix t) (i:Z) (j:Z), (valid_index m i j) ->
  ((get m i j) =
   (sum (to_indexes m)
    (fun (o:(Z* Z)%type) => (get (basis_projection m (fir o) (sec o)) i j)))).

Axiom indexes_decomp_pre_gen :
  forall (m:matrix t), forall (i:Z) (j:Z), (valid_index m i j) ->
  ((get m i j) =
   (sum (to_indexes m)
    (fun (o:(Z* Z)%type) => (get (basis_projection m (fir o) (sec o)) i j)))).

Axiom mat_to_indexes_decomp : forall (m:matrix t), (m = (indexes_decomp m)).

Parameter basis_decomp: (matrix t) -> matrix t.

Axiom basis_decomp_def :
  forall (m:matrix t),
  ((basis_decomp m) =
   (mat_sum (basis_projections m) (fun (y0:matrix t) => (p_id y0)))).

Axiom basis_decomp_spec :
  forall (m:matrix t), ((rows (basis_decomp m)) = (rows m)).

Axiom basis_decomp_spec1 :
  forall (m:matrix t), ((columns (basis_decomp m)) = (columns m)).

Axiom indexes_basis_decomp_equal_pre :
  forall (m:matrix t) (i:Z) (j:Z), (valid_index m i j) ->
  ((get (indexes_decomp m) i j) = (get (basis_decomp m) i j)).

Axiom indexes_basis_decomp_equal :
  forall (m:matrix t), ((indexes_decomp m) = (basis_decomp m)).

Axiom mat_to_basis_decomp : forall (m:matrix t), (m = (indexes_decomp m)).

Parameter fc10:
  forall {a:Type} {a_WT:WhyType a}, (matrix t) -> (set a) ->
  (a -> matrix t) -> a -> matrix t.

Axiom fc_def10 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s:set a) (f:a -> matrix t) (a1:a),
  ((mem a1 s) -> (((fc10 m s f) a1) = (mat_mult m (f a1)))) /\
  (~ (mem a1 s) -> (((fc10 m s f) a1) = m)).

Axiom product_mat_sum_r_pre :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s':set a) (s:set a) (f:a -> matrix t),
  (constant_size s f) -> ((columns m) = (s_rows s f)) -> (subset s' s) ->
  ((cardinal s') > 0%Z)%Z ->
  ((mat_mult m (mat_sum s' f)) = (mat_sum s' (fc10 m s f))).

Axiom product_mat_sum_r_pre1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s':set a) (s:set a) (f:a -> matrix t),
  (constant_size s f) -> ((columns m) = (s_rows s f)) -> (subset s' s) ->
  ((cardinal s') > 0%Z)%Z ->
  ((mat_mult m (mat_sum s' f)) =
   (mat_sum s' (fun (a1:a) => (mat_mult m (f a1))))).

Axiom product_mat_sum_r_pre2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s':set a) (s:set a) (f:a -> matrix t),
  (constant_size s f) -> ((columns m) = (s_rows s f)) -> (subset s' s) ->
  ((cardinal s') > 0%Z)%Z -> ((rows (mat_sum s' f)) = (s_rows s f)).

Axiom product_mat_sum_r_pre3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s':set a) (s:set a) (f:a -> matrix t),
  (constant_size s f) -> ((columns m) = (s_rows s f)) -> (subset s' s) ->
  ((cardinal s') > 0%Z)%Z -> ((columns (mat_sum s' f)) = (s_columns s f)).

Axiom product_mat_sum_r_pre4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s':set a) (s:set a) (f:a -> matrix t),
  (constant_size s f) -> ((columns m) = (s_rows s f)) -> (subset s' s) ->
  ((cardinal s') > 0%Z)%Z -> ((rows (mat_mult m (mat_sum s' f))) = (rows m)).

Axiom product_mat_sum_r_pre5 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s':set a) (s:set a) (f:a -> matrix t),
  (constant_size s f) -> ((columns m) = (s_rows s f)) -> (subset s' s) ->
  ((cardinal s') > 0%Z)%Z ->
  ((columns (mat_mult m (mat_sum s' f))) = (s_columns s f)).

Axiom product_mat_sum_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((columns m) = (s_rows s f)) -> ((cardinal s) > 0%Z)%Z ->
  ((mat_mult m (mat_sum s f)) =
   (mat_sum s (fun (a1:a) => (mat_mult m (f a1))))).

Axiom product_mat_sum_r_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix t) (s:set a) (f:a -> matrix t), (constant_size s f) ->
  ((columns m) = (s_rows s f)) -> ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s (fun (a1:a) => (mat_mult m (f a1)))) =
   (mat_mult m (mat_sum s f))).

Axiom p_injective_proj :
  forall (m:matrix t),
  p_injective
  ((fun (y0:Z -> Z -> matrix t) (y1:(Z* Z)%type) => (couple y0 y1))
   ((fun (y0:matrix t) (y1:Z) (y2:Z) => (basis_projection y0 y1 y2)) m))
  (nonn_mat_subset
   ((fun (y0:Z -> Z -> matrix t) (y1:(Z* Z)%type) => (couple y0 y1))
    ((fun (y0:matrix t) (y1:Z) (y2:Z) => (basis_projection y0 y1 y2)) m))
   (to_indexes m)).

Axiom mat_decomp_equal_indexes :
  forall (m:matrix t), (m = (indexes_decomp m)).

Parameter ket_basis: Z -> set (matrix t).

Axiom ket_basis_def :
  forall (n:Z), (0%Z <= n)%Z ->
  ((ket_basis n) = (basis_mat (power 2%Z n) 1%Z)).

Axiom ket_basis_spec :
  forall (n:Z), (0%Z <= n)%Z ->
  ((ket_basis n) =
   (map
    (fun (o:(Z* Z)%type) =>
     (ind_basis_mat (fir o) (sec o) (power 2%Z n) 1%Z))
    (cartesian_product (to_fset 0%Z (power 2%Z n)) (to_fset 0%Z 1%Z)))).

Axiom ket_basis_spec1 :
  forall (n:Z), (0%Z <= n)%Z ->
  ((ket_basis n) = (basis_mat (power 2%Z n) 1%Z)).

Axiom ket_basis_spec2 :
  forall (n:Z), (0%Z <= n)%Z -> forall (mat:matrix t),
  (mem mat (ket_basis n)) -> ((rows mat) = (power 2%Z n)).

Axiom ket_basis_spec3 :
  forall (n:Z), (0%Z <= n)%Z -> forall (mat:matrix t),
  (mem mat (ket_basis n)) -> ((columns mat) = 1%Z).

Axiom ket_basis_spec4 :
  forall (n:Z), (0%Z <= n)%Z -> forall (mat:matrix t),
  (mem mat (ket_basis n)) -> ((rows mat) = (power 2%Z n)).

Axiom ket_basis_spec5 :
  forall (n:Z), (0%Z <= n)%Z -> forall (mat:matrix t),
  (mem mat (ket_basis n)) -> ((columns mat) = 1%Z).

Axiom ket_basis_spec6 :
  forall (n:Z), (0%Z <= n)%Z -> forall (mat:matrix t),
  (mem mat (ket_basis n)) ->
  exists i:Z, (valid_index mat i 0%Z) /\ ((basis_mat_indexes mat) = (i, 0%Z)).

Axiom unary_ket_basis :
  forall (n:Z), (0%Z <= n)%Z ->
  ((ket_basis n) =
   (map (fun (i:Z) => (ind_basis_mat i 0%Z (power 2%Z n) 1%Z))
    (to_fset 0%Z (power 2%Z n)))).

Axiom to_ket_basis :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  mem (ind_basis_mat i 0%Z (power 2%Z n) 1%Z) (ket_basis n).

Parameter ket_basis_index: (matrix t) -> Z -> Z.

Axiom ket_basis_index_def :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (mem m (ket_basis n)) ->
  ((ket_basis_index m n) = (fir (basis_mat_indexes m))).

Axiom ket_basis_index_spec :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (mem m (ket_basis n)) ->
  mem (ind_basis_mat (ket_basis_index m n) 0%Z (power 2%Z n) 1%Z)
  (ket_basis n).

Axiom ket_basis_index_spec1 :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (mem m (ket_basis n)) ->
  (m =
   (make_f (rows m) 1%Z
    (fun (i:Z) (us:Z) => (indic (ket_basis_index m n) i)))).

Axiom ket_basis_index_spec2 :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (mem m (ket_basis n)) ->
  forall (i:Z), (valid_index m i 0%Z) -> ~ (i = (ket_basis_index m n)) ->
  ((get m i 0%Z) = tzero).

Axiom ket_basis_index_spec3 :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (mem m (ket_basis n)) ->
  valid_index m (ket_basis_index m n) 0%Z.

Axiom set_ket_basis :
  forall (m:matrix t) (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (mem m (ket_basis n)) ->
  ((get m i 0%Z) = tone) -> ((ket_basis_index m n) = i).

Axiom set_ket_basis1 :
  forall (m:matrix t) (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (mem m (ket_basis n)) ->
  ((get m i 0%Z) = tone) -> forall (i1:Z), (valid_index m i1 0%Z) ->
  ~ (i1 = i) -> ((get m i1 0%Z) = tzero).

Axiom set_ket_basis2 :
  forall (m:matrix t) (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (mem m (ket_basis n)) ->
  ((get m i 0%Z) = tone) -> mem m (ket_basis n).

Axiom set_ket_basis3 :
  forall (m:matrix t) (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (mem m (ket_basis n)) ->
  ((get m i 0%Z) = tone) ->
  (m = (make_f (rows m) (columns m) (fun (i1:Z) (us:Z) => (indic i i1)))).

Axiom from_ket_basis :
  forall (n:Z) (m:matrix t), (0%Z <= n)%Z -> (mem m (ket_basis n)) ->
  exists i:Z,
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
  (m = (ind_basis_mat i 0%Z (power 2%Z n) 1%Z)).

Axiom int_to_ket_basis :
  forall (n:Z) (i:Z), (n > 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> mem (ket n i) (ket_basis n).

Parameter is_a_ket_basis_elt: (matrix t) -> Prop.

Axiom is_a_ket_basis_elt_def :
  forall (m:matrix t),
  (is_a_ket_basis_elt m) <->
  ((is_a_ket m) /\ (mem m (ket_basis (ket_length m)))).

Axiom ket_basis_elt_are_kets :
  forall (m:matrix t), (is_a_ket_basis_elt m) -> is_a_ket m.

Axiom get_is_a_ket_basis_elt :
  forall (m:matrix t), (is_a_ket_basis_elt m) -> is_a_ket m.

Axiom get_is_a_ket_basis_elt1 :
  forall (m:matrix t), (is_a_ket_basis_elt m) ->
  mem m (ket_basis (ket_length m)).

Axiom get_is_a_ket_basis_elt2 :
  forall (m:matrix t), (is_a_ket_basis_elt m) ->
  exists i:Z,
  ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) /\
  (m = (ket (ket_length m) i)).

Axiom get_is_a_ket_basis_elt3 :
  forall (m:matrix t), (is_a_ket_basis_elt m) ->
  exists i:Z,
  ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) /\
  (((get m i 0%Z) = tone) /\
   forall (j:Z),
   (((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) /\
    ~ ((get m j 0%Z) = tzero)) ->
   (i = j)).

Axiom get_is_a_ket_basis_elt4 :
  forall (m:matrix t), (is_a_ket_basis_elt m) -> forall (i:Z),
  (((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) /\
   ((get m i 0%Z) = tone)) ->
  forall (j:Z),
  (((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) /\
   ~ ((get m j 0%Z) = tzero)) ->
  (i = j).

Axiom get_is_a_ket_basis_elt_indic :
  forall (m:matrix t), (is_a_ket_basis_elt m) ->
  exists i:Z,
  ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) /\
  forall (j:Z), ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) ->
  ((get m j 0%Z) = (indic i j)).

Axiom set_is_a_ket_basis_elt :
  forall (m:matrix t), (is_a_ket m) ->
  (exists i:Z,
   ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) /\
   (m = (ket (ket_length m) i))) ->
  is_a_ket_basis_elt m.

Axiom set_is_a_ket_basis_elt_exists :
  forall (m:matrix t), (is_a_ket m) ->
  (exists j:Z,
   ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) /\
   (m =
    (make_f (power 2%Z (ket_length m)) 1%Z (fun (i:Z) (us:Z) => (indic i j))))) ->
  is_a_ket_basis_elt m.

Axiom ket_func_sets_ket_basis_elts :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> is_a_ket_basis_elt (ket n i).

Axiom ket_func_sets_ket_basis_elts1 :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((ket_length (ket n i)) = n).

Axiom kronecker_is_a_ket_basis_elt :
  forall (x:matrix t) (y:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_basis_elt y) -> is_a_ket_basis_elt (kronecker x y).

Axiom ket_is_a_ket_basis_elt :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> is_a_ket_basis_elt (ket n i).

Axiom ket_basis_non_null_val :
  forall (m:matrix t) (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (is_a_ket_basis_elt m) ->
  ((ket_length m) = n) -> ~ ((get m i 0%Z) = tzero) -> (m = (ket n i)).

Parameter ket_to_int: (matrix t) -> Z.

Axiom ket_to_int_spec :
  forall (m:matrix t), (is_a_ket_basis_elt m) -> (0%Z <= (ket_to_int m))%Z.

Axiom ket_to_int_spec1 :
  forall (m:matrix t), (is_a_ket_basis_elt m) ->
  ((ket_to_int m) < (power 2%Z (ket_length m)))%Z.

Axiom ket_to_int_spec2 :
  forall (m:matrix t), (is_a_ket_basis_elt m) ->
  ((get m (ket_to_int m) 0%Z) = tone).

Axiom ket_to_int_spec3 :
  forall (m:matrix t), (is_a_ket_basis_elt m) ->
  (m = (ket (ket_length m) (ket_to_int m))).

Axiom ket_to_int_spec4 :
  forall (m:matrix t), (is_a_ket_basis_elt m) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) ->
  (m = (ket (ket_length m) i)) -> (i = (ket_to_int m)).

Axiom ket_to_int_ket :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((ket_to_int (ket n i)) = i).

Parameter bin_to_ket: Z -> (Z -> Z) -> matrix t.

Axiom bin_to_ket_def :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  ((bin_to_ket n bvx) = (ket n (bin_to_int bvx n))).

Axiom bin_to_ket_spec :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  is_a_ket_basis_elt (bin_to_ket n bvx).

Axiom bin_to_ket_spec1 :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  ((ket_length (bin_to_ket n bvx)) = n).

Axiom bin_to_ket_spec2 :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  ((ket_to_int (bin_to_ket n bvx)) = (bin_to_int bvx n)).

Axiom bin_to_ket_spec3 :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  ((rows (bin_to_ket n bvx)) = (power 2%Z n)).

Axiom bin_to_ket_spec4 :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  ((columns (bin_to_ket n bvx)) = 1%Z).

Axiom bin_to_ket_spec5 :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  is_a_ket (bin_to_ket n bvx).

Axiom bin_to_ket_spec6 :
  forall (n:Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (binary bvx) ->
  is_a_ket_l (bin_to_ket n bvx) n.

Axiom bin_to_ket_l :
  forall (n:Z) (n':Z) (bvx:Z -> Z), (n >= 0%Z)%Z -> (n = n') ->
  (binary bvx) -> is_a_ket_l (bin_to_ket n bvx) n'.

Axiom bin_to_ket_eq :
  forall (n1:Z) (n2:Z) (bvx1:Z -> Z) (bvx2:Z -> Z), (n1 >= 0%Z)%Z ->
  (binary bvx1) -> (binary bvx2) -> (n2 = n1) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n1)%Z) -> ((bvx1 i) = (bvx2 i))) ->
  ((bin_to_ket n1 bvx1) = (bin_to_ket n2 bvx2)).

Axiom kronecker_kets_bin_to_ket :
  forall (f1:Z -> Z) (f2:Z -> Z) (n1:Z) (n2:Z), (binary f1) -> (binary f2) ->
  (0%Z <= n1)%Z -> (0%Z <= n2)%Z ->
  ((kronecker (bin_to_ket n1 f1) (bin_to_ket n2 f2)) =
   (bin_to_ket (n1 + n2)%Z
    ((((fun (y0:Z -> Z) (y1:Z -> Z) (y2:Z) (y3:Z) =>
        (concat_fun y0 y1 y2 y3))
       f1)
      f2)
     n1))).

Axiom kronecker_ket_to_int :
  forall (x:matrix t) (y:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_basis_elt y) -> is_a_ket_basis_elt (kronecker x y).

Axiom kronecker_ket_to_int1 :
  forall (x:matrix t) (y:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_basis_elt y) ->
  ((ket_length (kronecker x y)) = ((ket_length x) + (ket_length y))%Z).

Axiom kronecker_ket_to_int2 :
  forall (x:matrix t) (y:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_basis_elt y) ->
  ((kronecker x y) =
   (ket ((ket_length x) + (ket_length y))%Z
    (((ket_to_int x) * (power 2%Z (ket_length y)))%Z + (ket_to_int y))%Z)).

Axiom kronecker_ket_to_int3 :
  forall (x:matrix t) (y:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_basis_elt y) ->
  ((ket_to_int (kronecker x y)) =
   (((ket_to_int x) * (power 2%Z (ket_length y)))%Z + (ket_to_int y))%Z).

Axiom ket_ket_to_int :
  forall (x:matrix t), (is_a_ket_basis_elt x) ->
  ((ket (ket_length x) (ket_to_int x)) = x).

Axiom ket_ket_to_int_values :
  forall (x:matrix t), (is_a_ket_basis_elt x) -> forall (i:Z) (j:Z),
  (valid_index x i j) -> ((get x i j) = (indic i (ket_to_int x))).

Parameter ket_basis_projection: (matrix t) -> Z -> matrix t.

Axiom ket_basis_projection_def :
  forall (m:matrix t) (j:Z), (is_a_ket m) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) ->
  ((ket_basis_projection m j) =
   (infix_asdtdt (get m j 0%Z) (ket (ket_length m) j))).

Axiom ket_basis_projection_spec :
  forall (m:matrix t) (j:Z), (is_a_ket m) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) ->
  ((ket_basis_projection m j) = (basis_projection m j 0%Z)).

Axiom ket_basis_projection_columns :
  forall (m:matrix t) (j:Z), (is_a_ket m) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) ->
  ((columns (ket_basis_projection m j)) = 1%Z).

Axiom ket_basis_projection_rows :
  forall (m:matrix t) (j:Z), (is_a_ket m) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) ->
  ((rows (ket_basis_projection m j)) = (rows m)).

Parameter ket_basis_projections: (matrix t) -> set (matrix t).

Parameter result18: (matrix t) -> Z -> matrix t.

Axiom result_def18 :
  forall (m:matrix t) (j:Z),
  ((mem j (to_fset 0%Z (power 2%Z (ket_length m)))) ->
   (((result18 m) j) = (ket_basis_projection m j))) /\
  (~ (mem j (to_fset 0%Z (power 2%Z (ket_length m)))) ->
   (((result18 m) j) = m)).

Axiom ket_basis_projections_def :
  forall (m:matrix t), (is_a_ket m) ->
  ((ket_basis_projections m) =
   (map (result18 m) (to_fset 0%Z (power 2%Z (ket_length m))))).

Axiom ket_basis_projections_spec :
  forall (m:matrix t), (is_a_ket m) ->
  ((ket_basis_projections m) = (basis_projections m)).

Parameter ket_basis_projections_antec: (matrix t) -> unit.

Axiom ket_basis_projections_antec_def :
  forall (m:matrix t), (is_a_ket m) -> ((ket_basis_projections_antec m) = tt).

Axiom ket_basis_projections_antec_spec :
  forall (m:matrix t), (is_a_ket m) -> forall (e1:matrix t),
  (mem e1 (ket_basis_projections m)) ->
  exists j:Z,
  ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) /\
  (e1 = (ket_basis_projection m j)).

Axiom ket_basis_projections_antec_spec1 :
  forall (m:matrix t), (is_a_ket m) -> forall (e1:matrix t),
  (exists j:Z,
   ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length m)))%Z) /\
   (e1 = (ket_basis_projection m j))) ->
  mem e1 (ket_basis_projections m).

Axiom ket_basis_projections_antec_spec2 :
  forall (m:matrix t), (is_a_ket m) -> forall (e1:matrix t),
  (mem e1 (ket_basis_projections m)) ->
  exists j:Z, exists i:Z,
  (valid_index m j i) /\ (e1 = (basis_projection m j i)).

Axiom ket_basis_projections_antec_spec3 :
  forall (m:matrix t), (is_a_ket m) -> forall (e1:matrix t),
  (exists j:Z, exists i:Z,
   (valid_index m j i) /\ (e1 = (basis_projection m j i))) ->
  mem e1 (ket_basis_projections m).

Parameter ket_sum:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix t) -> matrix t.

Axiom ket_sum_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket (f e1)) ->
  (exists l:Z, forall (e1:a), (mem e1 s) -> ((ket_length (f e1)) = l)) ->
  ((ket_sum s f) = (mat_sum s f)).

Axiom ket_sum_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket (f e1)) ->
  (exists l:Z, forall (e1:a), (mem e1 s) -> ((ket_length (f e1)) = l)) ->
  forall (i:Z), (ket_valid_index (ket_sum s f) i) ->
  ((get_ket (ket_sum s f) i) = (sum s (fun (e1:a) => (get_ket (f e1) i)))).

Axiom ket_sum_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket (f e1)) ->
  (exists l:Z, forall (e1:a), (mem e1 s) -> ((ket_length (f e1)) = l)) ->
  is_a_ket (ket_sum s f).

Axiom ket_sum_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket (f e1)) ->
  (exists l:Z, forall (e1:a), (mem e1 s) -> ((ket_length (f e1)) = l)) ->
  forall (e1:a), (mem e1 s) ->
  ((ket_length (ket_sum s f)) = (ket_length (f e1))).

Parameter ket_sum_l:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix t) -> Z ->
  matrix t.

Axiom ket_sum_l_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((ket_sum_l s f l) = (mat_sum s f)).

Axiom ket_sum_l_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  is_a_ket (ket_sum_l s f l).

Axiom ket_sum_l_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) -> forall (i:Z),
  (ket_valid_index (ket_sum_l s f l) i) ->
  ((get_ket (ket_sum_l s f l) i) =
   (sum s (fun (e1:a) => (get_ket (f e1) i)))).

Axiom ket_sum_l_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  is_a_ket_l (ket_sum_l s f l) l.

Axiom ket_sum_l_spec3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((ket_length (ket_sum_l s f l)) = l).

Axiom ket_sum_l_rows :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((rows (ket_sum_l s f l)) = (power 2%Z l)).

Axiom ket_sum_l_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z l))%Z) -> (j = 0%Z) ->
  ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((get (ket_sum_l s f l) i j) = (sum s (fun (e1:a) => (get (f e1) i 0%Z)))).

Axiom get_ket_sum_l_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z) (i:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z l))%Z) -> ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((get_ket (ket_sum_l s f l) i) =
   (sum s (fun (e1:a) => (get_ket (f e1) i)))).

Axiom ket_sum_l_columns :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((columns (ket_sum_l s f l)) = 1%Z).

Axiom ket_sum_null_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (e1:a), ((cardinal s) > 1%Z)%Z ->
  (forall (e2:a), (mem e2 s) -> is_a_ket (f e2)) -> (constant_size s f) ->
  (mem e1 s) ->
  (forall (e':a), (mem e' s) -> ~ (e1 = e') -> null_mat (f e')) ->
  ((ket_sum s f) = (f e1)).

Axiom ket_sum_null :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 1%Z)%Z ->
  (l >= 0%Z)%Z -> (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  (forall (e1:a), (mem e1 s) -> null_mat (f e1)) -> forall (j:Z),
  ((0%Z <= j)%Z /\ (j < (power 2%Z l))%Z) ->
  ((get_ket (ket_sum_l s f l) j) = tzero).

Axiom ket_sum_l_null_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix t) (s:set a) (e1:a) (l:Z), ((cardinal s) > 1%Z)%Z ->
  (forall (e2:a), (mem e2 s) -> is_a_ket_l (f e2) l) -> (mem e1 s) ->
  (forall (e':a), (mem e' s) -> ~ (e1 = e') -> null_mat (f e')) ->
  ((ket_sum_l s f l) = (f e1)).

Axiom ket_sum_ket_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  is_a_ket_l (ket_sum_l s f l) l.

Axiom ket_sum_comp_l :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix t) (g:b -> matrix t) (l:Z),
  ((cardinal s) > 0%Z)%Z ->
  (forall (e1:b), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  (forall (e1:b), (mem e1 s) -> is_a_ket_l (g e1) l) ->
  ((ket_sum_l s (fun (k:b) => (add_ket_l (f k) (g k) l)) l) =
   (add_ket_l (ket_sum_l s f l) (ket_sum_l s g l) l)).

Axiom ket_sum_comp_l_rev :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix t) (g:b -> matrix t) (l:Z),
  ((cardinal s) > 0%Z)%Z ->
  (forall (e1:b), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  (forall (e1:b), (mem e1 s) -> is_a_ket_l (g e1) l) ->
  ((add_ket_l (ket_sum_l s f l) (ket_sum_l s g l) l) =
   (ket_sum_l s (fun (k:b) => (add_ket_l (f k) (g k) l)) l)).

Axiom ket_sum_scalar_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (a1:t) (l:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((cardinal s) > 0%Z)%Z ->
  ((ket_sum_l s (fun (k:a) => (infix_asdtdt a1 (f k))) l) =
   (infix_asdtdt a1 (ket_sum_l s f l))).

Axiom ket_l_ket_sum_scalar :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (a1:t) (l:Z) (n:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((cardinal s) > 0%Z)%Z -> (l = n) ->
  is_a_ket_l (infix_asdtdt a1 (ket_sum_l s f l)) n.

Axiom scal_ket_sum_scalar_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (b:t) (l:Z) (l':Z),
  (forall (e1:a), (mem e1 s) ->
   exists a1:t,
   exists k:matrix t, ((f e1) = (infix_asdtdt a1 k)) /\ (is_a_ket_l k l)) ->
  ((cardinal s) > 0%Z)%Z -> (l = l') ->
  is_a_ket_l (infix_asdtdt b (ket_sum_l s f l)) l'.

Axiom ket_sum_scalar_rev_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (a1:t) (l:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((cardinal s) > 0%Z)%Z ->
  ((infix_asdtdt a1 (ket_sum_l s f l)) =
   (ket_sum_l s (fun (k:a) => (infix_asdtdt a1 (f k))) l)).

Axiom ket_sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix t) (g:a -> matrix t) (l:Z),
  ((cardinal s) > 0%Z)%Z -> (s = s') ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  (forall (a1:a), (mem a1 s) -> ((f a1) = (g a1))) ->
  ((ket_sum_l s f l) = (ket_sum_l s' g l)).

Axiom ket_sum_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix t) (g:a -> matrix t) (l1:Z)
    (l2:Z),
  ((cardinal s) > 0%Z)%Z -> (s = s') -> (l1 = l2) ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) ->
  (forall (a1:a), (mem a1 s) -> ((f a1) = (g a1))) ->
  ((ket_sum_l s f l1) = (ket_sum_l s' g l2)).

Axiom ket_sum_bvs_eq :
  forall (n1:Z) (n2:Z) (f:bitvec -> matrix t) (g:bitvec -> matrix t) 
    (l1:Z) (l2:Z),
  (l1 = l2) -> (n1 = n2) -> (n1 >= 0%Z)%Z ->
  (forall (e1:bitvec), (mem e1 (n_bvs n1)) -> is_a_ket_l (f e1) l1) ->
  (forall (e1:bitvec), (mem e1 (n_bvs n1)) -> ((f e1) = (g e1))) ->
  ((ket_sum_l (n_bvs n1) f l1) = (ket_sum_l (n_bvs n2) g l2)).

Axiom ket_sum_scal_bvs_eq :
  forall (n1:Z) (n2:Z) (f:bitvec -> matrix t) (g:bitvec -> matrix t) 
    (l1:Z) (l2:Z) (s1:t) (s2:t),
  (l1 = l2) -> (n1 = n2) -> (s1 = s2) -> (n1 >= 0%Z)%Z ->
  (forall (e1:bitvec), (mem e1 (n_bvs n1)) -> is_a_ket_l (f e1) l1) ->
  (forall (e1:bitvec), (mem e1 (n_bvs n1)) -> ((f e1) = (g e1))) ->
  ((infix_asdtdt s1 (ket_sum_l (n_bvs n1) f l1)) =
   (infix_asdtdt s2 (ket_sum_l (n_bvs n2) g l2))).

Axiom ket_sum_sum_bvs_eq :
  forall (n1:Z) (n2:Z) (n1':Z) (n2':Z) (f:bitvec -> bitvec -> matrix t)
    (g:bitvec -> bitvec -> matrix t) (l1:Z) (l2:Z) (l1':Z) (l2':Z),
  ((l1 = l2) /\ ((l2 = l1') /\ (l1' = l2'))) -> (n1 = n1') ->
  (n1 >= 0%Z)%Z -> (n2 = n2') -> (n2 >= 0%Z)%Z ->
  (forall (e1:bitvec) (e':bitvec), (mem e1 (n_bvs n1)) ->
   (mem e' (n_bvs n2)) -> is_a_ket_l ((f e1) e') l1) ->
  (forall (e1:bitvec) (e':bitvec), (mem e1 (n_bvs n1)) ->
   (mem e' (n_bvs n2)) -> (((f e1) e') = ((g e1) e'))) ->
  ((ket_sum_l (n_bvs n1) (fun (k:bitvec) => (ket_sum_l (n_bvs n2) (f k) l1))
    l2)
   =
   (ket_sum_l (n_bvs n1')
    (fun (k:bitvec) => (ket_sum_l (n_bvs n2') (g k) l1')) l2')).

Axiom ket_sum_sum_scal_bvs_eq :
  forall (n1:Z) (n2:Z) (n1':Z) (n2':Z) (f:bitvec -> bitvec -> matrix t)
    (g:bitvec -> bitvec -> matrix t) (l1:Z) (l2:Z) (l1':Z) (l2':Z) (s1:t)
    (s2:t),
  ((l1 = l2) /\ ((l2 = l1') /\ (l1' = l2'))) -> (n1 = n1') ->
  (n1 >= 0%Z)%Z -> (n2 = n2') -> (s1 = s2) -> (n2 >= 0%Z)%Z ->
  (forall (e1:bitvec) (e':bitvec), (mem e1 (n_bvs n1)) ->
   (mem e' (n_bvs n2)) -> is_a_ket_l ((f e1) e') l1) ->
  (forall (e1:bitvec) (e':bitvec), (mem e1 (n_bvs n1)) ->
   (mem e' (n_bvs n2)) -> (((f e1) e') = ((g e1) e'))) ->
  ((infix_asdtdt s1
    (ket_sum_l (n_bvs n1) (fun (k:bitvec) => (ket_sum_l (n_bvs n2) (f k) l1))
     l2))
   =
   (infix_asdtdt s1
    (ket_sum_l (n_bvs n1')
     (fun (k:bitvec) => (ket_sum_l (n_bvs n2') (g k) l1')) l2'))).

Axiom ket_sum_sum_scal_mult_bvs_eq :
  forall (n1:Z) (n2:Z) (n1':Z) (n2':Z) (f:bitvec -> bitvec -> matrix t)
    (g:bitvec -> bitvec -> matrix t) (l1:Z) (l2:Z) (l1':Z) (l2':Z) (s1:t)
    (s2:t) (s3:t),
  ((l1 = l2) /\ ((l2 = l1') /\ (l1' = l2'))) -> (n1 = n1') ->
  (n1 >= 0%Z)%Z -> (s3 = (infix_asdt s1 s2)) -> (n2 = n2') ->
  (n2 >= 0%Z)%Z ->
  (forall (e1:bitvec) (e':bitvec), (mem e1 (n_bvs n1)) ->
   (mem e' (n_bvs n2)) -> is_a_ket_l ((f e1) e') l1) ->
  (forall (e1:bitvec) (e':bitvec), (mem e1 (n_bvs n1)) ->
   (mem e' (n_bvs n2)) -> (((f e1) e') = ((g e1) e'))) ->
  ((infix_asdtdt s1
    (ket_sum_l (n_bvs n1')
     (fun (k:bitvec) => (infix_asdtdt s2 (ket_sum_l (n_bvs n2') (f k) l1')))
     l2'))
   =
   (infix_asdtdt s3
    (ket_sum_l (n_bvs n1) (fun (k:bitvec) => (ket_sum_l (n_bvs n2) (g k) l1))
     l2))).

Axiom ket_sum_l_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z), ((cardinal s) = 1%Z) ->
  (is_a_ket_l (f (choose s)) l) -> ((ket_sum_l s f l) = (f (choose s))).

Axiom ket_sum_l_plus_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (e1:a) (f:a -> matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  ~ (mem e1 s) -> (forall (e2:a), (mem e2 s) -> is_a_ket_l (f e2) l) ->
  (is_a_ket_l (f e1) l) ->
  ((ket_sum_l (add e1 s) f l) = (add_ket_l (ket_sum_l s f l) (f e1) l)).

Axiom ket_sum_l_valid_index :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (l:Z) (i:Z), ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  (forall (e1:a), (mem e1 s) -> ket_valid_index (f e1) i) ->
  ket_valid_index (ket_sum_l s f l) i.

Axiom ket_sum_const :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (is_a_ket_l x l) ->
  ((ket_sum_l s (fun (us:a) => x) l) =
   (infix_asdtdt (i_to_t (cardinal s)) x)).

Axiom ket_sum_const_w :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:matrix t) (l:Z), ((cardinal s) > 0%Z)%Z ->
  (is_a_ket_l x l) ->
  ((infix_asdtdt (infix_sldt tone (i_to_t (cardinal s)))
    (ket_sum_l s (fun (us:a) => x) l))
   = x).

Axiom map_ket_sum_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> matrix t) (s:set a) (t1:a -> b) (n:Z),
  ((cardinal s) > 0%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f (t1 e1)) n) ->
  (p_injective t1 s) ->
  ((ket_sum_l (map t1 s) f n) = (ket_sum_l s (fun (a1:a) => (f (t1 a1))) n)).

Axiom ket_norm_l_unif_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (c:Z) (n:Z), (n >= 0%Z)%Z ->
  ((cardinal s) = c) -> (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) n) ->
  (forall (e1:a), (mem e1 s) -> ((ket_norm_l (f e1) n) = tone)) ->
  ((ket_norm_l
    (infix_asdtdt (infix_sldt tone (square_rt (i_to_t c))) (ket_sum_l s f n))
    n)
   = tone).

Axiom ket_sum_partition :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s1:set a) (s2:set a) (f:a -> matrix t) (n:Z),
  (0%Z <= n)%Z -> (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) n) ->
  (s = (union s1 s2)) -> ((inter s1 s2) = (empty : set a)) ->
  ((ket_sum_l s f n) = (add_mat (ket_sum_l s1 f n) (ket_sum_l s2 f n))).

Axiom ket_decomp :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((ket_length m) = n) ->
  (m =
   (mat_sum (to_fset 0%Z (power 2%Z n))
    (fun (j:Z) => (infix_asdtdt (get m j 0%Z) (ket n j))))).

Axiom ket_decomp_bv :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((ket_length m) = n) ->
  (m =
   (ket_sum_l (n_bvs n)
    (fun (bvx:bitvec) =>
     (infix_asdtdt (get m (bv_to_int bvx) 0%Z) (ket n (bv_to_int bvx))))
    n)).

Axiom ket_recomp :
  forall (f:Z -> t) (n:Z), (0%Z <= n)%Z ->
  ((mat_sum (to_fset 0%Z (power 2%Z n))
    (fun (j:Z) => (infix_asdtdt (f j) (ket n j))))
   = (make_f (power 2%Z n) 1%Z (fun (x:Z) (us:Z) => (f x)))).

Axiom ket_decomp_quant :
  forall (m:matrix t), (is_a_ket m) ->
  (m =
   (mat_sum (to_fset 0%Z (power 2%Z (ket_length m)))
    (fun (j:Z) => (infix_asdtdt (get m j 0%Z) (ket (ket_length m) j))))).

Axiom mat_mult_ket_basis :
  forall (m:matrix t) (x:matrix t), (is_a_ket_basis_elt x) ->
  (((columns m) = (rows m)) /\ ((rows m) = (rows x))) ->
  ((mat_mult m x) =
   (mat_sum (to_fset 0%Z (rows x))
    (fun (k:Z) =>
     (infix_asdtdt (get m k (ket_to_int x)) (ket (ket_length x) k))))).

Axiom ket_mult_diag :
  forall (m:matrix t) (x:matrix t), ((ket_length x) >= 1%Z)%Z ->
  (is_a_ket_basis_elt x) -> ((rows m) = (power 2%Z (ket_length x))) ->
  ((columns m) = (power 2%Z (ket_length x))) ->
  (forall (i:Z) (j:Z),
   ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length x)))%Z) ->
   ((0%Z <= j)%Z /\ (j < (power 2%Z (ket_length x)))%Z) -> ~ (i = j) ->
   ((get m i j) = tzero)) ->
  ((mat_mult m x) =
   (infix_asdtdt (get m (ket_to_int x) (ket_to_int x))
    (ket (ket_length x) (ket_to_int x)))).

Axiom mat_mult_ket_basis_bv :
  forall (m:matrix t) (x:matrix t) (n:Z), ((ket_length x) = n) ->
  (is_a_ket_basis_elt x) ->
  (((columns m) = (rows m)) /\ ((rows m) = (rows x))) ->
  ((mat_mult m x) =
   (ket_sum_l (n_bvs n)
    (fun (bvx:bitvec) =>
     (infix_asdtdt (get m (bv_to_int bvx) (ket_to_int x))
      (ket n (bv_to_int bvx))))
    n)).

Axiom mat_mult_ket_basis_bv_gen :
  forall (m:matrix t) (x:matrix t), (is_a_ket_basis_elt x) ->
  (((columns m) = (rows m)) /\ ((rows m) = (rows x))) ->
  ((mat_mult m x) =
   (ket_sum_l (n_bvs (ket_length x))
    (fun (bvx:bitvec) =>
     (infix_asdtdt (get m (bv_to_int bvx) (ket_to_int x))
      (ket (ket_length x) (bv_to_int bvx))))
    (ket_length x))).

Axiom mat_mult_ket_bv :
  forall (m:matrix t) (x:matrix t) (n:Z), (is_a_ket_l x n) ->
  (((columns m) = (rows m)) /\
   (((rows m) = (rows x)) /\ ((rows x) = (power 2%Z n)))) ->
  ((mat_mult m x) =
   (ket_sum_l (n_bvs n)
    (fun (bvx:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int bvx))
      (mat_mult m (ket n (bv_to_int bvx)))))
    n)).

Axiom mat_mult_ket_bv_gen :
  forall (m:matrix t) (x:matrix t), (is_a_ket x) ->
  (((columns m) = (rows m)) /\ ((rows m) = (rows x))) ->
  ((mat_mult m x) =
   (ket_sum_l (n_bvs (ket_length x))
    (fun (bvx:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int bvx))
      (mat_mult m (ket (ket_length x) (bv_to_int bvx)))))
    (ket_length x))).

Axiom fun_inversion_pre :
  forall (f:Z -> Z) (s:set Z) (s':set Z) (a:Z -> t) (n:Z), (0%Z <= n)%Z ->
  ((cardinal s) > 0%Z)%Z -> (p_bijective f s s') ->
  (subset s (to_fset 0%Z n)) -> (subset s' (to_fset 0%Z n)) ->
  ((mat_sum s
    (fun (j:Z) =>
     (infix_asdtdt (a j) (set1 (make n 1%Z tzero) (f j) 0%Z tone))))
   =
   (mat_sum s'
    (fun (j:Z) =>
     (infix_asdtdt (a (inv_func f s s' j))
      (set1 (make n 1%Z tzero) j 0%Z tone))))).

Axiom ket_fun_inversion :
  forall (f:Z -> Z) (a:Z -> t) (m:matrix t) (pow_2_n:Z),
  (pow_2_n = (power 2%Z (ket_length m))) -> (is_a_ket m) ->
  (pow_2_n > 0%Z)%Z ->
  (p_bijective f (to_fset 0%Z pow_2_n) (to_fset 0%Z pow_2_n)) ->
  (m =
   (mat_sum (to_fset 0%Z pow_2_n)
    (fun (j:Z) => (infix_asdtdt (a j) (ket (ket_length m) (f j)))))) ->
  (m =
   (mat_sum (to_fset 0%Z pow_2_n)
    (fun (j:Z) =>
     (infix_asdtdt (a (inv_ f (to_fset 0%Z pow_2_n) (to_fset 0%Z pow_2_n) j))
      (ket (ket_length m) j))))).

Parameter ket_to_bv: (matrix t) -> bitvec.

Axiom ket_to_bv_def :
  forall (x:matrix t), (is_a_ket_basis_elt x) ->
  ((ket_to_bv x) = (int_to_bv (ket_to_int x) (ket_length x))).

Axiom ket_to_bv_spec :
  forall (x:matrix t), (is_a_ket_basis_elt x) ->
  ((bv_to_int (ket_to_bv x)) = (ket_to_int x)).

Axiom ket_to_bv_spec1 :
  forall (x:matrix t), (is_a_ket_basis_elt x) ->
  ((length (ket_to_bv x)) = (ket_length x)).

Axiom ket_to_bv_spec2 :
  forall (x:matrix t), (is_a_ket_basis_elt x) ->
  mem (ket_to_bv x) (n_bvs (ket_length x)).

Axiom ket_to_bv_length :
  forall (x:matrix t) (n:Z), (is_a_ket_basis_elt x) ->
  ((ket_length x) = n) -> ((length (ket_to_bv x)) = n).

Parameter bv_to_ket: bitvec -> matrix t.

Axiom bv_to_ket_def :
  forall (bv:bitvec), ((bv_to_ket bv) = (ket (length bv) (bv_to_int bv))).

Axiom bv_to_ket_spec : forall (bv:bitvec), is_a_ket_basis_elt (bv_to_ket bv).

Axiom bv_to_ket_spec1 :
  forall (bv:bitvec), ((ket_to_int (bv_to_ket bv)) = (bv_to_int bv)).

Axiom bv_to_ket_spec2 :
  forall (bv:bitvec), ((ket_length (bv_to_ket bv)) = (length bv)).

Axiom bv_to_ket_spec3 :
  forall (bv:bitvec), ((rows (bv_to_ket bv)) = (power 2%Z (length bv))).

Axiom bv_to_ket_spec4 : forall (bv:bitvec), ((columns (bv_to_ket bv)) = 1%Z).

Axiom bv_to_ket_spec5 :
  forall (bv:bitvec), ((bv_to_ket bv) = (bin_to_ket (length bv) (getbv bv))).

Axiom ket_to_bv_ket_length :
  forall (i:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((length (ket_to_bv (ket n i))) = n).

Axiom is_a_ket_l_bv_to_ket :
  forall (bv:bitvec) (l:Z), ((length bv) = l) -> is_a_ket_l (bv_to_ket bv) l.

Axiom bin_to_ket_to_bv_to_ket :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  ((bin_to_ket n f) = (bv_to_ket (make_bv f n))).

Axiom bin_to_ket_to_bv_to_ket_abs :
  forall (f:Z -> Z) (n:Z) (a:bitvec), (0%Z <= n)%Z -> (a = (make_bv f n)) ->
  (binary f) -> ((bin_to_ket n f) = (bv_to_ket a)).

Axiom ket_to_int_to_bv_to_ket :
  forall (n:Z) (e1:bitvec), (0%Z <= n)%Z -> (mem e1 (n_bvs n)) ->
  ((ket n (bv_to_int e1)) = (bv_to_ket e1)).

Axiom ket_to_bv_ket :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((ket_to_bv (ket n i)) = (int_to_bv i n)).

Axiom bv_to_ket_length :
  forall (bv:bitvec), ((ket_length (bv_to_ket bv)) = (length bv)).

Axiom is_a_ket_l_bvs :
  forall (e1:bitvec) (n:Z), (0%Z <= n)%Z -> (mem e1 (n_bvs n)) ->
  is_a_ket_l (bv_to_ket e1) n.

Axiom is_a_ket_l_scal_bvs :
  forall (e1:bitvec) (n:Z) (a:t), (0%Z <= n)%Z -> (mem e1 (n_bvs n)) ->
  is_a_ket_l (infix_asdtdt a (bv_to_ket e1)) n.

Axiom ket_to_bv_concat :
  forall (x:bitvec) (y:bitvec),
  ((bv_to_ket (concat x y)) = (kronecker (bv_to_ket x) (bv_to_ket y))).

Axiom bv_to_ket_concat_rev :
  forall (x:bitvec) (y:bitvec),
  ((kronecker (bv_to_ket x) (bv_to_ket y)) = (bv_to_ket (concat x y))).

Axiom bv_to_ket_to_bv :
  forall (bv:bitvec), ((ket_to_bv (bv_to_ket bv)) = bv).

Axiom ket_to_bv_to_ket :
  forall (x:matrix t), (is_a_ket_basis_elt x) ->
  ((bv_to_ket (ket_to_bv x)) = x).

Axiom bv_to_ket_eq :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
   (((getbv bv1) i) = ((getbv bv2) i))) ->
  ((bv_to_ket bv1) = (bv_to_ket bv2)).

Axiom ket_to_bv_kronecker :
  forall (x:matrix t) (y:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_basis_elt y) ->
  ((ket_to_bv (kronecker x y)) = (concat (ket_to_bv x) (ket_to_bv y))).

Axiom ket_decomp_bv_ket :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((ket_length m) = n) ->
  (m =
   (ket_sum_l (n_bvs n)
    (fun (bvx:bitvec) =>
     (infix_asdtdt (get_ket m (bv_to_int bvx)) (ket n (bv_to_int bvx))))
    n)).

Axiom ket_zero : forall (n:Z), (n >= 0%Z)%Z -> is_a_ket_l (ket n 0%Z) n.

Axiom ket_zero1 :
  forall (n:Z), (n >= 0%Z)%Z -> is_a_ket_basis_elt (ket n 0%Z).

Axiom ket_zero2 :
  forall (n:Z), (n >= 0%Z)%Z ->
  ((ket_to_bv (ket n 0%Z)) = (make_bv (fun (us:Z) => 0%Z) n)).

Axiom ket_zero3 :
  forall (n:Z), (n >= 0%Z)%Z -> forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((getbv (ket_to_bv (ket n 0%Z))) i) = 0%Z).

Axiom uniform_ket_norm_l :
  forall (x:matrix t) (f:bitvec -> t) (n:Z), (is_a_ket_l x n) ->
  (forall (e1:bitvec), (mem e1 (n_bvs n)) -> ((modulus (f e1)) = tone)) ->
  (x =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (x1:bitvec) => (infix_asdtdt (f x1) (bv_to_ket x1))) n))) ->
  ((ket_norm_l x n) = tone).

Axiom ket_sum_of_scalars :
  forall (f:bitvec -> t) (n:Z), (n >= 0%Z)%Z ->
  is_a_ket_l
  (ket_sum_l (n_bvs n) (fun (x:bitvec) => (infix_asdtdt (f x) (bv_to_ket x)))
   n)
  n.

Axiom ket_sum_of_scalars1 :
  forall (f:bitvec -> t) (n:Z), (n >= 0%Z)%Z -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((get
    (ket_sum_l (n_bvs n)
     (fun (x:bitvec) => (infix_asdtdt (f x) (bv_to_ket x))) n)
    i 0%Z)
   = (f (int_to_bv i n))).

Axiom mat_sum_sum_cartesian_product_pre :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (f:a -> b -> matrix t) (r:Z) (c:Z),
  (0%Z < r)%Z -> (0%Z < c)%Z ->
  (forall (a1:a) (b1:b), (mem a1 s1) -> (mem b1 s2) ->
   ((rows ((f a1) b1)) = r)) ->
  (forall (a1:a) (b1:b), (mem a1 s1) -> (mem b1 s2) ->
   ((columns ((f a1) b1)) = c)) ->
  ((cardinal s1) > 0%Z)%Z -> ((cardinal s2) > 0%Z)%Z ->
  ((mat_sum s1 (fun (a1:a) => (mat_sum s2 (f a1)))) =
   (mat_sum (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom mat_sum_comp1 :
  forall (f:bitvec -> bitvec -> matrix t) (l:Z) (x:Z) (y:Z), (0%Z <= x)%Z ->
  (0%Z <= y)%Z -> (0%Z <= l)%Z ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> is_a_ket ((f bvy) bvx)) ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> ((ket_length ((f bvy) bvx)) = l)) ->
  ((mat_sum (n_bvs y)
    (fun (bvy:bitvec) =>
     (mat_sum (n_bvs x) (fun (bvx:bitvec) => ((f bvy) bvx)))))
   =
   (mat_sum (n_bvs (x + y)%Z)
    (fun (bv:bitvec) => ((f (hpart bv y)) (tpart bv y))))).

Axiom mat_sum_comp_rev :
  forall (f:bitvec -> bitvec -> matrix t) (l:Z) (x:Z) (y:Z), (0%Z <= x)%Z ->
  (0%Z <= y)%Z -> (0%Z <= l)%Z ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> is_a_ket ((f bvy) bvx)) ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> ((ket_length ((f bvy) bvx)) = l)) ->
  ((mat_sum (n_bvs (x + y)%Z)
    (fun (bv:bitvec) => ((f (hpart bv y)) (tpart bv y))))
   =
   (mat_sum (n_bvs y)
    (fun (bvy:bitvec) =>
     (mat_sum (n_bvs x) (fun (bvx:bitvec) => ((f bvy) bvx)))))).

Axiom ket_sum_bin_comp_l :
  forall (f:bitvec -> bitvec -> matrix t) (scal:bitvec -> t) (l:Z) (x:Z)
    (y:Z),
  (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> is_a_ket_l ((f bvy) bvx) l) ->
  ((ket_sum_l (n_bvs y)
    (fun (bvy:bitvec) =>
     (infix_asdtdt (scal bvy)
      (ket_sum_l (n_bvs x) (fun (bvx:bitvec) => ((f bvy) bvx)) l)))
    l)
   =
   (ket_sum_l (n_bvs (x + y)%Z)
    (fun (bv:bitvec) =>
     (infix_asdtdt (scal (hpart bv y)) ((f (hpart bv y)) (tpart bv y))))
    l)).

Axiom ket_sum_bin_comp :
  forall (f:bitvec -> bitvec -> matrix t) (l:Z) (x:Z) (y:Z), (0%Z <= x)%Z ->
  (0%Z <= y)%Z ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> is_a_ket_l ((f bvy) bvx) l) ->
  ((ket_sum_l (n_bvs y)
    (fun (bvy:bitvec) =>
     (ket_sum_l (n_bvs x) (fun (bvx:bitvec) => ((f bvy) bvx)) l))
    l)
   =
   (ket_sum_l (n_bvs (x + y)%Z)
    (fun (bv:bitvec) => ((f (hpart bv y)) (tpart bv y))) l)).

Axiom ket_sum_bin_comp_rev :
  forall (f:bitvec -> bitvec -> matrix t) (l:Z) (x:Z) (y:Z), (0%Z <= x)%Z ->
  (0%Z <= y)%Z ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> is_a_ket_l ((f bvy) bvx) l) ->
  ((ket_sum_l (n_bvs (x + y)%Z)
    (fun (bv:bitvec) => ((f (hpart bv y)) (tpart bv y))) l)
   =
   (ket_sum_l (n_bvs y)
    (fun (bvy:bitvec) =>
     (ket_sum_l (n_bvs x) (fun (bvx:bitvec) => ((f bvy) bvx)) l))
    l)).

Axiom ket_sum_bin_comp_rev_ :
  forall (f:bitvec -> bitvec -> matrix t) (l:Z) (x:Z) (y:Z), (0%Z <= x)%Z ->
  (0%Z <= y)%Z ->
  (forall (bvx:bitvec) (bvy:bitvec), (mem bvx (n_bvs x)) ->
   (mem bvy (n_bvs y)) -> is_a_ket_l ((f bvx) bvy) l) ->
  ((ket_sum_l (n_bvs (x + y)%Z)
    (fun (bv:bitvec) => ((f (hpart bv x)) (tpart bv x))) l)
   =
   (ket_sum_l (n_bvs x)
    (fun (bvx:bitvec) =>
     (ket_sum_l (n_bvs y) (fun (bvy:bitvec) => ((f bvx) bvy)) l))
    l)).

Axiom ket_sum_bv_to_ints :
  forall (n:Z) (f:bitvec -> matrix t) (g:Z -> matrix t), (n >= 0%Z)%Z ->
  (forall (x:bitvec), ((length x) = n) -> ((f x) = (g (bv_to_int x)))) ->
  ((ket_sum_l (n_bvs n) f n) = (ket_sum_l (to_fset 0%Z (power 2%Z n)) g n)).

Axiom ket_sum_sum_rev :
  forall (f:bitvec -> bitvec -> matrix t) (sx:set bitvec) (sy:set bitvec)
    (l:Z),
  (0%Z <= l)%Z -> (forall (x:bitvec), (mem x sx) -> ((length x) = l)) ->
  (forall (y:bitvec), (mem y sy) -> ((length y) = l)) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = l) -> ((length y) = l) ->
   is_a_ket_l ((f x) y) l) ->
  ((ket_sum_l sx (fun (x:bitvec) => (ket_sum_l sy (f x) l)) l) =
   (ket_sum_l sy
    (fun (y:bitvec) => (ket_sum_l sx (fun (x:bitvec) => ((f x) y)) l)) l)).

Axiom get_ket_sum :
  forall (f:bitvec -> t) (n:Z) (i:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (n >= 0%Z)%Z ->
  ((get_ket
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) => (infix_asdtdt (f y) (bv_to_ket y))) n)
    i)
   = (f (int_to_bv i n))).

Axiom get_ket_scalar :
  forall (x:matrix t) (a:t) (i:Z),
  ((0%Z <= i)%Z /\ (i < (ket_length x))%Z) ->
  ((get_ket (infix_asdtdt a x) i) = (infix_asdt a (get_ket x i))).

Axiom get_ket_scalar_zero :
  forall (x:matrix t) (a:t),
  ((get_ket (infix_asdtdt a x) 0%Z) = (infix_asdt a (get_ket x 0%Z))).

Axiom ket_sum_sum_complex :
  forall (f:bitvec -> bitvec -> t) (sx:set bitvec) (sy:set bitvec) (l:Z),
  (0%Z <= l)%Z -> (forall (x:bitvec), (mem x sx) -> ((length x) = l)) ->
  (forall (y:bitvec), (mem y sy) -> ((length y) = l)) ->
  ((ket_sum_l sx
    (fun (x:bitvec) =>
     (ket_sum_l sy (fun (y:bitvec) => (infix_asdtdt ((f x) y) (bv_to_ket y)))
      l))
    l)
   =
   (ket_sum_l sy
    (fun (y:bitvec) =>
     (infix_asdtdt (sum sx (fun (x:bitvec) => ((f x) y))) (bv_to_ket y)))
    l)).

Axiom circuit : Type.
Parameter circuit_WhyType : WhyType circuit.
Existing Instance circuit_WhyType.

Parameter width: circuit -> Z.

Axiom width_spec : forall (c:circuit), ((width c) >= 0%Z)%Z.

Parameter size: circuit -> Z.

Axiom size_spec : forall (c:circuit), ((size c) >= 0%Z)%Z.

Parameter ancillas: circuit -> Z.

Axiom ancillas_spec : forall (c:circuit), ((ancillas c) >= 0%Z)%Z.

Parameter range: circuit -> Z.

Axiom range_spec : forall (c:circuit), ((range c) >= 0%Z)%Z.

Parameter basis_ket: circuit -> bitvec -> bitvec -> bitvec.

Axiom basis_ket_spec :
  forall (c:circuit) (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
  ((length y) = (range c)) -> ((length (basis_ket c x y)) = (width c)).

Parameter basis_ket_i: circuit -> bitvec -> bitvec -> Z -> Z.

Axiom basis_ket_i_def :
  forall (c:circuit) (x:bitvec) (y:bitvec) (i:Z),
  ((basis_ket_i c x y i) = ((getbv (basis_ket c x y)) i)).

Axiom basis_ket_i_spec :
  forall (c:circuit) (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
  ((length y) = (range c)) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
  ((basis_ket_i c x y i) = ((getbv (basis_ket c x y)) i)).

Axiom basis_ket_from_i :
  forall (c:circuit) (x:bitvec) (y:bitvec) (z:bitvec),
  ((length x) = (width c)) -> ((length y) = (range c)) ->
  ((length z) = (width c)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   (((getbv z) i) = (basis_ket_i c x y i))) ->
  ((basis_ket c x y) = z).

Parameter ang_ind_i: circuit -> bitvec -> bitvec -> Z -> angle.

Parameter ang_ind_bound: circuit -> Z.

Parameter ang_ind: circuit -> bitvec -> bitvec -> angle.

Axiom ang_ind_def :
  forall (c:circuit) (x:bitvec) (y:bitvec),
  ((ang_ind c x y) =
   (ang_sum
    ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
        (ang_ind_i y0 y1 y2 y3))
       c)
      x)
     y)
    0%Z (ang_ind_bound c))).

Parameter ang_ind_exp: circuit -> bitvec -> bitvec -> t.

Axiom ang_ind_exp_def :
  forall (c:circuit) (x:bitvec) (y:bitvec),
  ((ang_ind_exp c x y) = (ang_exp (ang_ind c x y))).

Parameter id: circuit.

Axiom id_def : ((ancillas id) = 0%Z).

Axiom id_def1 : ((size id) = 0%Z).

Axiom id_def2 : ((range id) = 0%Z).

Axiom id_def3 : ((width id) = 1%Z).

Axiom id_def4 :
  forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) -> ((length y) = 0%Z) ->
  ((basis_ket id x y) = x).

Axiom id_def5 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 1%Z) ->
  ((length y) = 0%Z) -> (i = 0%Z) -> ((basis_ket_i id x y i) = ((getbv x) i)).

Axiom id_def6 : ((ang_ind_bound id) = 1%Z).

Axiom id_def7 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 1%Z) ->
  ((length y) = 0%Z) -> (i = 0%Z) -> ((ang_ind_i id x y i) = ang_zero).

Axiom id_def8 :
  forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) -> ((length y) = 0%Z) ->
  ((ang_ind id x y) = ang_zero).

Parameter swap: circuit.

Axiom swap_def : ((ancillas swap) = 0%Z).

Axiom swap_def1 : ((size swap) = 0%Z).

Axiom swap_def2 : ((range swap) = 0%Z).

Axiom swap_def3 : ((width swap) = 2%Z).

Axiom swap_def4 :
  forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) -> ((length y) = 0%Z) ->
  ((basis_ket swap x y) =
   (make_bv (fun (i:Z) => ((getbv x) (1%Z - i)%Z)) 2%Z)).

Axiom swap_def5 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 1%Z) ->
  ((length y) = 0%Z) -> (i = 0%Z) ->
  ((basis_ket_i swap x y i) = ((getbv x) (1%Z - i)%Z)).

Axiom swap_def6 : ((ang_ind_bound swap) = 1%Z).

Axiom swap_def7 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 1%Z) ->
  ((length y) = 0%Z) -> (i = 0%Z) -> ((ang_ind_i swap x y i) = ang_zero).

Axiom swap_def8 :
  forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) -> ((length y) = 0%Z) ->
  ((ang_ind swap x y) = ang_zero).

Parameter phase: angle -> circuit.

Axiom phase_spec : forall (o:angle), ((ancillas (phase o)) = 0%Z).

Axiom phase_spec1 : forall (o:angle), ((size (phase o)) = 1%Z).

Axiom phase_spec2 : forall (o:angle), ((range (phase o)) = 0%Z).

Axiom phase_spec3 : forall (o:angle), ((width (phase o)) = 1%Z).

Axiom phase_spec4 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) ->
  ((length y) = 0%Z) -> ((basis_ket (phase o) x y) = x).

Axiom phase_spec5 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = 1%Z) -> ((length y) = 0%Z) -> (i = 0%Z) ->
  ((basis_ket_i (phase o) x y i) = ((getbv x) i)).

Axiom phase_spec6 : forall (o:angle), ((ang_ind_bound (phase o)) = 1%Z).

Axiom phase_spec7 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = 1%Z) -> ((length y) = 0%Z) -> (i = 0%Z) ->
  ((ang_ind_i (phase o) x y i) = o).

Axiom phase_spec8 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) ->
  ((length y) = 0%Z) -> ((ang_ind (phase o) x y) = o).

Parameter rz: angle -> circuit.

Axiom rz_spec : forall (o:angle), ((ancillas (rz o)) = 0%Z).

Axiom rz_spec1 : forall (o:angle), ((size (rz o)) = 1%Z).

Axiom rz_spec2 : forall (o:angle), ((range (rz o)) = 0%Z).

Axiom rz_spec3 : forall (o:angle), ((width (rz o)) = 1%Z).

Axiom rz_spec4 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) ->
  ((length y) = 0%Z) -> ((basis_ket (rz o) x y) = x).

Axiom rz_spec5 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = 1%Z) -> ((length y) = 0%Z) -> (i = 0%Z) ->
  ((basis_ket_i (rz o) x y i) = ((getbv x) i)).

Axiom rz_spec6 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) ->
  ((length y) = 0%Z) ->
  ((ang_ind (rz o) x y) = (phase_inv_ (1%Z - ((getbv x) 0%Z))%Z o)).

Axiom rz_spec7 : forall (o:angle), ((ang_ind_bound (rz o)) = 1%Z).

Axiom rz_spec8 :
  forall (o:angle), forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = 1%Z) -> ((length y) = 0%Z) -> (i = 0%Z) ->
  ((ang_ind_i (rz o) x y i) = (phase_inv_ (1%Z - ((getbv x) i))%Z o)).

Parameter hadamard: circuit.

Axiom hadamard_def : ((ancillas hadamard) = 0%Z).

Axiom hadamard_def1 : ((size hadamard) = 1%Z).

Axiom hadamard_def2 : ((range hadamard) = 1%Z).

Axiom hadamard_def3 : ((width hadamard) = 1%Z).

Axiom hadamard_def4 :
  forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) -> ((length y) = 1%Z) ->
  ((basis_ket hadamard x y) = y).

Axiom hadamard_def5 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 1%Z) ->
  ((length y) = 1%Z) -> (i = 0%Z) ->
  ((basis_ket_i hadamard x y i) = ((getbv y) i)).

Axiom hadamard_def6 :
  forall (x:bitvec) (y:bitvec), ((length x) = 1%Z) -> ((length y) = 1%Z) ->
  ((ang_ind hadamard x y) =
   (int_to_ang (((getbv x) 0%Z) * ((getbv y) 0%Z))%Z 1%Z)).

Axiom hadamard_def7 : ((ang_ind_bound hadamard) = 1%Z).

Axiom hadamard_def8 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 1%Z) ->
  ((length y) = 1%Z) -> (i = 0%Z) ->
  ((ang_ind_i hadamard x y i) =
   (int_to_ang (((getbv x) i) * ((getbv y) i))%Z 1%Z)).

Parameter cnot: circuit.

Axiom cnot_def : ((ancillas cnot) = 0%Z).

Axiom cnot_def1 : ((size cnot) = 1%Z).

Axiom cnot_def2 : ((range cnot) = 0%Z).

Axiom cnot_def3 : ((width cnot) = 2%Z).

Axiom cnot_def4 :
  forall (x:bitvec) (y:bitvec), ((length x) = 2%Z) -> ((length y) = 0%Z) ->
  ((((getbv x) 0%Z) = 0%Z) -> ((basis_ket cnot x y) = x)) /\
  (~ (((getbv x) 0%Z) = 0%Z) ->
   ((((getbv x) 1%Z) = 0%Z) -> ((basis_ket cnot x y) = (int_to_bv 3%Z 2%Z))) /\
   (~ (((getbv x) 1%Z) = 0%Z) ->
    ((basis_ket cnot x y) = (int_to_bv 2%Z 2%Z)))).

Axiom cnot_def5 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 2%Z) ->
  ((length y) = 1%Z) -> (i = 0%Z) ->
  ((basis_ket_i cnot x y i) = ((getbv x) i)).

Axiom cnot_def6 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = 2%Z) ->
  ((length y) = 1%Z) -> (i = 1%Z) ->
  ((basis_ket_i cnot x y i) = (xor_i ((getbv x) 0%Z) ((getbv x) i))).

Axiom cnot_def7 :
  forall (x:bitvec) (y:bitvec), ((length x) = 2%Z) -> ((length y) = 0%Z) ->
  ((ang_ind cnot x y) = ang_zero).

Axiom cnot_def8 : ((ang_ind_bound cnot) = 1%Z).

Axiom cnot_def9 :
  forall (x:bitvec) (y:bitvec), ((length x) = 2%Z) -> ((length y) = 0%Z) ->
  ((ang_ind_i cnot x y 0%Z) = ang_zero).

Parameter parallel: circuit -> circuit -> circuit.

Axiom parallel_spec :
  forall (d:circuit) (e1:circuit),
  ((ancillas (parallel d e1)) = ((ancillas d) + (ancillas e1))%Z).

Axiom parallel_spec1 :
  forall (d:circuit) (e1:circuit),
  ((size (parallel d e1)) = ((size d) + (size e1))%Z).

Axiom parallel_spec2 :
  forall (d:circuit) (e1:circuit),
  ((width (parallel d e1)) = ((width d) + (width e1))%Z).

Axiom parallel_spec3 :
  forall (d:circuit) (e1:circuit),
  ((range (parallel d e1)) = ((range d) + (range e1))%Z).

Axiom parallel_spec4 :
  forall (d:circuit) (e1:circuit), forall (x:bitvec) (y:bitvec),
  ((length x) = (width (parallel d e1))) ->
  ((length y) = (range (parallel d e1))) ->
  ((basis_ket (parallel d e1) x y) =
   (concat (basis_ket d (hpart x (width d)) (hpart y (range d)))
    (basis_ket e1 (tpart x (width d)) (tpart y (range d))))).

Axiom parallel_spec5 :
  forall (d:circuit) (e1:circuit), forall (x:bitvec) (y:bitvec),
  forall (i:Z), ((length x) = (width (parallel d e1))) ->
  ((length y) = (range (parallel d e1))) ->
  ((0%Z <= i)%Z /\ (i < ((width d) + (width e1))%Z)%Z) ->
  ((i < (width d))%Z ->
   ((basis_ket_i (parallel d e1) x y i) =
    (basis_ket_i d (hpart x (width d)) (hpart y (range d)) i))) /\
  (~ (i < (width d))%Z ->
   ((basis_ket_i (parallel d e1) x y i) =
    (basis_ket_i e1 (tpart x (width d)) (tpart y (range d))
     (i - (width d))%Z))).

Axiom parallel_spec6 :
  forall (d:circuit) (e1:circuit),
  ((ang_ind_bound (parallel d e1)) =
   ((ang_ind_bound d) + (ang_ind_bound e1))%Z).

Axiom parallel_spec7 :
  forall (d:circuit) (e1:circuit), forall (x:bitvec) (y:bitvec),
  forall (i:Z), ((length x) = (width (parallel d e1))) ->
  ((length y) = (range (parallel d e1))) ->
  ((0%Z <= i)%Z /\ (i < ((range d) + (range e1))%Z)%Z) ->
  ((i < (ang_ind_bound d))%Z ->
   ((ang_ind_i (parallel d e1) x y i) =
    (ang_ind_i d (hpart x (width d)) (hpart y (range d)) i))) /\
  (~ (i < (ang_ind_bound d))%Z ->
   ((ang_ind_i (parallel d e1) x y i) =
    (ang_ind_i e1 (tpart x (width d)) (tpart y (range d)) (i - (range d))%Z))).

Axiom parallel_spec8 :
  forall (d:circuit) (e1:circuit), forall (x:bitvec) (y:bitvec),
  ((length x) = (width (parallel d e1))) ->
  ((length y) = (range (parallel d e1))) ->
  ((ang_ind (parallel d e1) x y) =
   (ang_add (ang_ind d (hpart x (width d)) (hpart y (range d)))
    (ang_ind e1 (tpart x (width d)) (tpart y (range d))))).

Parameter sequence: circuit -> circuit -> circuit.

Axiom sequence_spec :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  ((ancillas (sequence d e1)) =
   (ZArith.BinInt.Z.max (ancillas d) (ancillas e1))).

Axiom sequence_spec1 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  ((size (sequence d e1)) = ((size d) + (size e1))%Z).

Axiom sequence_spec2 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  ((range (sequence d e1)) = ((range d) + (range e1))%Z).

Axiom sequence_spec3 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  ((width (sequence d e1)) = (width d)).

Axiom sequence_spec4 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  forall (x:bitvec) (y:bitvec), ((length x) = (width (sequence d e1))) ->
  ((length y) = (range (sequence d e1))) ->
  ((basis_ket (sequence d e1) x y) =
   (basis_ket e1 (basis_ket d x (hpart y (range d))) (tpart y (range d)))).

Axiom sequence_spec5 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = (width (sequence d e1))) ->
  ((length y) = (range (sequence d e1))) ->
  ((0%Z <= i)%Z /\ (i < (width d))%Z) ->
  ((basis_ket_i (sequence d e1) x y i) =
   (basis_ket_i e1 (basis_ket d x (hpart y (range d))) (tpart y (range d)) i)).

Axiom sequence_spec6 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  ((ang_ind_bound (sequence d e1)) =
   ((ang_ind_bound d) + (ang_ind_bound e1))%Z).

Axiom sequence_spec7 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = (width (sequence d e1))) ->
  ((length y) = (range (sequence d e1))) ->
  ((0%Z <= i)%Z /\ (i < (ang_ind_bound (sequence d e1)))%Z) ->
  ((i < (ang_ind_bound d))%Z ->
   ((ang_ind_i (sequence d e1) x y i) =
    (ang_ind_i d x (hpart y (range d)) i))) /\
  (~ (i < (ang_ind_bound d))%Z ->
   ((ang_ind_i (sequence d e1) x y i) =
    (ang_ind_i e1 (basis_ket d x (hpart y (range d))) (tpart y (range d))
     (i - (range d))%Z))).

Axiom sequence_spec8 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  forall (x:bitvec) (y:bitvec), ((length x) = (width (sequence d e1))) ->
  ((length y) = (range (sequence d e1))) ->
  ((ang_ind (sequence d e1) x y) =
   (ang_add (ang_ind d x (hpart y (range d)))
    (ang_ind e1 (basis_ket d x (hpart y (range d))) (tpart y (range d))))).

Axiom sequence_eq :
  forall (d:circuit) (d':circuit) (e1:circuit) (e':circuit),
  ((width d) = (width e1)) -> (d = d') -> (e1 = e') ->
  ((sequence d e1) = (sequence d' e')).

Axiom parallel_eq :
  forall (d:circuit) (d':circuit) (e1:circuit) (e':circuit), (d = d') ->
  (e1 = e') -> ((parallel d e1) = (parallel d' e')).

Parameter sequence_iter_anc:
  (Z -> circuit) -> Z -> Z -> Z -> Z -> Z -> circuit.

Axiom sequence_iter_anc_def :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z) (anc:Z) (s:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((ancillas (f k)) = anc)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((size (f k)) <= s)%Z) ->
  (j = (i + 1%Z)%Z) -> ((sequence_iter_anc f d i j anc s) = (f i)).

Axiom sequence_iter_anc_def1 :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z) (anc:Z) (s:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((ancillas (f k)) = anc)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((size (f k)) <= s)%Z) ->
  ~ (j = (i + 1%Z)%Z) ->
  ((sequence_iter_anc f d i j anc s) =
   (sequence (sequence_iter_anc f d i (j - 1%Z)%Z anc s) (f (j - 1%Z)%Z))).

Axiom sequence_iter_anc_spec :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z) (anc:Z) (s:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((ancillas (f k)) = anc)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((size (f k)) <= s)%Z) ->
  ((width (sequence_iter_anc f d i j anc s)) = d).

Axiom sequence_iter_anc_spec1 :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z) (anc:Z) (s:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((ancillas (f k)) = anc)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((size (f k)) <= s)%Z) ->
  ((ancillas (sequence_iter_anc f d i j anc s)) = anc).

Axiom sequence_iter_anc_spec2 :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z) (anc:Z) (s:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((ancillas (f k)) = anc)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((size (f k)) <= s)%Z) ->
  ((size (sequence_iter_anc f d i j anc s)) <= (s * (j - i)%Z)%Z)%Z.

Axiom sequence_iter_anc_one :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z) (anc:Z) (s:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((ancillas (f k)) = anc)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((size (f k)) <= s)%Z) ->
  (j = (i + 1%Z)%Z) -> ((sequence_iter_anc f d i j anc s) = (f i)).

Axiom sequence_iter_anc_re :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z) (anc:Z) (s:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((ancillas (f k)) = anc)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((size (f k)) <= s)%Z) ->
  ((i + 1%Z)%Z < j)%Z ->
  ((sequence_iter_anc f d i j anc s) =
   (sequence (sequence_iter_anc f d i (j - 1%Z)%Z anc s) (f (j - 1%Z)%Z))).

Parameter mat_sem: circuit -> matrix t.

Axiom mat_sem_spec :
  forall (c:circuit), ((columns (mat_sem c)) = (power 2%Z (width c))).

Axiom mat_sem_spec1 :
  forall (c:circuit), ((rows (mat_sem c)) = (power 2%Z (width c))).

Parameter path_sum_scheme_unit:
  (bitvec -> bitvec -> angle) -> (bitvec -> bitvec -> bitvec) -> Z -> 
  Z -> bitvec -> matrix t.

Axiom path_sum_scheme_unit_def :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:bitvec),
  (range1 >= 0%Z)%Z -> ((length x) = width1) ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  ((path_sum_scheme_unit a k width1 range1 x) =
   (infix_asdtdt (pow_inv_sqrt_2 range1)
    (ket_sum_l (n_bvs range1)
     (fun (y:bitvec) =>
      (infix_asdtdt (ang_exp ((a x) y)) (bv_to_ket ((k x) y))))
     width1))).

Axiom path_sum_scheme_unit_spec :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:bitvec),
  (range1 >= 0%Z)%Z -> ((length x) = width1) ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  is_a_ket_l (path_sum_scheme_unit a k width1 range1 x) width1.

Parameter path_sum_scheme:
  (bitvec -> bitvec -> angle) -> (bitvec -> bitvec -> bitvec) -> Z -> 
  Z -> (matrix t) -> matrix t.

Axiom path_sum_scheme_def :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:matrix t),
  (is_a_ket_l x width1) -> (range1 >= 0%Z)%Z ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  ((path_sum_scheme a k width1 range1 x) =
   (ket_sum_l (n_bvs width1)
    (fun (z:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int z))
      (path_sum_scheme_unit a k width1 range1 (hpart z width1))))
    width1)).

Axiom path_sum_scheme_spec :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:matrix t),
  (is_a_ket_l x width1) -> (range1 >= 0%Z)%Z ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  is_a_ket_l (path_sum_scheme a k width1 range1 x) width1.

Axiom path_sum_scheme_spec1 :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:matrix t),
  (is_a_ket_l x width1) -> (range1 >= 0%Z)%Z ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  ((path_sum_scheme a k width1 range1 x) =
   (ket_sum_l (n_bvs width1)
    (fun (z:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int z))
      (path_sum_scheme_unit a k width1 range1 z)))
    width1)).

Axiom path_sum_scheme_basis :
  forall (a:bitvec -> bitvec -> angle),
  forall (k:bitvec -> bitvec -> bitvec), forall (width1:Z) (range1:Z),
  forall (x:matrix t), (is_a_ket_l x width1) -> (range1 >= 0%Z)%Z ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  (is_a_ket_basis_elt x) ->
  ((path_sum_scheme a k width1 range1 x) =
   (path_sum_scheme_unit a k width1 range1 (ket_to_bv x))).

Axiom set_path_sum_basis :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:matrix t),
  (is_a_ket_l x width1) -> (is_a_ket_basis_elt x) -> (range1 >= 0%Z)%Z ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  ((path_sum_scheme a k width1 range1 x) =
   (path_sum_scheme_unit a k width1 range1 (ket_to_bv x))).

Axiom mat_sem_sequence :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) ->
  ((mat_sem (sequence d e1)) = (mat_mult (mat_sem e1) (mat_sem d))).

Axiom mat_sem_par :
  forall (d:circuit) (e1:circuit),
  ((mat_sem (parallel d e1)) = (kronecker (mat_sem d) (mat_sem e1))).

Axiom path_sum_decomp :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:matrix t),
  (is_a_ket_l x width1) -> (range1 >= 0%Z)%Z ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  ((path_sum_scheme a k width1 range1 x) =
   (ket_sum_l (n_bvs width1)
    (fun (z:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int z))
      (path_sum_scheme a k width1 range1 (bv_to_ket z))))
    width1)).

Axiom get_path_sum_basis :
  forall (a:bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (width1:Z) (range1:Z) (x:bitvec),
  ((length x) = width1) -> (range1 >= 0%Z)%Z ->
  (forall (x1:bitvec) (y:bitvec), ((length x1) = width1) ->
   ((length y) = range1) -> ((length ((k x1) y)) = width1)) ->
  ((path_sum_scheme_unit a k width1 range1 x) =
   (path_sum_scheme a k width1 range1 (bv_to_ket x))).

Parameter correct_path_sum_unit:
  circuit -> (bitvec -> bitvec -> angle) -> (bitvec -> bitvec -> bitvec) ->
  Z -> bitvec -> Prop.

Axiom correct_path_sum_unit_def :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (range1:Z) (x:bitvec),
  (correct_path_sum_unit c a k range1 x) <->
  exists p:angle,
  (forall (x1:bitvec) (y:bitvec), ((length x1) = (width c)) ->
   ((length y) = range1) -> ((length ((k x1) y)) = (width c))) /\
  ((range1 >= 0%Z)%Z /\
   (((length x) = (width c)) /\
    ((mat_mult (mat_sem c) (bv_to_ket x)) =
     (infix_asdtdt (ang_exp p) (path_sum_scheme_unit a k (width c) range1 x))))).

Parameter correct_path_sum:
  circuit -> (bitvec -> bitvec -> angle) -> (bitvec -> bitvec -> bitvec) ->
  Z -> Prop.

Axiom correct_path_sum_def :
  exists p:angle,
  forall (c:circuit), forall (a:bitvec -> bitvec -> angle),
  forall (k:bitvec -> bitvec -> bitvec), forall (range1:Z),
  (correct_path_sum c a k range1) <->
  ((forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
    ((length y) = range1) -> ((length ((k x) y)) = (width c))) /\
   ((range1 >= 0%Z)%Z /\
    forall (x:matrix t), (is_a_ket_l x (width c)) ->
    ((mat_mult (mat_sem c) x) =
     (infix_asdtdt (ang_exp p) (path_sum_scheme a k (width c) range1 x))))).

Axiom correct_path_sum_basis :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (range1:Z) (x:bitvec),
  ((length x) = (width c)) -> (correct_path_sum c a k range1) ->
  correct_path_sum_unit c a k range1 x.

Axiom correct_main_path_sum :
  forall (c:circuit),
  correct_path_sum c
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (ang_ind y0 y1 y2)) c)
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (basis_ket y0 y1 y2)) c)
  (range c).

Axiom set_correct_main_path_sum :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (b:bitvec -> bitvec -> bitvec) (r:Z),
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = r) -> (((a x) y) = (ang_ind c x y))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = r) -> (((b x) y) = (basis_ket c x y))) ->
  (r = (range c)) -> correct_path_sum c a b r.

Parameter pat_sem: circuit -> (matrix t) -> matrix t.

Axiom pat_sem_def :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) ->
  ((pat_sem c x) =
   (path_sum_scheme
    ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (ang_ind y0 y1 y2)) c)
    ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (basis_ket y0 y1 y2)) c)
    (width c) (range c) x)).

Axiom pat_sem_spec :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) ->
  is_a_ket_l (pat_sem c x) (width c).

Axiom pat_sem_decomp :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) ->
  ((pat_sem c x) =
   (ket_sum_l (n_bvs (width c))
    (fun (z:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int z)) (pat_sem c (bv_to_ket z))))
    (width c))).

Axiom pat_sem_unit :
  forall (c:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width c)) ->
  ((pat_sem c x) =
   (infix_asdtdt (pow_inv_sqrt_2 (range c))
    (ket_sum_l (n_bvs (range c))
     (fun (y:bitvec) =>
      (infix_asdtdt (ang_exp (ang_ind c (ket_to_bv x) y))
       (bv_to_ket (basis_ket c (ket_to_bv x) y))))
     (width c)))).

Parameter sem: circuit -> (matrix t) -> (matrix t) -> Prop.

Axiom sem_def :
  forall (c:circuit) (x:matrix t) (y:matrix t),
  (sem c x y) <-> ((is_a_ket_l x (width c)) /\ (infix_eqeq (pat_sem c x) y)).

Parameter circuit_equiv: circuit -> circuit -> Prop.

Axiom circuit_equiv_def :
  forall (c:circuit) (c':circuit),
  (circuit_equiv c c') <->
  (((width c) = (width c')) /\
   forall (x:bitvec), ((length x) = (width c)) ->
   ((pat_sem c (bv_to_ket x)) = (pat_sem c' (bv_to_ket x)))).

Axiom sem_ket_l :
  forall (c:circuit) (x:matrix t) (y:matrix t), (sem c x y) ->
  is_a_ket_l y (width c).

Axiom pat_sem_ket_l :
  forall (c:circuit) (x:matrix t) (n:Z), (is_a_ket_l x (width c)) ->
  ((width c) = n) -> is_a_ket_l (pat_sem c x) n.

Axiom pat_to_mat_sem :
  forall (c:circuit) (x:matrix t) (y:matrix t), (is_a_ket_l x (width c)) ->
  ((pat_sem c x) = y) -> ((mat_mult (mat_sem c) x) = y).

Axiom mat_to_pat_sem :
  forall (c:circuit) (x:matrix t) (y:matrix t), (is_a_ket_l x (width c)) ->
  ((mat_mult (mat_sem c) x) = y) -> ((pat_sem c x) = y).

Axiom sem_to_mat :
  forall (c:circuit) (x:matrix t) (y:matrix t), (sem c x y) ->
  ((mat_mult (mat_sem c) x) = y).

Axiom sem_to_pat :
  forall (c:circuit) (x:matrix t) (y:matrix t), (sem c x y) ->
  ((pat_sem c x) = y).

Axiom mat_to_sem :
  forall (c:circuit) (x:matrix t) (y:matrix t), (is_a_ket_l x (width c)) ->
  ((mat_mult (mat_sem c) x) = y) -> sem c x y.

Axiom pat_to_sem :
  forall (c:circuit) (x:matrix t) (y:matrix t), (is_a_ket_l x (width c)) ->
  ((pat_sem c x) = y) -> sem c x y.

Axiom add_sem :
  forall (c:circuit) (x:matrix t) (x':matrix t) (y:matrix t) (y':matrix t),
  (sem c x y) -> (sem c x' y') -> sem c (add_mat x x') (add_mat y y').

Axiom pat_sem_add :
  forall (c:circuit) (x:matrix t) (x':matrix t) (y:matrix t) (y':matrix t),
  ((pat_sem c x) = y) -> ((pat_sem c x') = y') ->
  ((pat_sem c (add_mat x x')) = (add_mat y y')).

Axiom scal_sem :
  forall (c:circuit) (x:matrix t) (y:matrix t) (sc:t), (sem c x y) ->
  sem c (infix_asdtdt sc x) (infix_asdtdt sc y).

Axiom pat_sem_scal_ :
  forall (c:circuit) (x:matrix t) (y:matrix t) (sc:t),
  (is_a_ket_l x (width c)) -> ((pat_sem c x) = y) ->
  ((pat_sem c (infix_asdtdt sc x)) = (infix_asdtdt sc y)).

Axiom pat_sem_scal :
  forall (c:circuit) (x:matrix t) (sc:t), (is_a_ket_l x (width c)) ->
  ((pat_sem c (infix_asdtdt sc x)) = (infix_asdtdt sc (pat_sem c x))).

Axiom comp_sem :
  forall (c:circuit) (c':circuit) (x:matrix t) (y:matrix t) (z:matrix t),
  ((width c) = (width c')) -> (sem c x y) -> (sem c' y z) ->
  sem (sequence c c') x z.

Axiom pat_sem_comp :
  forall (c:circuit) (c':circuit) (x:matrix t) (y:matrix t) (z:matrix t),
  ((width c) = (width c')) -> ((pat_sem c x) = y) -> ((pat_sem c' y) = z) ->
  ((pat_sem (sequence c c') x) = z).

Axiom par_sem :
  forall (c:circuit) (c':circuit) (x:matrix t) (y:matrix t) (z:matrix t)
    (t1:matrix t),
  (sem c x y) -> (sem c' z t1) ->
  sem (parallel c c') (kronecker x z) (kronecker y t1).

Axiom sum_sem :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:circuit) (s:set a) (f:a -> matrix t) (g:a -> matrix t),
  ((cardinal s) >= 1%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> sem c (f e1) (g e1)) ->
  sem c (ket_sum_l s f (width c)) (ket_sum_l s g (width c)).

Axiom sum_sem_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:circuit) (s:set a) (f:a -> matrix t) (g:a -> matrix t) (l1:Z)
    (l2:Z),
  ((cardinal s) >= 1%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> sem c (f e1) (g e1)) -> (l1 = (width c)) ->
  (l2 = (width c)) -> sem c (ket_sum_l s f l1) (ket_sum_l s g l2).

Axiom sum_scal_sem :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:circuit) (s:set a) (f:a -> matrix t) (h:a -> matrix t) (g:a -> t),
  ((cardinal s) >= 1%Z)%Z ->
  (forall (e1:a), (mem e1 s) -> sem c (f e1) (h e1)) ->
  sem c (ket_sum_l s (fun (e1:a) => (infix_asdtdt (g e1) (f e1))) (width c))
  (ket_sum_l s (fun (e1:a) => (infix_asdtdt (g e1) (h e1))) (width c)).

Axiom scal_pat_sem :
  forall (c:circuit) (x:matrix t) (sc:t),
  ((pat_sem c (infix_asdtdt sc x)) = (infix_asdtdt sc (pat_sem c x))).

Axiom comp_sem_scal :
  forall (c:circuit) (c':circuit) (x:matrix t) (y:matrix t) (z:matrix t)
    (a:t),
  ((width c) = (width c')) -> (sem c x y) -> (sem c' y z) ->
  sem (sequence c c') (infix_asdtdt a x) (infix_asdtdt a z).

Axiom comp_sem_add :
  forall (c:circuit) (c':circuit) (x:matrix t) (x':matrix t) (y:matrix t)
    (y':matrix t) (z:matrix t) (z':matrix t),
  ((width c) = (width c')) -> (sem c x y) -> (sem c x' y') -> (sem c' y z) ->
  (sem c' y' z') -> sem (sequence c c') (add_mat x x') (add_mat z z').

Axiom comp_sem_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:circuit) (c':circuit) (f:a -> matrix t) (g:a -> matrix t)
    (h:a -> matrix t) (s:set a),
  ((cardinal s) > 0%Z)%Z -> ((width c) = (width c')) ->
  (forall (e1:a), (mem e1 s) -> sem c (f e1) (g e1)) ->
  (forall (e1:a), (mem e1 s) -> sem c' (g e1) (h e1)) ->
  sem (sequence c c') (ket_sum_l s f (width c)) (ket_sum_l s h (width c)).

Axiom comp_sem_basis :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:circuit) (c':circuit) (g:a -> matrix t) (h:a -> matrix t)
    (s:set a) (x:matrix t),
  ((cardinal s) > 0%Z)%Z -> ((width c) = (width c')) ->
  (sem c x (ket_sum_l s g (width c))) ->
  (forall (e1:a), (mem e1 s) -> sem c' (g e1) (h e1)) ->
  sem (sequence c c') x (ket_sum_l s h (width c)).

Axiom sem_decomp :
  forall (c:circuit) (f:bitvec -> matrix t) (x:matrix t),
  (forall (x1:bitvec), ((length x1) = (width c)) ->
   sem c (bv_to_ket x1) (f x1)) ->
  sem c x
  (ket_sum_l (n_bvs (width c))
   (fun (j:bitvec) => (infix_asdtdt (get_ket_bv x j) (f j))) (width c)).

Axiom pat_sem_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:circuit) (s:set a) (f:a -> matrix t) (g:a -> matrix t) (n:Z),
  ((cardinal s) >= 1%Z)%Z -> (n = (width c)) ->
  (forall (x:a), (mem x s) -> is_a_ket_l (f x) (width c)) ->
  (forall (x:a), (mem x s) -> ((pat_sem c (f x)) = (g x))) ->
  ((pat_sem c (ket_sum_l s f n)) = (ket_sum_l s g n)).

Axiom pat_sem_sum_ :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:circuit) (s:set a) (f:a -> matrix t) (n:Z),
  ((cardinal s) >= 1%Z)%Z -> (n = (width c)) ->
  (forall (x:a), (mem x s) -> is_a_ket_l (f x) (width c)) ->
  ((pat_sem c (ket_sum_l s f n)) =
   (ket_sum_l s (fun (x:a) => (pat_sem c (f x))) n)).

Axiom set_correct_path_sum :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (r >= 0%Z)%Z ->
  (forall (x:bitvec), ((length x) = (width c)) ->
   correct_path_sum_unit c a k r x) ->
  correct_path_sum c a k r.

Axiom get_correct_path_sum :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> (r >= 0%Z)%Z.

Axiom get_correct_path_sum1 :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> forall (x:bitvec),
  ((length x) = (width c)) -> correct_path_sum_unit c a k r x.

Axiom get_correct_path_sum2 :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width c)) -> ((length y) = r) ->
  ((length ((k x) y)) = (width c)).

Axiom get_correct_path_sum3 :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> forall (x:bitvec),
  ((length x) = (width c)) ->
  ((mat_mult (mat_sem c) (bv_to_ket x)) =
   (path_sum_scheme_unit a k (width c) r x)).

Axiom get_correct_path_sum4 :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> forall (x:bitvec),
  ((length x) = (width c)) ->
  ((mat_mult (mat_sem c) (bv_to_ket x)) =
   (infix_asdtdt (pow_inv_sqrt_2 r)
    (ket_sum_l (n_bvs r)
     (fun (y:bitvec) =>
      (infix_asdtdt (ang_exp ((a x) y)) (bv_to_ket ((k x) y))))
     (width c)))).

Axiom set_sem_by_correct_ps :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (b:bitvec -> bitvec -> bitvec) (r:Z) (s:Z) (x:matrix t),
  (correct_path_sum c a b r) -> (is_a_ket_l x s) -> (is_a_ket_basis_elt x) ->
  (s = (width c)) ->
  sem c x
  (infix_asdtdt (pow_inv_sqrt_2 r)
   (ket_sum_l (n_bvs r)
    (fun (y:bitvec) =>
     (infix_asdtdt (ang_exp ((a (ket_to_bv x)) y))
      (bv_to_ket ((b (ket_to_bv x)) y))))
    s)).

Axiom pat_set_sem_by_correct_ps :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (b:bitvec -> bitvec -> bitvec) (r:Z) (s:Z) (x:matrix t),
  (correct_path_sum c a b r) -> (is_a_ket_l x s) -> (is_a_ket_basis_elt x) ->
  (s = (width c)) ->
  ((pat_sem c x) =
   (infix_asdtdt (pow_inv_sqrt_2 r)
    (ket_sum_l (n_bvs r)
     (fun (y:bitvec) =>
      (infix_asdtdt (ang_exp ((a (ket_to_bv x)) y))
       (bv_to_ket ((b (ket_to_bv x)) y))))
     s))).

Axiom set_sem_by_main_basis :
  forall (c:circuit) (f:bitvec -> matrix t) (r:Z) (s:Z) (x:matrix t),
  (is_a_ket_l x s) -> (is_a_ket_basis_elt x) ->
  (forall (y:bitvec), ((length y) = r) ->
   ((f y) =
    (infix_asdtdt (ang_exp (ang_ind c (ket_to_bv x) y))
     (bv_to_ket (basis_ket c (ket_to_bv x) y))))) ->
  (r = (range c)) -> (s = (width c)) ->
  sem c x (infix_asdtdt (pow_inv_sqrt_2 r) (ket_sum_l (n_bvs r) f s)).

Axiom set_correct_path_sum_sim :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (a':bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (k':bitvec -> bitvec -> bitvec) (range1:Z) (range':Z),
  (range1 >= 0%Z)%Z -> (range1 = range') ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = range1) -> (((a x) y) = ((a' x) y))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = range1) -> ((length ((k' x) y)) = (width c))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width c)) ->
   ((length y) = range1) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   (((getbv ((k x) y)) i) = ((getbv ((k' x) y)) i))) ->
  (correct_path_sum c a k range1) -> correct_path_sum c a' k' range'.

Axiom path_sum_equiv :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (a':bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (k':bitvec -> bitvec -> bitvec) (range1:Z) (range':Z),
  (range1 >= 0%Z)%Z -> (range1 = range') ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = range1) -> (((a x) y) = ((a' x) y))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = range1) -> (((k x) y) = ((k' x) y))) ->
  (correct_path_sum c a k range1) -> correct_path_sum c a' k' range'.

Axiom path_sum_equiv1 :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (a':bitvec -> bitvec -> angle) (k:bitvec -> bitvec -> bitvec)
    (k':bitvec -> bitvec -> bitvec) (range1:Z) (range':Z),
  (range1 >= 0%Z)%Z -> (range1 = range') ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = range1) -> (((a x) y) = ((a' x) y))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = range1) -> (((k x) y) = ((k' x) y))) ->
  (correct_path_sum c a' k' range') -> correct_path_sum c a k range1.

Axiom correct_seq :
  forall (c:circuit) (c':circuit),
  forall (a:bitvec -> bitvec -> angle) (a':bitvec -> bitvec -> angle),
  forall (k:bitvec -> bitvec -> bitvec) (k':bitvec -> bitvec -> bitvec),
  forall (range1:Z) (range':Z), (correct_path_sum c a k range1) ->
  (correct_path_sum c' a' k' range') ->
  correct_path_sum (sequence c c')
  (fun (x:bitvec) (y:bitvec) =>
   (ang_add ((a x) (hpart y range1))
    ((a' ((k x) (hpart y range1))) (tpart y range1))))
  (fun (x:bitvec) (y:bitvec) =>
   ((k' ((k x) (hpart y range1))) (tpart y range1)))
  (range1 + range')%Z.

Axiom set_correct_seq :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> angle)
    (a:bitvec -> bitvec -> angle) (a':bitvec -> bitvec -> angle)
    (bse:bitvec -> bitvec -> bitvec) (b:bitvec -> bitvec -> bitvec)
    (b':bitvec -> bitvec -> bitvec) (s:Z) (rse:Z) (r:Z) (r':Z),
  (0%Z <= r)%Z -> (0%Z <= r')%Z ->
  (((width c) = (width c')) /\ ((width c') = s)) ->
  (correct_path_sum c a b r) -> (correct_path_sum c' a' b' r') ->
  (forall (x:bitvec) (y:bitvec), ((length x) = s) -> ((length y) = rse) ->
   (((ase x) y) =
    (ang_add ((a x) (hpart y r)) ((a' ((b x) (hpart y r))) (tpart y r))))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = s) -> ((length y) = rse) ->
   (((bse x) y) = ((b' ((b x) (hpart y r))) (tpart y r)))) ->
  (rse = (r + r')%Z) -> correct_path_sum (sequence c c') ase bse rse.

Axiom correct_par :
  forall (c:circuit) (c':circuit),
  forall (a:bitvec -> bitvec -> angle) (a':bitvec -> bitvec -> angle),
  forall (k:bitvec -> bitvec -> bitvec) (k':bitvec -> bitvec -> bitvec),
  forall (range1:Z) (range':Z), (correct_path_sum c a k range1) ->
  (correct_path_sum c' a' k' range') ->
  correct_path_sum (parallel c c')
  (fun (x:bitvec) (y:bitvec) =>
   (ang_add ((a (hpart x (width c))) (hpart y range1))
    ((a' (tpart x (width c))) (tpart y range1))))
  (fun (x:bitvec) (y:bitvec) =>
   (concat ((k (hpart x (width c))) (hpart y range1))
    ((k' (tpart x (width c))) (tpart y range1))))
  (range1 + range')%Z.

Axiom set_correct_par :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> angle)
    (a:bitvec -> bitvec -> angle) (a':bitvec -> bitvec -> angle)
    (bse:bitvec -> bitvec -> bitvec) (b:bitvec -> bitvec -> bitvec)
    (b':bitvec -> bitvec -> bitvec) (s:Z) (rse:Z) (r:Z) (r':Z),
  (0%Z <= r)%Z -> (0%Z <= r')%Z -> (correct_path_sum c a b r) ->
  (correct_path_sum c' a' b' r') ->
  (forall (x:bitvec) (y:bitvec), ((length x) = s) -> ((length y) = rse) ->
   (((ase x) y) =
    (ang_add ((a (hpart x (width c))) (hpart y r))
     ((a' (tpart x (width c))) (tpart y r))))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = s) -> ((length y) = rse) ->
   (((bse x) y) =
    (concat ((b (hpart x (width c))) (hpart y r))
     ((b' (tpart x (width c))) (tpart y r))))) ->
  (rse = (r + r')%Z) -> (s = ((width c) + (width c'))%Z) ->
  correct_path_sum (parallel c c') ase bse rse.

Axiom correct_to_pat_sem :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> forall (x:matrix t),
  (is_a_ket_l x (width c)) ->
  ((path_sum_scheme a k (width c) r x) = (pat_sem c x)).

Axiom correct_to_mat_sem :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> forall (x:matrix t),
  (is_a_ket_l x (width c)) ->
  ((path_sum_scheme a k (width c) r x) = (mat_mult (mat_sem c) x)).

Axiom correct_to_sem :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (correct_path_sum c a k r) -> forall (x:matrix t) (y:matrix t),
  (is_a_ket_l x (width c)) -> ((path_sum_scheme a k (width c) r x) = y) ->
  sem c x y.

Axiom mat_sem_to_correct :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (r >= 0%Z)%Z ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = r) -> ((length ((k x) y)) = (width c))) ->
  (forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
   ((path_sum_scheme a k (width c) r x) = (mat_mult (mat_sem c) x))) ->
  correct_path_sum c a k r.

Axiom pat_sem_to_correct :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (r >= 0%Z)%Z ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = r) -> ((length ((k x) y)) = (width c))) ->
  (forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
   ((path_sum_scheme a k (width c) r x) = (pat_sem c x))) ->
  correct_path_sum c a k r.

Axiom sem_to_correct :
  forall (c:circuit) (a:bitvec -> bitvec -> angle)
    (k:bitvec -> bitvec -> bitvec) (r:Z),
  (r >= 0%Z)%Z ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = r) -> ((length ((k x) y)) = (width c))) ->
  (forall (x:matrix t) (y:matrix t), (is_a_ket_l x (width c)) ->
   (is_a_ket_basis_elt x) -> ((path_sum_scheme a k (width c) r x) = y) ->
   sem c x y) ->
  correct_path_sum c a k r.

Axiom hadamard_comp :
  forall (x:bitvec), ((length x) = 1%Z) ->
  ((pat_sem hadamard (pat_sem hadamard (bv_to_ket x))) = (bv_to_ket x)).

Parameter aux: Z -> bitvec -> circuit.

Axiom aux_def :
  forall (k:Z) (x:bitvec), ((length x) = 1%Z) -> (1%Z <= k)%Z -> (k = 1%Z) ->
  ((aux k x) = hadamard).

Axiom aux_def1 :
  forall (k:Z) (x:bitvec), ((length x) = 1%Z) -> (1%Z <= k)%Z ->
  ~ (k = 1%Z) -> ((aux k x) = (sequence (aux (k - 1%Z)%Z x) hadamard)).

Axiom aux_spec :
  forall (k:Z) (x:bitvec), ((length x) = 1%Z) -> (1%Z <= k)%Z ->
  ((width (aux k x)) = 1%Z).

Axiom aux_spec1 :
  forall (k:Z) (x:bitvec), ((length x) = 1%Z) -> (1%Z <= k)%Z ->
  ((odd k) = true) ->
  ((pat_sem (aux k x) (bv_to_ket x)) = (pat_sem hadamard (bv_to_ket x))).

Axiom aux_spec2 :
  forall (k:Z) (x:bitvec), ((length x) = 1%Z) -> (1%Z <= k)%Z ->
  ((even k) = true) -> ((pat_sem (aux k x) (bv_to_ket x)) = (bv_to_ket x)).

Parameter correct_path_sum_i:
  circuit -> (bitvec -> bitvec -> Z -> angle) -> Z -> Z ->
  (bitvec -> bitvec -> Z -> Z) -> Z -> Prop.

Axiom correct_path_sum_i_spec :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
  ((length y) = range1) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
  (0%Z <= (((k x) y) i))%Z.

Axiom correct_path_sum_i_spec1 :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
  ((length y) = range1) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
  ((((k x) y) i) < 2%Z)%Z.

Axiom correct_path_sum_i_spec2 :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  correct_path_sum c
  (fun (x:bitvec) (y:bitvec) => (ang_sum (fun (i:Z) => (((a x) y) i)) l h))
  (fun (x:bitvec) (y:bitvec) =>
   (make_bv (fun (i:Z) => (((k x) y) i)) (width c)))
  range1.

Axiom correct_path_sum_i_spec3 :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  ((forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
    ((length y) = range1) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
    (0%Z <= (((k x) y) i))%Z /\ ((((k x) y) i) < 2%Z)%Z) /\
   (correct_path_sum c
    (fun (x:bitvec) (y:bitvec) => (ang_sum (fun (i:Z) => (((a x) y) i)) l h))
    (fun (x:bitvec) (y:bitvec) =>
     (make_bv (fun (i:Z) => (((k x) y) i)) (width c)))
    range1)) ->
  correct_path_sum_i c a l h k range1.

Axiom set_correct_path_sum_i :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = range1) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   (0%Z <= (((k x) y) i))%Z /\ ((((k x) y) i) < 2%Z)%Z) ->
  (correct_path_sum c
   (fun (x:bitvec) (y:bitvec) => (ang_sum (fun (i:Z) => (((a x) y) i)) l h))
   (fun (x:bitvec) (y:bitvec) =>
    (make_bv (fun (i:Z) => (((k x) y) i)) (width c)))
   range1) ->
  correct_path_sum_i c a l h k range1.

Axiom correct_path_sum_i_main :
  forall (c:circuit) (h':Z) (r':Z), (h' = (ang_ind_bound c)) ->
  (r' = (range c)) ->
  correct_path_sum_i c
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
    (ang_ind_i y0 y1 y2 y3))
   c)
  0%Z h'
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
    (basis_ket_i y0 y1 y2 y3))
   c)
  r'.

Axiom correct_path_sum_i_to_sem_basis :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z) (x:matrix t)
    (f:bitvec -> matrix t),
  (correct_path_sum_i c a l h k range1) -> (is_a_ket_l x (width c)) ->
  (is_a_ket_basis_elt x) ->
  (forall (y:bitvec), ((length y) = range1) ->
   ((f y) =
    (infix_asdtdt (ang_exp (ang_sum ((a (ket_to_bv x)) y) l h))
     (bv_to_ket (make_bv ((k (ket_to_bv x)) y) (width c)))))) ->
  sem c x
  (infix_asdtdt (pow_inv_sqrt_2 range1)
   (ket_sum_l (n_bvs range1) f (width c))).

Axiom correct_path_sum_i_to_sem_basis_gen :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z)
    (f:bitvec -> bitvec -> matrix t),
  (correct_path_sum_i c a l h k range1) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = range1) ->
   (((f x) y) =
    (infix_asdtdt (ang_exp (ang_sum ((a x) y) l h))
     (bv_to_ket (make_bv ((k x) y) (width c)))))) ->
  forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
  sem c x
  (infix_asdtdt (pow_inv_sqrt_2 range1)
   (ket_sum_l (n_bvs range1) (f (ket_to_bv x)) (width c))).

Axiom get_correct_path_sum_i :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) -> (range1 >= 0%Z)%Z.

Axiom get_correct_path_sum_i1 :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
  ((length y) = range1) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
  (0%Z <= (((k x) y) i))%Z.

Axiom get_correct_path_sum_i2 :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
  ((length y) = range1) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
  ((((k x) y) i) < 2%Z)%Z.

Axiom get_correct_path_sum_i3 :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  correct_path_sum c
  (fun (x:bitvec) (y:bitvec) => (ang_sum (fun (i:Z) => (((a x) y) i)) l h))
  (fun (x:bitvec) (y:bitvec) =>
   (make_bv (fun (i:Z) => (((k x) y) i)) (width c)))
  range1.

Axiom get_correct_path_sum_i4 :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  correct_path_sum c
  (fun (x:bitvec) (y:bitvec) => (ang_sum (fun (i:Z) => (((a x) y) i)) l h))
  (fun (x:bitvec) (y:bitvec) =>
   (makes_bv (fun (i:Z) => (((k x) y) i)) (width c)))
  range1.

Parameter sequence_spec_i:
  circuit -> circuit -> (bitvec -> bitvec -> Z -> angle) ->
  (bitvec -> bitvec -> Z -> angle) -> (bitvec -> bitvec -> Z -> angle) ->
  Z -> Z -> Z -> (bitvec -> bitvec -> Z -> Z) ->
  (bitvec -> bitvec -> Z -> Z) -> (bitvec -> bitvec -> Z -> Z) -> Z -> 
  Z -> Z -> circuit.

Axiom sequence_spec_i_def :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> Z -> angle)
    (l:Z) (z:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l z b r) ->
  (correct_path_sum_i c' a' z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    (((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) =
    (((a' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> ((l <= z)%Z /\ (z <= h)%Z) ->
  ((sequence_spec_i c c' ase a a' l z h bse b b' rse r r') = (sequence c c')).

Axiom sequence_spec_i_spec :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> Z -> angle)
    (l:Z) (z:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l z b r) ->
  (correct_path_sum_i c' a' z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    (((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) =
    (((a' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> ((l <= z)%Z /\ (z <= h)%Z) ->
  correct_path_sum_i (sequence_spec_i c c' ase a a' l z h bse b b' rse r r')
  ase l h bse rse.

Axiom sequence_spec_i_spec1 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> Z -> angle)
    (l:Z) (z:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l z b r) ->
  (correct_path_sum_i c' a' z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    (((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) =
    (((a' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> ((l <= z)%Z /\ (z <= h)%Z) ->
  ((width (sequence_spec_i c c' ase a a' l z h bse b b' rse r r')) =
   (width c)).

Axiom sequence_spec_i_spec2 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> Z -> angle)
    (l:Z) (z:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l z b r) ->
  (correct_path_sum_i c' a' z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    (((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) =
    (((a' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> ((l <= z)%Z /\ (z <= h)%Z) ->
  ((sequence_spec_i c c' ase a a' l z h bse b b' rse r r') = (sequence c c')).

Parameter sequence_spec_i_r:
  circuit -> circuit -> (bitvec -> bitvec -> Z -> angle) ->
  (bitvec -> bitvec -> Z -> angle) -> (bitvec -> bitvec -> angle) -> 
  Z -> Z -> (bitvec -> bitvec -> Z -> Z) -> (bitvec -> bitvec -> Z -> Z) ->
  (bitvec -> bitvec -> bitvec) -> Z -> Z -> Z -> circuit.

Axiom sequence_spec_i_r_def :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a':bitvec -> bitvec -> Z -> angle) (a:bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b':bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum c a b r) ->
  (correct_path_sum_i c' a' (l + 1%Z)%Z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) = (((b' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) -> ((((ase x) y) l) = ((a x) (hpart y r)))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> (((l + 1%Z)%Z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  ((sequence_spec_i_r c c' ase a' a l h bse b' b rse r r') =
   (sequence_spec_i c c' ase (fun (x:bitvec) (y:bitvec) (i:Z) => ((a x) y))
    a' l (l + 1%Z)%Z h bse
    (fun (x:bitvec) (y:bitvec) (i:Z) => ((getbv ((b x) y)) i)) b' rse r r')).

Axiom sequence_spec_i_r_spec :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a':bitvec -> bitvec -> Z -> angle) (a:bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b':bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum c a b r) ->
  (correct_path_sum_i c' a' (l + 1%Z)%Z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) = (((b' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) -> ((((ase x) y) l) = ((a x) (hpart y r)))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> (((l + 1%Z)%Z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  correct_path_sum_i (sequence_spec_i_r c c' ase a' a l h bse b' b rse r r')
  ase l h bse rse.

Axiom sequence_spec_i_r_spec1 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a':bitvec -> bitvec -> Z -> angle) (a:bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b':bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum c a b r) ->
  (correct_path_sum_i c' a' (l + 1%Z)%Z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) = (((b' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) -> ((((ase x) y) l) = ((a x) (hpart y r)))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> (((l + 1%Z)%Z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  ((width (sequence_spec_i_r c c' ase a' a l h bse b' b rse r r')) =
   (width c)).

Axiom sequence_spec_i_r_spec2 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a':bitvec -> bitvec -> Z -> angle) (a:bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b':bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum c a b r) ->
  (correct_path_sum_i c' a' (l + 1%Z)%Z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) = (((b' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) -> ((((ase x) y) l) = ((a x) (hpart y r)))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> (((l + 1%Z)%Z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a' ((b x) (hpart y r))) (tpart y r)) i))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  ((sequence_spec_i_r c c' ase a' a l h bse b' b rse r r') = (sequence c c')).

Parameter sequence_spec_i_l:
  circuit -> circuit -> (bitvec -> bitvec -> Z -> angle) ->
  (bitvec -> bitvec -> Z -> angle) -> (bitvec -> bitvec -> angle) -> 
  Z -> Z -> (bitvec -> bitvec -> Z -> Z) -> (bitvec -> bitvec -> Z -> Z) ->
  (bitvec -> bitvec -> bitvec) -> Z -> Z -> Z -> circuit.

Axiom sequence_spec_i_l_def :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l (h - 1%Z)%Z b r) ->
  (correct_path_sum c' a' b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    ((getbv ((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r))) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < (h - 1%Z)%Z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) ->
   ((((ase x) y) (h - 1%Z)%Z) =
    ((a' (make_bv (fun (i:Z) => (((b x) (hpart y r)) i)) (width c)))
     (tpart y r)))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  ((sequence_spec_i_l c c' ase a a' l h bse b b' rse r r') =
   (sequence_spec_i c c' ase a
    (fun (x:bitvec) (y:bitvec) (i:Z) => ((a' x) y)) l (h - 1%Z)%Z h bse b
    (fun (x:bitvec) (y:bitvec) (i:Z) => ((getbv ((b' x) y)) i)) rse r r')).

Axiom sequence_spec_i_l_spec :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l (h - 1%Z)%Z b r) ->
  (correct_path_sum c' a' b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    ((getbv ((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r))) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < (h - 1%Z)%Z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) ->
   ((((ase x) y) (h - 1%Z)%Z) =
    ((a' (make_bv (fun (i:Z) => (((b x) (hpart y r)) i)) (width c)))
     (tpart y r)))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  correct_path_sum_i (sequence_spec_i_l c c' ase a a' l h bse b b' rse r r')
  ase l h bse rse.

Axiom sequence_spec_i_l_spec1 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l (h - 1%Z)%Z b r) ->
  (correct_path_sum c' a' b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    ((getbv ((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r))) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < (h - 1%Z)%Z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) ->
   ((((ase x) y) (h - 1%Z)%Z) =
    ((a' (make_bv (fun (i:Z) => (((b x) (hpart y r)) i)) (width c)))
     (tpart y r)))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  ((width (sequence_spec_i_l c c' ase a a' l h bse b b' rse r r')) =
   (width c)).

Axiom sequence_spec_i_l_spec2 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> angle) 
    (l:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> bitvec) (rse:Z)
    (r:Z) (r':Z),
  ((width c) = (width c')) -> (correct_path_sum_i c a l (h - 1%Z)%Z b r) ->
  (correct_path_sum c' a' b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) =
    ((getbv ((b' (make_bv ((b x) (hpart y r)) (width c))) (tpart y r))) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < (h - 1%Z)%Z)%Z) ->
   ((((ase x) y) i) = (((a x) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = rse) ->
   ((((ase x) y) (h - 1%Z)%Z) =
    ((a' (make_bv (fun (i:Z) => (((b x) (hpart y r)) i)) (width c)))
     (tpart y r)))) ->
  (rse = (r + r')%Z) -> (l < h)%Z ->
  ((sequence_spec_i_l c c' ase a a' l h bse b b' rse r r') = (sequence c c')).

Parameter parallel_spec_i:
  circuit -> circuit -> (bitvec -> bitvec -> Z -> angle) ->
  (bitvec -> bitvec -> Z -> angle) -> (bitvec -> bitvec -> Z -> angle) ->
  Z -> Z -> Z -> (bitvec -> bitvec -> Z -> Z) ->
  (bitvec -> bitvec -> Z -> Z) -> (bitvec -> bitvec -> Z -> Z) -> Z -> 
  Z -> Z -> circuit.

Axiom parallel_spec_i_def :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> Z -> angle)
    (l:Z) (z:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z) (r':Z),
  (correct_path_sum_i c a l z b r) -> (correct_path_sum_i c' a' z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((l <= i)%Z /\ (i < z)%Z) ->
   ((((ase x) y) i) = (((a (hpart x (width c))) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a' (tpart x (width c))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) = (((b (hpart x (width c))) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   (((width c) <= i)%Z /\ (i < ((width c) + (width c'))%Z)%Z) ->
   ((((bse x) y) i) =
    (((b' (tpart x (width c))) (tpart y r)) (i - (width c))%Z))) ->
  (rse = (r + r')%Z) -> ((l <= z)%Z /\ (z <= h)%Z) ->
  ((parallel_spec_i c c' ase a a' l z h bse b b' rse r r') = (parallel c c')).

Axiom parallel_spec_i_spec :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> Z -> angle)
    (l:Z) (z:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z) (r':Z),
  (correct_path_sum_i c a l z b r) -> (correct_path_sum_i c' a' z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((l <= i)%Z /\ (i < z)%Z) ->
   ((((ase x) y) i) = (((a (hpart x (width c))) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a' (tpart x (width c))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) = (((b (hpart x (width c))) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   (((width c) <= i)%Z /\ (i < ((width c) + (width c'))%Z)%Z) ->
   ((((bse x) y) i) =
    (((b' (tpart x (width c))) (tpart y r)) (i - (width c))%Z))) ->
  (rse = (r + r')%Z) -> ((l <= z)%Z /\ (z <= h)%Z) ->
  correct_path_sum_i (parallel c c') ase l h bse rse.

Axiom parallel_spec_i_spec1 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (a':bitvec -> bitvec -> Z -> angle)
    (l:Z) (z:Z) (h:Z) (bse:bitvec -> bitvec -> Z -> Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z) (r':Z),
  (correct_path_sum_i c a l z b r) -> (correct_path_sum_i c' a' z h b' r') ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((l <= i)%Z /\ (i < z)%Z) ->
   ((((ase x) y) i) = (((a (hpart x (width c))) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((z <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a' (tpart x (width c))) (tpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((bse x) y) i) = (((b (hpart x (width c))) (hpart y r)) i))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z),
   ((length x) = ((width c) + (width c'))%Z) -> ((length y) = rse) ->
   (((width c) <= i)%Z /\ (i < ((width c) + (width c'))%Z)%Z) ->
   ((((bse x) y) i) =
    (((b' (tpart x (width c))) (tpart y r)) (i - (width c))%Z))) ->
  (rse = (r + r')%Z) -> ((l <= z)%Z /\ (z <= h)%Z) ->
  ((width (parallel_spec_i c c' ase a a' l z h bse b b' rse r r')) =
   ((width c) + (width c'))%Z).

Axiom replace_ang_ind_i :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle)
    (a':bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z) (l':Z) (h':Z)
    (b:bitvec -> bitvec -> Z -> Z) (r:Z),
  (correct_path_sum_i c a l h b r) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = r) ->
   ((ang_sum ((a x) y) l h) = (ang_sum ((a' x) y) l' h'))) ->
  correct_path_sum_i c a' l' h' b r.

Axiom replace_ang_ind_i_eq :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle)
    (a':bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (b:bitvec -> bitvec -> Z -> Z) (r:Z),
  (correct_path_sum_i c a l h b r) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width c)) ->
   ((length y) = r) -> ((l <= i)%Z /\ (i < h)%Z) ->
   ((((a x) y) i) = (((a' x) y) i))) ->
  correct_path_sum_i c a' l h b r.

Axiom replace_ket_i :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (r:Z),
  (correct_path_sum_i c a l h b r) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = r) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((b x) y) i) = (((b' x) y) i))) ->
  correct_path_sum_i c a l h b' r.

Axiom set_sum_i_sim :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle)
    (a':bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z) (l':Z) (h':Z)
    (b:bitvec -> bitvec -> Z -> Z) (b':bitvec -> bitvec -> Z -> Z) (r:Z)
    (r':Z),
  (correct_path_sum_i c a l h b r) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   ((length y) = r) ->
   ((ang_sum ((a x) y) l h) = (ang_sum ((a' x) y) l' h'))) ->
  (forall (x:bitvec) (y:bitvec) (i:Z), ((length x) = (width c)) ->
   ((length y) = r) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((b x) y) i) = (((b' x) y) i))) ->
  (r = r') -> correct_path_sum_i c a' l' h' b' r'.

Axiom set_correct_path_sum_i_cardone :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z) (l':Z)
    (h':Z) (b:bitvec -> bitvec -> Z -> Z) (r:Z),
  (correct_path_sum_i c a l h b r) -> ((l' + 1%Z)%Z = h') ->
  correct_path_sum_i c
  (fun (x:bitvec) (y:bitvec) (us:Z) =>
   (ang_sum (fun (j:Z) => (((a x) y) j)) l h))
  l' h' b r.

Axiom set_sem_by_sim_i :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (bound:Z)
    (k:bitvec -> bitvec -> Z -> Z) (x:matrix t) (f:bitvec -> matrix t),
  (is_a_ket_basis_elt x) -> (is_a_ket_l x (width c)) ->
  (bound = (ang_ind_bound c)) ->
  (forall (x1:bitvec) (y:bitvec), forall (i:Z), ((length x1) = (width c)) ->
   ((length y) = (range c)) -> ((0%Z <= i)%Z /\ (i < bound)%Z) ->
   ((ang_ind_i c x1 y i) = (((a x1) y) i))) ->
  (forall (x1:bitvec) (y:bitvec) (i:Z), ((length x1) = (width c)) ->
   ((length y) = (range c)) -> ((0%Z <= i)%Z /\ (i < (width c))%Z) ->
   ((((k x1) y) i) = (basis_ket_i c x1 y i))) ->
  (forall (y:bitvec), ((length y) = (range c)) ->
   ((f y) =
    (infix_asdtdt (ang_exp (ang_sum ((a (ket_to_bv x)) y) 0%Z bound))
     (bv_to_ket (make_bv ((k (ket_to_bv x)) y) (width c)))))) ->
  sem c x
  (infix_asdtdt (pow_inv_sqrt_2 (range c))
   (ket_sum_l (n_bvs (range c)) f (width c))).

Axiom set_correct_path_sum_by_i :
  forall (c:circuit) (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (k:bitvec -> bitvec -> Z -> Z) (range1:Z),
  (correct_path_sum_i c a l h k range1) ->
  correct_path_sum c
  (fun (x:bitvec) (y:bitvec) => (ang_sum (fun (i:Z) => (((a x) y) i)) l h))
  (fun (x:bitvec) (y:bitvec) =>
   (make_bv (fun (i:Z) => (((k x) y) i)) (width c)))
  range1.

Parameter place: circuit -> Z -> Z -> circuit.

Axiom place_spec :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> ((ancillas (place c k n)) = (ancillas c)).

Axiom place_spec1 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> ((size (place c k n)) = (size c)).

Axiom place_spec2 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> ((range (place c k n)) = (range c)).

Axiom place_spec3 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> ((width (place c k n)) = n).

Axiom place_spec4 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = n) -> ((length y) = (range c)) ->
  ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((basis_ket_i (place c k n) x y i) =
    (basis_ket_i c (htpart x k (width c)) y (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((basis_ket_i (place c k n) x y i) = ((getbv x) i))).

Parameter fc11: circuit -> Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def11 :
  forall (c:circuit) (k:Z) (x:bitvec) (y:bitvec) (i:Z),
  (((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   (((fc11 c k x y) i) = (basis_ket_i c (htpart x k (width c)) y (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   (((fc11 c k x y) i) = ((getbv x) i))).

Axiom place_spec5 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = (range c)) ->
  ((basis_ket (place c k n) x y) = (make_bv (fc11 c k x y) n)).

Axiom place_spec6 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = (ang_ind_bound c)) ->
  ((ang_ind (place c k n) x y) = (ang_ind c (htpart x k (width c)) y)).

Parameter place_i:
  circuit -> Z -> Z -> (bitvec -> bitvec -> Z -> angle) -> Z -> Z ->
  (bitvec -> bitvec -> Z -> Z) -> Z -> circuit.

Axiom place_i_spec :
  forall (c:circuit) (k:Z) (n:Z) (a:bitvec -> bitvec -> Z -> angle) (l:Z)
    (h:Z) (b:bitvec -> bitvec -> Z -> Z) (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (l < h)%Z ->
  (correct_path_sum_i c a l h b r) -> ((width (place_i c k n a l h b r)) = n).

Parameter fc12:
  circuit -> Z -> (bitvec -> bitvec -> Z -> Z) -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def12 :
  forall (c:circuit) (k:Z) (b:bitvec -> bitvec -> Z -> Z) (x:bitvec)
    (y:bitvec) (i:Z),
  (((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   (((((fc12 c k b) x) y) i) = (((b (htpart x k (width c))) y) (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   (((((fc12 c k b) x) y) i) = ((getbv x) i))).

Axiom place_i_spec1 :
  forall (c:circuit) (k:Z) (n:Z) (a:bitvec -> bitvec -> Z -> angle) (l:Z)
    (h:Z) (b:bitvec -> bitvec -> Z -> Z) (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (l < h)%Z ->
  (correct_path_sum_i c a l h b r) ->
  correct_path_sum_i (place_i c k n a l h b r)
  (fun (x:bitvec) (y:bitvec) (i:Z) => (((a (htpart x k (width c))) y) i)) l h
  (fc12 c k b) r.

Axiom place_i_spec2 :
  forall (c:circuit) (k:Z) (n:Z) (a:bitvec -> bitvec -> Z -> angle) (l:Z)
    (h:Z) (b:bitvec -> bitvec -> Z -> Z) (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (l < h)%Z ->
  (correct_path_sum_i c a l h b r) ->
  ((place_i c k n a l h b r) = (place c k n)).

Parameter place_spec_i:
  circuit -> Z -> Z -> (bitvec -> bitvec -> Z -> angle) ->
  (bitvec -> bitvec -> Z -> angle) -> Z -> Z ->
  (bitvec -> bitvec -> Z -> Z) -> (bitvec -> bitvec -> Z -> Z) -> Z -> 
  Z -> circuit.

Axiom place_spec_i_def :
  forall (c:circuit) (k:Z) (n:Z) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (bse:bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (l < h)%Z -> (rse = r) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((((bse x) y) i) = (((b (htpart x k (width c))) y) (i - k)%Z))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < k)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> (((k + (width c))%Z <= i)%Z /\ (i < n)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a (htpart x k (width c))) y) i))) ->
  (correct_path_sum_i c a l h b r) ->
  ((place_spec_i c k n ase a l h bse b rse r) = (place_i c k n a l h b r)).

Axiom place_spec_i_spec :
  forall (c:circuit) (k:Z) (n:Z) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (bse:bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (l < h)%Z -> (rse = r) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((((bse x) y) i) = (((b (htpart x k (width c))) y) (i - k)%Z))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < k)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> (((k + (width c))%Z <= i)%Z /\ (i < n)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a (htpart x k (width c))) y) i))) ->
  (correct_path_sum_i c a l h b r) ->
  ((width (place_spec_i c k n ase a l h bse b rse r)) = n).

Axiom place_spec_i_spec1 :
  forall (c:circuit) (k:Z) (n:Z) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (bse:bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (l < h)%Z -> (rse = r) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((((bse x) y) i) = (((b (htpart x k (width c))) y) (i - k)%Z))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < k)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> (((k + (width c))%Z <= i)%Z /\ (i < n)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a (htpart x k (width c))) y) i))) ->
  (correct_path_sum_i c a l h b r) ->
  ((place_spec_i c k n ase a l h bse b rse r) = (place c k n)).

Axiom place_spec_i_spec2 :
  forall (c:circuit) (k:Z) (n:Z) (ase:bitvec -> bitvec -> Z -> angle)
    (a:bitvec -> bitvec -> Z -> angle) (l:Z) (h:Z)
    (bse:bitvec -> bitvec -> Z -> Z) (b:bitvec -> bitvec -> Z -> Z) (rse:Z)
    (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (l < h)%Z -> (rse = r) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((((bse x) y) i) = (((b (htpart x k (width c))) y) (i - k)%Z))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((0%Z <= i)%Z /\ (i < k)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> (((k + (width c))%Z <= i)%Z /\ (i < n)%Z) ->
   ((((bse x) y) i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = rse) -> ((l <= i)%Z /\ (i < h)%Z) ->
   ((((ase x) y) i) = (((a (htpart x k (width c))) y) i))) ->
  (correct_path_sum_i c a l h b r) ->
  correct_path_sum_i (place_spec_i c k n ase a l h bse b rse r) ase l h bse
  rse.

Parameter fc13:
  circuit -> Z -> (bitvec -> bitvec -> bitvec) -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def13 :
  forall (c:circuit) (k:Z) (b:bitvec -> bitvec -> bitvec) (x:bitvec)
    (y:bitvec) (i:Z),
  (((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   (((fc13 c k b x y) i) =
    ((getbv ((b (htpart x k (width c))) y)) (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   (((fc13 c k b x y) i) = ((getbv x) i))).

Axiom place_comp_scheme :
  forall (c:circuit) (k:Z) (n:Z) (a:bitvec -> bitvec -> angle)
    (b:bitvec -> bitvec -> bitvec) (r:Z),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (correct_path_sum c a b r) ->
  correct_path_sum (place c k n)
  (fun (x:bitvec) (y:bitvec) => ((a (htpart x k (width c))) y))
  (fun (x:bitvec) (y:bitvec) => (make_bv (fc13 c k b x y) n)) r.

Axiom place_kron :
  forall (c:circuit) (k:Z) (n:Z) (x:matrix t) (y:matrix t) (y':matrix t)
    (z:matrix t),
  (k >= 0%Z)%Z -> (n >= ((width c) + k)%Z)%Z -> (is_a_ket_l x k) ->
  (is_a_ket_l y (width c)) -> (is_a_ket_l z ((n - (width c))%Z - k)%Z) ->
  (sem c y y') ->
  sem (place c k n) (kronecker x (kronecker y z))
  (kronecker x (kronecker y' z)).

Axiom place_kron_left :
  forall (c:circuit) (n:Z) (y:matrix t) (y':matrix t) (z:matrix t),
  (n >= (width c))%Z -> (is_a_ket_l y (width c)) ->
  (is_a_ket_l z (n - (width c))%Z) -> (sem c y y') ->
  sem (place c 0%Z n) (kronecker y z) (kronecker y' z).

Axiom place_kron_left_basis_gen :
  forall (c:circuit) (n:Z), (n >= (width c))%Z ->
  forall (y:matrix t) (y':matrix t) (z:matrix t), (is_a_ket_l y (width c)) ->
  (is_a_ket_basis_elt y) -> (is_a_ket_l z (n - (width c))%Z) ->
  (sem c y y') -> sem (place c 0%Z n) (kronecker y z) (kronecker y' z).

Axiom place_kron_right :
  forall (c:circuit) (k:Z) (n:Z) (x:matrix t) (y:matrix t) (y':matrix t),
  (n = ((width c) + k)%Z) -> (is_a_ket_l x k) -> (is_a_ket_l y (width c)) ->
  (sem c y y') -> sem (place c k n) (kronecker x y) (kronecker x y').

Axiom place_kron_left_gen :
  forall (c:circuit) (n:Z), (n >= (width c))%Z ->
  forall (y:matrix t) (y':matrix t) (z:matrix t),
  (is_a_ket_l z (n - (width c))%Z) -> (sem c y y') ->
  sem (place c 0%Z n) (kronecker y z) (kronecker y' z).

Axiom place_kron_right_gen :
  forall (c:circuit) (k:Z) (n:Z), (n = ((width c) + k)%Z) ->
  forall (y:matrix t) (y':matrix t) (x:matrix t), (is_a_ket_l x k) ->
  (sem c y y') -> sem (place c k n) (kronecker x y) (kronecker x y').

Axiom place_kron_right_pat :
  forall (c:circuit) (k:Z) (n:Z), (n = ((width c) + k)%Z) ->
  forall (y:matrix t) (x:matrix t), (is_a_ket_l x k) ->
  (is_a_ket_l y (n - k)%Z) ->
  ((pat_sem (place c k n) (kronecker x y)) = (kronecker x (pat_sem c y))).

Parameter cont_size: Z.

Axiom cont_size_def : (0%Z < cont_size)%Z.

Parameter cont: circuit -> Z -> Z -> Z -> circuit.

Axiom cont_spec :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((size (cont c co ft n)) <= ((size c) * cont_size)%Z)%Z.

Axiom cont_spec1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((ancillas (cont c co ft n)) = (ancillas c)).

Axiom cont_spec2 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((range (cont c co ft n)) = (range c)).

Axiom cont_spec3 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((width (cont c co ft n)) = n).

Axiom cont_spec4 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((ancillas (cont c co ft n)) = (ancillas c)).

Axiom cont_spec5 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec) (y:bitvec), ((length bv) = n) ->
  ((length y) = (range c)) -> (((getbv bv) co) = 0%Z) ->
  ((basis_ket (cont c co ft n) bv y) = bv).

Axiom cont_spec6 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec) (y:bitvec), ((length bv) = n) ->
  ((length y) = (range c)) -> (((getbv bv) co) = 0%Z) ->
  ((ang_ind (cont c co ft n) bv y) = ang_zero).

Axiom cont_spec7 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec) (y:bitvec), forall (i:Z), ((length bv) = n) ->
  ((length y) = (range c)) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((getbv bv) co) = 1%Z) ->
  (((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((basis_ket_i (cont c co ft n) bv y i) =
    (basis_ket_i c (htpart bv ft (width c)) y (i - ft)%Z))) /\
  (~ ((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((basis_ket_i (cont c co ft n) bv y i) = ((getbv bv) i))).

Axiom cont_spec8 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec) (y:bitvec), ((length bv) = n) ->
  ((length y) = (range c)) -> (((getbv bv) co) = 1%Z) ->
  ((ang_ind (cont c co ft n) bv y) = (ang_ind c (htpart bv ft (width c)) y)).

Axiom cont_spec9 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec), ((length bv) = n) -> ((length bv) = n) ->
  (((getbv bv) co) = 0%Z) ->
  sem (cont c co ft n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cont_spec10 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec), ((length bv) = n) -> (((getbv bv) co) = 1%Z) ->
  sem (cont c co ft n) (bv_to_ket bv) (pat_sem (place c ft n) (bv_to_ket bv)).

Axiom cont_spec11 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((width (cont c co ft n)) = n).

Axiom cont_spec12 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z ->
  ((size (cont c co ft n)) <= ((size c) * cont_size)%Z)%Z.

Axiom cont_spec13 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z ->
  ((ancillas (cont c co ft n)) = (ancillas c)).

Axiom cont_spec14 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> ((range (cont c co ft n)) = (range c)).

Axiom cont_spec15 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> ((width (cont c co ft n)) = n).

Axiom cont_spec16 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z ->
  ((ancillas (cont c co ft n)) = (ancillas c)).

Axiom cont_spec17 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec) (y:bitvec),
  ((length bv) = n) -> ((length y) = (range c)) -> (((getbv bv) co) = 0%Z) ->
  ((basis_ket (cont c co ft n) bv y) = bv).

Axiom cont_spec18 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec) (y:bitvec),
  ((length bv) = n) -> ((length y) = (range c)) -> (((getbv bv) co) = 0%Z) ->
  ((ang_ind (cont c co ft n) bv y) = ang_zero).

Axiom cont_spec19 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec) (y:bitvec),
  forall (i:Z), ((length bv) = n) -> ((length y) = (range c)) ->
  ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv bv) co) = 1%Z) ->
  (((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((basis_ket_i (cont c co ft n) bv y i) =
    (basis_ket_i c (htpart bv ft (width c)) y (i - ft)%Z))) /\
  (~ ((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((basis_ket_i (cont c co ft n) bv y i) = ((getbv bv) i))).

Axiom cont_spec20 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec) (y:bitvec),
  ((length bv) = n) -> ((length y) = (range c)) -> (((getbv bv) co) = 1%Z) ->
  ((ang_ind (cont c co ft n) bv y) = (ang_ind c (htpart bv ft (width c)) y)).

Axiom cont_spec21 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  ((length bv) = n) -> (((getbv bv) co) = 0%Z) ->
  sem (cont c co ft n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cont_spec22 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) co) = 1%Z) ->
  sem (cont c co ft n) (bv_to_ket bv) (pat_sem (place c ft n) (bv_to_ket bv)).

Axiom cont_spec23 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> ((width (cont c co ft n)) = n).

Axiom bound_size_cont :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (s:Z),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((size c) <= s)%Z -> ((size (cont c co ft n)) <= (cont_size * s)%Z)%Z.

Axiom bound_size_cont1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (s:Z),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> ((size c) <= s)%Z ->
  ((size (cont c co ft n)) <= (cont_size * s)%Z)%Z.

Axiom mat_cont :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:matrix t), (is_a_ket_l x n) -> (is_a_ket_basis_elt x) ->
  (((getbv (ket_to_bv x)) co) = 0%Z) -> sem (cont c co ft n) x x.

Axiom mat_cont1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:matrix t), (is_a_ket_l x n) -> (is_a_ket_basis_elt x) ->
  (((getbv (ket_to_bv x)) co) = 1%Z) ->
  sem (cont c co ft n) x (pat_sem (place c ft n) x).

Axiom mat_cont2 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 0%Z) ->
  sem (cont c co ft n) x x.

Axiom mat_cont3 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 1%Z) ->
  sem (cont c co ft n) x (pat_sem (place c ft n) x).

Axiom pat_cont :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec), ((length bv) = n) -> (((getbv bv) co) = 0%Z) ->
  ((pat_sem (cont c co ft n) (bv_to_ket bv)) = (bv_to_ket bv)).

Axiom pat_cont1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (bv:bitvec), ((length bv) = n) -> (((getbv bv) co) = 1%Z) ->
  ((pat_sem (cont c co ft n) (bv_to_ket bv)) =
   (pat_sem (place c ft n) (bv_to_ket bv))).

Axiom pat_cont2 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) co) = 0%Z) ->
  ((pat_sem (cont c co ft n) (bv_to_ket bv)) = (bv_to_ket bv)).

Axiom pat_cont3 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) co) = 1%Z) ->
  ((pat_sem (cont c co ft n) (bv_to_ket bv)) =
   (pat_sem (place c ft n) (bv_to_ket bv))).

Axiom pat_cont_ketz :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (x:matrix t),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (is_a_ket_l x n) -> (is_a_ket_basis_elt x) ->
  (((getbv (ket_to_bv x)) co) = 0%Z) -> ((pat_sem (cont c co ft n) x) = x).

Axiom pat_cont_ketz1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (x:matrix t),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 0%Z) ->
  ((pat_sem (cont c co ft n) x) = x).

Axiom pat_cont_keto :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (x:matrix t),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (is_a_ket_l x n) -> (is_a_ket_basis_elt x) ->
  (((getbv (ket_to_bv x)) co) = 1%Z) ->
  ((pat_sem (cont c co ft n) x) = (pat_sem (place c ft n) x)).

Axiom pat_cont_keto1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (x:matrix t),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 1%Z) ->
  ((pat_sem (cont c co ft n) x) = (pat_sem (place c ft n) x)).

Axiom pat_cont_ketz_gen :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:matrix t), (is_a_ket_l x n) -> (is_a_ket_basis_elt x) ->
  (((getbv (ket_to_bv x)) co) = 0%Z) -> ((pat_sem (cont c co ft n) x) = x).

Axiom pat_cont_ketz_gen1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 0%Z) ->
  ((pat_sem (cont c co ft n) x) = x).

Axiom pat_cont_keto_gen :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:matrix t), (is_a_ket_l x n) -> (is_a_ket_basis_elt x) ->
  (((getbv (ket_to_bv x)) co) = 1%Z) ->
  ((pat_sem (cont c co ft n) x) = (pat_sem (place c ft n) x)).

Axiom pat_cont_keto_gen1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 1%Z) ->
  ((pat_sem (cont c co ft n) x) = (pat_sem (place c ft n) x)).

Axiom cont_ketz_gen :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:matrix t), (is_a_ket_l x n) -> (is_a_ket_basis_elt x) ->
  (((getbv (ket_to_bv x)) co) = 0%Z) -> sem (cont c co ft n) x x.

Axiom cont_ketz_gen1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 0%Z) ->
  sem (cont c co ft n) x x.

Axiom cont_keto_gen :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (f:bitvec -> matrix t),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  (forall (x:bitvec), ((length x) = n) ->
   sem (place c ft n) (bv_to_ket x) (f x)) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((getbv x) co) = 1%Z) -> sem (cont c co ft n) (bv_to_ket x) (f x).

Axiom cont_keto_gen1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z) (f:bitvec -> matrix t),
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  (forall (x:bitvec), ((length x) = n) ->
   sem (place c ft n) (bv_to_ket x) (f x)) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((getbv x) co) = 1%Z) -> sem (cont c co ft n) (bv_to_ket x) (f x).

Parameter diag_mat: Z -> (Z -> t) -> matrix t.

Axiom diag_mat_def :
  forall (n:Z) (f:Z -> t), (n > 0%Z)%Z ->
  ((diag_mat n f) =
   (make_f n n (fun (i:Z) (j:Z) => (infix_asdt (f i) (indic i j))))).

Axiom diag_mat_spec :
  forall (n:Z) (f:Z -> t), (n > 0%Z)%Z -> forall (i:Z) (j:Z),
  (((0%Z <= i)%Z /\ (i < n)%Z) /\ ((0%Z <= j)%Z /\ (j < n)%Z)) ->
  ~ (i = j) -> ((get (diag_mat n f) i j) = tzero).

Axiom diag_mat_spec1 :
  forall (n:Z) (f:Z -> t), (n > 0%Z)%Z -> forall (i:Z) (j:Z),
  (((0%Z <= i)%Z /\ (i < n)%Z) /\ ((0%Z <= j)%Z /\ (j < n)%Z)) -> (i = j) ->
  ((get (diag_mat n f) i j) = (f i)).

Axiom diag_mat_values :
  forall (n:Z) (f:Z -> t) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((0%Z <= j)%Z /\ (j < n)%Z) ->
  ((get (diag_mat n f) i j) = (infix_asdt (f i) (indic i j))).

Axiom diag_mat_eq :
  forall (f:Z -> t) (g:Z -> t) (n:Z), (n > 0%Z)%Z ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ((f i) = (g i))) ->
  ((diag_mat n f) = (diag_mat n g)).

Axiom mat_mult_diag :
  forall (m:matrix t) (f:Z -> t),
  ((mat_mult m (diag_mat (columns m) f)) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_asdt (get m i j) (f j))))).

Axiom diag_mult_mat :
  forall (m:matrix t) (f:Z -> t),
  ((mat_mult (diag_mat (rows m) f) m) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_asdt (get m i j) (f i))))).

Axiom diag_mult_diag :
  forall (f:Z -> t) (g:Z -> t) (n:Z), (n > 0%Z)%Z ->
  ((mat_mult (diag_mat n f) (diag_mat n g)) =
   (diag_mat n (fun (i:Z) => (infix_asdt (f i) (g i))))).

Axiom ind_product_re :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (n:Z), (i < j)%Z -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((ind_product (fun (i1:Z) => ((f i1) k)) i (j + 1%Z)%Z) =
   (infix_asdt (ind_product (fun (i1:Z) => ((f i1) k)) i j) ((f j) k))).

Axiom int_mat_diag_prod :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (n:Z), (n > 0%Z)%Z -> (i <= j)%Z ->
  ((int_mat_prod (fun (k:Z) => (diag_mat n (f k))) i j) =
   (diag_mat n
    (fun (k:Z) => (ind_product (fun (l:Z) => ((f l) k)) i (j + 1%Z)%Z)))).

Parameter diag_two_mat: Z -> (Z -> Z -> Z -> t) -> matrix t.

Parameter result19: Z -> (Z -> Z -> Z -> t) -> Z -> Z -> t.

Axiom result_def19 :
  forall (n:Z) (f:Z -> Z -> Z -> t) (i:Z) (j:Z),
  ((((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
    ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result19 n f) i) j) =
    (infix_asdt (indic (tail_bits i n) (tail_bits j n))
     (((f (head_bit i n)) (head_bit j n)) (tail_bits i n))))) /\
  (~ (((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
      ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result19 n f) i) j) = tzero)).

Axiom diag_two_mat_def :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((diag_two_mat n f) = (make_f (power 2%Z n) (power 2%Z n) (result19 n f))).

Axiom diag_two_mat_spec :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((rows (diag_two_mat n f)) = (power 2%Z n)).

Axiom diag_two_mat_spec1 :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((columns (diag_two_mat n f)) = (power 2%Z n)).

Axiom diag_two_mat_spec2 :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((diag_two_mat n f) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt (indic (tail_bits i n) (tail_bits j n))
      (((f (head_bit i n)) (head_bit j n)) (tail_bits i n)))))).

Parameter two_bloc_diag_mat: Z -> (Z -> Z -> Z -> t) -> matrix t.

Parameter result20: Z -> (Z -> Z -> Z -> t) -> Z -> Z -> t.

Axiom result_def20 :
  forall (n:Z) (f:Z -> Z -> Z -> t) (i:Z) (j:Z),
  ((((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
    ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result20 n f) i) j) =
    (infix_asdt (indic (head_bit i n) (head_bit j n))
     (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n))))) /\
  (~ (((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
      ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result20 n f) i) j) = tzero)).

Axiom two_bloc_diag_mat_def :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((two_bloc_diag_mat n f) =
   (make_f (power 2%Z n) (power 2%Z n) (result20 n f))).

Axiom two_bloc_diag_mat_spec :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((rows (two_bloc_diag_mat n f)) = (power 2%Z n)).

Axiom two_bloc_diag_mat_spec1 :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((columns (two_bloc_diag_mat n f)) = (power 2%Z n)).

Axiom two_bloc_diag_mat_spec2 :
  forall (n:Z) (f:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((two_bloc_diag_mat n f) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt (indic (head_bit i n) (head_bit j n))
      (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n)))))).

Axiom two_bloc_diag_two_val :
  forall (n:Z) (f:Z -> Z -> Z -> t) (g:Z -> Z -> Z -> t) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) -> (n >= 2%Z)%Z ->
  ((get (mat_mult (two_bloc_diag_mat n f) (diag_two_mat n g)) i j) =
   (infix_asdt (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n))
    (((g (head_bit i n)) (head_bit j n)) (tail_bits j n)))).

Axiom two_bloc_diag_two :
  forall (n:Z) (f:Z -> Z -> Z -> t) (g:Z -> Z -> Z -> t), (n >= 2%Z)%Z ->
  ((mat_mult (two_bloc_diag_mat n f) (diag_two_mat n g)) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n))
      (((g (head_bit i n)) (head_bit j n)) (tail_bits j n)))))).

Axiom two_bloc_mult_diag :
  forall (n:Z) (f:Z -> Z -> Z -> t) (g:Z -> t), (n >= 2%Z)%Z ->
  ((mat_mult (two_bloc_diag_mat n f) (diag_mat (power 2%Z n) g)) =
   (two_bloc_diag_mat n
    (fun (hi:Z) (ti:Z) (tj:Z) =>
     (infix_asdt (((f hi) ti) tj) (g (ht_to_int hi tj n)))))).

Axiom kronecker_scalar_distr :
  forall (m:matrix t) (n:matrix t) (a:t),
  ((kronecker (infix_asdtdt a m) n) = (infix_asdtdt a (kronecker m n))).

Axiom kronecker_scalar_distr_r :
  forall (m:matrix t) (n:matrix t) (a:t),
  ((kronecker m (infix_asdtdt a n)) = (infix_asdtdt a (kronecker m n))).

Axiom kronecker_scalars :
  forall (m:matrix t) (n:matrix t) (a:t) (b:t),
  ((kronecker (infix_asdtdt a m) (infix_asdtdt b n)) =
   (infix_asdtdt (infix_asdt a b) (kronecker m n))).

Parameter mat_k_id: (matrix t) -> Z -> matrix t.

Axiom mat_k_id_def :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((mat_k_id m n) = (kronecker m (identity n))).

Axiom mat_k_id_spec :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((mat_k_id m n) =
   (make_f ((rows m) * (power 2%Z n))%Z ((columns m) * (power 2%Z n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (indic (int.EuclideanDivision.mod1 i (power 2%Z n))
       (int.EuclideanDivision.mod1 j (power 2%Z n)))
      (get m (int.EuclideanDivision.div i (power 2%Z n))
       (int.EuclideanDivision.div j (power 2%Z n))))))).

Axiom mat_k_id_values :
  forall (m:matrix t) (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < ((rows m) * (power 2%Z n))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < ((columns m) * (power 2%Z n))%Z)%Z) ->
  ((get (mat_k_id m n) i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i (power 2%Z n))
     (int.EuclideanDivision.mod1 j (power 2%Z n)))
    (get m (int.EuclideanDivision.div i (power 2%Z n))
     (int.EuclideanDivision.div j (power 2%Z n))))).

Axiom mat_k_id_rows :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((rows (mat_k_id m n)) = ((rows m) * (power 2%Z n))%Z).

Axiom mat_k_id_columns :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns (mat_k_id m n)) = ((columns m) * (power 2%Z n))%Z).

Parameter id_k_mat: (matrix t) -> Z -> matrix t.

Axiom id_k_mat_def :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((id_k_mat m n) = (kronecker (identity n) m)).

Axiom id_k_mat_spec :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((id_k_mat m n) =
   (make_f ((rows m) * (power 2%Z n))%Z ((columns m) * (power 2%Z n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (indic (int.EuclideanDivision.div i (rows m))
       (int.EuclideanDivision.div j (columns m)))
      (get m (int.EuclideanDivision.mod1 i (rows m))
       (int.EuclideanDivision.mod1 j (columns m))))))).

Axiom id_k_mat_values :
  forall (m:matrix t) (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < ((rows m) * (power 2%Z n))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < ((columns m) * (power 2%Z n))%Z)%Z) ->
  ((get (id_k_mat m n) i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.div i (rows m))
     (int.EuclideanDivision.div j (columns m)))
    (get m (int.EuclideanDivision.mod1 i (rows m))
     (int.EuclideanDivision.mod1 j (columns m))))).

Axiom id_k_mat_rows :
  forall (m:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((rows (id_k_mat m n)) = ((rows m) * (power 2%Z n))%Z).

Axiom id_k_mat_columns :
  forall (m:matrix t) (n:Z), (0%Z < n)%Z ->
  ((columns (id_k_mat m n)) = ((columns m) * (power 2%Z n))%Z).

Parameter mat_prod_k_id: (matrix t) -> (matrix t) -> Z -> matrix t.

Axiom mat_prod_k_id_def :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((mat_prod_k_id m o n) = (kronecker (mat_mult m o) (identity n))).

Axiom mat_prod_k_id_spec :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((mat_prod_k_id m o n) =
   (make_f ((rows m) * (power 2%Z n))%Z ((columns o) * (power 2%Z n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (indic (int.EuclideanDivision.mod1 i (power 2%Z n))
       (int.EuclideanDivision.mod1 j (power 2%Z n)))
      (ind_sum
       (fun (k:Z) =>
        (infix_asdt (get m (int.EuclideanDivision.div i (power 2%Z n)) k)
         (get o k (int.EuclideanDivision.div j (power 2%Z n)))))
       0%Z (columns m)))))).

Parameter id_k_mat_prod: (matrix t) -> (matrix t) -> Z -> matrix t.

Axiom id_k_mat_prod_def :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((id_k_mat_prod m o n) = (kronecker (identity n) (mat_mult m o))).

Axiom id_k_mat_prod_spec :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((id_k_mat_prod m o n) =
   (make_f ((rows m) * (power 2%Z n))%Z ((columns o) * (power 2%Z n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (indic (int.EuclideanDivision.div i (rows m))
       (int.EuclideanDivision.div j (columns o)))
      (ind_sum
       (fun (k:Z) =>
        (infix_asdt (get m (int.EuclideanDivision.mod1 i (rows m)) k)
         (get o k (int.EuclideanDivision.mod1 j (columns o)))))
       0%Z (columns m)))))).

Axiom filter_sum_mod_indic :
  forall (v:Z) (n:Z) (p:Z) (g:Z -> t), (n > 0%Z)%Z -> (v > 0%Z)%Z ->
  ((0%Z <= p)%Z /\ (p < v)%Z) ->
  ((sum (to_fset 0%Z (v * n)%Z)
    (fun (k:Z) =>
     (infix_asdt (indic (int.EuclideanDivision.mod1 k v) p)
      (g (int.EuclideanDivision.div k v)))))
   = (sum (to_fset 0%Z n) g)).

Axiom filter_sum_indic_div :
  forall (v:Z) (n:Z) (p:Z) (g:Z -> t), (n > 0%Z)%Z -> (v > 0%Z)%Z ->
  ((0%Z <= p)%Z /\ (p < n)%Z) ->
  ((sum (to_fset 0%Z (v * n)%Z)
    (fun (k:Z) =>
     (infix_asdt (g (int.EuclideanDivision.mod1 k v))
      (indic (int.EuclideanDivision.div k v) p))))
   = (sum (to_fset 0%Z v) g)).

Axiom filtered_ind_sum_mod_indic :
  forall (v:Z) (n:Z) (p:Z) (g:Z -> t), (n > 0%Z)%Z -> (v > 0%Z)%Z ->
  ((0%Z <= p)%Z /\ (p < v)%Z) ->
  ((ind_sum
    (fun (k:Z) =>
     (infix_asdt (indic (int.EuclideanDivision.mod1 k v) p)
      (g (int.EuclideanDivision.div k v))))
    0%Z (v * n)%Z)
   = (ind_sum g 0%Z n)).

Axiom filtered_ind_sum_indic_div :
  forall (v:Z) (n:Z) (p:Z) (g:Z -> t), (n > 0%Z)%Z -> (v > 0%Z)%Z ->
  ((0%Z <= p)%Z /\ (p < n)%Z) ->
  ((ind_sum
    (fun (k:Z) =>
     (infix_asdt (g (int.EuclideanDivision.mod1 k v))
      (indic (int.EuclideanDivision.div k v) p)))
    0%Z (v * n)%Z)
   = (ind_sum g 0%Z v)).

Axiom prod_mat_k_id_pre :
  forall (m:matrix t) (o:matrix t) (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((0%Z <= i)%Z /\ (i < ((rows m) * (power 2%Z n))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < ((columns o) * (power 2%Z n))%Z)%Z) ->
  ((get (mat_mult (mat_k_id m n) (mat_k_id o n)) i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i (power 2%Z n))
     (int.EuclideanDivision.mod1 j (power 2%Z n)))
    (ind_sum
     (fun (k:Z) =>
      (infix_asdt (get m (int.EuclideanDivision.div i (power 2%Z n)) k)
       (get o k (int.EuclideanDivision.div j (power 2%Z n)))))
     0%Z (columns m)))).

Parameter prod_mat_k_id: (matrix t) -> (matrix t) -> Z -> matrix t.

Axiom prod_mat_k_id_def :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((prod_mat_k_id m o n) = (mat_mult (mat_k_id m n) (mat_k_id o n))).

Axiom prod_mat_k_id_spec :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((prod_mat_k_id m o n) =
   (make_f ((rows m) * (power 2%Z n))%Z ((columns o) * (power 2%Z n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (indic (int.EuclideanDivision.mod1 i (power 2%Z n))
       (int.EuclideanDivision.mod1 j (power 2%Z n)))
      (ind_sum
       (fun (k:Z) =>
        (infix_asdt (get m (int.EuclideanDivision.div i (power 2%Z n)) k)
         (get o k (int.EuclideanDivision.div j (power 2%Z n)))))
       0%Z (columns m)))))).

Axiom prod_mat_k_id_dec :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) -> ((prod_mat_k_id m o n) = (mat_prod_k_id m o n)).

Axiom k_id_prod_mat_pre :
  forall (m:matrix t) (o:matrix t) (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((0%Z <= i)%Z /\ (i < ((rows m) * (power 2%Z n))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < ((columns o) * (power 2%Z n))%Z)%Z) ->
  ((get (mat_mult (id_k_mat m n) (id_k_mat o n)) i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.div i (rows m))
     (int.EuclideanDivision.div j (columns o)))
    (ind_sum
     (fun (k:Z) =>
      (infix_asdt (get m (int.EuclideanDivision.mod1 i (rows m)) k)
       (get o k (int.EuclideanDivision.mod1 j (columns o)))))
     0%Z (columns m)))).

Parameter k_id_prod_mat: (matrix t) -> (matrix t) -> Z -> matrix t.

Axiom k_id_prod_mat_def :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((k_id_prod_mat m o n) = (mat_mult (id_k_mat m n) (id_k_mat o n))).

Axiom k_id_prod_mat_spec :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) ->
  ((k_id_prod_mat m o n) =
   (make_f ((rows m) * (power 2%Z n))%Z ((columns o) * (power 2%Z n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (indic (int.EuclideanDivision.div i (rows m))
       (int.EuclideanDivision.div j (columns o)))
      (ind_sum
       (fun (k:Z) =>
        (infix_asdt (get m (int.EuclideanDivision.mod1 i (rows m)) k)
         (get o k (int.EuclideanDivision.mod1 j (columns o)))))
       0%Z (columns m)))))).

Axiom k_id_prod_mat_dec :
  forall (m:matrix t) (o:matrix t) (n:Z), (0%Z <= n)%Z ->
  ((columns m) = (rows o)) -> ((k_id_prod_mat m o n) = (id_k_mat_prod m o n)).

Axiom split_ne_pre :
  forall (m1:matrix t) (m2:matrix t) (nc1:Z) (nc2:Z) (nr1:Z) (nr2:Z) 
    (i:Z) (j:Z),
  (0%Z <= nr1)%Z -> (0%Z <= nr2)%Z -> (0%Z <= nc1)%Z -> (0%Z <= nc2)%Z ->
  ((columns m1) = (power 2%Z nc1)) -> ((columns m2) = (power 2%Z nc2)) ->
  ((rows m1) = (power 2%Z nr1)) -> ((rows m2) = (power 2%Z nr2)) ->
  ((0%Z <= i)%Z /\ (i < ((power 2%Z nr1) * (power 2%Z nr2))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < ((power 2%Z nc1) * (power 2%Z nc2))%Z)%Z) ->
  ((get (mat_mult (id_k_mat m1 nr2) (mat_k_id m2 nc1)) i j) =
   (get (kronecker m2 m1) i j)).

Axiom split_nw_pre :
  forall (m1:matrix t) (m2:matrix t) (nc1:Z) (nc2:Z) (nr1:Z) (nr2:Z) 
    (i:Z) (j:Z),
  (0%Z <= nr1)%Z -> (0%Z <= nr2)%Z -> (0%Z <= nc1)%Z -> (0%Z <= nc2)%Z ->
  ((columns m1) = (power 2%Z nc1)) -> ((columns m2) = (power 2%Z nc2)) ->
  ((rows m1) = (power 2%Z nr1)) -> ((rows m2) = (power 2%Z nr2)) ->
  ((0%Z <= i)%Z /\ (i < ((power 2%Z nr1) * (power 2%Z nr2))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < ((power 2%Z nc1) * (power 2%Z nc2))%Z)%Z) ->
  ((get (mat_mult (mat_k_id m1 nr2) (id_k_mat m2 nc1)) i j) =
   (get (kronecker m1 m2) i j)).

Axiom split_ne :
  forall (m1:matrix t) (m2:matrix t) (nc1:Z) (nc2:Z) (nr1:Z) (nr2:Z),
  (0%Z <= nr1)%Z -> (0%Z <= nr2)%Z -> (0%Z <= nc1)%Z -> (0%Z <= nc2)%Z ->
  ((columns m1) = (power 2%Z nc1)) -> ((columns m2) = (power 2%Z nc2)) ->
  ((rows m1) = (power 2%Z nr1)) -> ((rows m2) = (power 2%Z nr2)) ->
  ((mat_mult (id_k_mat m1 nr2) (mat_k_id m2 nc1)) = (kronecker m2 m1)).

Axiom split_nw :
  forall (m1:matrix t) (m2:matrix t) (nc1:Z) (nc2:Z) (nr1:Z) (nr2:Z),
  (0%Z <= nr1)%Z -> (0%Z <= nr2)%Z -> (0%Z <= nc1)%Z -> (0%Z <= nc2)%Z ->
  ((columns m1) = (power 2%Z nc1)) -> ((columns m2) = (power 2%Z nc2)) ->
  ((rows m1) = (power 2%Z nr1)) -> ((rows m2) = (power 2%Z nr2)) ->
  ((mat_mult (mat_k_id m1 nr2) (id_k_mat m2 nc1)) = (kronecker m1 m2)).

Axiom shift_k_id :
  forall (m1:matrix t) (m2:matrix t) (nc1:Z) (nc2:Z) (nr1:Z) (nr2:Z),
  (0%Z <= nr1)%Z -> (0%Z <= nr2)%Z -> (0%Z <= nc1)%Z -> (0%Z <= nc2)%Z ->
  ((columns m1) = (power 2%Z nc1)) -> ((columns m2) = (power 2%Z nc2)) ->
  ((rows m1) = (power 2%Z nr1)) -> ((rows m2) = (power 2%Z nr2)) ->
  ((mat_mult (mat_k_id m1 nr2) (id_k_mat m2 nc1)) =
   (mat_mult (id_k_mat m2 nr1) (mat_k_id m1 nc2))).

Axiom kronecker_mult_commut :
  forall (a:matrix t) (b:matrix t) (c:matrix t) (d:matrix t) (ra:Z) (ca:Z)
    (cc:Z) (rb:Z) (cb:Z) (cd:Z),
  (0%Z <= ra)%Z -> (0%Z <= ca)%Z -> (0%Z <= cc)%Z -> (0%Z <= rb)%Z ->
  (0%Z <= cb)%Z -> (0%Z <= cd)%Z -> ((rows a) = (power 2%Z ra)) ->
  ((columns a) = (power 2%Z ca)) -> ((rows c) = (power 2%Z ca)) ->
  ((columns c) = (power 2%Z cc)) -> ((rows b) = (power 2%Z rb)) ->
  ((columns b) = (power 2%Z cb)) -> ((rows d) = (power 2%Z cb)) ->
  ((columns d) = (power 2%Z cd)) ->
  ((mat_mult (kronecker a b) (kronecker c d)) =
   (kronecker (mat_mult a c) (mat_mult b d))).

Parameter isa_square: (matrix t) -> Prop.

Axiom isa_square_def :
  forall (m:matrix t), (isa_square m) <-> ((rows m) = (columns m)).

Parameter pow2dim: (matrix t) -> Prop.

Axiom pow2dim_def :
  forall (m:matrix t),
  (pow2dim m) <->
  exists i:Z, exists j:Z,
  ((rows m) = (power 2%Z i)) /\ ((columns m) = (power 2%Z j)).

Parameter pow2dim_square: (matrix t) -> Prop.

Axiom pow2dim_square_def :
  forall (m:matrix t),
  (pow2dim_square m) <->
  exists i:Z, ((rows m) = (power 2%Z i)) /\ ((columns m) = (power 2%Z i)).

Axiom pow_2dim_kets : forall (m:matrix t), (is_a_ket m) -> pow2dim m.

Parameter lnr: (matrix t) -> Z.

Axiom lnr_spec :
  forall (m:matrix t), (pow2dim m) -> ((rows m) = (power 2%Z (lnr m))).

Axiom lnr_spec1 : forall (m:matrix t), (pow2dim m) -> ((lnr m) >= 0%Z)%Z.

Parameter lnc: (matrix t) -> Z.

Axiom lnc_spec :
  forall (m:matrix t), (pow2dim m) -> ((columns m) = (power 2%Z (lnc m))).

Axiom lnc_spec1 : forall (m:matrix t), (pow2dim m) -> ((lnc m) >= 0%Z)%Z.

Axiom get_pow2dim :
  forall (m:matrix t), (pow2dim m) ->
  exists i:Z, exists j:Z,
  ((rows m) = (power 2%Z i)) /\ ((columns m) = (power 2%Z j)).

Axiom set_pow2dim :
  forall (m:matrix t),
  (exists i:Z, exists j:Z,
   ((rows m) = (power 2%Z i)) /\ ((columns m) = (power 2%Z j))) ->
  pow2dim m.

Axiom get_pow2dim_elt :
  forall (m:matrix t) (i:Z) (j:Z), (pow2dim m) -> ((lnr m) = i) ->
  ((lnc m) = j) -> ((rows m) = (power 2%Z i)).

Axiom get_pow2dim_elt1 :
  forall (m:matrix t) (i:Z) (j:Z), (pow2dim m) -> ((lnr m) = i) ->
  ((lnc m) = j) -> ((columns m) = (power 2%Z j)).

Axiom set_pow2dim_elt :
  forall (m:matrix t) (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((rows m) = (power 2%Z i)) -> ((columns m) = (power 2%Z j)) -> pow2dim m.

Axiom set_pow2dim_elt1 :
  forall (m:matrix t) (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((rows m) = (power 2%Z i)) -> ((columns m) = (power 2%Z j)) ->
  ((lnr m) = i).

Axiom set_pow2dim_elt2 :
  forall (m:matrix t) (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((rows m) = (power 2%Z i)) -> ((columns m) = (power 2%Z j)) ->
  ((lnc m) = j).

Parameter mat_size: (matrix t) -> Z.

Axiom mat_size_def :
  forall (m:matrix t), (isa_square m) -> ((mat_size m) = (rows m)).

Axiom mat_size_spec :
  forall (m:matrix t), (isa_square m) -> ((mat_size m) = (rows m)).

Axiom mat_size_spec1 :
  forall (m:matrix t), (isa_square m) -> ((mat_size m) = (columns m)).

Axiom get_square :
  forall (m:matrix t), (isa_square m) -> ((rows m) = (columns m)).

Axiom set_square :
  forall (m:matrix t), ((rows m) = (columns m)) -> isa_square m.

Axiom set_square_elt :
  forall (m:matrix t) (i:Z), ((rows m) = i) -> ((columns m) = i) ->
  isa_square m.

Axiom set_square_elt1 :
  forall (m:matrix t) (i:Z), ((rows m) = i) -> ((columns m) = i) ->
  ((mat_size m) = i).

Axiom get_square_elt :
  forall (m:matrix t) (i:Z), (isa_square m) -> ((mat_size m) = i) ->
  ((rows m) = i).

Axiom get_square_elt1 :
  forall (m:matrix t) (i:Z), (isa_square m) -> ((mat_size m) = i) ->
  ((columns m) = i).

Axiom pow2dim_square_dec :
  forall (m:matrix t), (isa_square m) -> (pow2dim m) -> pow2dim_square m.

Axiom dec_pow2dim_square :
  forall (m:matrix t), (pow2dim_square m) -> isa_square m.

Axiom dec_pow2dim_square1 :
  forall (m:matrix t), (pow2dim_square m) -> pow2dim m.

Parameter ln_size: (matrix t) -> Z.

Axiom ln_size_def :
  forall (m:matrix t), (pow2dim_square m) -> ((ln_size m) = (lnr m)).

Axiom ln_size_spec :
  forall (m:matrix t), (pow2dim_square m) -> ((ln_size m) = (lnc m)).

Axiom ln_size_spec1 :
  forall (m:matrix t), (pow2dim_square m) ->
  ((rows m) = (power 2%Z (ln_size m))).

Axiom ln_size_spec2 :
  forall (m:matrix t), (pow2dim_square m) ->
  ((columns m) = (power 2%Z (ln_size m))).

Axiom set_ln_size_lnc :
  forall (m:matrix t) (i:Z), (pow2dim_square m) -> ((lnc m) = i) ->
  ((ln_size m) = i).

Axiom set_ln_size_lnr :
  forall (m:matrix t) (i:Z), (pow2dim_square m) -> ((lnr m) = i) ->
  ((ln_size m) = i).

Axiom set_ln_size_columns :
  forall (m:matrix t) (i:Z), (0%Z <= i)%Z -> (pow2dim_square m) ->
  ((columns m) = (power 2%Z i)) -> ((ln_size m) = i).

Axiom set_ln_size_rows :
  forall (m:matrix t) (i:Z), (0%Z <= i)%Z -> (pow2dim_square m) ->
  ((rows m) = (power 2%Z i)) -> ((ln_size m) = i).

Axiom set_pow2dim_square :
  forall (m:matrix t),
  (exists i:Z, ((rows m) = (columns m)) /\ ((columns m) = (power 2%Z i))) ->
  pow2dim_square m.

Axiom set_pow2dim_square_elt :
  forall (m:matrix t) (i:Z), (0%Z <= i)%Z ->
  (((rows m) = (columns m)) /\ ((columns m) = (power 2%Z i))) ->
  pow2dim_square m.

Axiom set_pow2dim_square_elt1 :
  forall (m:matrix t) (i:Z), (0%Z <= i)%Z ->
  (((rows m) = (columns m)) /\ ((columns m) = (power 2%Z i))) ->
  ((ln_size m) = i).

Axiom get_pow2dim_square_elt :
  forall (m:matrix t) (i:Z), (pow2dim_square m) -> ((ln_size m) = i) ->
  ((rows m) = (power 2%Z i)).

Axiom get_pow2dim_square_elt1 :
  forall (m:matrix t) (i:Z), (pow2dim_square m) -> ((ln_size m) = i) ->
  ((columns m) = (power 2%Z i)).

Axiom kronecker_mult_commut_p :
  forall (a:matrix t) (b:matrix t) (c:matrix t) (d:matrix t),
  ((columns a) = (rows c)) -> ((columns b) = (rows d)) -> (pow2dim a) ->
  (pow2dim b) -> (pow2dim c) -> (pow2dim d) ->
  ((mat_mult (kronecker a b) (kronecker c d)) =
   (kronecker (mat_mult a c) (mat_mult b d))).

Axiom kronecker_mult_commut_p_quant :
  forall (a:matrix t) (b:matrix t), (pow2dim a) -> (pow2dim b) ->
  forall (c:matrix t) (d:matrix t), ((columns a) = (rows c)) ->
  ((columns b) = (rows d)) -> (pow2dim c) -> (pow2dim d) ->
  ((mat_mult (kronecker a b) (kronecker c d)) =
   (kronecker (mat_mult a c) (mat_mult b d))).

Axiom kronecker_add_distr_l :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((rows (kronecker (add_mat m n) o)) = ((rows m) * (rows o))%Z).

Axiom kronecker_add_distr_l1 :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((columns (kronecker (add_mat m n) o)) = ((columns m) * (columns o))%Z).

Axiom kronecker_add_distr_l2 :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((kronecker (add_mat m n) o) = (add_mat (kronecker m o) (kronecker n o))).

Axiom kronecker_add_distr_r :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((kronecker o (add_mat m n)) = (add_mat (kronecker o m) (kronecker o n))).

Axiom kronecker_add_distr_r1 :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((rows (kronecker o (add_mat m n))) = ((rows m) * (rows o))%Z).

Axiom kronecker_add_distr_r2 :
  forall (m:matrix t) (n:matrix t) (o:matrix t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((columns (kronecker o (add_mat m n))) = ((columns m) * (columns o))%Z).

Axiom kronecker_sum_distr_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((columns (mat_sum s (fun (k:a) => (kronecker (f k) m)))) =
   (columns ((fun (k:a) => (kronecker (f k) m)) (choose s)))).

Axiom kronecker_sum_distr_l1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((columns ((fun (k:a) => (kronecker (f k) m)) (choose s))) =
   ((columns m) * (columns (f (choose s))))%Z).

Axiom kronecker_sum_distr_l2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((rows (mat_sum s (fun (k:a) => (kronecker (f k) m)))) =
   (rows ((fun (k:a) => (kronecker (f k) m)) (choose s)))).

Axiom kronecker_sum_distr_l3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((rows ((fun (k:a) => (kronecker (f k) m)) (choose s))) =
   ((rows m) * (rows (f (choose s))))%Z).

Axiom kronecker_sum_distr_l4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((kronecker (mat_sum s f) m) =
   (mat_sum s (fun (k:a) => (kronecker (f k) m)))).

Axiom kronecker_sum_distr_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((columns (mat_sum s (fun (k:a) => (kronecker m (f k))))) =
   (columns ((fun (k:a) => (kronecker m (f k))) (choose s)))).

Axiom kronecker_sum_distr_r1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((columns ((fun (k:a) => (kronecker m (f k))) (choose s))) =
   ((columns m) * (columns (f (choose s))))%Z).

Axiom kronecker_sum_distr_r2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((rows (mat_sum s (fun (k:a) => (kronecker m (f k))))) =
   (rows ((fun (k:a) => (kronecker m (f k))) (choose s)))).

Axiom kronecker_sum_distr_r3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((rows ((fun (k:a) => (kronecker m (f k))) (choose s))) =
   ((rows m) * (rows (f (choose s))))%Z).

Axiom kronecker_sum_distr_r4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((kronecker m (mat_sum s f)) =
   (mat_sum s (fun (k:a) => (kronecker m (f k))))).

Axiom mat_sum_scalar1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (a1:t), (constant_size s f) ->
  ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s (fun (k:a) => (infix_asdtdt a1 (f k)))) =
   (infix_asdtdt a1 (mat_sum s f))).

Axiom kronecker_sum_distr_sc :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (a1:t),
  (constant_size s f) -> ((cardinal s) > 0%Z)%Z ->
  ((mat_sum s (fun (k:a) => (kronecker (infix_asdtdt a1 (f k)) m))) =
   (infix_asdtdt a1 (mat_sum s (fun (k:a) => (kronecker (f k) m))))).

Axiom kronecker_ket_sum_distr_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  is_a_ket_l (ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + l2)%Z)
  (l1 + l2)%Z.

Axiom kronecker_ket_sum_distr_l1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  ((kronecker (ket_sum_l s f l1) m) =
   (ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + l2)%Z)).

Axiom kronecker_ket_sum_distr_l_nol :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket m) ->
  ((cardinal s) > 0%Z)%Z ->
  is_a_ket_l
  (ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + (ket_length m))%Z)
  (l1 + (ket_length m))%Z.

Axiom kronecker_ket_sum_distr_l_nol1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket m) ->
  ((cardinal s) > 0%Z)%Z ->
  ((kronecker (ket_sum_l s f l1) m) =
   (ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + (ket_length m))%Z)).

Axiom kronecker_ket_sum_distr_l_rew :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket m) ->
  ((cardinal s) > 0%Z)%Z ->
  ((kronecker (ket_sum_l s f l1) m) =
   (ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + (ket_length m))%Z)).

Axiom kronecker_ket_sum_distr_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  is_a_ket_l (ket_sum_l s (fun (k:a) => (kronecker m (f k))) (l1 + l2)%Z)
  (l1 + l2)%Z.

Axiom kronecker_ket_sum_distr_r1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  ((kronecker m (ket_sum_l s f l1)) =
   (ket_sum_l s (fun (k:a) => (kronecker m (f k))) (l1 + l2)%Z)).

Axiom kronecker_ket_sum_distr_l_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  is_a_ket_l (ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + l2)%Z)
  (l1 + l2)%Z.

Axiom kronecker_ket_sum_distr_l_rev1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  ((ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + l2)%Z) =
   (kronecker (ket_sum_l s f l1) m)).

Axiom kronecker_ket_sum_distr_r_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  is_a_ket_l (ket_sum_l s (fun (k:a) => (kronecker m (f k))) (l1 + l2)%Z)
  (l1 + l2)%Z.

Axiom kronecker_ket_sum_distr_r_rev1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  ((ket_sum_l s (fun (k:a) => (kronecker m (f k))) (l1 + l2)%Z) =
   (kronecker m (ket_sum_l s f l1))).

Axiom kronecker_ket_sum_distr_r_rew :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (l1:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket m) ->
  ((cardinal s) > 0%Z)%Z ->
  ((kronecker m (ket_sum_l s f l1)) =
   (ket_sum_l s (fun (k:a) => (kronecker m (f k))) (l1 + (ket_length m))%Z)).

Axiom ket_sum_scalar :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (a1:t) (l:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l) ->
  ((cardinal s) > 0%Z)%Z ->
  ((ket_sum_l s (fun (k:a) => (infix_asdtdt a1 (f k))) l) =
   (infix_asdtdt a1 (ket_sum_l s f l))).

Axiom kronecker_ket_sum_distr_sc :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix t) (m:matrix t) (a1:t) (l1:Z) (l2:Z),
  (forall (e1:a), (mem e1 s) -> is_a_ket_l (f e1) l1) -> (is_a_ket_l m l2) ->
  ((cardinal s) > 0%Z)%Z ->
  ((ket_sum_l s (fun (k:a) => (kronecker (infix_asdtdt a1 (f k)) m))
    (l1 + l2)%Z)
   =
   (infix_asdtdt a1
    (ket_sum_l s (fun (k:a) => (kronecker (f k) m)) (l1 + l2)%Z))).

Axiom kronecker_decomp_r :
  forall (m:matrix t) (n:matrix t) (lm:Z) (ln:Z), (is_a_ket_l m lm) ->
  (is_a_ket_l n ln) ->
  ((kronecker m n) =
   (ket_sum_l (n_bvs ln)
    (fun (x:bitvec) =>
     (infix_asdtdt (get_ket n (bv_to_int x)) (kronecker m (bv_to_ket x))))
    (lm + ln)%Z)).

Axiom kronecker_decomp_l :
  forall (m:matrix t) (n:matrix t) (lm:Z) (ln:Z), (is_a_ket_l m lm) ->
  (is_a_ket_l n ln) ->
  ((kronecker m n) =
   (ket_sum_l (n_bvs lm)
    (fun (x:bitvec) =>
     (infix_asdtdt (get_ket m (bv_to_int x)) (kronecker (bv_to_ket x) n)))
    (lm + ln)%Z)).

Axiom kronecker_ket_sum_distr_double :
  forall (i:Z) (j:Z) (f:bitvec -> matrix t) (g:bitvec -> matrix t) (l1:Z)
    (l2:Z),
  (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  (forall (bv:bitvec), (mem bv (n_bvs i)) -> is_a_ket_l (f bv) l1) ->
  (forall (bv:bitvec), (mem bv (n_bvs j)) -> is_a_ket_l (g bv) l2) ->
  ((kronecker (ket_sum_l (n_bvs i) f l1) (ket_sum_l (n_bvs j) g l2)) =
   (ket_sum_l (n_bvs (i + j)%Z)
    (fun (k:bitvec) => (kronecker (f (hpart k i)) (g (tpart k i))))
    (l1 + l2)%Z)).

Axiom kronecker_sem_decomp_r :
  forall (c:circuit) (m1:matrix t) (m2:matrix t) (f:bitvec -> matrix t)
    (s2:Z),
  (is_a_ket_l m1 ((width c) - s2)%Z) ->
  (forall (x:bitvec), ((length x) = s2) ->
   sem c (kronecker m1 (bv_to_ket x)) (f x)) ->
  (is_a_ket_l m2 s2) ->
  sem c (kronecker m1 m2)
  (ket_sum_l (n_bvs s2)
   (fun (x:bitvec) => (infix_asdtdt (get_ket m2 (bv_to_int x)) (f x)))
   (width c)).

Axiom kronecker_sem_decomp_r1 :
  forall (c:circuit) (m1:matrix t) (m2:matrix t) (f:bitvec -> matrix t)
    (s2:Z),
  (is_a_ket_l m1 ((width c) - s2)%Z) ->
  (forall (x:bitvec), ((length x) = s2) ->
   sem c (kronecker m1 (bv_to_ket x)) (f x)) ->
  (is_a_ket_l m2 s2) ->
  sem c (kronecker m1 m2)
  (ket_sum_l (n_bvs s2)
   (fun (x:bitvec) =>
    (infix_asdtdt (get_ket m2 (bv_to_int x))
     (pat_sem c (kronecker m1 (bv_to_ket x)))))
   (width c)).

Axiom kronecker_sem_decomp_l :
  forall (c:circuit) (m1:matrix t) (m2:matrix t) (f:bitvec -> matrix t)
    (s1:Z),
  (is_a_ket_l m2 ((width c) - s1)%Z) ->
  (forall (x:bitvec), ((length x) = s1) ->
   sem c (kronecker (bv_to_ket x) m2) (f x)) ->
  (is_a_ket_l m1 s1) ->
  sem c (kronecker m1 m2)
  (ket_sum_l (n_bvs s1)
   (fun (x:bitvec) => (infix_asdtdt (get_ket m1 (bv_to_int x)) (f x)))
   (width c)).

Axiom kronecker_sem_decomp_l1 :
  forall (c:circuit) (m1:matrix t) (m2:matrix t) (f:bitvec -> matrix t)
    (s1:Z),
  (is_a_ket_l m2 ((width c) - s1)%Z) ->
  (forall (x:bitvec), ((length x) = s1) ->
   sem c (kronecker (bv_to_ket x) m2) (f x)) ->
  (is_a_ket_l m1 s1) ->
  sem c (kronecker m1 m2)
  (ket_sum_l (n_bvs s1)
   (fun (x:bitvec) =>
    (infix_asdtdt (get_ket m1 (bv_to_int x))
     (pat_sem c (kronecker (bv_to_ket x) m2))))
   (width c)).

Axiom sem_kronecker_decomp_l :
  forall (c:circuit) (m1:matrix t) (m2:matrix t) (y:matrix t)
    (f:bitvec -> matrix t) (s2:Z),
  (forall (x:bitvec), ((length x) = (width c)) -> sem c (bv_to_ket x) (f x)) ->
  (sem c m1 y) -> (is_a_ket_l m2 s2) ->
  ((kronecker y m2) =
   (ket_sum_l (n_bvs (width c))
    (fun (x:bitvec) =>
     (infix_asdtdt (get_ket m1 (bv_to_int x)) (kronecker (f x) m2)))
    ((width c) + s2)%Z)).

Axiom sem_kronecker_decomp_r :
  forall (c:circuit) (m1:matrix t) (m2:matrix t) (y:matrix t)
    (f:bitvec -> matrix t) (s1:Z),
  (forall (x:bitvec), ((length x) = (width c)) -> sem c (bv_to_ket x) (f x)) ->
  (sem c m2 y) -> (is_a_ket_l m1 s1) ->
  ((kronecker m1 y) =
   (ket_sum_l (n_bvs (width c))
    (fun (x:bitvec) =>
     (infix_asdtdt (get_ket m2 (bv_to_int x)) (kronecker m1 (f x))))
    ((width c) + s1)%Z)).

Axiom cont_kron_left_contz :
  forall (c:circuit) (co:Z) (n:Z) (x:matrix t) (y:matrix t),
  (((width c) <= co)%Z /\ (co < n)%Z) -> (is_a_ket_l x (width c)) ->
  (is_a_ket_l y (n - (width c))%Z) -> (is_a_ket_basis_elt y) ->
  (((getbv (ket_to_bv y)) (co - (width c))%Z) = 0%Z) ->
  sem (cont c co 0%Z n) (kronecker x y) (kronecker x y).

Axiom cont_kron_left_conto :
  forall (c:circuit) (co:Z) (n:Z) (f:bitvec -> matrix t) (x:matrix t)
    (y:matrix t),
  (((width c) <= co)%Z /\ (co < n)%Z) -> (is_a_ket_l x (width c)) ->
  (is_a_ket_l y (n - (width c))%Z) -> (is_a_ket_basis_elt y) ->
  (((getbv (ket_to_bv y)) (co - (width c))%Z) = 1%Z) ->
  (forall (z:bitvec), ((length z) = (width c)) -> sem c (bv_to_ket z) (f z)) ->
  sem (cont c co 0%Z n) (kronecker x y) (kronecker (pat_sem c x) y).

Axiom cont_kron_left_bv_to_ket :
  forall (c:circuit) (n:Z) (x:matrix t),
  ((0%Z <= (width c))%Z /\ ((width c) = (n - 1%Z)%Z)) ->
  (is_a_ket_l x (width c)) -> forall (y:bitvec), ((length y) = 1%Z) ->
  (((getbv y) 0%Z) = 0%Z) ->
  ((pat_sem (cont c (n - 1%Z)%Z 0%Z n) (kronecker x (bv_to_ket y))) =
   (kronecker x (bv_to_ket y))).

Axiom cont_kron_left_bv_to_ket1 :
  forall (c:circuit) (n:Z) (x:matrix t),
  ((0%Z <= (width c))%Z /\ ((width c) = (n - 1%Z)%Z)) ->
  (is_a_ket_l x (width c)) -> forall (y:bitvec), ((length y) = 1%Z) ->
  (((getbv y) 0%Z) = 1%Z) ->
  ((pat_sem (cont c (n - 1%Z)%Z 0%Z n) (kronecker x (bv_to_ket y))) =
   (kronecker (pat_sem c x) (bv_to_ket y))).

Axiom place_kron_left_pat :
  forall (c:circuit) (n:Z), ((width c) < n)%Z ->
  forall (x:matrix t) (y:matrix t), (is_a_ket_l x (width c)) ->
  (is_a_ket_l y (n - (width c))%Z) ->
  ((pat_sem (place c 0%Z n) (kronecker x y)) = (kronecker (pat_sem c x) y)).

Axiom cont_kron_right_contz :
  forall (c:circuit) (co:Z) (n:Z) (x:matrix t) (y:matrix t),
  ((0%Z <= co)%Z /\ (co < (n - (width c))%Z)%Z) ->
  (is_a_ket_l x (n - (width c))%Z) -> (is_a_ket_l y (width c)) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 0%Z) ->
  sem (cont c co (n - (width c))%Z n) (kronecker x y) (kronecker x y).

Axiom cont_kron_right_conto :
  forall (c:circuit) (co:Z) (n:Z) (f:bitvec -> matrix t) (x:matrix t)
    (y:matrix t),
  ((0%Z <= co)%Z /\ (co < (n - (width c))%Z)%Z) ->
  (is_a_ket_l x (n - (width c))%Z) -> (is_a_ket_l y (width c)) ->
  (is_a_ket_basis_elt x) -> (((getbv (ket_to_bv x)) co) = 1%Z) ->
  (forall (z:bitvec), ((length z) = (width c)) -> sem c (bv_to_ket z) (f z)) ->
  sem (cont c co (n - (width c))%Z n) (kronecker x y)
  (kronecker x (pat_sem c y)).

Axiom cont_kron_gen_right :
  forall (circ:circuit) (c:Z) (ft:Z) (n:Z) (y:matrix t) (z:matrix t),
  ((0%Z <= c)%Z /\ (c < ft)%Z) -> (n = (ft + (width circ))%Z) ->
  (sem circ y z) -> forall (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x ft) -> (((getbv (ket_to_bv x)) c) = 0%Z) ->
  sem (cont circ c ft n) (kronecker x y) (kronecker x y).

Axiom cont_kron_gen_right1 :
  forall (circ:circuit) (c:Z) (ft:Z) (n:Z) (y:matrix t) (z:matrix t),
  ((0%Z <= c)%Z /\ (c < ft)%Z) -> (n = (ft + (width circ))%Z) ->
  (sem circ y z) -> forall (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x ft) -> (((getbv (ket_to_bv x)) c) = 1%Z) ->
  sem (cont circ c ft n) (kronecker x y) (kronecker x z).

Axiom cont_kron_pat_right :
  forall (circ:circuit) (c:Z) (ft:Z) (n:Z) (y:matrix t),
  ((0%Z <= c)%Z /\ (c < ft)%Z) -> (n = (ft + (width circ))%Z) ->
  (is_a_ket_l y (width circ)) -> forall (x:matrix t),
  (is_a_ket_basis_elt x) -> (is_a_ket_l x ft) ->
  (((getbv (ket_to_bv x)) c) = 0%Z) ->
  ((pat_sem (cont circ c ft n) (kronecker x y)) = (kronecker x y)).

Axiom cont_kron_pat_right1 :
  forall (circ:circuit) (c:Z) (ft:Z) (n:Z) (y:matrix t),
  ((0%Z <= c)%Z /\ (c < ft)%Z) -> (n = (ft + (width circ))%Z) ->
  (is_a_ket_l y (width circ)) -> forall (x:matrix t),
  (is_a_ket_basis_elt x) -> (is_a_ket_l x ft) ->
  (((getbv (ket_to_bv x)) c) = 1%Z) ->
  ((pat_sem (cont circ c ft n) (kronecker x y)) =
   (kronecker x (pat_sem circ y))).

Axiom cont_kron_pat_right_gen :
  forall (circ:circuit) (c:Z) (ft:Z) (n:Z), ((0%Z <= c)%Z /\ (c < ft)%Z) ->
  (n = (ft + (width circ))%Z) -> forall (y:matrix t), forall (x:bitvec),
  (is_a_ket_l y (width circ)) -> ((length x) = ft) ->
  (((getbv x) c) = 0%Z) ->
  ((pat_sem (cont circ c ft n) (kronecker (bv_to_ket x) y)) =
   (kronecker (bv_to_ket x) y)).

Axiom cont_kron_pat_right_gen1 :
  forall (circ:circuit) (c:Z) (ft:Z) (n:Z), ((0%Z <= c)%Z /\ (c < ft)%Z) ->
  (n = (ft + (width circ))%Z) -> forall (y:matrix t), forall (x:bitvec),
  (is_a_ket_l y (width circ)) -> ((length x) = ft) ->
  (((getbv x) c) = 1%Z) ->
  ((pat_sem (cont circ c ft n) (kronecker (bv_to_ket x) y)) =
   (kronecker (bv_to_ket x) (pat_sem circ y))).

Parameter place_hadamard: Z -> Z -> circuit.

Axiom place_hadamard_def :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((place_hadamard k n) = (place hadamard k n)).

Axiom place_hadamard_spec :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((range (place_hadamard k n)) = 1%Z).

Axiom place_hadamard_spec1 :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((width (place_hadamard k n)) = n).

Axiom place_hadamard_spec2 :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
  ((length y) = 1%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((i = k) -> ((basis_ket_i (place_hadamard k n) x y i) = ((getbv y) 0%Z))) /\
  (~ (i = k) -> ((basis_ket_i (place_hadamard k n) x y i) = ((getbv x) i))).

Parameter fc14: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def14 :
  forall (k:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = k) -> (((fc14 k x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = k) -> (((fc14 k x y) i) = ((getbv x) i))).

Axiom place_hadamard_spec3 :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((basis_ket (place_hadamard k n) x y) = (make_bv (fc14 k x y) n)).

Axiom place_hadamard_spec4 :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((ang_ind (place_hadamard k n) x y) =
   (int_to_ang (((getbv x) k) * ((getbv y) 0%Z))%Z 1%Z)).

Axiom place_hadamard_spec5 :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  forall (x:bitvec) (y:bitvec), forall (m:Z), (m >= 1%Z)%Z ->
  ((length x) = n) -> ((length y) = 1%Z) ->
  ((ang_ind (place_hadamard k n) x y) =
   (int_to_ang
    ((((getbv x) k) * ((getbv y) 0%Z))%Z * (power_ 2%Z (m - 1%Z)%Z))%Z m)).

Parameter bv_get:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> bitvec -> bitvec -> a.

Axiom bv_get_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (x:bitvec) (y:bitvec),
  ((bv_get m x y) = (get m (bv_to_int x) (bv_to_int y))).

Parameter bv_make:
  forall {a:Type} {a_WT:WhyType a}, (bitvec -> bitvec -> a) -> Z -> Z ->
  matrix a.

Axiom bv_make_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:bitvec -> bitvec -> a) (size1:Z) (range1:Z), (0%Z <= size1)%Z ->
  (0%Z <= range1)%Z ->
  ((bv_make f size1 range1) =
   (make_f (power 2%Z size1) (power 2%Z range1)
    (fun (i:Z) (j:Z) => ((f (int_to_bv i size1)) (int_to_bv j range1))))).

Axiom bv_make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:bitvec -> bitvec -> a) (size1:Z) (range1:Z), (0%Z <= size1)%Z ->
  (0%Z <= range1)%Z -> forall (x:bitvec) (y:bitvec), ((length x) = size1) ->
  ((length y) = range1) ->
  ((bv_get (bv_make f size1 range1) x y) = ((f x) y)).

Axiom bv_make_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:bitvec -> bitvec -> a) (size1:Z) (range1:Z), (0%Z <= size1)%Z ->
  (0%Z <= range1)%Z -> ((rows (bv_make f size1 range1)) = (power 2%Z size1)).

Axiom bv_make_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:bitvec -> bitvec -> a) (size1:Z) (range1:Z), (0%Z <= size1)%Z ->
  (0%Z <= range1)%Z ->
  ((columns (bv_make f size1 range1)) = (power 2%Z range1)).

Axiom bk_func : Type.
Parameter bk_func_WhyType : WhyType bk_func.
Existing Instance bk_func_WhyType.

Parameter mat_k: bk_func -> matrix bitvec.

Parameter size_k: bk_func -> Z.

Parameter range_k: bk_func -> Z.

Axiom bk_func'invariant : forall (self:bk_func), ((size_k self) >= 0%Z)%Z.

Axiom bk_func'invariant1 : forall (self:bk_func), ((range_k self) >= 0%Z)%Z.

Axiom bk_func'invariant2 :
  forall (self:bk_func), ((rows (mat_k self)) = (power 2%Z (size_k self))).

Axiom bk_func'invariant3 :
  forall (self:bk_func),
  ((columns (mat_k self)) = (power 2%Z (range_k self))).

Axiom bk_func'invariant4 :
  forall (self:bk_func), forall (x:bitvec) (y:bitvec),
  ((length x) = (size_k self)) -> ((length y) = (range_k self)) ->
  ((length (bv_get (mat_k self) x y)) = (size_k self)).

Parameter get_k: bk_func -> bitvec -> bitvec -> bitvec.

Axiom get_k_def :
  forall (k:bk_func) (x:bitvec) (y:bitvec),
  ((get_k k x y) = (bv_get (mat_k k) x y)).

Axiom get_k_spec :
  forall (k:bk_func) (x:bitvec) (y:bitvec), ((length x) = (size_k k)) ->
  ((length y) = (range_k k)) -> ((length (get_k k x y)) = (size_k k)).

Parameter get_k_int: bk_func -> bitvec -> bitvec -> Z.

Axiom get_k_int_def :
  forall (k:bk_func) (x:bitvec) (y:bitvec),
  ((get_k_int k x y) = (bv_to_int (get_k k x y))).

Axiom get_k_int_spec :
  forall (k:bk_func) (x:bitvec) (y:bitvec),
  ((get_k_int k x y) = (bv_to_int (bv_get (mat_k k) x y))).

Axiom get_k_int_spec1 :
  forall (k:bk_func) (x:bitvec) (y:bitvec), ((length x) = (size_k k)) ->
  ((length y) = (range_k k)) -> (0%Z <= (get_k_int k x y))%Z.

Axiom get_k_int_spec2 :
  forall (k:bk_func) (x:bitvec) (y:bitvec), ((length x) = (size_k k)) ->
  ((length y) = (range_k k)) ->
  ((get_k_int k x y) < (power 2%Z (size_k k)))%Z.

Parameter get_k_ket: bk_func -> bitvec -> bitvec -> matrix t.

Axiom get_k_ket_def :
  forall (k:bk_func) (x:bitvec) (y:bitvec),
  ((get_k_ket k x y) = (bv_to_ket (get_k k x y))).

Axiom get_k_ket_spec :
  forall (k:bk_func) (x:bitvec) (y:bitvec),
  ((get_k_ket k x y) = (bv_to_ket (bv_get (mat_k k) x y))).

Axiom get_k_ket_spec1 :
  forall (k:bk_func) (x:bitvec) (y:bitvec), ((length x) = (size_k k)) ->
  ((length y) = (range_k k)) -> is_a_ket_l (get_k_ket k x y) (size_k k).

Axiom get_k_ket_spec2 :
  forall (k:bk_func) (x:bitvec) (y:bitvec),
  is_a_ket_basis_elt (get_k_ket k x y).

Axiom get_k_ket_spec3 :
  forall (k:bk_func) (x:bitvec) (y:bitvec), ((length x) = (size_k k)) ->
  ((length y) = (range_k k)) ->
  ((get_k_ket k x y) = (ket (size_k k) (get_k_int k x y))).

Axiom get_k_ket_is_a_ket_l :
  forall (k:bk_func) (x:bitvec) (y:bitvec) (l:Z), ((length x) = l) ->
  ((length y) = (range_k k)) -> (l = (size_k k)) ->
  is_a_ket_l (get_k_ket k x y) l.

Axiom get_k_length :
  forall (k:bk_func) (x:bitvec) (y:bitvec), ((length x) = (size_k k)) ->
  ((length y) = (range_k k)) -> ((length (get_k k x y)) = (size_k k)).

Parameter get_ki: bk_func -> bitvec -> bitvec -> Z -> Z.

Axiom get_ki_def :
  forall (k:bk_func) (x:bitvec) (y:bitvec) (i:Z),
  ((get_ki k x y i) = ((getbv (get_k k x y)) i)).

Axiom get_ki_spec :
  forall (k:bk_func) (x:bitvec) (y:bitvec) (i:Z),
  ((get_ki k x y i) = ((getbv (bv_get (mat_k k) x y)) i)).

Axiom length_bk :
  forall (k:bk_func) (x:bitvec) (y:bitvec), ((length x) = (size_k k)) ->
  ((length y) = (range_k k)) -> ((length (get_k k x y)) = (size_k k)).

Parameter make_k: (bitvec -> bitvec -> bitvec) -> Z -> Z -> bk_func.

Axiom make_k_spec :
  forall (f:bitvec -> bitvec -> bitvec) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z ->
  (forall (x:bitvec) (y:bitvec), ((length x) = size1) ->
   ((length y) = range1) -> ((length ((f x) y)) = size1)) ->
  forall (x:bitvec) (y:bitvec), ((length x) = size1) ->
  ((length y) = range1) -> ((get_k (make_k f size1 range1) x y) = ((f x) y)).

Axiom make_k_spec1 :
  forall (f:bitvec -> bitvec -> bitvec) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z ->
  (forall (x:bitvec) (y:bitvec), ((length x) = size1) ->
   ((length y) = range1) -> ((length ((f x) y)) = size1)) ->
  ((mat_k (make_k f size1 range1)) = (bv_make f size1 range1)).

Axiom make_k_spec2 :
  forall (f:bitvec -> bitvec -> bitvec) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z ->
  (forall (x:bitvec) (y:bitvec), ((length x) = size1) ->
   ((length y) = range1) -> ((length ((f x) y)) = size1)) ->
  ((size_k (make_k f size1 range1)) = size1).

Axiom make_k_spec3 :
  forall (f:bitvec -> bitvec -> bitvec) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z ->
  (forall (x:bitvec) (y:bitvec), ((length x) = size1) ->
   ((length y) = range1) -> ((length ((f x) y)) = size1)) ->
  ((range_k (make_k f size1 range1)) = range1).

Axiom angle_func : Type.
Parameter angle_func_WhyType : WhyType angle_func.
Existing Instance angle_func_WhyType.

Parameter mat_a: angle_func -> matrix angle.

Parameter size_a: angle_func -> Z.

Parameter range_a: angle_func -> Z.

Axiom angle_func'invariant :
  forall (self:angle_func), ((size_a self) >= 0%Z)%Z.

Axiom angle_func'invariant1 :
  forall (self:angle_func), ((range_a self) >= 0%Z)%Z.

Axiom angle_func'invariant2 :
  forall (self:angle_func), ((rows (mat_a self)) = (power 2%Z (size_a self))).

Axiom angle_func'invariant3 :
  forall (self:angle_func),
  ((columns (mat_a self)) = (power 2%Z (range_a self))).

Parameter get_a: angle_func -> bitvec -> bitvec -> angle.

Axiom get_a_def :
  forall (k:angle_func) (x:bitvec) (y:bitvec),
  ((get_a k x y) = (bv_get (mat_a k) x y)).

Parameter get_ac: angle_func -> bitvec -> bitvec -> t.

Axiom get_ac_def :
  forall (k:angle_func) (x:bitvec) (y:bitvec),
  ((get_ac k x y) = (ang_exp (bv_get (mat_a k) x y))).

Parameter gen_ket: angle_func -> Prop.

Axiom gen_ket_def :
  forall (a:angle_func), (gen_ket a) <-> ((range_a a) = 0%Z).

Parameter make_a: (bitvec -> bitvec -> angle) -> Z -> Z -> angle_func.

Axiom make_a_spec :
  forall (f:bitvec -> bitvec -> angle) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = size1) -> ((length y) = range1) ->
  ((get_a (make_a f size1 range1) x y) = ((f x) y)).

Axiom make_a_spec1 :
  forall (f:bitvec -> bitvec -> angle) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = size1) -> ((length y) = range1) ->
  ((get_ac (make_a f size1 range1) x y) = (ang_exp ((f x) y))).

Axiom make_a_spec2 :
  forall (f:bitvec -> bitvec -> angle) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z ->
  ((mat_a (make_a f size1 range1)) = (bv_make f size1 range1)).

Axiom make_a_spec3 :
  forall (f:bitvec -> bitvec -> angle) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z ->
  ((size_a (make_a f size1 range1)) = size1).

Axiom make_a_spec4 :
  forall (f:bitvec -> bitvec -> angle) (size1:Z) (range1:Z),
  (size1 >= 0%Z)%Z -> (range1 >= 0%Z)%Z ->
  ((range_a (make_a f size1 range1)) = range1).

Parameter k_seq: bk_func -> bk_func -> bk_func.

Axiom k_seq_def :
  forall (k1:bk_func) (k2:bk_func), ((size_k k1) = (size_k k2)) ->
  ((k_seq k1 k2) =
   (make_k
    (fun (x:bitvec) (y:bitvec) =>
     (get_k k2 (get_k k1 x (hpart y (range_k k1))) (tpart y (range_k k1))))
    (size_k k1) ((range_k k1) + (range_k k2))%Z)).

Axiom k_seq_spec :
  forall (k1:bk_func) (k2:bk_func), ((size_k k1) = (size_k k2)) ->
  forall (x:bitvec) (y:bitvec), ((length x) = (size_k k1)) ->
  ((length y) = ((range_k k1) + (range_k k2))%Z) ->
  ((get_k (k_seq k1 k2) x y) =
   (get_k k2 (get_k k1 x (hpart y (range_k k1))) (tpart y (range_k k1)))).

Axiom k_seq_spec1 :
  forall (k1:bk_func) (k2:bk_func), ((size_k k1) = (size_k k2)) ->
  ((size_k (k_seq k1 k2)) = (size_k k1)).

Axiom k_seq_spec2 :
  forall (k1:bk_func) (k2:bk_func), ((size_k k1) = (size_k k2)) ->
  ((range_k (k_seq k1 k2)) = ((range_k k1) + (range_k k2))%Z).

Axiom k_seq_spec3 :
  forall (k1:bk_func) (k2:bk_func), ((size_k k1) = (size_k k2)) ->
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (size_k k1)) ->
  ((length y) = ((range_k k1) + (range_k k2))%Z) ->
  ((0%Z <= i)%Z /\ (i < ((range_k k1) + (range_k k2))%Z)%Z) ->
  ((get_ki (k_seq k1 k2) x y i) =
   (get_ki k2 (get_k k1 x (hpart y (range_k k1))) (tpart y (range_k k1)) i)).

Parameter k_par: bk_func -> bk_func -> bk_func.

Axiom k_par_def :
  forall (k1:bk_func) (k2:bk_func),
  ((k_par k1 k2) =
   (make_k
    (fun (x:bitvec) (y:bitvec) =>
     (concat (get_k k1 (hpart x (size_k k1)) (hpart y (range_k k1)))
      (get_k k2 (tpart x (size_k k1)) (tpart y (range_k k1)))))
    ((size_k k1) + (size_k k2))%Z ((range_k k1) + (range_k k2))%Z)).

Axiom k_par_spec :
  forall (k1:bk_func) (k2:bk_func),
  ((size_k (k_par k1 k2)) = ((size_k k1) + (size_k k2))%Z).

Axiom k_par_spec1 :
  forall (k1:bk_func) (k2:bk_func),
  ((range_k (k_par k1 k2)) = ((range_k k1) + (range_k k2))%Z).

Axiom k_par_spec2 :
  forall (k1:bk_func) (k2:bk_func), forall (x:bitvec) (y:bitvec),
  ((length x) = ((size_k k1) + (size_k k2))%Z) ->
  ((length y) = ((range_k k1) + (range_k k2))%Z) ->
  ((get_k (k_par k1 k2) x y) =
   (concat (get_k k1 (hpart x (size_k k1)) (hpart y (range_k k1)))
    (get_k k2 (tpart x (size_k k1)) (tpart y (range_k k1))))).

Axiom k_par_spec3 :
  forall (k1:bk_func) (k2:bk_func), forall (x:bitvec) (y:bitvec),
  forall (i:Z), ((length x) = ((size_k k1) + (size_k k2))%Z) ->
  ((length y) = ((range_k k1) + (range_k k2))%Z) ->
  ((0%Z <= i)%Z /\ (i < (size_k k1))%Z) ->
  ((get_ki (k_par k1 k2) x y i) =
   (get_ki k1 (hpart x (size_k k1)) (hpart y (range_k k1)) i)).

Axiom k_par_spec4 :
  forall (k1:bk_func) (k2:bk_func), forall (x:bitvec) (y:bitvec),
  forall (i:Z), ((length x) = ((size_k k1) + (size_k k2))%Z) ->
  ((length y) = ((range_k k1) + (range_k k2))%Z) ->
  (((size_k k1) <= i)%Z /\ (i < ((size_k k1) + (size_k k2))%Z)%Z) ->
  ((get_ki (k_par k1 k2) x y i) =
   (get_ki k2 (tpart x (size_k k1)) (tpart y (range_k k1))
    (i - (size_k k1))%Z)).

Parameter a_seq: angle_func -> angle_func -> bk_func -> angle_func.

Axiom a_seq_def :
  forall (a1:angle_func) (a2:angle_func) (k1:bk_func),
  (((size_a a1) = (size_a a2)) /\ ((size_a a2) = (size_k k1))) ->
  ((range_a a1) = (range_k k1)) ->
  ((a_seq a1 a2 k1) =
   (make_a
    (fun (x:bitvec) (y:bitvec) =>
     (ang_add (get_a a1 x (hpart y (range_a a1)))
      (get_a a2 (get_k k1 x (hpart y (range_a a1))) (tpart y (range_a a1)))))
    (size_a a1) ((range_a a1) + (range_a a2))%Z)).

Axiom a_seq_spec :
  forall (a1:angle_func) (a2:angle_func) (k1:bk_func),
  (((size_a a1) = (size_a a2)) /\ ((size_a a2) = (size_k k1))) ->
  ((range_a a1) = (range_k k1)) -> ((size_a (a_seq a1 a2 k1)) = (size_a a1)).

Axiom a_seq_spec1 :
  forall (a1:angle_func) (a2:angle_func) (k1:bk_func),
  (((size_a a1) = (size_a a2)) /\ ((size_a a2) = (size_k k1))) ->
  ((range_a a1) = (range_k k1)) ->
  ((range_a (a_seq a1 a2 k1)) = ((range_a a1) + (range_a a2))%Z).

Axiom a_seq_spec2 :
  forall (a1:angle_func) (a2:angle_func) (k1:bk_func),
  (((size_a a1) = (size_a a2)) /\ ((size_a a2) = (size_k k1))) ->
  ((range_a a1) = (range_k k1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (size_a a1)) ->
  ((length y) = ((range_a a1) + (range_a a2))%Z) ->
  ((get_a (a_seq a1 a2 k1) x y) =
   (ang_add (get_a a1 x (hpart y (range_a a1)))
    (get_a a2 (get_k k1 x (hpart y (range_a a1))) (tpart y (range_a a1))))).

Axiom a_seq_spec3 :
  forall (a1:angle_func) (a2:angle_func) (k1:bk_func),
  (((size_a a1) = (size_a a2)) /\ ((size_a a2) = (size_k k1))) ->
  ((range_a a1) = (range_k k1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (size_a a1)) ->
  ((length y) = ((range_a a1) + (range_a a2))%Z) ->
  ((get_ac (a_seq a1 a2 k1) x y) =
   (infix_asdt (get_ac a1 x (hpart y (range_a a1)))
    (get_ac a2 (get_k k1 x (hpart y (range_a a1))) (tpart y (range_a a1))))).

Parameter a_par: angle_func -> angle_func -> angle_func.

Axiom a_par_def :
  forall (a1:angle_func) (a2:angle_func),
  ((a_par a1 a2) =
   (make_a
    (fun (x:bitvec) (y:bitvec) =>
     (ang_add (get_a a1 (hpart x (size_a a1)) (hpart y (range_a a1)))
      (get_a a2 (tpart x (size_a a1)) (tpart y (range_a a1)))))
    ((size_a a1) + (size_a a2))%Z ((range_a a1) + (range_a a2))%Z)).

Axiom a_par_spec :
  forall (a1:angle_func) (a2:angle_func),
  ((size_a (a_par a1 a2)) = ((size_a a1) + (size_a a2))%Z).

Axiom a_par_spec1 :
  forall (a1:angle_func) (a2:angle_func),
  ((range_a (a_par a1 a2)) = ((range_a a1) + (range_a a2))%Z).

Axiom a_par_spec2 :
  forall (a1:angle_func) (a2:angle_func), forall (x:bitvec) (y:bitvec),
  ((length x) = ((size_a a1) + (size_a a2))%Z) ->
  ((length y) = ((range_a a1) + (range_a a2))%Z) ->
  ((get_a (a_par a1 a2) x y) =
   (ang_add (get_a a1 (hpart x (size_a a1)) (hpart y (range_a a1)))
    (get_a a2 (tpart x (size_a a1)) (tpart y (range_a a1))))).

Axiom a_par_spec3 :
  forall (a1:angle_func) (a2:angle_func), forall (x:bitvec) (y:bitvec),
  ((length x) = ((size_a a1) + (size_a a2))%Z) ->
  ((length y) = ((range_a a1) + (range_a a2))%Z) ->
  ((get_ac (a_par a1 a2) x y) =
   (infix_asdt (get_ac a1 (hpart x (size_a a1)) (hpart y (range_a a1)))
    (get_ac a2 (tpart x (size_a a1)) (tpart y (range_a a1))))).

Parameter flat: circuit -> Prop.

Axiom flat_def :
  forall (c:circuit),
  (flat c) <->
  exists a:bitvec -> angle, exists b:bitvec -> bitvec,
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
  (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z.

Axiom set_flat :
  forall (c:circuit) (a:bitvec -> angle) (b:bitvec -> bitvec),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z) ->
  flat c.

Axiom get_flat :
  forall (c:circuit), (flat c) ->
  exists a:bitvec -> angle, exists b:bitvec -> bitvec,
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
  (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z.

Axiom flat_phase : forall (o:angle), flat (phase o).

Axiom flat_rz : forall (o:angle), flat (rz o).

Axiom flat_cnot : flat cnot.

Axiom seq_pres_flat_pre :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle)
    (b:bitvec -> bitvec) (b':bitvec -> bitvec),
  ((width c) = (width c')) ->
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => (b' x)) 0%Z) ->
  correct_path_sum (sequence c c')
  (fun (x:bitvec) (us:bitvec) => (ang_add (a x) (a' (b x))))
  (fun (x:bitvec) (us:bitvec) => (b' (b x))) 0%Z.

Axiom seq_pres_flat_pre1 :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle)
    (b:bitvec -> bitvec) (b':bitvec -> bitvec),
  ((width c) = (width c')) ->
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => (b' x)) 0%Z) ->
  flat (sequence c c').

Axiom par_pres_flat_pre :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle)
    (b:bitvec -> bitvec) (b':bitvec -> bitvec),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => (b' x)) 0%Z) ->
  correct_path_sum (parallel c c')
  (fun (x:bitvec) (us:bitvec) =>
   (ang_add (a (hpart x (width c))) (a' (tpart x (width c)))))
  (fun (x:bitvec) (us:bitvec) =>
   (concat (b (hpart x (width c))) (b' (tpart x (width c)))))
  0%Z.

Axiom par_pres_flat_pre1 :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle)
    (b:bitvec -> bitvec) (b':bitvec -> bitvec),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => (b' x)) 0%Z) ->
  flat (parallel c c').

Parameter flat_ang: circuit -> bitvec -> angle.

Parameter flat_ket: circuit -> bitvec -> bitvec.

Axiom flat_ket_spec :
  forall (c:circuit), (flat c) -> forall (x:bitvec),
  ((length x) = (width c)) -> ((length ((flat_ket c) x)) = (width c)).

Parameter flat_ket_i: circuit -> bitvec -> Z -> Z.

Axiom flat_ket_i_def :
  forall (c:circuit) (x:bitvec) (i:Z), (flat c) ->
  ((length x) = (width c)) -> ((0%Z <= i)%Z /\ (i < (length x))%Z) ->
  ((flat_ket_i c x i) = ((getbv ((flat_ket c) x)) i)).

Axiom flat_correct :
  forall (c:circuit), (flat c) ->
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => ((flat_ang c) x))
  (fun (x:bitvec) (us:bitvec) => ((flat_ket c) x)) 0%Z.

Axiom unic_flat_correct_pre :
  forall (c:circuit) (a:bitvec -> angle) (b:bitvec -> bitvec) (x:bitvec),
  (correct_path_sum c (fun (x1:bitvec) (us:bitvec) => (a x1))
   (fun (x1:bitvec) (us:bitvec) => (b x1)) 0%Z) ->
  ((length x) = (width c)) -> (((flat_ang c) x) = (a x)).

Axiom unic_flat_correct_pre1 :
  forall (c:circuit) (a:bitvec -> angle) (b:bitvec -> bitvec) (x:bitvec),
  (correct_path_sum c (fun (x1:bitvec) (us:bitvec) => (a x1))
   (fun (x1:bitvec) (us:bitvec) => (b x1)) 0%Z) ->
  ((length x) = (width c)) -> (((flat_ket c) x) = (b x)).

Axiom unic_flat_correct :
  forall (c:circuit) (a:bitvec -> angle) (b:bitvec -> bitvec),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z) ->
  forall (x:bitvec), ((length x) = (width c)) -> (((flat_ang c) x) = (a x)).

Axiom unic_flat_correct1 :
  forall (c:circuit) (a:bitvec -> angle) (b:bitvec -> bitvec),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z) ->
  forall (x:bitvec), ((length x) = (width c)) -> (((flat_ket c) x) = (b x)).

Axiom seq_pres_flat :
  forall (c:circuit) (c':circuit), ((width c) = (width c')) -> (flat c) ->
  (flat c') -> flat (sequence c c').

Axiom diag_pres_flat :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  flat (parallel c c').

Axiom flat_ang_phase :
  forall (o:angle), ((flat_ang (phase o)) = (fun (us:bitvec) => o)).

Axiom flat_ang_rz :
  forall (o:angle),
  ((flat_ang (rz o)) =
   (fun (x:bitvec) => (phase_inv_ (1%Z - ((getbv x) 0%Z))%Z o))).

Axiom flat_ang_cnot : ((flat_ang cnot) = (fun (us:bitvec) => ang_zero)).

Axiom flat_ang_sequence :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((flat_ang (sequence c c')) =
   (fun (x:bitvec) =>
    (ang_add ((flat_ang c) x) ((flat_ang c') ((flat_ket c') x))))).

Axiom flat_ang_parallel :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((flat_ang (parallel c c')) =
   (fun (x:bitvec) =>
    (ang_add ((flat_ang c) (hpart x (width c)))
     ((flat_ang c') (tpart x (width c)))))).

Axiom flat_ket_phase :
  forall (o:angle), ((flat_ket (phase o)) = (fun (i:bitvec) => i)).

Axiom flat_ket_rz :
  forall (o:angle), ((flat_ket (rz o)) = (fun (i:bitvec) => i)).

Axiom flat_ket_cnot :
  let fc15 := flat_ket cnot in
  forall (x:bitvec),
  (((0%Z <= (bv_to_int x))%Z /\ ((bv_to_int x) < 2%Z)%Z) -> ((fc15 x) = x)) /\
  (~ ((0%Z <= (bv_to_int x))%Z /\ ((bv_to_int x) < 2%Z)%Z) ->
   (((bv_to_int x) = 2%Z) -> ((fc15 x) = (int_to_bv 3%Z 2%Z))) /\
   (~ ((bv_to_int x) = 2%Z) -> ((fc15 x) = (int_to_bv 2%Z 2%Z)))).

Axiom flat_ket_sequence :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((flat_ket (sequence c c')) =
   (fun (x:bitvec) => ((flat_ket c') ((flat_ket c) x)))).

Axiom flat_ket_parallel :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((flat_ket (parallel c c')) =
   (fun (x:bitvec) =>
    (concat ((flat_ket c) (hpart x (width c)))
     ((flat_ket c') (tpart x (width c)))))).

Parameter f_sequence: circuit -> circuit -> circuit.

Axiom f_sequence_def :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width c) = (width c')) -> ((f_sequence c c') = (sequence c c')).

Axiom f_sequence_spec :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width c) = (width c')) -> ((width (f_sequence c c')) = (width c)).

Axiom f_sequence_spec1 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width c) = (width c')) ->
  ((size (f_sequence c c')) = ((size c) + (size c'))%Z).

Axiom f_sequence_spec2 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width c) = (width c')) ->
  ((ancillas (f_sequence c c')) =
   (ZArith.BinInt.Z.max (ancillas c) (ancillas c'))).

Axiom f_sequence_spec3 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width c) = (width c')) -> flat (f_sequence c c').

Axiom f_sequence_spec4 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width c) = (width c')) ->
  ((flat_ang (f_sequence c c')) =
   (fun (x:bitvec) =>
    (ang_add ((flat_ang c) x) ((flat_ang c') ((flat_ket c') x))))).

Axiom f_sequence_spec5 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width c) = (width c')) ->
  ((flat_ket (f_sequence c c')) =
   (fun (x:bitvec) => ((flat_ket c') ((flat_ket c) x)))).

Parameter f_parallel: circuit -> circuit -> circuit.

Axiom f_parallel_def :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((f_parallel c c') = (parallel c c')).

Axiom f_parallel_spec :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((width (f_parallel c c')) = ((width c) + (width c'))%Z).

Axiom f_parallel_spec1 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((size (f_parallel c c')) = ((size c) + (size c'))%Z).

Axiom f_parallel_spec2 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((ancillas (f_parallel c c')) = ((ancillas c) + (ancillas c'))%Z).

Axiom f_parallel_spec3 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  flat (f_parallel c c').

Axiom f_parallel_spec4 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((flat_ang (f_parallel c c')) =
   (fun (x:bitvec) =>
    (ang_add ((flat_ang c) (hpart x (width c)))
     ((flat_ang c') (tpart x (width c)))))).

Axiom f_parallel_spec5 :
  forall (c:circuit) (c':circuit), (flat c) -> (flat c') ->
  ((flat_ket (f_parallel c c')) =
   (fun (x:bitvec) =>
    (concat ((flat_ket c) (hpart x (width c)))
     ((flat_ket c') (tpart x (width c)))))).

Axiom set_correct_path_sum_flat_pat :
  forall (c:circuit) (a:bitvec -> angle) (k:bitvec -> bitvec),
  (forall (x:bitvec), ((length x) = (size c)) ->
   ((pat_sem c (bv_to_ket x)) =
    (infix_asdtdt (ang_exp (a x)) (bv_to_ket (k x))))) ->
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
  (fun (x:bitvec) (us:bitvec) => (k x)) 0%Z.

Axiom get_flat_pat_sem :
  forall (c:circuit), (flat c) -> forall (x:bitvec),
  ((pat_sem c (bv_to_ket x)) =
   (infix_asdtdt (ang_exp ((flat_ang c) x)) (bv_to_ket ((flat_ket c) x)))).

Parameter f_place: circuit -> Z -> Z -> circuit.

Axiom f_place_def :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((f_place c k n) = (place c k n)).

Axiom f_place_spec :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) -> flat (f_place c k n).

Axiom f_place_spec1 :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((range (f_place c k n)) = (range c)).

Axiom f_place_spec2 :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((width (f_place c k n)) = n).

Axiom f_place_spec3 :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((ancillas (f_place c k n)) = (ancillas c)).

Axiom f_place_spec4 :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) -> forall (x:bitvec),
  forall (i:Z), ((length x) = n) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((flat_ket_i (f_place c k n) x i) =
    (flat_ket_i c (htpart x k (width c)) (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (width c))%Z)%Z) ->
   ((flat_ket_i (f_place c k n) x i) = ((getbv x) i))).

Axiom f_place_spec5 :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) -> forall (x:bitvec),
  ((length x) = n) ->
  (((flat_ang (f_place c k n)) x) = ((flat_ang c) (htpart x k (width c)))).

Axiom f_place_spec6 :
  forall (c:circuit) (k:Z) (n:Z), (flat c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((width (f_place c k n)) = n).

Parameter f_cont: circuit -> Z -> Z -> Z -> circuit.

Axiom f_cont_def :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((f_cont c co ft n) = (cont c co ft n)).

Axiom f_cont_def1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> ((f_cont c co ft n) = (cont c co ft n)).

Axiom f_cont_spec :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  flat (f_cont c co ft n).

Axiom f_cont_spec1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((width (f_cont c co ft n)) = n).

Axiom f_cont_spec2 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((range (f_cont c co ft n)) = (range c)).

Axiom f_cont_spec3 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((ancillas (f_cont c co ft n)) = (ancillas c)).

Axiom f_cont_spec4 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:bitvec), ((length x) = n) -> (((getbv x) co) = 0%Z) ->
  (((flat_ket (f_cont c co ft n)) x) = x).

Axiom f_cont_spec5 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:bitvec), ((length x) = n) -> (((getbv x) co) = 0%Z) ->
  (((flat_ang (f_cont c co ft n)) x) = ang_zero).

Axiom f_cont_spec6 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:bitvec), forall (i:Z), ((length x) = n) ->
  ((0%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) co) = 1%Z) ->
  (((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((flat_ket_i (f_cont c co ft n) x i) =
    (flat_ket_i c (htpart x ft (width c)) (i - ft)%Z))) /\
  (~ ((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((flat_ket_i (f_cont c co ft n) x i) = ((getbv x) i))).

Parameter fc15: circuit -> Z -> bitvec -> Z -> Z.

Axiom fc_def15 :
  forall (c:circuit) (ft:Z) (x:bitvec) (i:Z),
  (((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   (((fc15 c ft x) i) = (flat_ket_i c (htpart x ft (width c)) (i - ft)%Z))) /\
  (~ ((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   (((fc15 c ft x) i) = ((getbv x) i))).

Axiom f_cont_spec7 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:bitvec), ((length x) = n) -> (((getbv x) co) = 1%Z) ->
  (((flat_ket (f_cont c co ft n)) x) = (make_bv (fc15 c ft x) n)).

Axiom f_cont_spec8 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:bitvec), ((length x) = n) -> (((getbv x) co) = 1%Z) ->
  (((flat_ang (f_cont c co ft n)) x) =
   ((flat_ang c) (htpart x ft (width c)))).

Axiom f_cont_spec9 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:bitvec), ((length x) = n) -> ((length x) = n) ->
  (((getbv x) co) = 0%Z) ->
  ((pat_sem (f_cont c co ft n) (bv_to_ket x)) = (bv_to_ket x)).

Axiom f_cont_spec10 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  forall (x:bitvec), ((length x) = n) -> (((getbv x) co) = 1%Z) ->
  ((pat_sem (f_cont c co ft n) (bv_to_ket x)) =
   (pat_sem (place c ft n) (bv_to_ket x))).

Axiom f_cont_spec11 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  ((size (f_cont c co ft n)) = (cont_size * (size c))%Z).

Axiom f_cont_spec12 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> flat (f_cont c co ft n).

Axiom f_cont_spec13 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> ((width (f_cont c co ft n)) = n).

Axiom f_cont_spec14 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> ((range (f_cont c co ft n)) = (range c)).

Axiom f_cont_spec15 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z ->
  ((ancillas (f_cont c co ft n)) = (ancillas c)).

Axiom f_cont_spec16 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((getbv x) co) = 0%Z) -> (((flat_ket (f_cont c co ft n)) x) = x).

Axiom f_cont_spec17 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((getbv x) co) = 0%Z) -> (((flat_ang (f_cont c co ft n)) x) = ang_zero).

Axiom f_cont_spec18 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), forall (i:Z),
  ((length x) = n) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((getbv x) co) = 1%Z) ->
  (((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((flat_ket_i (f_cont c co ft n) x i) =
    (flat_ket_i c (htpart x ft (width c)) (i - ft)%Z))) /\
  (~ ((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   ((flat_ket_i (f_cont c co ft n) x i) = ((getbv x) i))).

Parameter fc16: circuit -> Z -> bitvec -> Z -> Z.

Axiom fc_def16 :
  forall (c:circuit) (ft:Z) (x:bitvec) (i:Z),
  (((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   (((fc16 c ft x) i) = (flat_ket_i c (htpart x ft (width c)) (i - ft)%Z))) /\
  (~ ((ft <= i)%Z /\ (i < (ft + (width c))%Z)%Z) ->
   (((fc16 c ft x) i) = ((getbv x) i))).

Axiom f_cont_spec19 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((getbv x) co) = 1%Z) ->
  (((flat_ket (f_cont c co ft n)) x) = (make_bv (fc16 c ft x) n)).

Axiom f_cont_spec20 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((getbv x) co) = 1%Z) ->
  (((flat_ang (f_cont c co ft n)) x) =
   ((flat_ang c) (htpart x ft (width c)))).

Axiom f_cont_spec21 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  ((length x) = n) -> (((getbv x) co) = 0%Z) ->
  ((pat_sem (f_cont c co ft n) (bv_to_ket x)) = (bv_to_ket x)).

Axiom f_cont_spec22 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((getbv x) co) = 1%Z) ->
  ((pat_sem (f_cont c co ft n) (bv_to_ket x)) =
   (pat_sem (place c ft n) (bv_to_ket x))).

Axiom f_cont_spec23 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), (flat c) ->
  ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z ->
  ((size (f_cont c co ft n)) = (cont_size * (size c))%Z).

Parameter diag: circuit -> Prop.

Axiom diag_def :
  forall (c:circuit),
  (diag c) <->
  exists a:bitvec -> angle,
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
  (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom set_diag :
  forall (c:circuit) (a:bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  diag c.

Axiom get_diag :
  forall (c:circuit), (diag c) ->
  exists a:bitvec -> angle,
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
  (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom get_diag_sem :
  forall (c:circuit), (diag c) ->
  exists a:bitvec -> angle,
  forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
  sem c x (infix_asdtdt (ang_exp (a (ket_to_bv x))) x).

Axiom set_diag_sem :
  forall (c:circuit),
  (exists a:bitvec -> angle,
   forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
   sem c x (infix_asdtdt (ang_exp (a (ket_to_bv x))) x)) ->
  diag c.

Axiom set_diag_sem_elt :
  forall (c:circuit) (a:bitvec -> angle),
  (forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
   sem c x (infix_asdtdt (ang_exp (a (ket_to_bv x))) x)) ->
  diag c.

Parameter diag_ang: circuit -> bitvec -> angle.

Axiom diag_correct :
  forall (c:circuit), (diag c) ->
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => ((diag_ang c) x))
  (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom diag_sem :
  forall (c:circuit), (diag c) -> forall (x:bitvec),
  ((length x) = (width c)) ->
  sem c (bv_to_ket x) (infix_asdtdt (ang_exp ((diag_ang c) x)) (bv_to_ket x)).

Axiom set_correct_diag_sim :
  forall (c:circuit) (a:bitvec -> angle), (diag c) ->
  (forall (x:bitvec), ((length x) = (width c)) -> (((diag_ang c) x) = (a x))) ->
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
  (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom set_correct_diag_sim_i :
  forall (c:circuit) (a:bitvec -> Z -> angle) (l:Z) (h:Z), (diag c) ->
  (l <= h)%Z ->
  (forall (x:bitvec), ((length x) = (width c)) ->
   (((diag_ang c) x) = (ang_sum (a x) l h))) ->
  correct_path_sum_i c (fun (x:bitvec) (us:bitvec) (i:Z) => ((a x) i)) l h
  (fun (x:bitvec) (us:bitvec) (i:Z) => ((getbv x) i)) 0%Z.

Axiom set_correct_diag_sim_ :
  forall (c:circuit) (a:bitvec -> bitvec -> angle), (diag c) ->
  (forall (x:bitvec) (y:bitvec) (y':bitvec), (((a x) y) = ((a x) y'))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = (width c)) ->
   (((diag_ang c) x) = ((a x) y))) ->
  correct_path_sum c a (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom correct_to_diag :
  forall (c:circuit) (a:bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  diag c.

Axiom correct_to_diag1 :
  forall (c:circuit) (a:bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  forall (x:bitvec), ((length x) = (width c)) ->
  sem c (bv_to_ket x) (infix_asdtdt (ang_exp (a x)) (bv_to_ket x)).

Axiom flat_correct_to_diag :
  forall (c:circuit) (a:bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  diag c.

Axiom flat_correct_to_diag1 :
  forall (c:circuit) (a:bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  forall (x:bitvec), ((length x) = (width c)) -> (((diag_ang c) x) = (a x)).

Axiom diag_sem_inst :
  forall (c:circuit) (x:bitvec) (a:angle), (diag c) ->
  ((length x) = (width c)) ->
  (sem c (bv_to_ket x) (infix_asdtdt (ang_exp a) (bv_to_ket x))) ->
  (a = ((diag_ang c) x)).

Axiom set_diag_eq :
  forall (c:circuit) (a:bitvec -> angle),
  (forall (x:bitvec), ((length x) = (width c)) ->
   sem c (bv_to_ket x) (infix_asdtdt (ang_exp (a x)) (bv_to_ket x))) ->
  diag c.

Axiom set_diag_eq1 :
  forall (c:circuit) (a:bitvec -> angle),
  (forall (x:bitvec), ((length x) = (width c)) ->
   sem c (bv_to_ket x) (infix_asdtdt (ang_exp (a x)) (bv_to_ket x))) ->
  correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
  (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom set_diag_eq2 :
  forall (c:circuit) (a:bitvec -> angle),
  (forall (x:bitvec), ((length x) = (width c)) ->
   sem c (bv_to_ket x) (infix_asdtdt (ang_exp (a x)) (bv_to_ket x))) ->
  forall (x:bitvec), ((length x) = (width c)) -> ((a x) = ((diag_ang c) x)).

Axiom diag_sem_inst_rev :
  forall (c:circuit) (x:bitvec) (a:angle), (diag c) ->
  ((length x) = (width c)) -> (a = ((diag_ang c) x)) ->
  sem c (bv_to_ket x) (infix_asdtdt (ang_exp a) (bv_to_ket x)).

Axiom diag_is_flat : forall (c:circuit), (diag c) -> flat c.

Axiom diag_phase : forall (o:angle), diag (phase o).

Axiom diag_rz : forall (o:angle), diag (rz o).

Axiom seq_pres_diag_pre :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle),
  ((width c) = (width c')) ->
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  correct_path_sum (sequence c c')
  (fun (x:bitvec) (us:bitvec) => (ang_add (a x) (a' x)))
  (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom seq_pres_diag_pre1 :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle),
  ((width c) = (width c')) ->
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  diag (sequence c c').

Axiom seq_pres_diag_pre2 :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle),
  ((width c) = (width c')) ->
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  forall (x:bitvec), ((length x) = (width (sequence c c'))) ->
  (((diag_ang (sequence c c')) x) = (ang_add (a x) (a' x))).

Axiom par_pres_diag_pre :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  correct_path_sum (parallel c c')
  (fun (x:bitvec) (us:bitvec) =>
   (ang_add (a (hpart x (width c))) (a' (tpart x (width c)))))
  (fun (x:bitvec) (us:bitvec) => x) 0%Z.

Axiom par_pres_diag_pre1 :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  diag (parallel c c').

Axiom par_pres_diag_pre2 :
  forall (c:circuit) (c':circuit) (a:bitvec -> angle) (a':bitvec -> angle),
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  (correct_path_sum c' (fun (x:bitvec) (us:bitvec) => (a' x))
   (fun (x:bitvec) (us:bitvec) => x) 0%Z) ->
  forall (x:bitvec), ((length x) = (width (parallel c c'))) ->
  (((diag_ang (parallel c c')) x) =
   (ang_add (a (hpart x (width c))) (a' (tpart x (width c))))).

Parameter diag_sum_scheme_unit: circuit -> (matrix t) -> matrix t.

Axiom diag_sum_scheme_unit_def :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) ->
  (is_a_ket_basis_elt x) -> (diag c) ->
  ((diag_sum_scheme_unit c x) =
   (infix_asdtdt (ang_exp ((diag_ang c) (ket_to_bv x))) x)).

Axiom diag_sum_scheme_unit_spec :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) ->
  (is_a_ket_basis_elt x) -> (diag c) ->
  is_a_ket_l (diag_sum_scheme_unit c x) (width c).

Axiom diag_sum_scheme_unit_spec1 :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) ->
  (is_a_ket_basis_elt x) -> (diag c) ->
  ((diag_sum_scheme_unit c x) =
   (path_sum_scheme_unit (fun (x1:bitvec) (us:bitvec) => ((diag_ang c) x1))
    (fun (x1:bitvec) (us:bitvec) => x1) (width c) 0%Z (ket_to_bv x))).

Axiom diag_sum_scheme_unit_spec2 :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) ->
  (is_a_ket_basis_elt x) -> (diag c) ->
  is_a_ket_l (diag_sum_scheme_unit c x) (width c).

Parameter diag_sum_scheme: circuit -> (matrix t) -> matrix t.

Axiom diag_sum_scheme_def :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) -> (diag c) ->
  ((diag_sum_scheme c x) =
   (ket_sum_l (n_bvs (width c))
    (fun (z:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int z))
      (diag_sum_scheme_unit c (bv_to_ket (hpart z (width c))))))
    (width c))).

Axiom diag_sum_scheme_spec :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) -> (diag c) ->
  is_a_ket_l (diag_sum_scheme c x) (width c).

Axiom diag_sum_scheme_spec1 :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) -> (diag c) ->
  ((diag_sum_scheme c x) =
   (ket_sum_l (n_bvs (width c))
    (fun (z:bitvec) =>
     (infix_asdtdt (get_ket x (bv_to_int z))
      (diag_sum_scheme_unit c (bv_to_ket z))))
    (width c))).

Axiom diag_sum_scheme_spec2 :
  forall (c:circuit) (x:matrix t), (is_a_ket_l x (width c)) -> (diag c) ->
  ((diag_sum_scheme c x) =
   (path_sum_scheme (fun (x1:bitvec) (us:bitvec) => ((diag_ang c) x1))
    (fun (x1:bitvec) (us:bitvec) => x1) (width c) 0%Z x)).

Axiom seq_pres_diag :
  forall (c:circuit) (c':circuit), ((width c) = (width c')) -> (diag c) ->
  (diag c') -> diag (sequence c c').

Axiom par_pres_diag :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  diag (parallel c c').

Axiom pat_sem_diag_basis :
  forall (c:circuit) (x:bitvec), (diag c) -> ((length x) = (width c)) ->
  ((pat_sem c (bv_to_ket x)) =
   (infix_asdtdt (ang_exp ((diag_ang c) x)) (bv_to_ket x))).

Axiom sem_diag_basis :
  forall (c:circuit) (x:bitvec), (diag c) -> ((length x) = (width c)) ->
  sem c (bv_to_ket x) (infix_asdtdt (ang_exp ((diag_ang c) x)) (bv_to_ket x)).

Axiom sem_diag_basis_gen :
  forall (c:circuit), (diag c) -> forall (x:bitvec),
  ((length x) = (width c)) ->
  sem c (bv_to_ket x) (infix_asdtdt (ang_exp ((diag_ang c) x)) (bv_to_ket x)).

Axiom set_diag_ang :
  forall (c:circuit) (f:bitvec -> angle),
  (forall (x:bitvec), ((length x) = (width c)) ->
   ((pat_sem c (bv_to_ket x)) = (infix_asdtdt (ang_exp (f x)) (bv_to_ket x)))) ->
  diag c.

Axiom set_diag_ang1 :
  forall (c:circuit) (f:bitvec -> angle),
  (forall (x:bitvec), ((length x) = (width c)) ->
   ((pat_sem c (bv_to_ket x)) = (infix_asdtdt (ang_exp (f x)) (bv_to_ket x)))) ->
  forall (x:bitvec), ((length x) = (width c)) -> (((diag_ang c) x) = (f x)).

Axiom set_diag_ang_sem :
  forall (c:circuit) (f:bitvec -> angle),
  (forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
   sem c x (infix_asdtdt (ang_exp (f (ket_to_bv x))) x)) ->
  diag c.

Axiom set_diag_ang_sem1 :
  forall (c:circuit) (f:bitvec -> angle),
  (forall (x:matrix t), (is_a_ket_l x (width c)) -> (is_a_ket_basis_elt x) ->
   sem c x (infix_asdtdt (ang_exp (f (ket_to_bv x))) x)) ->
  forall (x:bitvec), ((length x) = (width c)) -> (((diag_ang c) x) = (f x)).

Axiom diag_ang_phase :
  forall (o:angle), ((diag_ang (phase o)) = (fun (us:bitvec) => o)).

Axiom diag_ang_rz :
  forall (o:angle),
  ((diag_ang (rz o)) =
   (fun (x:bitvec) => (phase_inv_ (1%Z - ((getbv x) 0%Z))%Z o))).

Axiom diag_ang_cnot : ((diag_ang cnot) = (fun (us:bitvec) => ang_zero)).

Axiom diag_ang_sequence :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((diag_ang (sequence c c')) =
   (fun (x:bitvec) => (ang_add ((diag_ang c) x) ((diag_ang c') x)))).

Axiom diag_ang_parallel :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((diag_ang (parallel c c')) =
   (fun (x:bitvec) =>
    (ang_add ((diag_ang c) (hpart x (width c)))
     ((diag_ang c') (tpart x (width c)))))).

Parameter d_sequence: circuit -> circuit -> circuit.

Axiom d_sequence_def :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((width c) = (width c')) -> ((d_sequence c c') = (sequence c c')).

Axiom d_sequence_spec :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((width c) = (width c')) ->
  ((size (d_sequence c c')) = ((size c) + (size c'))%Z).

Axiom d_sequence_spec1 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((width c) = (width c')) ->
  ((ancillas (d_sequence c c')) =
   (ZArith.BinInt.Z.max (ancillas c) (ancillas c'))).

Axiom d_sequence_spec2 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((width c) = (width c')) -> ((width (d_sequence c c')) = (width c)).

Axiom d_sequence_spec3 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((width c) = (width c')) -> diag (d_sequence c c').

Axiom d_sequence_spec4 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((width c) = (width c')) ->
  ((diag_ang (d_sequence c c')) =
   (fun (x:bitvec) => (ang_add ((diag_ang c) x) ((diag_ang c') x)))).

Axiom d_sequence_eq :
  forall (d:circuit) (d':circuit) (e1:circuit) (e':circuit), (diag d) ->
  (diag e1) -> ((width d) = (width e1)) -> (d = d') -> (e1 = e') ->
  ((d_sequence d e1) = (d_sequence d' e')).

Parameter d_parallel: circuit -> circuit -> circuit.

Axiom d_parallel_def :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((d_parallel c c') = (parallel c c')).

Axiom d_parallel_spec :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((size (d_parallel c c')) = ((size c) + (size c'))%Z).

Axiom d_parallel_spec1 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((ancillas (d_parallel c c')) = ((ancillas c) + (ancillas c'))%Z).

Axiom d_parallel_spec2 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((width (d_parallel c c')) = ((width c) + (width c'))%Z).

Axiom d_parallel_spec3 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  diag (d_parallel c c').

Axiom d_parallel_spec4 :
  forall (c:circuit) (c':circuit), (diag c) -> (diag c') ->
  ((diag_ang (d_parallel c c')) =
   (fun (x:bitvec) =>
    (ang_add ((diag_ang c) (hpart x (width c)))
     ((diag_ang c') (tpart x (width c)))))).

Axiom d_parallel_eq :
  forall (d:circuit) (d':circuit) (e1:circuit) (e':circuit), (diag d) ->
  (diag e1) -> (d = d') -> (e1 = e') ->
  ((d_parallel d e1) = (d_parallel d' e')).

Parameter d_place: circuit -> Z -> Z -> circuit.

Axiom d_place_def :
  forall (c:circuit) (k:Z) (n:Z), (diag c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((d_place c k n) = (place c k n)).

Axiom d_place_spec :
  forall (c:circuit) (k:Z) (n:Z), (diag c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) -> diag (d_place c k n).

Axiom d_place_spec1 :
  forall (c:circuit) (k:Z) (n:Z), (diag c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((width (d_place c k n)) = n).

Axiom d_place_spec2 :
  forall (c:circuit) (k:Z) (n:Z), (diag c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) ->
  ((ancillas (d_place c k n)) = (ancillas c)).

Axiom d_place_spec3 :
  forall (c:circuit) (k:Z) (n:Z), (diag c) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k <= (n - (width c))%Z)%Z) -> forall (x:bitvec),
  ((length x) = n) ->
  (((diag_ang (d_place c k n)) x) = ((diag_ang c) (htpart x k (width c)))).

Parameter d_seq_iter: (Z -> circuit) -> Z -> Z -> Z -> circuit.

Axiom d_seq_iter_def :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> diag (f k)) ->
  (j = (i + 1%Z)%Z) -> ((d_seq_iter f d i j) = (f i)).

Axiom d_seq_iter_def1 :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> diag (f k)) ->
  ~ (j = (i + 1%Z)%Z) ->
  ((d_seq_iter f d i j) =
   (d_sequence (d_seq_iter f d i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom d_seq_iter_spec :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> diag (f k)) ->
  diag (d_seq_iter f d i j).

Axiom d_seq_iter_spec1 :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> diag (f k)) ->
  ((width (d_seq_iter f d i j)) = d).

Axiom d_seq_iter_spec2 :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> diag (f k)) ->
  forall (x:bitvec), ((length x) = d) ->
  (((diag_ang (d_seq_iter f d i j)) x) =
   (ang_sum (fun (k:Z) => ((diag_ang (f k)) x)) i j)).

Axiom d_seq_iter_one :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z), ((i + 1%Z)%Z = j) ->
  ((width (f i)) = d) -> (diag (f i)) -> ((d_seq_iter f d i j) = (f i)).

Axiom d_seq_iter_plus_one :
  forall (f:Z -> circuit) (d:Z) (i:Z) (j:Z), ((i + 1%Z)%Z < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> diag (f k)) ->
  ((d_seq_iter f d i j) =
   (d_sequence (d_seq_iter f d i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom d_seq_iter_eq :
  forall (f:Z -> circuit) (g:Z -> circuit) (d:Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((width (f k)) = d)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> diag (f k)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((d_seq_iter g d i j) = (d_seq_iter f d i j)).

Parameter rzp: Z -> circuit.

Axiom rzp_def :
  forall (n:Z), (n >= 0%Z)%Z ->
  ((rzp n) =
   (d_sequence (phase (int_to_ang 1%Z (n + 1%Z)%Z))
    (rz (int_to_ang 1%Z (n + 1%Z)%Z)))).

Axiom rzp_spec : forall (n:Z), (n >= 0%Z)%Z -> ((size (rzp n)) = 2%Z).

Axiom rzp_spec1 : forall (n:Z), (n >= 0%Z)%Z -> ((ancillas (rzp n)) = 0%Z).

Axiom rzp_spec2 : forall (n:Z), (n >= 0%Z)%Z -> ((width (rzp n)) = 1%Z).

Axiom rzp_spec3 : forall (n:Z), (n >= 0%Z)%Z -> diag (rzp n).

Axiom rzp_spec4 :
  forall (n:Z), (n >= 0%Z)%Z -> forall (x:bitvec), ((length x) = 1%Z) ->
  (((diag_ang (rzp n)) x) = (int_to_ang ((getbv x) 0%Z) n)).

Parameter przp: Z -> Z -> Z -> circuit.

Axiom przp_def :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ((przp i k n) = (d_place (rzp i) k n)).

Axiom przp_spec :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ((size (przp i k n)) = 2%Z).

Axiom przp_spec1 :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ((ancillas (przp i k n)) = 0%Z).

Axiom przp_spec2 :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ((width (przp i k n)) = n).

Axiom przp_spec3 :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> diag (przp i k n).

Axiom przp_spec4 :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (przp i k n)) x) = (int_to_ang ((getbv x) k) i)).

Axiom przp_spec5 :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> (i <= n)%Z -> forall (x:bitvec),
  ((length x) = n) ->
  (((diag_ang (przp i k n)) x) =
   (int_to_ang (((getbv x) k) * (power_ 2%Z (n - i)%Z))%Z n)).

Parameter rzp_neg: Z -> circuit.

Axiom rzp_neg_def :
  forall (n:Z), (n >= 0%Z)%Z ->
  ((rzp_neg n) =
   (d_sequence (phase (int_to_ang (-1%Z)%Z (n + 1%Z)%Z))
    (rz (int_to_ang (-1%Z)%Z (n + 1%Z)%Z)))).

Axiom rzp_neg_spec :
  forall (n:Z), (n >= 0%Z)%Z -> ((width (rzp_neg n)) = 1%Z).

Axiom rzp_neg_spec1 : forall (n:Z), (n >= 0%Z)%Z -> diag (rzp_neg n).

Axiom rzp_neg_spec2 :
  forall (n:Z), (n >= 0%Z)%Z -> forall (x:bitvec), ((length x) = 1%Z) ->
  (((diag_ang (rzp_neg n)) x) = (int_to_ang (-((getbv x) 0%Z))%Z n)).

Parameter dplace: circuit -> Z -> Z -> circuit.

Axiom dplace_def :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> (diag c) -> ((dplace c k n) = (place c k n)).

Axiom dplace_spec :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> (diag c) -> diag (dplace c k n).

Axiom dplace_spec1 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> (diag c) -> ((width (dplace c k n)) = n).

Axiom dplace_spec2 :
  forall (c:circuit) (k:Z) (n:Z), (k >= 0%Z)%Z ->
  (n >= ((width c) + k)%Z)%Z -> (diag c) -> forall (x:bitvec),
  ((length x) = n) ->
  (((diag_ang (dplace c k n)) x) = ((diag_ang c) (htpart x k (width c)))).

Parameter dcont: circuit -> Z -> Z -> Z -> circuit.

Axiom dcont_def :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> ((dcont c co ft n) = (cont c co ft n)).

Axiom dcont_def1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) ->
  ((dcont c co ft n) = (cont c co ft n)).

Axiom dcont_spec :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> ((ancillas (dcont c co ft n)) = (ancillas c)).

Axiom dcont_spec1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> ((size (dcont c co ft n)) <= (cont_size * (size c))%Z)%Z.

Axiom dcont_spec2 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> diag (dcont c co ft n).

Axiom dcont_spec3 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> ((width (dcont c co ft n)) = n).

Axiom dcont_spec4 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (dcont c co ft n)) x) =
   (ang_mult_int ((diag_ang c) (htpart x ft (width c))) ((getbv x) co))).

Axiom dcont_spec5 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) ->
  ((ancillas (dcont c co ft n)) = (ancillas c)).

Axiom dcont_spec6 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) ->
  ((size (dcont c co ft n)) <= (cont_size * (size c))%Z)%Z.

Axiom dcont_spec7 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) -> diag (dcont c co ft n).

Axiom dcont_spec8 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) -> ((width (dcont c co ft n)) = n).

Axiom dcont_spec9 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) -> forall (x:bitvec),
  ((length x) = n) ->
  (((diag_ang (dcont c co ft n)) x) =
   (ang_mult_int ((diag_ang c) (htpart x ft (width c))) ((getbv x) co))).

Parameter d_cont: circuit -> Z -> Z -> Z -> circuit.

Axiom d_cont_def :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> ((d_cont c co ft n) = (dcont c co ft n)).

Axiom d_cont_def1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) ->
  ((d_cont c co ft n) = (dcont c co ft n)).

Axiom d_cont_spec :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> diag (d_cont c co ft n).

Axiom d_cont_spec1 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> ((width (d_cont c co ft n)) = n).

Axiom d_cont_spec2 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) -> ~ (ft <= co)%Z ->
  (diag c) -> forall (x:bitvec), ((length x) = n) ->
  ((((getbv x) co) = 1%Z) ->
   (((diag_ang (d_cont c co ft n)) x) =
    ((diag_ang c) (htpart x ft (width c))))) /\
  (~ (((getbv x) co) = 1%Z) ->
   (((diag_ang (d_cont c co ft n)) x) = ang_zero)).

Axiom d_cont_spec3 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) -> diag (d_cont c co ft n).

Axiom d_cont_spec4 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) ->
  ((width (d_cont c co ft n)) = n).

Axiom d_cont_spec5 :
  forall (c:circuit) (co:Z) (ft:Z) (n:Z), ((0%Z <= co)%Z /\ (co < n)%Z) ->
  ((0%Z <= ft)%Z /\ (ft <= (n - (width c))%Z)%Z) ->
  ((ft + (width c))%Z <= co)%Z -> (diag c) -> forall (x:bitvec),
  ((length x) = n) ->
  ((((getbv x) co) = 1%Z) ->
   (((diag_ang (d_cont c co ft n)) x) =
    ((diag_ang c) (htpart x ft (width c))))) /\
  (~ (((getbv x) co) = 1%Z) ->
   (((diag_ang (d_cont c co ft n)) x) = ang_zero)).

Parameter c_rzp_pos: Z -> Z -> Z -> Z -> circuit.

Axiom c_rzp_pos_def :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((c_rzp_pos k co ft n) = (dcont (rzp k) co ft n)).

Axiom c_rzp_pos_def1 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((c_rzp_pos k co ft n) = (dcont (rzp k) co ft n)).

Axiom c_rzp_pos_spec :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((width (c_rzp_pos k co ft n)) = n).

Axiom c_rzp_pos_spec1 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((ancillas (c_rzp_pos k co ft n)) = 0%Z).

Axiom c_rzp_pos_spec2 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((size (c_rzp_pos k co ft n)) <= (cont_size * 2%Z)%Z)%Z.

Axiom c_rzp_pos_spec3 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> diag (c_rzp_pos k co ft n).

Axiom c_rzp_pos_spec4 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (c_rzp_pos k co ft n)) x) =
   (int_to_ang (((getbv x) co) * ((getbv x) ft))%Z k)).

Axiom c_rzp_pos_spec5 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_pos k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_pos_spec6 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_pos k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power_ 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_pos_spec7 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((width (c_rzp_pos k co ft n)) = n).

Axiom c_rzp_pos_spec8 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((ancillas (c_rzp_pos k co ft n)) = 0%Z).

Axiom c_rzp_pos_spec9 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((size (c_rzp_pos k co ft n)) <= (cont_size * 2%Z)%Z)%Z.

Axiom c_rzp_pos_spec10 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> diag (c_rzp_pos k co ft n).

Axiom c_rzp_pos_spec11 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (c_rzp_pos k co ft n)) x) =
   (int_to_ang (((getbv x) co) * ((getbv x) ft))%Z k)).

Axiom c_rzp_pos_spec12 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_pos k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_pos_spec13 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_pos k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power_ 2%Z (m - k)%Z))%Z m)).

Parameter c_rzp_neg: Z -> Z -> Z -> Z -> circuit.

Axiom c_rzp_neg_def :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((c_rzp_neg k co ft n) = (dcont (rzp_neg k) co ft n)).

Axiom c_rzp_neg_def1 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((c_rzp_neg k co ft n) = (dcont (rzp_neg k) co ft n)).

Axiom c_rzp_neg_spec :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((ancillas (c_rzp_neg k co ft n)) = 0%Z).

Axiom c_rzp_neg_spec1 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((size (c_rzp_neg k co ft n)) <= (cont_size * 2%Z)%Z)%Z.

Axiom c_rzp_neg_spec2 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((width (c_rzp_neg k co ft n)) = n).

Axiom c_rzp_neg_spec3 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> diag (c_rzp_neg k co ft n).

Axiom c_rzp_neg_spec4 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (c_rzp_neg k co ft n)) x) =
   (int_to_ang ((-((getbv x) co))%Z * ((getbv x) ft))%Z k)).

Axiom c_rzp_neg_spec5 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_neg k co ft n)) x) =
   (int_to_ang
    (((-((getbv x) co))%Z * ((getbv x) ft))%Z * (power 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_neg_spec6 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_neg k co ft n)) x) =
   (int_to_ang
    (((-((getbv x) co))%Z * ((getbv x) ft))%Z * (power_ 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_neg_spec7 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((ancillas (c_rzp_neg k co ft n)) = 0%Z).

Axiom c_rzp_neg_spec8 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((size (c_rzp_neg k co ft n)) <= (cont_size * 2%Z)%Z)%Z.

Axiom c_rzp_neg_spec9 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((width (c_rzp_neg k co ft n)) = n).

Axiom c_rzp_neg_spec10 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> diag (c_rzp_neg k co ft n).

Axiom c_rzp_neg_spec11 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (c_rzp_neg k co ft n)) x) =
   (int_to_ang ((-((getbv x) co))%Z * ((getbv x) ft))%Z k)).

Axiom c_rzp_neg_spec12 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_neg k co ft n)) x) =
   (int_to_ang
    (((-((getbv x) co))%Z * ((getbv x) ft))%Z * (power 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_neg_spec13 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (k >= 0%Z)%Z -> (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp_neg k co ft n)) x) =
   (int_to_ang
    (((-((getbv x) co))%Z * ((getbv x) ft))%Z * (power_ 2%Z (m - k)%Z))%Z m)).

Parameter c_rzp: Z -> Z -> Z -> Z -> circuit.

Axiom c_rzp_def :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> (k >= 0%Z)%Z ->
  ((c_rzp k co ft n) = (c_rzp_pos k co ft n)).

Axiom c_rzp_def1 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ~ (k >= 0%Z)%Z ->
  ((c_rzp k co ft n) = (c_rzp_neg (-k)%Z co ft n)).

Axiom c_rzp_def2 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> (k >= 0%Z)%Z -> ((c_rzp k co ft n) = (c_rzp_pos k co ft n)).

Axiom c_rzp_def3 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ~ (k >= 0%Z)%Z ->
  ((c_rzp k co ft n) = (c_rzp_neg (-k)%Z co ft n)).

Axiom c_rzp_spec :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((width (c_rzp k co ft n)) = n).

Axiom c_rzp_spec1 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((ancillas (c_rzp k co ft n)) = 0%Z).

Axiom c_rzp_spec2 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> ((size (c_rzp k co ft n)) <= (cont_size * 2%Z)%Z)%Z.

Axiom c_rzp_spec3 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> diag (c_rzp k co ft n).

Axiom c_rzp_spec4 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (c_rzp k co ft n)) x) =
   (int_to_ang (((getbv x) co) * ((getbv x) ft))%Z k)).

Axiom c_rzp_spec5 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_spec6 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft <= co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power_ 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_spec7 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((width (c_rzp k co ft n)) = n).

Axiom c_rzp_spec8 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((ancillas (c_rzp k co ft n)) = 0%Z).

Axiom c_rzp_spec9 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> ((size (c_rzp k co ft n)) <= (cont_size * 2%Z)%Z)%Z.

Axiom c_rzp_spec10 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> diag (c_rzp k co ft n).

Axiom c_rzp_spec11 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (c_rzp k co ft n)) x) =
   (int_to_ang (((getbv x) co) * ((getbv x) ft))%Z k)).

Axiom c_rzp_spec12 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power 2%Z (m - k)%Z))%Z m)).

Axiom c_rzp_spec13 :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  (ft < co)%Z -> forall (x:bitvec), forall (m:Z), (m >= k)%Z ->
  ((length x) = n) ->
  (((diag_ang (c_rzp k co ft n)) x) =
   (int_to_ang
    ((((getbv x) co) * ((getbv x) ft))%Z * (power_ 2%Z (m - k)%Z))%Z m)).

Parameter xx: unit -> circuit.

Axiom xx_def :
  forall (us:unit),
  ((xx us) = (sequence hadamard (sequence (rzp 1%Z) hadamard))).

Axiom xx_spec : forall (us:unit), flat (xx us).

Axiom xx_spec1 : forall (us:unit), ((size (xx us)) = 4%Z).

Axiom xx_spec2 : forall (us:unit), ((ancillas (xx us)) = 0%Z).

Axiom xx_spec3 : forall (us:unit), ((width (xx us)) = 1%Z).

Axiom xx_spec4 :
  forall (us:unit), forall (x:bitvec), ((length x) = 1%Z) ->
  (((flat_ang (xx us)) x) = ang_zero).

Axiom xx_spec5 :
  forall (us:unit), forall (x:bitvec), ((length x) = 1%Z) ->
  (((getbv ((flat_ket (xx us)) x)) 0%Z) = (1%Z - ((getbv x) 0%Z))%Z).

Parameter place_xx: Z -> Z -> circuit.

Axiom place_xx_def :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((place_xx c n) = (place (xx tt) c n)).

Axiom place_xx_spec :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) -> flat (place_xx c n).

Axiom place_xx_spec1 :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((size (place_xx c n)) = 4%Z).

Axiom place_xx_spec2 :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((ancillas (place_xx c n)) = 0%Z).

Axiom place_xx_spec3 :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((width (place_xx c n)) = n).

Axiom place_xx_spec4 :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) -> forall (x:bitvec),
  ((length x) = n) -> (((flat_ang (place_xx c n)) x) = ang_zero).

Axiom place_xx_spec5 :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) -> forall (x:bitvec),
  ((length x) = n) ->
  ((flat_ket_i (place_xx c n) x c) = (1%Z - ((getbv x) c))%Z).

Axiom place_xx_spec6 :
  forall (c:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) -> forall (x:bitvec),
  forall (i:Z), ((length x) = n) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ~ (i = c) -> ((flat_ket_i (place_xx c n) x i) = ((getbv x) i)).

Parameter x_kron: Z -> circuit.

Axiom x_kron_def :
  forall (n:Z), (0%Z < n)%Z -> (n = 1%Z) -> ((x_kron n) = (xx tt)).

Axiom x_kron_def1 :
  forall (n:Z), (0%Z < n)%Z -> ~ (n = 1%Z) ->
  ((x_kron n) = (f_parallel (x_kron (n - 1%Z)%Z) (xx tt))).

Axiom x_kron_spec : forall (n:Z), (0%Z < n)%Z -> flat (x_kron n).

Axiom x_kron_spec1 : forall (n:Z), (0%Z < n)%Z -> ((width (x_kron n)) = n).

Axiom x_kron_spec2 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((flat_ang (x_kron n)) x) = ang_zero).

Axiom x_kron_spec3 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((flat_ket (x_kron n)) x) =
   (make_bv (fun (i:Z) => (1%Z - ((getbv x) i))%Z) n)).

Axiom x_kron_spec4 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), forall (i:Z),
  ((length x) = n) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
  (((getbv ((flat_ket (x_kron n)) x)) i) = (1%Z - ((getbv x) i))%Z).

Parameter gen_phase: angle -> Z -> circuit.

Axiom gen_phase_def :
  forall (o:angle) (n:Z), (0%Z < n)%Z ->
  ((gen_phase o n) = (dplace (phase o) 0%Z n)).

Axiom gen_phase_spec :
  forall (o:angle) (n:Z), (0%Z < n)%Z -> diag (gen_phase o n).

Axiom gen_phase_spec1 :
  forall (o:angle) (n:Z), (0%Z < n)%Z -> ((width (gen_phase o n)) = n).

Axiom gen_phase_spec2 :
  forall (o:angle) (n:Z), (0%Z < n)%Z -> forall (x:bitvec),
  ((length x) = n) -> (((diag_ang (gen_phase o n)) x) = o).

Parameter correct_flat:
  circuit -> (bitvec -> angle) -> (bitvec -> bitvec) -> Prop.

Axiom correct_flat_def :
  forall (c:circuit) (a:bitvec -> angle) (b:bitvec -> bitvec),
  (correct_flat c a b) <->
  (correct_path_sum c (fun (x:bitvec) (us:bitvec) => (a x))
   (fun (x:bitvec) (us:bitvec) => (b x)) 0%Z).

Axiom correct_flat_spec : forall (c:circuit), flat c.

Axiom set_correct_flat :
  forall (c:circuit), (flat c) -> correct_flat c (flat_ang c) (flat_ket c).

Axiom set_correct_flat_sim_diag :
  forall (c:circuit) (a:bitvec -> angle) (b:bitvec -> bitvec), (diag c) ->
  (forall (x:bitvec), ((length x) = (width c)) -> (((diag_ang c) x) = (a x))) ->
  (forall (x:bitvec), ((length x) = (width c)) -> ((b x) = x)) ->
  correct_flat c a b.

Axiom set_correct_diag :
  forall (c:circuit), (diag c) ->
  correct_flat c (diag_ang c) (fun (y:bitvec) => y).

Axiom get_diag_from_correct_flat :
  forall (c:circuit), (correct_flat c (diag_ang c) (fun (y:bitvec) => y)) ->
  diag c.

Axiom get_diag_from_correct_flat1 :
  forall (c:circuit) (a:bitvec -> angle),
  (correct_flat c (diag_ang c) (fun (y:bitvec) => y)) -> forall (x:bitvec),
  ((length x) = (width c)) -> (((diag_ang c) x) = (a x)).

Parameter flat_sequ:
  circuit -> circuit -> (bitvec -> angle) -> (bitvec -> angle) ->
  (bitvec -> angle) -> (bitvec -> bitvec) -> (bitvec -> bitvec) ->
  (bitvec -> bitvec) -> Z -> circuit.

Axiom flat_sequ_def :
  forall (c:circuit) (c':circuit) (ase:bitvec -> angle) (a:bitvec -> angle)
    (a':bitvec -> angle) (bse:bitvec -> bitvec) (b:bitvec -> bitvec)
    (b':bitvec -> bitvec) (s:Z),
  (flat c) -> (flat c') -> (((width c) = (width c')) /\ ((width c') = s)) ->
  (correct_flat c a b) -> (correct_flat c' a' b') ->
  (forall (x:bitvec), ((length x) = s) ->
   ((ase x) = (ang_add (a x) (a' (b x))))) ->
  (forall (x:bitvec), ((length x) = s) -> ((bse x) = (b' (b x)))) ->
  ((flat_sequ c c' ase a a' bse b b' s) = (sequence c c')).

Axiom flat_sequ_spec :
  forall (c:circuit) (c':circuit) (ase:bitvec -> angle) (a:bitvec -> angle)
    (a':bitvec -> angle) (bse:bitvec -> bitvec) (b:bitvec -> bitvec)
    (b':bitvec -> bitvec) (s:Z),
  (flat c) -> (flat c') -> (((width c) = (width c')) /\ ((width c') = s)) ->
  (correct_flat c a b) -> (correct_flat c' a' b') ->
  (forall (x:bitvec), ((length x) = s) ->
   ((ase x) = (ang_add (a x) (a' (b x))))) ->
  (forall (x:bitvec), ((length x) = s) -> ((bse x) = (b' (b x)))) ->
  correct_flat (flat_sequ c c' ase a a' bse b b' s) ase bse.

Axiom flat_sequ_spec1 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> angle) (a:bitvec -> angle)
    (a':bitvec -> angle) (bse:bitvec -> bitvec) (b:bitvec -> bitvec)
    (b':bitvec -> bitvec) (s:Z),
  (flat c) -> (flat c') -> (((width c) = (width c')) /\ ((width c') = s)) ->
  (correct_flat c a b) -> (correct_flat c' a' b') ->
  (forall (x:bitvec), ((length x) = s) ->
   ((ase x) = (ang_add (a x) (a' (b x))))) ->
  (forall (x:bitvec), ((length x) = s) -> ((bse x) = (b' (b x)))) ->
  ((width (flat_sequ c c' ase a a' bse b b' s)) = s).

Axiom flat_sequ_spec2 :
  forall (c:circuit) (c':circuit) (ase:bitvec -> angle) (a:bitvec -> angle)
    (a':bitvec -> angle) (bse:bitvec -> bitvec) (b:bitvec -> bitvec)
    (b':bitvec -> bitvec) (s:Z),
  (flat c) -> (flat c') -> (((width c) = (width c')) /\ ((width c') = s)) ->
  (correct_flat c a b) -> (correct_flat c' a' b') ->
  (forall (x:bitvec), ((length x) = s) ->
   ((ase x) = (ang_add (a x) (a' (b x))))) ->
  (forall (x:bitvec), ((length x) = s) -> ((bse x) = (b' (b x)))) ->
  correct_path_sum (flat_sequ c c' ase a a' bse b b' s)
  (fun (x:bitvec) (us:bitvec) => (ase x))
  (fun (x:bitvec) (us:bitvec) => (bse x)) 0%Z.

Parameter c_rzp_zh_: Z -> Z -> Z -> Z -> circuit.

Axiom c_rzp_zh__def :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((c_rzp_zh_ k co t1 n) = (c_rzp k co t1 n)).

Axiom c_rzp_zh__spec :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((ancillas (c_rzp_zh_ k co t1 n)) = 0%Z).

Axiom c_rzp_zh__spec1 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((size (c_rzp_zh_ k co t1 n)) <= (cont_size * 2%Z)%Z)%Z.

Parameter had_zh_: Z -> Z -> circuit.

Axiom had_zh__def :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((had_zh_ t1 n) = (place hadamard t1 n)).

Axiom had_zh__spec :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((width (had_zh_ t1 n)) = n).

Axiom had_zh__spec1 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((size (had_zh_ t1 n)) = 1%Z).

Axiom had_zh__spec2 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((ancillas (had_zh_ t1 n)) = 0%Z).

Parameter cont_zh: circuit -> Prop.

Axiom zh_had :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  cont_zh (had_zh_ t1 n).

Axiom zh_cont_rzp :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> cont_zh (c_rzp_zh_ k co ft n).

Axiom seq_pres_zh :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> cont_zh (sequence d e1).

Axiom par_pres_zh :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> cont_zh (parallel d e1).

Parameter zh_range: circuit -> Z.

Axiom zh_range_spec :
  forall (g:circuit), (cont_zh g) -> ((zh_range g) >= 0%Z)%Z.

Axiom had_zh_range :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((zh_range (had_zh_ t1 n)) = 1%Z).

Axiom cont_zh_range :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> ((zh_range (c_rzp_zh_ k co ft n)) = 0%Z).

Axiom seq_zh_range :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) ->
  ((zh_range (sequence d e1)) = ((zh_range d) + (zh_range e1))%Z).

Axiom par_zh_range :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((zh_range (parallel d e1)) = ((zh_range d) + (zh_range e1))%Z).

Axiom zh_range_eq :
  forall (g:circuit) (g':circuit), (g = g') -> ((zh_range g) = (zh_range g')).

Parameter zh_ket: circuit -> bitvec -> bitvec -> bitvec.

Axiom zh_ket_spec :
  forall (c:circuit) (x:bitvec) (y:bitvec), (cont_zh c) -> forall (n:Z),
  (n = (width c)) -> ((length x) = (width c)) ->
  ((length y) = (zh_range c)) -> ((length (zh_ket c x y)) = n).

Parameter fc17: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def17 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc17 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc17 t1 x y) i) = ((getbv x) i))).

Axiom had_zh_ket :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ket (had_zh_ t1 n) x y) = (make_bv (fc17 t1 x y) n)).

Axiom cont_zh_ket :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> ((zh_ket (c_rzp_zh_ k co ft n) x y) = x).

Axiom seq_zh_ket :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width d)) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) ->
  ((zh_ket (sequence d e1) x y) =
   (zh_ket e1 (zh_ket d x (hpart y (zh_range d))) (tpart y (zh_range d)))).

Axiom par_zh_ket :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = ((width d) + (width e1))%Z) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) ->
  ((zh_ket (parallel d e1) x y) =
   (concat (zh_ket d (hpart x (width d)) (hpart y (zh_range d)))
    (zh_ket e1 (tpart x (width d)) (tpart y (zh_range d))))).

Axiom zh_ket_eq :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> ((length x) = (width g)) -> (x = x') ->
  ((length y) = (zh_range g)) -> (y = y') ->
  ((zh_ket g x y) = (zh_ket g' x' y')).

Axiom zh_ket_eq_bv :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> (((length x) = (length x')) /\ ((length x') = (width g))) ->
  (((length y) = (length y')) /\ ((length y') = (zh_range g))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length x))%Z) ->
   (((getbv x) i) = ((getbv x') i))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length y))%Z) ->
   (((getbv y) i) = ((getbv y') i))) ->
  ((zh_ket g x y) = (zh_ket g' x' y')).

Parameter zh_ket_i: circuit -> bitvec -> bitvec -> Z -> Z.

Axiom zh_ket_i_def :
  forall (c:circuit) (x:bitvec) (y:bitvec) (i:Z), (cont_zh c) ->
  ((zh_ket_i c x y i) = ((getbv (zh_ket c x y)) i)).

Axiom zh_ket_i_spec :
  forall (c:circuit) (x:bitvec) (y:bitvec) (i:Z), (cont_zh c) ->
  ((length x) = (width c)) -> ((length y) = (zh_range c)) ->
  ((0%Z <= i)%Z /\ (i < (width c))%Z) -> (0%Z <= (zh_ket_i c x y i))%Z.

Axiom zh_ket_i_spec1 :
  forall (c:circuit) (x:bitvec) (y:bitvec) (i:Z), (cont_zh c) ->
  ((length x) = (width c)) -> ((length y) = (zh_range c)) ->
  ((0%Z <= i)%Z /\ (i < (width c))%Z) -> ((zh_ket_i c x y i) < 2%Z)%Z.

Axiom zh_ket_value :
  forall (g:circuit) (x:bitvec) (y:bitvec) (i:Z) (j:Z), (cont_zh g) ->
  ((length x) = (width g)) -> ((length y) = (zh_range g)) ->
  ((0%Z <= i)%Z /\ (i < (width g))%Z) -> ((zh_ket_i g x y i) = j) ->
  (((getbv (zh_ket g x y)) i) = j).

Axiom had_zh_ket_i :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ket_i (had_zh_ t1 n) x y t1) = ((getbv y) 0%Z)).

Axiom had_zh_ket_i' :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ~ (i = t1) ->
  ((zh_ket_i (had_zh_ t1 n) x y i) = ((getbv x) i)).

Axiom cont_zh_ket_i :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (c_rzp_zh_ k co ft n) x y i) = ((getbv x) i)).

Axiom seq_zh_ket_i :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width d)) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (width d))%Z) ->
  ((zh_ket_i (sequence d e1) x y i) =
   (zh_ket_i e1 (zh_ket d x (hpart y (zh_range d))) (tpart y (zh_range d)) i)).

Axiom par_zh_ket_i :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = ((width d) + (width e1))%Z) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (width d))%Z) ->
  ((zh_ket_i (parallel d e1) x y i) =
   (zh_ket_i d (hpart x (width d)) (hpart y (zh_range d)) i)).

Axiom par_zh_ket_i' :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = ((width d) + (width e1))%Z) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) -> forall (i:Z),
  (((width d) <= i)%Z /\ (i < ((width d) + (width e1))%Z)%Z) ->
  ((zh_ket_i (parallel d e1) x y i) =
   (zh_ket_i e1 (tpart x (width d)) (tpart y (zh_range d)) (i - (width d))%Z)).

Axiom zh_ket_i_eq :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec) (i:Z) (i':Z),
  (g = g') -> ((length x) = (width g)) -> (x = x') ->
  ((length y) = (zh_range g)) -> (y = y') -> (i = i') ->
  ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
  ((zh_ket_i g x y i) = (zh_ket_i g' x' y' i')).

Axiom zh_ket_i_eq_bv :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec) (i:Z) (i':Z),
  (g = g') -> (((length x) = (length x')) /\ ((length x') = (width g))) ->
  (((length y) = (length y')) /\ ((length y') = (zh_range g))) ->
  (forall (j:Z), ((0%Z <= j)%Z /\ (j < (length x))%Z) ->
   (((getbv x) j) = ((getbv x') j))) ->
  (forall (j:Z), ((0%Z <= j)%Z /\ (j < (length y))%Z) ->
   (((getbv y) j) = ((getbv y') j))) ->
  (i = i') -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
  ((zh_ket_i g x y i) = (zh_ket_i g' x' y' i')).

Parameter zh_ang_coeff: circuit -> bitvec -> bitvec -> Z.

Axiom had_zh_ang_coeff :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang_coeff (had_zh_ t1 n) x y) =
   ((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z).

Axiom cont_zh_ang_coeff :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> (0%Z <= k)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff (c_rzp_zh_ k co ft n) x y) =
   ((((getbv x) ft) * ((getbv x) co))%Z * (power_ 2%Z (n - k)%Z))%Z).

Axiom seq_zh_ang_coeff :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width d)) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) ->
  ((zh_ang_coeff (sequence d e1) x y) =
   ((zh_ang_coeff d x (hpart y (zh_range d))) +
    (zh_ang_coeff e1 (zh_ket d x (hpart y (zh_range d)))
     (tpart y (zh_range d))))%Z).

Axiom par_zh_ang_coeff :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = ((width d) + (width e1))%Z) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) ->
  ((zh_ang_coeff (parallel d e1) x y) =
   ((zh_ang_coeff d (hpart x (width d)) (hpart y (zh_range d))) +
    (zh_ang_coeff e1 (tpart x (width d)) (tpart y (zh_range d))))%Z).

Axiom zh_ang_coeff_eq :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> ((length x) = (width g)) -> (x = x') ->
  ((length y) = (zh_range g)) -> (y = y') ->
  ((zh_ang_coeff g x y) = (zh_ang_coeff g' x' y')).

Axiom zh_ang_coeff_eq_bv :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> (((length x) = (length x')) /\ ((length x') = (width g))) ->
  (((length y) = (length y')) /\ ((length y') = (zh_range g))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length x))%Z) ->
   (((getbv x) i) = ((getbv x') i))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length y))%Z) ->
   (((getbv y) i) = ((getbv y') i))) ->
  ((zh_ang_coeff g x y) = (zh_ang_coeff g' x' y')).

Parameter zh_ang_coeff_neg: circuit -> bitvec -> bitvec -> Z.

Axiom had_zh_ang_coeff_neg :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang_coeff_neg (had_zh_ t1 n) x y) =
   ((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z).

Axiom cont_zh_ang_coeff_neg :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> (k <= 0%Z)%Z ->
  ((zh_ang_coeff_neg (c_rzp_zh_ k co ft n) x y) =
   ((((getbv x) ft) * ((getbv x) co))%Z * (power_ 2%Z (n + k)%Z))%Z).

Axiom seq_zh_ang_coeff_neg :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width d)) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) ->
  ((zh_ang_coeff_neg (sequence d e1) x y) =
   ((zh_ang_coeff_neg d x (hpart y (zh_range d))) +
    (zh_ang_coeff_neg e1 (zh_ket d x (hpart y (zh_range d)))
     (tpart y (zh_range d))))%Z).

Axiom par_zh_ang_coeff_neg :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = ((width d) + (width e1))%Z) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) ->
  ((zh_ang_coeff_neg (parallel d e1) x y) =
   ((zh_ang_coeff_neg d (hpart x (width d)) (hpart y (zh_range d))) +
    (zh_ang_coeff_neg e1 (tpart x (width d)) (tpart y (zh_range d))))%Z).

Axiom zh_ang_coeff_neg_eq :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> ((length x) = (width g)) -> (x = x') ->
  ((length y) = (zh_range g)) -> (y = y') ->
  ((zh_ang_coeff_neg g x y) = (zh_ang_coeff_neg g' x' y')).

Axiom zh_ang_coeff_neg_eq_bv :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> (((length x) = (length x')) /\ ((length x') = (width g))) ->
  (((length y) = (length y')) /\ ((length y') = (zh_range g))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length x))%Z) ->
   (((getbv x) i) = ((getbv x') i))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length y))%Z) ->
   (((getbv y) i) = ((getbv y') i))) ->
  ((zh_ang_coeff_neg g x y) = (zh_ang_coeff_neg g' x' y')).

Parameter zh_ang: circuit -> bitvec -> bitvec -> angle.

Axiom had_zh_ang :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang (had_zh_ t1 n) x y) =
   (int_to_ang (((getbv x) t1) * ((getbv y) 0%Z))%Z 1%Z)).

Axiom cont_zh_ang :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> (0%Z <= k)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang (c_rzp_zh_ k co ft n) x y) =
   (int_to_ang (((getbv x) ft) * ((getbv x) co))%Z k)).

Axiom cont_zh_ang_n :
  forall (k:Z) (co:Z) (ft:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= ft)%Z /\ (ft < n)%Z) ->
  ~ (ft = co) -> (k <= 0%Z)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang (c_rzp_zh_ k co ft n) x y) =
   (int_to_ang (-(((getbv x) ft) * ((getbv x) co))%Z)%Z (-k)%Z)).

Axiom seq_zh_ang :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width d)) ->
  ((length y) = ((zh_range d) + (zh_range e1))%Z) ->
  ((zh_ang (sequence d e1) x y) =
   (ang_add (zh_ang d x (hpart y (zh_range d)))
    (zh_ang e1 (zh_ket d x (hpart y (zh_range d))) (tpart y (zh_range d))))).

Axiom par_zh_ang :
  forall (d:circuit) (e1:circuit), (cont_zh d) -> (cont_zh e1) ->
  ((width d) = (width e1)) -> forall (x:bitvec) (y:bitvec),
  ((length x) = 1%Z) -> ((length y) = 1%Z) ->
  ((zh_ang (parallel d e1) x y) =
   (ang_add (zh_ang d (hpart x (width d)) (hpart y (zh_range d)))
    (zh_ang e1 (tpart x (width d)) (tpart y (zh_range d))))).

Axiom zh_ang_from_coeff :
  forall (g:circuit), (cont_zh g) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width g)) -> ((length y) = (zh_range g)) ->
  ((zh_ang g x y) = (int_to_ang (zh_ang_coeff g x y) (width g))).

Axiom zh_ang_from_coeff_neg :
  forall (g:circuit), (cont_zh g) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width g)) -> ((length y) = (zh_range g)) ->
  ((zh_ang g x y) = (int_to_ang (-(zh_ang_coeff_neg g x y))%Z (width g))).

Axiom zh_ket_from_i :
  forall (g:circuit), (cont_zh g) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width g)) -> ((length y) = (zh_range g)) ->
  ((zh_ket g x y) =
   (make_bv
    ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
        (zh_ket_i y0 y1 y2 y3))
       g)
      x)
     y)
    (width g))).

Axiom zh_ang_eq :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> ((length x) = (width g)) -> (x = x') ->
  ((length y) = (zh_range g)) -> (y = y') ->
  ((zh_ang g x y) = (zh_ang g' x' y')).

Axiom zh_ang_eq_bv :
  forall (g:circuit) (g':circuit) (x:bitvec) (x':bitvec) (y:bitvec)
    (y':bitvec),
  (g = g') -> (((length x) = (length x')) /\ ((length x') = (width g))) ->
  (((length y) = (length y')) /\ ((length y') = (zh_range g))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length x))%Z) ->
   (((getbv x) i) = ((getbv x') i))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length y))%Z) ->
   (((getbv y) i) = ((getbv y') i))) ->
  ((zh_ang g x y) = (zh_ang g' x' y')).

Axiom get_zh_ang :
  forall (g:circuit) (x:bitvec) (y:bitvec) (k:Z) (n:Z), (cont_zh g) ->
  (n = (width g)) -> ((length x) = (width g)) ->
  ((length y) = (zh_range g)) -> ((zh_ang_coeff g x y) = k) ->
  ((zh_ang g x y) = (int_to_ang k n)).

Axiom get_zh_ang_by_neg :
  forall (g:circuit) (x:bitvec) (y:bitvec) (k:Z) (n:Z), (cont_zh g) ->
  (n = (width g)) -> ((length x) = (width g)) ->
  ((length y) = (zh_range g)) ->
  ((int_to_ang (zh_ang_coeff_neg g x y) n) = (int_to_ang k n)) ->
  ((zh_ang g x y) = (int_to_ang (-k)%Z n)).

Axiom get_zh_ang_by :
  forall (g:circuit) (x:bitvec) (y:bitvec) (k:Z) (n:Z), (cont_zh g) ->
  (n = (width g)) -> ((length x) = (width g)) ->
  ((length y) = (zh_range g)) ->
  ((int_to_ang (zh_ang_coeff g x y) n) = (int_to_ang k n)) ->
  ((zh_ang g x y) = (int_to_ang k n)).

Axiom get_zh_ket_i :
  forall (g:circuit) (x:bitvec) (y:bitvec) (i:Z), (cont_zh g) ->
  ((length x) = (width g)) -> ((length y) = (zh_range g)) ->
  ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
  ((zh_ket_i g x y i) = ((getbv (zh_ket g x y)) i)).

Axiom get_bv_zh_ket :
  forall (g:circuit) (x:bitvec) (y:bitvec) (i:Z), (cont_zh g) ->
  ((length x) = (width g)) -> ((length y) = (zh_range g)) ->
  ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
  (((getbv (zh_ket g x y)) i) = (zh_ket_i g x y i)).

Parameter c_rzp_zh: Z -> Z -> Z -> Z -> circuit.

Axiom c_rzp_zh_def :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((c_rzp_zh k co t1 n) = (c_rzp k co t1 n)).

Axiom c_rzp_zh_spec :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((c_rzp_zh k co t1 n) = (c_rzp_zh_ k co t1 n)).

Axiom c_rzp_zh_spec1 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> cont_zh (c_rzp_zh k co t1 n).

Axiom c_rzp_zh_spec2 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((ancillas (c_rzp_zh k co t1 n)) = 0%Z).

Axiom c_rzp_zh_spec3 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((size (c_rzp_zh k co t1 n)) <= (cont_size * 2%Z)%Z)%Z.

Axiom c_rzp_zh_spec4 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((width (c_rzp_zh k co t1 n)) = n).

Axiom c_rzp_zh_spec5 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> ((zh_range (c_rzp_zh k co t1 n)) = 0%Z).

Axiom c_rzp_zh_spec6 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> ((zh_ket (c_rzp_zh k co t1 n) x y) = x).

Axiom c_rzp_zh_spec7 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (c_rzp_zh k co t1 n) x y i) = ((getbv x) i)).

Axiom c_rzp_zh_spec8 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> (0%Z <= k)%Z ->
  ((zh_ang (c_rzp_zh k co t1 n) x y) =
   (int_to_ang (((getbv x) t1) * ((getbv x) co))%Z k)).

Axiom c_rzp_zh_spec9 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> (k <= 0%Z)%Z ->
  ((zh_ang (c_rzp_zh k co t1 n) x y) =
   (int_to_ang (-(((getbv x) t1) * ((getbv x) co))%Z)%Z (-k)%Z)).

Axiom c_rzp_zh_spec10 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> (0%Z <= k)%Z ->
  ((zh_ang_coeff (c_rzp_zh k co t1 n) x y) =
   ((((getbv x) t1) * ((getbv x) co))%Z * (power_ 2%Z (n - k)%Z))%Z).

Axiom c_rzp_zh_spec11 :
  forall (k:Z) (co:Z) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= co)%Z /\ (co < n)%Z) -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = co) -> forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = 0%Z) -> (k <= 0%Z)%Z ->
  ((zh_ang_coeff_neg (c_rzp_zh k co t1 n) x y) =
   ((((getbv x) t1) * ((getbv x) co))%Z * (power_ 2%Z (n + k)%Z))%Z).

Parameter had_zh: Z -> Z -> circuit.

Axiom had_zh_def :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((had_zh t1 n) = (place hadamard t1 n)).

Axiom had_zh_spec :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((had_zh t1 n) = (had_zh_ t1 n)).

Axiom had_zh_spec1 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  cont_zh (had_zh t1 n).

Axiom had_zh_spec2 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((size (had_zh t1 n)) = 1%Z).

Axiom had_zh_spec3 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((ancillas (had_zh t1 n)) = 0%Z).

Axiom had_zh_spec4 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((width (had_zh t1 n)) = n).

Axiom had_zh_spec5 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((zh_range (had_zh t1 n)) = 1%Z).

Axiom had_zh_spec6 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ket_i (had_zh t1 n) x y t1) = ((getbv y) 0%Z)).

Axiom had_zh_spec7 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ~ (i = t1) ->
  ((zh_ket_i (had_zh t1 n) x y i) = ((getbv x) i)).

Parameter fc18: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def18 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc18 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc18 t1 x y) i) = ((getbv x) i))).

Axiom had_zh_spec8 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ket (had_zh t1 n) x y) = (make_bv (fc18 t1 x y) n)).

Axiom had_zh_spec9 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang_coeff (had_zh t1 n) x y) =
   ((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z).

Axiom had_zh_spec10 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang_coeff_neg (had_zh t1 n) x y) =
   ((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z).

Axiom had_zh_spec11 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang (had_zh t1 n) x y) =
   (int_to_ang (((getbv x) t1) * ((getbv y) 0%Z))%Z 1%Z)).

Axiom had_zh_spec12 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (k:Z) (j:Z) (a:Z) (b:Z), (0%Z < k)%Z -> (j = (k - 1%Z)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  (a = ((getbv x) t1)) -> (b = ((getbv y) 0%Z)) ->
  ((zh_ang (had_zh t1 n) x y) =
   (int_to_ang ((a * b)%Z * (power_ 2%Z j))%Z k)).

Axiom had_zh_spec13 :
  forall (t1:Z) (n:Z), (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (k:Z) (j:Z) (a:Z) (b:Z), (0%Z < k)%Z -> (j = (k - 1%Z)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  (a = ((getbv x) t1)) -> (b = ((getbv y) 0%Z)) ->
  ((zh_ang (had_zh t1 n) x y) =
   (int_to_ang (-((a * b)%Z * (power_ 2%Z j))%Z)%Z k)).

Parameter sequence_zh: circuit -> circuit -> circuit.

Axiom sequence_zh_def :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> ((sequence_zh d e1) = (sequence d e1)).

Axiom sequence_zh_spec :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> cont_zh (sequence_zh d e1).

Axiom sequence_zh_spec1 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) ->
  ((ancillas (sequence_zh d e1)) =
   (ZArith.BinInt.Z.max (ancillas d) (ancillas e1))).

Axiom sequence_zh_spec2 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> ((size (sequence_zh d e1)) = ((size d) + (size e1))%Z).

Axiom sequence_zh_spec3 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> ((width (sequence_zh d e1)) = (width d)).

Axiom sequence_zh_spec4 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) ->
  ((zh_range (sequence_zh d e1)) = ((zh_range d) + (zh_range e1))%Z).

Axiom sequence_zh_spec5 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (sequence_zh d e1))) ->
  ((length y) = (zh_range (sequence_zh d e1))) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (width d))%Z) ->
  ((zh_ket_i (sequence_zh d e1) x y i) =
   (zh_ket_i e1 (zh_ket d x (hpart y (zh_range d))) (tpart y (zh_range d)) i)).

Axiom sequence_zh_spec6 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (sequence_zh d e1))) ->
  ((length y) = (zh_range (sequence_zh d e1))) ->
  ((zh_ket (sequence_zh d e1) x y) =
   (zh_ket e1 (zh_ket d x (hpart y (zh_range d))) (tpart y (zh_range d)))).

Axiom sequence_zh_spec7 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (sequence_zh d e1))) ->
  ((length y) = (zh_range (sequence_zh d e1))) ->
  ((zh_ang_coeff (sequence_zh d e1) x y) =
   ((zh_ang_coeff d x (hpart y (zh_range d))) +
    (zh_ang_coeff e1 (zh_ket d x (hpart y (zh_range d)))
     (tpart y (zh_range d))))%Z).

Axiom sequence_zh_spec8 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (sequence_zh d e1))) ->
  ((length y) = (zh_range (sequence_zh d e1))) ->
  ((zh_ang_coeff_neg (sequence_zh d e1) x y) =
   ((zh_ang_coeff_neg d x (hpart y (zh_range d))) +
    (zh_ang_coeff_neg e1 (zh_ket d x (hpart y (zh_range d)))
     (tpart y (zh_range d))))%Z).

Axiom sequence_zh_spec9 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (sequence_zh d e1))) ->
  ((length y) = (zh_range (sequence_zh d e1))) ->
  ((zh_ang (sequence_zh d e1) x y) =
   (ang_add (zh_ang d x (hpart y (zh_range d)))
    (zh_ang e1 (zh_ket d x (hpart y (zh_range d))) (tpart y (zh_range d))))).

Parameter parallel_zh: circuit -> circuit -> circuit.

Axiom parallel_zh_def :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> ((parallel_zh d e1) = (parallel d e1)).

Axiom parallel_zh_spec :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> cont_zh (parallel_zh d e1).

Axiom parallel_zh_spec1 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> ((width (parallel_zh d e1)) = ((width d) + (width e1))%Z).

Axiom parallel_zh_spec2 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) ->
  ((zh_range (parallel_zh d e1)) = ((zh_range d) + (zh_range e1))%Z).

Axiom parallel_zh_spec3 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (parallel_zh d e1))) ->
  ((length y) = (zh_range (parallel_zh d e1))) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (width d))%Z) ->
  ((zh_ket_i (parallel_zh d e1) x y i) =
   (zh_ket_i d (hpart x (width d)) (hpart y (zh_range d)) i)).

Axiom parallel_zh_spec4 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (parallel_zh d e1))) ->
  ((length y) = (zh_range (parallel_zh d e1))) -> forall (i:Z),
  (((width d) <= i)%Z /\ (i < ((width d) + (width e1))%Z)%Z) ->
  ((zh_ket_i (parallel_zh d e1) x y i) =
   (zh_ket_i e1 (tpart x (width d)) (tpart y (zh_range d)) (i - (width d))%Z)).

Axiom parallel_zh_spec5 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (parallel_zh d e1))) ->
  ((length y) = (zh_range (parallel_zh d e1))) ->
  ((zh_ket (parallel_zh d e1) x y) =
   (concat (zh_ket d (hpart x (width d)) (hpart y (zh_range d)))
    (zh_ket e1 (tpart x (width d)) (tpart y (zh_range d))))).

Axiom parallel_zh_spec6 :
  forall (d:circuit) (e1:circuit), ((width d) = (width e1)) -> (cont_zh d) ->
  (cont_zh e1) -> forall (x:bitvec) (y:bitvec),
  ((length x) = (width (parallel_zh d e1))) ->
  ((length y) = (zh_range (parallel_zh d e1))) ->
  ((zh_ang_coeff (parallel_zh d e1) x y) =
   ((zh_ang_coeff d (hpart x (width d)) (hpart y (zh_range d))) +
    (zh_ang_coeff e1 (tpart x (width d)) (tpart y (zh_range d))))%Z).

Axiom correct_path_sum_zh :
  forall (g:circuit), (cont_zh g) ->
  correct_path_sum g
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (zh_ang y0 y1 y2)) g)
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (zh_ket y0 y1 y2)) g)
  (zh_range g).

Axiom correct_ps_ket_i :
  forall (g:circuit), (cont_zh g) ->
  correct_path_sum g
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (zh_ang y0 y1 y2)) g)
  (fun (x:bitvec) (y:bitvec) =>
   (make_bv
    ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
        (zh_ket_i y0 y1 y2 y3))
       g)
      x)
     y)
    (width g)))
  (zh_range g).

Axiom correct_ps_coeff :
  forall (g:circuit), (cont_zh g) ->
  correct_path_sum g
  (fun (x:bitvec) (y:bitvec) => (int_to_ang (zh_ang_coeff g x y) (width g)))
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (zh_ket y0 y1 y2)) g)
  (zh_range g).

Axiom correct_ps_neg_coeff :
  forall (g:circuit), (cont_zh g) ->
  correct_path_sum g
  (fun (x:bitvec) (y:bitvec) =>
   (int_to_ang (-(zh_ang_coeff_neg g x y))%Z (width g)))
  ((fun (y0:circuit) (y1:bitvec) (y2:bitvec) => (zh_ket y0 y1 y2)) g)
  (zh_range g).

Axiom correct_ps_coeff_ket_i :
  forall (g:circuit), (cont_zh g) ->
  correct_path_sum g
  (fun (x:bitvec) (y:bitvec) => (int_to_ang (zh_ang_coeff g x y) (width g)))
  (fun (x:bitvec) (y:bitvec) =>
   (make_bv
    ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
        (zh_ket_i y0 y1 y2 y3))
       g)
      x)
     y)
    (width g)))
  (zh_range g).

Axiom correct_ps_neg_coeff_ket_i :
  forall (g:circuit), (cont_zh g) ->
  correct_path_sum g
  (fun (x:bitvec) (y:bitvec) =>
   (int_to_ang (-(zh_ang_coeff_neg g x y))%Z (width g)))
  (fun (x:bitvec) (y:bitvec) =>
   (make_bv
    ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
        (zh_ket_i y0 y1 y2 y3))
       g)
      x)
     y)
    (width g)))
  (zh_range g).

Axiom pat_sem_unit_zh :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  ((pat_sem g x) =
   (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
    (ket_sum_l (n_bvs (zh_range g))
     (fun (y:bitvec) =>
      (infix_asdtdt (ang_exp (zh_ang g (ket_to_bv x) y))
       (bv_to_ket (zh_ket g (ket_to_bv x) y))))
     (width g)))).

Axiom pat_sem_unit_zh_ket_i :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  ((pat_sem g x) =
   (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
    (ket_sum_l (n_bvs (zh_range g))
     (fun (y:bitvec) =>
      (infix_asdtdt (ang_exp (zh_ang g (ket_to_bv x) y))
       (bv_to_ket
        (make_bv
         ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
             (zh_ket_i y0 y1 y2 y3))
            g)
           (ket_to_bv x))
          y)
         (width g)))))
     (width g)))).

Axiom pat_sem_unit_zh_coeff :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  ((pat_sem g x) =
   (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
    (ket_sum_l (n_bvs (zh_range g))
     (fun (y:bitvec) =>
      (infix_asdtdt
       (ang_exp (int_to_ang (zh_ang_coeff g (ket_to_bv x) y) (width g)))
       (bv_to_ket (zh_ket g (ket_to_bv x) y))))
     (width g)))).

Axiom pat_sem_unit_zh_coeff_neg :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  ((pat_sem g x) =
   (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
    (ket_sum_l (n_bvs (zh_range g))
     (fun (y:bitvec) =>
      (infix_asdtdt
       (ang_exp
        (int_to_ang (-(zh_ang_coeff_neg g (ket_to_bv x) y))%Z (width g)))
       (bv_to_ket (zh_ket g (ket_to_bv x) y))))
     (width g)))).

Axiom pat_sem_unit_zh_coeff_ket_i :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  ((pat_sem g x) =
   (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
    (ket_sum_l (n_bvs (zh_range g))
     (fun (y:bitvec) =>
      (infix_asdtdt
       (ang_exp (int_to_ang (zh_ang_coeff g (ket_to_bv x) y) (width g)))
       (bv_to_ket
        (make_bv
         ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
             (zh_ket_i y0 y1 y2 y3))
            g)
           (ket_to_bv x))
          y)
         (width g)))))
     (width g)))).

Axiom pat_sem_unit_zh_coeff_neg_ket_i :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  ((pat_sem g x) =
   (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
    (ket_sum_l (n_bvs (zh_range g))
     (fun (y:bitvec) =>
      (infix_asdtdt
       (ang_exp
        (int_to_ang (-(zh_ang_coeff_neg g (ket_to_bv x) y))%Z (width g)))
       (bv_to_ket
        (make_bv
         ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
             (zh_ket_i y0 y1 y2 y3))
            g)
           (ket_to_bv x))
          y)
         (width g)))))
     (width g)))).

Axiom sem_unit_zh :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  sem g x
  (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
   (ket_sum_l (n_bvs (zh_range g))
    (fun (y:bitvec) =>
     (infix_asdtdt (ang_exp (zh_ang g (ket_to_bv x) y))
      (bv_to_ket (zh_ket g (ket_to_bv x) y))))
    (width g))).

Axiom sem_unit_zh_ket_i :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  sem g x
  (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
   (ket_sum_l (n_bvs (zh_range g))
    (fun (y:bitvec) =>
     (infix_asdtdt (ang_exp (zh_ang g (ket_to_bv x) y))
      (bv_to_ket
       (make_bv
        ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
            (zh_ket_i y0 y1 y2 y3))
           g)
          (ket_to_bv x))
         y)
        (width g)))))
    (width g))).

Axiom sem_unit_zh_coeff :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  sem g x
  (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
   (ket_sum_l (n_bvs (zh_range g))
    (fun (y:bitvec) =>
     (infix_asdtdt
      (ang_exp (int_to_ang (zh_ang_coeff g (ket_to_bv x) y) (width g)))
      (bv_to_ket (zh_ket g (ket_to_bv x) y))))
    (width g))).

Axiom sem_unit_zh_coeff_neg :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  sem g x
  (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
   (ket_sum_l (n_bvs (zh_range g))
    (fun (y:bitvec) =>
     (infix_asdtdt
      (ang_exp
       (int_to_ang (-(zh_ang_coeff_neg g (ket_to_bv x) y))%Z (width g)))
      (bv_to_ket (zh_ket g (ket_to_bv x) y))))
    (width g))).

Axiom sem_unit_zh_coeff_ket_i :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  sem g x
  (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
   (ket_sum_l (n_bvs (zh_range g))
    (fun (y:bitvec) =>
     (infix_asdtdt
      (ang_exp (int_to_ang (zh_ang_coeff g (ket_to_bv x) y) (width g)))
      (bv_to_ket
       (make_bv
        ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
            (zh_ket_i y0 y1 y2 y3))
           g)
          (ket_to_bv x))
         y)
        (width g)))))
    (width g))).

Axiom sem_unit_zh_coeff_neg_ket_i :
  forall (g:circuit) (x:matrix t), (is_a_ket_basis_elt x) ->
  (is_a_ket_l x (width g)) -> (cont_zh g) ->
  sem g x
  (infix_asdtdt (pow_inv_sqrt_2 (zh_range g))
   (ket_sum_l (n_bvs (zh_range g))
    (fun (y:bitvec) =>
     (infix_asdtdt
      (ang_exp
       (int_to_ang (-(zh_ang_coeff_neg g (ket_to_bv x) y))%Z (width g)))
      (bv_to_ket
       (make_bv
        ((((fun (y0:circuit) (y1:bitvec) (y2:bitvec) (y3:Z) =>
            (zh_ket_i y0 y1 y2 y3))
           g)
          (ket_to_bv x))
         y)
        (width g)))))
    (width g))).

Parameter cascade_cont_rz: Z -> Z -> Z -> Z -> Z -> circuit.

Axiom cascade_cont_rz_def :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z -> (l = 0%Z) ->
  ((cascade_cont_rz first_k first_c t1 l n) =
   (c_rzp_zh first_k first_c t1 n)).

Axiom cascade_cont_rz_def1 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z -> ~ (l = 0%Z) ->
  ((cascade_cont_rz first_k first_c t1 l n) =
   (sequence_zh (cascade_cont_rz first_k first_c t1 (l - 1%Z)%Z n)
    (c_rzp_zh (first_k + l)%Z (first_c + l)%Z t1 n))).

Axiom cascade_cont_rz_def2 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> (l = 0%Z) ->
  ((cascade_cont_rz first_k first_c t1 l n) =
   (c_rzp_zh first_k first_c t1 n)).

Axiom cascade_cont_rz_def3 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> ~ (l = 0%Z) ->
  ((cascade_cont_rz first_k first_c t1 l n) =
   (sequence_zh (cascade_cont_rz first_k first_c t1 (l - 1%Z)%Z n)
    (c_rzp_zh (first_k + l)%Z (first_c + l)%Z t1 n))).

Axiom cascade_cont_rz_spec :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((width (cascade_cont_rz first_k first_c t1 l n)) = n).

Axiom cascade_cont_rz_spec1 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((ancillas (cascade_cont_rz first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_spec2 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((size (cascade_cont_rz first_k first_c t1 l n)) <=
   ((cont_size * 2%Z)%Z * (l + 1%Z)%Z)%Z)%Z.

Axiom cascade_cont_rz_spec3 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  cont_zh (cascade_cont_rz first_k first_c t1 l n).

Axiom cascade_cont_rz_spec4 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((zh_range (cascade_cont_rz first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_spec5 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff (cascade_cont_rz first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) * ((getbv x) (first_c + k)%Z))%Z *
      (power_ 2%Z (n - (k + first_k)%Z)%Z))%Z)
    0%Z (l + 1%Z)%Z)).

Axiom cascade_cont_rz_spec6 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff (cascade_cont_rz first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) *
       ((getbv x) (first_c + (((k - n)%Z + l)%Z + 1%Z)%Z)%Z))%Z
      * (power_ 2%Z (((((n + n)%Z - k)%Z - l)%Z - 1%Z)%Z - first_k)%Z))%Z)
    (n - (l + 1%Z)%Z)%Z n)).

Axiom cascade_cont_rz_spec7 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ket (cascade_cont_rz first_k first_c t1 l n) x y) = x).

Axiom cascade_cont_rz_spec8 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (cascade_cont_rz first_k first_c t1 l n) x y i) = ((getbv x) i)).

Axiom cascade_cont_rz_spec9 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((width (cascade_cont_rz first_k first_c t1 l n)) = n).

Axiom cascade_cont_rz_spec10 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((ancillas (cascade_cont_rz first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_spec11 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((size (cascade_cont_rz first_k first_c t1 l n)) <=
   ((cont_size * 2%Z)%Z * (l + 1%Z)%Z)%Z)%Z.

Axiom cascade_cont_rz_spec12 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  cont_zh (cascade_cont_rz first_k first_c t1 l n).

Axiom cascade_cont_rz_spec13 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((zh_range (cascade_cont_rz first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_spec14 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff (cascade_cont_rz first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) * ((getbv x) (first_c + k)%Z))%Z *
      (power_ 2%Z (n - (k + first_k)%Z)%Z))%Z)
    0%Z (l + 1%Z)%Z)).

Axiom cascade_cont_rz_spec15 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff (cascade_cont_rz first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) *
       ((getbv x) (first_c + (((k - n)%Z + l)%Z + 1%Z)%Z)%Z))%Z
      * (power_ 2%Z (((((n + n)%Z - k)%Z - l)%Z - 1%Z)%Z - first_k)%Z))%Z)
    (n - (l + 1%Z)%Z)%Z n)).

Axiom cascade_cont_rz_spec16 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ket (cascade_cont_rz first_k first_c t1 l n) x y) = x).

Axiom cascade_cont_rz_spec17 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (cascade_cont_rz first_k first_c t1 l n) x y i) = ((getbv x) i)).

Parameter cascade_cont_rz_neg: Z -> Z -> Z -> Z -> Z -> circuit.

Axiom cascade_cont_rz_neg_def :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z -> (l = 0%Z) ->
  ((cascade_cont_rz_neg first_k first_c t1 l n) =
   (c_rzp_zh (-first_k)%Z first_c t1 n)).

Axiom cascade_cont_rz_neg_def1 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z -> ~ (l = 0%Z) ->
  ((cascade_cont_rz_neg first_k first_c t1 l n) =
   (sequence_zh (cascade_cont_rz_neg first_k first_c t1 (l - 1%Z)%Z n)
    (c_rzp_zh (-(first_k + l)%Z)%Z (first_c + l)%Z t1 n))).

Axiom cascade_cont_rz_neg_def2 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> (l = 0%Z) ->
  ((cascade_cont_rz_neg first_k first_c t1 l n) =
   (c_rzp_zh (-first_k)%Z first_c t1 n)).

Axiom cascade_cont_rz_neg_def3 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> ~ (l = 0%Z) ->
  ((cascade_cont_rz_neg first_k first_c t1 l n) =
   (sequence_zh (cascade_cont_rz_neg first_k first_c t1 (l - 1%Z)%Z n)
    (c_rzp_zh (-(first_k + l)%Z)%Z (first_c + l)%Z t1 n))).

Axiom cascade_cont_rz_neg_spec :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((width (cascade_cont_rz_neg first_k first_c t1 l n)) = n).

Axiom cascade_cont_rz_neg_spec1 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((ancillas (cascade_cont_rz_neg first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_neg_spec2 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((size (cascade_cont_rz_neg first_k first_c t1 l n)) <=
   ((cont_size * 2%Z)%Z * (l + 1%Z)%Z)%Z)%Z.

Axiom cascade_cont_rz_neg_spec3 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  cont_zh (cascade_cont_rz_neg first_k first_c t1 l n).

Axiom cascade_cont_rz_neg_spec4 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  ((zh_range (cascade_cont_rz_neg first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_neg_spec5 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff_neg (cascade_cont_rz_neg first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) * ((getbv x) (first_c + k)%Z))%Z *
      (power_ 2%Z (n - (k + first_k)%Z)%Z))%Z)
    0%Z (l + 1%Z)%Z)).

Axiom cascade_cont_rz_neg_spec6 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff_neg (cascade_cont_rz_neg first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) *
       ((getbv x) (first_c + (((k - n)%Z + l)%Z + 1%Z)%Z)%Z))%Z
      * (power_ 2%Z (((((n + n)%Z - k)%Z - l)%Z - 1%Z)%Z - first_k)%Z))%Z)
    (n - (l + 1%Z)%Z)%Z n)).

Axiom cascade_cont_rz_neg_spec7 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang (cascade_cont_rz_neg first_k first_c t1 l n) x y) =
   (int_to_ang
    (-(ind_isum
       (fun (k:Z) =>
        ((((getbv x) t1) *
          ((getbv x) (first_c + (((k - n)%Z + l)%Z + 1%Z)%Z)%Z))%Z
         * (power_ 2%Z (((((n + n)%Z - k)%Z - l)%Z - 1%Z)%Z - first_k)%Z))%Z)
       (n - (l + 1%Z)%Z)%Z n))%Z
    n)).

Axiom cascade_cont_rz_neg_spec8 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ket (cascade_cont_rz_neg first_k first_c t1 l n) x y) = x).

Axiom cascade_cont_rz_neg_spec9 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> ~ (t1 <= (first_c + l)%Z)%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (cascade_cont_rz_neg first_k first_c t1 l n) x y i) =
   ((getbv x) i)).

Axiom cascade_cont_rz_neg_spec10 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((width (cascade_cont_rz_neg first_k first_c t1 l n)) = n).

Axiom cascade_cont_rz_neg_spec11 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((ancillas (cascade_cont_rz_neg first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_neg_spec12 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((size (cascade_cont_rz_neg first_k first_c t1 l n)) <=
   ((cont_size * 2%Z)%Z * (l + 1%Z)%Z)%Z)%Z.

Axiom cascade_cont_rz_neg_spec13 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  cont_zh (cascade_cont_rz_neg first_k first_c t1 l n).

Axiom cascade_cont_rz_neg_spec14 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z ->
  ((zh_range (cascade_cont_rz_neg first_k first_c t1 l n)) = 0%Z).

Axiom cascade_cont_rz_neg_spec15 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff_neg (cascade_cont_rz_neg first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) * ((getbv x) (first_c + k)%Z))%Z *
      (power_ 2%Z (n - (k + first_k)%Z)%Z))%Z)
    0%Z (l + 1%Z)%Z)).

Axiom cascade_cont_rz_neg_spec16 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff_neg (cascade_cont_rz_neg first_k first_c t1 l n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) *
       ((getbv x) (first_c + (((k - n)%Z + l)%Z + 1%Z)%Z)%Z))%Z
      * (power_ 2%Z (((((n + n)%Z - k)%Z - l)%Z - 1%Z)%Z - first_k)%Z))%Z)
    (n - (l + 1%Z)%Z)%Z n)).

Axiom cascade_cont_rz_neg_spec17 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang (cascade_cont_rz_neg first_k first_c t1 l n) x y) =
   (int_to_ang
    (-(ind_isum
       (fun (k:Z) =>
        ((((getbv x) t1) *
          ((getbv x) (first_c + (((k - n)%Z + l)%Z + 1%Z)%Z)%Z))%Z
         * (power_ 2%Z (((((n + n)%Z - k)%Z - l)%Z - 1%Z)%Z - first_k)%Z))%Z)
       (n - (l + 1%Z)%Z)%Z n))%Z
    n)).

Axiom cascade_cont_rz_neg_spec18 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ket (cascade_cont_rz_neg first_k first_c t1 l n) x y) = x).

Axiom cascade_cont_rz_neg_spec19 :
  forall (first_k:Z) (first_c:Z) (t1:Z) (l:Z) (n:Z),
  ((0%Z <= l)%Z /\ (l < n)%Z) -> ((0%Z <= first_c)%Z /\ (first_c < n)%Z) ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> ((first_c + l)%Z < n)%Z ->
  (0%Z <= first_k)%Z -> (t1 < first_c)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = 0%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (cascade_cont_rz_neg first_k first_c t1 l n) x y i) =
   ((getbv x) i)).

Axiom set_had_zh_ang :
  forall (a:Z) (b:Z) (c:Z) (t1:Z) (n:Z) (x:bitvec) (y:bitvec),
  (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (a = ((getbv x) t1)) ->
  (b = ((getbv y) 0%Z)) -> (c = (n - 1%Z)%Z) -> ((length x) = n) ->
  ((length y) = 1%Z) ->
  ((zh_ang (had_zh t1 n) x y) =
   (int_to_ang (-((a * b)%Z * (power_ 2%Z c))%Z)%Z n)).

Axiom set_had_zh_ang1 :
  forall (a:Z) (b:Z) (c:Z) (t1:Z) (n:Z) (x:bitvec) (y:bitvec),
  (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (a = ((getbv x) t1)) ->
  (b = ((getbv y) 0%Z)) -> (c = (n - 1%Z)%Z) -> ((length x) = n) ->
  ((length y) = 1%Z) ->
  ((zh_ang (had_zh t1 n) x y) =
   (int_to_ang ((a * b)%Z * (power_ 2%Z c))%Z n)).

Axiom set_had_zh_ang2 :
  forall (a:Z) (b:Z) (c:Z) (t1:Z) (n:Z) (x:bitvec) (y:bitvec),
  (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (a = ((getbv x) t1)) ->
  (b = ((getbv y) 0%Z)) -> (c = (n - 1%Z)%Z) -> ((length x) = n) ->
  ((length y) = 1%Z) ->
  ((zh_ang_coeff_neg (had_zh t1 n) x y) = ((a * b)%Z * (power_ 2%Z c))%Z).

Axiom set_had_zh_ang3 :
  forall (a:Z) (b:Z) (c:Z) (t1:Z) (n:Z) (x:bitvec) (y:bitvec),
  (n >= 0%Z)%Z -> ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (a = ((getbv x) t1)) ->
  (b = ((getbv y) 0%Z)) -> (c = (n - 1%Z)%Z) -> ((length x) = n) ->
  ((length y) = 1%Z) ->
  ((zh_ang_coeff (had_zh t1 n) x y) = ((a * b)%Z * (power_ 2%Z c))%Z).

Parameter had_seq_zh: circuit -> Z -> Z -> circuit.

Axiom had_seq_zh_def :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((had_seq_zh g t1 n) = (sequence_zh (had_zh t1 n) g)).

Axiom had_seq_zh_spec :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  cont_zh (had_seq_zh g t1 n).

Axiom had_seq_zh_spec1 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((width (had_seq_zh g t1 n)) = n).

Axiom had_seq_zh_spec2 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((size (had_seq_zh g t1 n)) = (1%Z + (size g))%Z).

Axiom had_seq_zh_spec3 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((ancillas (had_seq_zh g t1 n)) = (ancillas g)).

Axiom had_seq_zh_spec4 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range (had_seq_zh g t1 n)) = ((zh_range g) + 1%Z)%Z).

Parameter fc19: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def19 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc19 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc19 t1 x y) i) = ((getbv x) i))).

Axiom had_seq_zh_spec5 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) ->
  ((zh_ang (had_seq_zh g t1 n) x y) =
   (ang_add (int_to_ang (((getbv x) t1) * ((getbv y) 0%Z))%Z 1%Z)
    (zh_ang g (make_bv (fc19 t1 x y) n) (tpart y 1%Z)))).

Parameter fc20: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def20 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc20 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc20 t1 x y) i) = ((getbv x) i))).

Axiom had_seq_zh_spec6 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) ->
  ((zh_ang_coeff_neg (had_seq_zh g t1 n) x y) =
   (((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z +
    (zh_ang_coeff_neg g (make_bv (fc20 t1 x y) n) (tpart y 1%Z)))%Z).

Parameter fc21: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def21 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc21 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc21 t1 x y) i) = ((getbv x) i))).

Axiom had_seq_zh_spec7 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) ->
  ((zh_ang_coeff (had_seq_zh g t1 n) x y) =
   (((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z +
    (zh_ang_coeff g (make_bv (fc21 t1 x y) n) (tpart y 1%Z)))%Z).

Parameter fc22: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def22 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc22 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc22 t1 x y) i) = ((getbv x) i))).

Axiom had_seq_zh_spec8 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (had_seq_zh g t1 n) x y i) =
   (zh_ket_i g (make_bv (fc22 t1 x y) n) (tpart y 1%Z) i)).

Parameter had_seq_diag_zh: circuit -> Z -> Z -> circuit.

Axiom had_seq_diag_zh_def :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  ((had_seq_diag_zh g t1 n) = (had_seq_zh g t1 n)).

Axiom had_seq_diag_zh_spec :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  cont_zh (had_seq_diag_zh g t1 n).

Axiom had_seq_diag_zh_spec1 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  ((size (had_seq_diag_zh g t1 n)) = (1%Z + (size g))%Z).

Axiom had_seq_diag_zh_spec2 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  ((ancillas (had_seq_diag_zh g t1 n)) = (ancillas g)).

Axiom had_seq_diag_zh_spec3 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  ((width (had_seq_diag_zh g t1 n)) = n).

Axiom had_seq_diag_zh_spec4 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  ((zh_range (had_seq_diag_zh g t1 n)) = 1%Z).

Parameter fc23: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def23 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc23 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc23 t1 x y) i) = ((getbv x) i))).

Axiom had_seq_diag_zh_spec5 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) ->
  ((zh_ang (had_seq_diag_zh g t1 n) x y) =
   (ang_add (int_to_ang (((getbv x) t1) * ((getbv y) 0%Z))%Z 1%Z)
    (zh_ang g (make_bv (fc23 t1 x y) n) (tpart y 1%Z)))).

Parameter fc24: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def24 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc24 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc24 t1 x y) i) = ((getbv x) i))).

Axiom had_seq_diag_zh_spec6 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) ->
  ((zh_ang_coeff (had_seq_diag_zh g t1 n) x y) =
   (((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z +
    (zh_ang_coeff g (make_bv (fc24 t1 x y) n) (tpart y 1%Z)))%Z).

Parameter fc25: Z -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def25 :
  forall (t1:Z) (x:bitvec) (y:bitvec) (i:Z),
  ((i = t1) -> (((fc25 t1 x y) i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> (((fc25 t1 x y) i) = ((getbv x) i))).

Axiom had_seq_diag_zh_spec7 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) ->
  ((zh_ang_coeff_neg (had_seq_diag_zh g t1 n) x y) =
   (((((getbv x) t1) * ((getbv y) 0%Z))%Z * (power_ 2%Z (n - 1%Z)%Z))%Z +
    (zh_ang_coeff_neg g (make_bv (fc25 t1 x y) n) (tpart y 1%Z)))%Z).

Axiom had_seq_diag_zh_spec8 :
  forall (g:circuit) (t1:Z) (n:Z), (n >= 0%Z)%Z ->
  ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (cont_zh g) -> ((width g) = n) ->
  ((zh_range g) = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = n) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < n)%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) ->
  ((length y) = ((zh_range g) + 1%Z)%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((i = t1) -> ((zh_ket_i (had_seq_diag_zh g t1 n) x y i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> ((zh_ket_i (had_seq_diag_zh g t1 n) x y i) = ((getbv x) i))).

Parameter seq_diag_zh: circuit -> circuit -> circuit.

Axiom seq_diag_zh_def :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  ((seq_diag_zh g g') = (sequence_zh g g')).

Axiom seq_diag_zh_spec :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  cont_zh (seq_diag_zh g g').

Axiom seq_diag_zh_spec1 :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  ((zh_range (seq_diag_zh g g')) = 0%Z).

Axiom seq_diag_zh_spec2 :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  ((width (seq_diag_zh g g')) = (width g)).

Axiom seq_diag_zh_spec3 :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = (width g)) ->
  ((length y) = 0%Z) ->
  ((zh_ang (seq_diag_zh g g') x y) =
   (ang_add (zh_ang g x y) (zh_ang g' x y))).

Axiom seq_diag_zh_spec4 :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = (width g)) ->
  ((length y) = 0%Z) ->
  ((zh_ang_coeff (seq_diag_zh g g') x y) =
   ((zh_ang_coeff g x y) + (zh_ang_coeff g' x y))%Z).

Axiom seq_diag_zh_spec5 :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = (width g)) ->
  ((length y) = 0%Z) ->
  ((zh_ang_coeff_neg (seq_diag_zh g g') x y) =
   ((zh_ang_coeff_neg g x y) + (zh_ang_coeff_neg g' x y))%Z).

Axiom seq_diag_zh_spec6 :
  forall (g:circuit) (g':circuit), (cont_zh g) -> (cont_zh g') ->
  ((width g) = (width g')) -> ((zh_range g) = 0%Z) ->
  ((zh_range g') = 0%Z) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g x y i) = ((getbv x) i))) ->
  (forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (width g)) ->
   ((length y) = 0%Z) -> ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
   ((zh_ket_i g' x y i) = ((getbv x) i))) ->
  forall (x:bitvec) (y:bitvec), ((length x) = (width g)) ->
  ((length y) = 0%Z) -> forall (i:Z), ((0%Z <= i)%Z /\ (i < (width g))%Z) ->
  ((zh_ket_i (seq_diag_zh g g') x y i) = ((getbv x) i)).

Parameter cascade_cont_qft: Z -> Z -> circuit.

Axiom cascade_cont_qft_def :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((cascade_cont_qft t1 n) =
   (cascade_cont_rz_neg 2%Z (t1 + 1%Z)%Z t1 (n - (t1 + 2%Z)%Z)%Z n)).

Axiom cascade_cont_qft_spec :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((width (cascade_cont_qft t1 n)) = n).

Axiom cascade_cont_qft_spec1 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((size (cascade_cont_qft t1 n)) <=
   ((cont_size * 2%Z)%Z * ((n - t1)%Z - 1%Z)%Z)%Z)%Z.

Axiom cascade_cont_qft_spec2 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((ancillas (cascade_cont_qft t1 n)) = 0%Z).

Axiom cascade_cont_qft_spec3 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  cont_zh (cascade_cont_qft t1 n).

Axiom cascade_cont_qft_spec4 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((zh_range (cascade_cont_qft t1 n)) = 0%Z).

Axiom cascade_cont_qft_spec5 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff_neg (cascade_cont_qft t1 n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) * ((getbv x) k))%Z *
      (power_ 2%Z (((n - k)%Z - 1%Z)%Z + t1)%Z))%Z)
    (t1 + 1%Z)%Z n)).

Axiom cascade_cont_qft_spec6 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (cascade_cont_qft t1 n) x y i) = ((getbv x) i)).

Parameter qft_rev_line: Z -> Z -> circuit.

Axiom qft_rev_line_def :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (t1 = (n - 1%Z)%Z) ->
  ((qft_rev_line t1 n) = (had_zh t1 n)).

Axiom qft_rev_line_def1 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = (n - 1%Z)%Z) ->
  ((qft_rev_line t1 n) = (had_seq_diag_zh (cascade_cont_qft t1 n) t1 n)).

Axiom qft_rev_line_spec :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((size (qft_rev_line t1 n)) <= ((cont_size * 2%Z)%Z * n)%Z)%Z.

Axiom qft_rev_line_spec1 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((ancillas (qft_rev_line t1 n)) = 0%Z).

Axiom qft_rev_line_spec2 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((width (qft_rev_line t1 n)) = n).

Axiom qft_rev_line_spec3 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  cont_zh (qft_rev_line t1 n).

Axiom qft_rev_line_spec4 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((zh_range (qft_rev_line t1 n)) = 1%Z).

Axiom qft_rev_line_spec5 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang_coeff_neg (qft_rev_line t1 n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) k) * ((getbv y) 0%Z))%Z *
      (power_ 2%Z (((n - k)%Z - 1%Z)%Z + t1)%Z))%Z)
    t1 n)).

Axiom qft_rev_line_spec6 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((i = t1) -> ((zh_ket_i (qft_rev_line t1 n) x y i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> ((zh_ket_i (qft_rev_line t1 n) x y i) = ((getbv x) i))).

Parameter qft_rev: Z -> circuit.

Axiom qft_rev_spec :
  forall (n:Z), (0%Z < n)%Z ->
  ((size (qft_rev n)) <= (polysquare n (2%Z * cont_size)%Z 0%Z 0%Z))%Z.

Axiom qft_rev_spec1 :
  forall (n:Z), (0%Z < n)%Z -> ((ancillas (qft_rev n)) = 0%Z).

Axiom qft_rev_spec2 :
  forall (n:Z), (0%Z < n)%Z -> ((ancillas (qft_rev n)) = 0%Z).

Axiom qft_rev_spec3 : forall (n:Z), (0%Z < n)%Z -> ((width (qft_rev n)) = n).

Axiom qft_rev_spec4 : forall (n:Z), (0%Z < n)%Z -> cont_zh (qft_rev n).

Axiom qft_rev_spec5 :
  forall (n:Z), (0%Z < n)%Z -> ((zh_range (qft_rev n)) = n).

Axiom qft_rev_spec6 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((zh_ang_coeff_neg (qft_rev n) x y) =
   (ind_isum
    (fun (l:Z) =>
     (ind_isum
      (fun (k:Z) =>
       ((((getbv x) k) * ((getbv y) l))%Z *
        (power_ 2%Z (((n - k)%Z - 1%Z)%Z + l)%Z))%Z)
      l n))
    0%Z n)).

Axiom qft_rev_spec7 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((zh_ang (qft_rev n) x y) =
   (int_to_ang (-((bv_to_int x) * (bv_to_int (bv_inversion y)))%Z)%Z n)).

Axiom qft_rev_spec8 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((zh_ang (qft_rev n) x y) =
   (real_to_ang
    (infix_asdt
     (infix_asdt (i_to_t (bv_to_int x))
      (i_to_t (-(bv_to_int (bv_inversion y)))%Z))
     (pow_inv_2 n)))).

Axiom qft_rev_spec9 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (qft_rev n) x y i) = ((getbv y) i)).

Parameter qft_rev_coeff: bitvec -> bitvec -> Z -> t.

Axiom qft_rev_coeff_def :
  forall (x:bitvec) (y:bitvec) (n:Z), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) ->
  ((qft_rev_coeff x y n) =
   (ang_exp
    (real_to_ang
     (infix_asdt
      (infix_asdt (i_to_t (-(bv_to_int x))%Z)
       (i_to_t (bv_to_int (bv_inversion y))))
      (pow_inv_2 n))))).

Axiom qft_rev_coeff_spec :
  forall (x:bitvec) (y:bitvec) (n:Z), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) ->
  ((qft_rev_coeff x y n) = (ang_exp (zh_ang (qft_rev n) x y))).

Parameter int_qft_rev_coeff: Z -> Z -> Z -> t.

Axiom int_qft_rev_coeff_def :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((int_qft_rev_coeff i j n) =
   (ang_exp
    (real_to_ang
     (infix_asdt
      (infix_asdt (i_to_t (int.EuclideanDivision.mod1 (-i)%Z (power_ 2%Z n)))
       (i_to_t
        (int_bit_inversion (int.EuclideanDivision.mod1 j (power_ 2%Z n)) n)))
      (pow_inv_2 n))))).

Axiom int_qft_rev_coeff_spec :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((int_qft_rev_coeff i j n) =
   (qft_rev_coeff (int_to_bv (int.EuclideanDivision.mod1 i (power_ 2%Z n)) n)
    (int_to_bv (int.EuclideanDivision.mod1 j (power_ 2%Z n)) n) n)).

Axiom qft_rev_ket :
  forall (x:bitvec) (y:bitvec) (n:Z), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) -> ((zh_ket (qft_rev n) x y) = y).

Axiom sem_rev_qft_unit :
  forall (n:Z), (0%Z < n)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) ->
  sem (qft_rev n) x
  (infix_asdtdt (pow_inv_sqrt_2 n)
   (ket_sum_l (n_bvs n)
    (fun (y:bitvec) =>
     (infix_asdtdt (qft_rev_coeff (ket_to_bv x) y n) (bv_to_ket y)))
    n)).

Axiom pat_sem_rev_qft_unit :
  forall (n:Z), (0%Z < n)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) ->
  ((pat_sem (qft_rev n) x) =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) =>
      (infix_asdtdt (qft_rev_coeff (ket_to_bv x) y n) (bv_to_ket y)))
     n))).

Axiom pat_sem_rev_qft_ket :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((pat_sem (qft_rev n) (ket n i)) =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) =>
      (infix_asdtdt (qft_rev_coeff (int_to_bv i n) y n) (bv_to_ket y)))
     n))).

Axiom pat_sem_rev_qft_ket_ind :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((pat_sem (qft_rev n) (ket n i)) =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) =>
      (infix_asdtdt (int_qft_rev_coeff i (bv_to_int y) n) (bv_to_ket y)))
     n))).

Axiom pat_sem_rev_qft_bv :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  ((pat_sem (qft_rev n) (bv_to_ket x)) =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) => (infix_asdtdt (qft_rev_coeff x y n) (bv_to_ket y)))
     n))).

Axiom sem_rev_qft_bv :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  sem (qft_rev n) (bv_to_ket x)
  (infix_asdtdt (pow_inv_sqrt_2 n)
   (ket_sum_l (n_bvs n)
    (fun (y:bitvec) => (infix_asdtdt (qft_rev_coeff x y n) (bv_to_ket y))) n)).

Parameter cascade_cont_qft1: Z -> Z -> circuit.

Axiom cascade_cont_qft_def1 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((cascade_cont_qft1 t1 n) =
   (cascade_cont_rz 2%Z (t1 + 1%Z)%Z t1 (n - (t1 + 2%Z)%Z)%Z n)).

Axiom cascade_cont_qft_spec7 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((width (cascade_cont_qft1 t1 n)) = n).

Axiom cascade_cont_qft_spec8 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((size (cascade_cont_qft1 t1 n)) <=
   ((cont_size * 2%Z)%Z * ((n - t1)%Z - 1%Z)%Z)%Z)%Z.

Axiom cascade_cont_qft_spec9 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((ancillas (cascade_cont_qft1 t1 n)) = 0%Z).

Axiom cascade_cont_qft_spec10 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  cont_zh (cascade_cont_qft1 t1 n).

Axiom cascade_cont_qft_spec11 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  ((zh_range (cascade_cont_qft1 t1 n)) = 0%Z).

Axiom cascade_cont_qft_spec12 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  ((zh_ang_coeff (cascade_cont_qft1 t1 n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) t1) * ((getbv x) k))%Z *
      (power_ 2%Z (((n - k)%Z - 1%Z)%Z + t1)%Z))%Z)
    (t1 + 1%Z)%Z n)).

Axiom cascade_cont_qft_spec13 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < (n - 1%Z)%Z)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 0%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((zh_ket_i (cascade_cont_qft1 t1 n) x y i) = ((getbv x) i)).

Parameter qft_line: Z -> Z -> circuit.

Axiom qft_line_def :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) -> (t1 = (n - 1%Z)%Z) ->
  ((qft_line t1 n) = (had_zh t1 n)).

Axiom qft_line_def1 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ~ (t1 = (n - 1%Z)%Z) ->
  ((qft_line t1 n) = (had_seq_diag_zh (cascade_cont_qft1 t1 n) t1 n)).

Axiom qft_line_spec :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((width (qft_line t1 n)) = n).

Axiom qft_line_spec1 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((size (qft_line t1 n)) <= ((cont_size * 2%Z)%Z * n)%Z)%Z.

Axiom qft_line_spec2 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((ancillas (qft_line t1 n)) = 0%Z).

Axiom qft_line_spec3 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  cont_zh (qft_line t1 n).

Axiom qft_line_spec4 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  ((zh_range (qft_line t1 n)) = 1%Z).

Axiom qft_line_spec5 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  ((zh_ang_coeff (qft_line t1 n) x y) =
   (ind_isum
    (fun (k:Z) =>
     ((((getbv x) k) * ((getbv y) 0%Z))%Z *
      (power_ 2%Z (((n - k)%Z - 1%Z)%Z + t1)%Z))%Z)
    t1 n)).

Axiom qft_line_spec6 :
  forall (t1:Z) (n:Z), ((0%Z <= t1)%Z /\ (t1 < n)%Z) ->
  forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = 1%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
  ((i = t1) -> ((zh_ket_i (qft_line t1 n) x y i) = ((getbv y) 0%Z))) /\
  (~ (i = t1) -> ((zh_ket_i (qft_line t1 n) x y i) = ((getbv x) i))).

Parameter qft: Z -> circuit.

Axiom qft_spec :
  forall (n:Z), (0%Z < n)%Z ->
  ((size (qft n)) <= (polysquare n (cont_size * 2%Z)%Z 0%Z 0%Z))%Z.

Axiom qft_spec1 : forall (n:Z), (0%Z < n)%Z -> ((ancillas (qft n)) = 0%Z).

Axiom qft_spec2 : forall (n:Z), (0%Z < n)%Z -> ((width (qft n)) = n).

Axiom qft_spec3 : forall (n:Z), (0%Z < n)%Z -> cont_zh (qft n).

Axiom qft_spec4 : forall (n:Z), (0%Z < n)%Z -> ((zh_range (qft n)) = n).

Axiom qft_spec5 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((zh_ang_coeff (qft n) x y) =
   (ind_isum
    (fun (l:Z) =>
     (ind_isum
      (fun (k:Z) =>
       ((((getbv x) k) * ((getbv y) l))%Z *
        (power_ 2%Z (((n - k)%Z - 1%Z)%Z + l)%Z))%Z)
      l n))
    0%Z n)).

Axiom qft_spec6 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((zh_ang (qft n) x y) =
   (int_to_ang ((bv_to_int x) * (bv_to_int (bv_inversion y)))%Z n)).

Axiom qft_spec7 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) ->
  ((zh_ang (qft n) x y) =
   (real_to_ang
    (infix_asdt
     (infix_asdt (i_to_t (bv_to_int x))
      (i_to_t (bv_to_int (bv_inversion y))))
     (pow_inv_2 n)))).

Axiom qft_spec8 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) -> ((zh_ket_i (qft n) x y i) = ((getbv y) i)).

Axiom qft_spec9 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec) (y:bitvec),
  ((length x) = n) -> ((length y) = n) -> ((zh_ket (qft n) x y) = y).

Parameter qft_coeff: bitvec -> bitvec -> Z -> t.

Axiom qft_coeff_def :
  forall (x:bitvec) (y:bitvec) (n:Z), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) ->
  ((qft_coeff x y n) =
   (ang_exp
    (real_to_ang
     (infix_asdt
      (infix_asdt (i_to_t (bv_to_int x))
       (i_to_t (bv_to_int (bv_inversion y))))
      (pow_inv_2 n))))).

Axiom qft_coeff_spec :
  forall (x:bitvec) (y:bitvec) (n:Z), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) -> ((qft_coeff x y n) = (ang_exp (zh_ang (qft n) x y))).

Parameter int_qft_coeff: Z -> Z -> Z -> t.

Axiom int_qft_coeff_def :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((int_qft_coeff i j n) =
   (ang_exp
    (real_to_ang
     (infix_asdt
      (infix_asdt (i_to_t (int.EuclideanDivision.mod1 i (power_ 2%Z n)))
       (i_to_t
        (int_bit_inversion (int.EuclideanDivision.mod1 j (power_ 2%Z n)) n)))
      (pow_inv_2 n))))).

Axiom int_qft_coeff_spec :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((int_qft_coeff i j n) =
   (qft_coeff (int_to_bv (int.EuclideanDivision.mod1 i (power_ 2%Z n)) n)
    (int_to_bv (int.EuclideanDivision.mod1 j (power_ 2%Z n)) n) n)).

Parameter int_qft_coeff_as_mod: Z -> Z -> Z -> unit.

Axiom int_qft_coeff_as_mod_def :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((int_qft_coeff_as_mod i j n) = tt).

Axiom int_qft_coeff_as_mod_spec :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((int_qft_coeff i j n) =
   (int_qft_coeff (int.EuclideanDivision.mod1 i (power_ 2%Z n)) j n)).

Parameter int_qft_coeff_eq: Z -> Z -> Z -> Z -> Z -> Z -> unit.

Axiom int_qft_coeff_eq_def :
  forall (i:Z) (i':Z) (j:Z) (j':Z) (n:Z) (n':Z), (n = n') -> (0%Z < n)%Z ->
  ((int.EuclideanDivision.mod1 i (power_ 2%Z n)) =
   (int.EuclideanDivision.mod1 i' (power_ 2%Z n))) ->
  ((int.EuclideanDivision.mod1 j (power_ 2%Z n)) =
   (int.EuclideanDivision.mod1 j' (power_ 2%Z n))) ->
  ((int_qft_coeff_eq i i' j j' n n') = tt).

Axiom int_qft_coeff_eq_spec :
  forall (i:Z) (i':Z) (j:Z) (j':Z) (n:Z) (n':Z), (n = n') -> (0%Z < n)%Z ->
  ((int.EuclideanDivision.mod1 i (power_ 2%Z n)) =
   (int.EuclideanDivision.mod1 i' (power_ 2%Z n))) ->
  ((int.EuclideanDivision.mod1 j (power_ 2%Z n)) =
   (int.EuclideanDivision.mod1 j' (power_ 2%Z n))) ->
  ((int_qft_coeff i j n) = (int_qft_coeff i' j' n)).

Parameter apply_qft: Z -> Z -> matrix t.

Axiom apply_qft_def :
  forall (n:Z) (i:Z), (0%Z < n)%Z ->
  ((apply_qft n i) =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) =>
      (infix_asdtdt (int_qft_coeff i (bv_to_int y) n) (bv_to_ket y)))
     n))).

Axiom apply_qft_spec :
  forall (n:Z) (i:Z), (0%Z < n)%Z -> is_a_ket_l (apply_qft n i) n.

Axiom apply_qft_spec1 :
  forall (n:Z) (i:Z), (0%Z < n)%Z ->
  ((apply_qft n i) =
   (pat_sem (qft n) (ket n (int.EuclideanDivision.mod1 i (power_ 2%Z n))))).

Axiom apply_qft_equiv :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((int.EuclideanDivision.mod1 i (power_ 2%Z n)) =
   (int.EuclideanDivision.mod1 j (power_ 2%Z n))) ->
  ((apply_qft n i) = (apply_qft n j)).

Axiom qft_rev_qft_int :
  forall (n:Z) (i:Z), (0%Z < n)%Z ->
  ((pat_sem (qft_rev n) (apply_qft n i)) =
   (ket n (int.EuclideanDivision.mod1 i (power_ 2%Z n)))).

Axiom apply_qft_eq :
  forall (n:Z) (n':Z) (i:Z) (i':Z), (0%Z < n)%Z -> (n = n') ->
  ((int.EuclideanDivision.mod1 i (power_ 2%Z n)) =
   (int.EuclideanDivision.mod1 i' (power_ 2%Z n))) ->
  ((apply_qft n i) = (apply_qft n' i')).

Parameter apply_qft_as_mod: Z -> Z -> unit.

Axiom apply_qft_as_mod_def :
  forall (n:Z) (i:Z), (0%Z < n)%Z -> ((apply_qft_as_mod n i) = tt).

Axiom apply_qft_as_mod_spec :
  forall (n:Z) (i:Z), (0%Z < n)%Z ->
  ((apply_qft n i) =
   (apply_qft n (int.EuclideanDivision.mod1 i (power_ 2%Z n)))).

Axiom int_qft_rev_coeff_to_qft_coeff :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) ->
  ((int_qft_rev_coeff i j n) = (int_qft_coeff (-i)%Z j n)).

Axiom qft_coeff_add :
  forall (i:Z) (i':Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((int_qft_coeff (i + i')%Z j n) =
   (infix_asdt (int_qft_coeff i j n) (int_qft_coeff i' j n))).

Axiom qft_ket :
  forall (x:bitvec) (y:bitvec) (n:Z), (0%Z < n)%Z -> ((length x) = n) ->
  ((length y) = n) -> ((zh_ket (qft n) x y) = y).

Axiom sem_rev_unit :
  forall (n:Z), (0%Z < n)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) ->
  sem (qft n) x
  (infix_asdtdt (pow_inv_sqrt_2 n)
   (ket_sum_l (n_bvs n)
    (fun (y:bitvec) =>
     (infix_asdtdt (qft_coeff (ket_to_bv x) y n) (bv_to_ket y)))
    n)).

Axiom pat_sem_qft_unit :
  forall (n:Z), (0%Z < n)%Z -> forall (x:matrix t), (is_a_ket_l x n) ->
  (is_a_ket_basis_elt x) ->
  ((pat_sem (qft n) x) =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) =>
      (infix_asdtdt (qft_coeff (ket_to_bv x) y n) (bv_to_ket y)))
     n))).

Axiom pat_sem_rev_qft_bv1 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  ((pat_sem (qft n) (bv_to_ket x)) =
   (infix_asdtdt (pow_inv_sqrt_2 n)
    (ket_sum_l (n_bvs n)
     (fun (y:bitvec) => (infix_asdtdt (qft_coeff x y n) (bv_to_ket y))) n))).

Axiom sem_rev_qft_bv1 :
  forall (n:Z), (0%Z < n)%Z -> forall (x:bitvec), ((length x) = n) ->
  sem (qft n) (bv_to_ket x)
  (infix_asdtdt (pow_inv_sqrt_2 n)
   (ket_sum_l (n_bvs n)
    (fun (y:bitvec) => (infix_asdtdt (qft_coeff x y n) (bv_to_ket y))) n)).

Parameter ancillable: circuit -> Z -> Z -> Prop.

Axiom ancillable_def :
  forall (c:circuit) (k:Z) (n:Z),
  (ancillable c k n) <->
  (((width c) = n) /\
   (((0%Z <= k)%Z /\ (k < n)%Z) /\
    forall (x:bitvec), ((length x) = (n - k)%Z) ->
    exists y:matrix t,
    (is_a_ket_l y (n - k)%Z) /\
    ((pat_sem c (bv_to_ket (concat x (make_bv (fun (us:Z) => 0%Z) k)))) =
     (kronecker y (bv_to_ket (make_bv (fun (us:Z) => 0%Z) k)))))).

Axiom set_ancillable :
  forall (c:circuit) (k:Z) (n:Z), ((width c) = n) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (forall (x:bitvec), ((length x) = (n - k)%Z) ->
   exists y:matrix t,
   (is_a_ket_l y (n - k)%Z) /\
   ((pat_sem c (bv_to_ket (concat x (make_bv (fun (us:Z) => 0%Z) k)))) =
    (kronecker y (bv_to_ket (make_bv (fun (us:Z) => 0%Z) k))))) ->
  ancillable c k n.

Parameter flat_ancillable: circuit -> Z -> Z -> Prop.

Axiom flat_ancillable_def :
  forall (c:circuit) (k:Z) (n:Z),
  (flat_ancillable c k n) <->
  (((width c) = n) /\
   (((0%Z <= k)%Z /\ (k < n)%Z) /\
    ((flat c) /\
     forall (x:bitvec), ((length x) = n) ->
     (forall (i:Z), (((n - k)%Z <= i)%Z /\ (i < n)%Z) ->
      (((getbv x) i) = 0%Z)) ->
     forall (i:Z), (((n - k)%Z <= i)%Z /\ (i < n)%Z) ->
     (((getbv ((flat_ket c) x)) i) = 0%Z)))).

Axiom anc_to_flat_anc_pre :
  forall (c:circuit) (k:Z) (n:Z) (x:bitvec), (flat_ancillable c k n) ->
  ((length x) = (n - k)%Z) ->
  ((pat_sem c (bv_to_ket (concat x (make_bv (fun (us:Z) => 0%Z) k)))) =
   (infix_asdtdt
    (ang_exp ((flat_ang c) (concat x (make_bv (fun (us:Z) => 0%Z) k))))
    (bv_to_ket ((flat_ket c) (concat x (make_bv (fun (us:Z) => 0%Z) k)))))).

Axiom anc_to_flat_anc_pre1 :
  forall (c:circuit) (k:Z) (n:Z) (x:bitvec), (flat_ancillable c k n) ->
  ((length x) = (n - k)%Z) ->
  (((flat_ket c) (concat x (make_bv (fun (us:Z) => 0%Z) k))) =
   (concat
    (hpart ((flat_ket c) (concat x (make_bv (fun (us:Z) => 0%Z) k)))
     (n - k)%Z)
    (make_bv (fun (us:Z) => 0%Z) k))).

Axiom anc_to_flat_anc :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) -> ancillable c k n.

Parameter ancilla: circuit -> Z -> Z -> circuit.

Axiom ancilla_spec :
  forall (c:circuit) (k:Z) (n:Z), (ancillable c k n) -> ((width c) = n) ->
  ((ancillas (ancilla c k n)) = (k + (ancillas c))%Z).

Axiom ancilla_spec1 :
  forall (c:circuit) (k:Z) (n:Z), (ancillable c k n) -> ((width c) = n) ->
  ((size (ancilla c k n)) = (size c)).

Axiom ancilla_spec2 :
  forall (c:circuit) (k:Z) (n:Z), (ancillable c k n) -> ((width c) = n) ->
  forall (x:bitvec), ((length x) = n) ->
  ((pat_sem c (bv_to_ket (concat x (make_bv (fun (us:Z) => 0%Z) k)))) =
   (kronecker (pat_sem (ancilla c k n) (bv_to_ket x))
    (bv_to_ket (make_bv (fun (us:Z) => 0%Z) k)))).

Axiom ancilla_spec3 :
  forall (c:circuit) (k:Z) (n:Z), (ancillable c k n) -> ((width c) = n) ->
  forall (x:bitvec), forall (i:Z), ((length x) = (n - k)%Z) ->
  ((0%Z <= i)%Z /\ (i < (n - k)%Z)%Z) ->
  ((get (pat_sem (ancilla c k n) (bv_to_ket x)) i 0%Z) =
   (get (pat_sem c (bv_to_ket (concat x (make_bv (fun (us:Z) => 0%Z) k)))) i
    0%Z)).

Axiom ancilla_spec4 :
  forall (c:circuit) (k:Z) (n:Z), (ancillable c k n) -> ((width c) = n) ->
  ((width (ancilla c k n)) = (n - k)%Z).

Axiom ancilla_equiv :
  forall (c:circuit) (c':circuit) (k:Z) (n:Z), (ancillable c k n) ->
  ((width c) = n) -> (circuit_equiv c c') ->
  circuit_equiv (ancilla c k n) (ancilla c' k n).

Parameter ancilla_ket: circuit -> Z -> Z -> circuit.

Axiom ancilla_ket_def :
  forall (c:circuit) (k:Z) (n:Z), ((width c) = n) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (forall (x:matrix t), (is_a_ket_l x (n - k)%Z) ->
   exists y:matrix t,
   (is_a_ket_l y (n - k)%Z) /\
   ((pat_sem c (kronecker x (ket 0%Z k))) = (kronecker y (ket 0%Z k)))) ->
  ((ancilla_ket c k n) = (ancilla c k n)).

Axiom ancilla_ket_spec :
  forall (c:circuit) (k:Z) (n:Z), ((width c) = n) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (forall (x:matrix t), (is_a_ket_l x (n - k)%Z) ->
   exists y:matrix t,
   (is_a_ket_l y (n - k)%Z) /\
   ((pat_sem c (kronecker x (ket 0%Z k))) = (kronecker y (ket 0%Z k)))) ->
  ((ancillas (ancilla_ket c k n)) = (k + (ancillas c))%Z).

Axiom ancilla_ket_spec1 :
  forall (c:circuit) (k:Z) (n:Z), ((width c) = n) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (forall (x:matrix t), (is_a_ket_l x (n - k)%Z) ->
   exists y:matrix t,
   (is_a_ket_l y (n - k)%Z) /\
   ((pat_sem c (kronecker x (ket 0%Z k))) = (kronecker y (ket 0%Z k)))) ->
  ((size (ancilla_ket c k n)) = (size c)).

Axiom ancilla_ket_spec2 :
  forall (c:circuit) (k:Z) (n:Z), ((width c) = n) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (forall (x:matrix t), (is_a_ket_l x (n - k)%Z) ->
   exists y:matrix t,
   (is_a_ket_l y (n - k)%Z) /\
   ((pat_sem c (kronecker x (ket 0%Z k))) = (kronecker y (ket 0%Z k)))) ->
  forall (x:matrix t) (y:matrix t), (is_a_ket_l x (n - k)%Z) ->
  ((pat_sem c (kronecker x (ket k 0%Z))) = (kronecker y (ket n 0%Z))) ->
  ((pat_sem (ancilla c k n) x) = y).

Axiom ancilla_ket_spec3 :
  forall (c:circuit) (k:Z) (n:Z), ((width c) = n) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (forall (x:matrix t), (is_a_ket_l x (n - k)%Z) ->
   exists y:matrix t,
   (is_a_ket_l y (n - k)%Z) /\
   ((pat_sem c (kronecker x (ket 0%Z k))) = (kronecker y (ket 0%Z k)))) ->
  ((width (ancilla_ket c k n)) = (n - k)%Z).

Parameter fc26:
  Z -> Z -> (bitvec -> bitvec -> bitvec) -> bitvec -> bitvec -> Z -> Z.

Axiom fc_def26 :
  forall (k:Z) (n:Z) (ancb:bitvec -> bitvec -> bitvec) (x:bitvec) (y:bitvec)
    (i:Z),
  (((0%Z <= i)%Z /\ (i < (n - k)%Z)%Z) ->
   (((fc26 k n ancb x y) i) = ((getbv ((ancb x) y)) i))) /\
  (~ ((0%Z <= i)%Z /\ (i < (n - k)%Z)%Z) -> (((fc26 k n ancb x y) i) = 0%Z)).

Axiom correct_path_sum_anc :
  forall (c:circuit), forall (k:Z) (n:Z), (ancillable c k n) ->
  forall (anca:bitvec -> bitvec -> angle) (a:bitvec -> bitvec -> angle),
  forall (ancb:bitvec -> bitvec -> bitvec) (b:bitvec -> bitvec -> bitvec),
  forall (r:Z) (r':Z),
  (forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = r) ->
   (forall (i:Z), (((n - k)%Z <= i)%Z /\ (i < n)%Z) -> (((getbv x) i) = 0%Z)) ->
   (((b x) y) = (make_bv (fc26 k n ancb x y) n))) ->
  (forall (x:bitvec) (y:bitvec), ((length x) = n) -> ((length y) = r) ->
   (((a x) y) = ((anca x) y))) ->
  (r = r') -> (correct_path_sum c a b r) -> correct_path_sum c anca ancb r'.

Parameter f_ancilla: circuit -> Z -> Z -> circuit.

Axiom f_ancilla_def :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) ->
  ((width c) = n) -> ((f_ancilla c k n) = (ancilla c k n)).

Axiom f_ancilla_spec :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) ->
  ((width c) = n) -> ((ancillas (f_ancilla c k n)) = (k + (ancillas c))%Z).

Axiom f_ancilla_spec1 :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) ->
  ((width c) = n) -> ((size (f_ancilla c k n)) = (size c)).

Axiom f_ancilla_spec2 :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) ->
  ((width c) = n) -> ((width (f_ancilla c k n)) = (n - k)%Z).

Axiom f_ancilla_spec3 :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) ->
  ((width c) = n) -> forall (x:bitvec), ((length x) = (n - k)%Z) ->
  ((pat_sem (f_ancilla c k n) (bv_to_ket x)) =
   (infix_asdtdt
    (ang_exp ((flat_ang c) (concat x (make_bv (fun (us:Z) => 0%Z) k))))
    (bv_to_ket
     (hpart ((flat_ket c) (concat x (make_bv (fun (us:Z) => 0%Z) k)))
      (n - k)%Z)))).

Axiom f_ancilla_spec4 :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) ->
  ((width c) = n) -> forall (x:bitvec), ((length x) = (n - k)%Z) ->
  (((flat_ket (f_ancilla c k n)) x) =
   (hpart ((flat_ket c) (concat x (make_bv (fun (us:Z) => 0%Z) k)))
    (n - k)%Z)).

Axiom f_ancilla_spec5 :
  forall (c:circuit) (k:Z) (n:Z), (flat_ancillable c k n) ->
  ((width c) = n) -> forall (x:bitvec), ((length x) = (n - k)%Z) ->
  (((flat_ang (f_ancilla c k n)) x) =
   ((flat_ang c) (concat x (make_bv (fun (us:Z) => 0%Z) k)))).

Axiom set_qft_ancillable :
  forall (c:circuit) (k:Z) (n:Z), ((width c) = n) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (power_ 2%Z (n - k)%Z))%Z) ->
   exists y:matrix t,
   (is_a_ket_l y (n - k)%Z) /\
   ((pat_sem c (kronecker (apply_qft (n - k)%Z i) (ket k 0%Z))) =
    (kronecker y (ket k 0%Z)))) ->
  ancillable c k n.

Parameter ind_cnot: Z -> Z -> Z -> circuit.

Axiom ind_cnot_def :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) ->
  ((ind_cnot c k n) = (f_cont (xx tt) c k n)).

Axiom ind_cnot_spec :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) ->
  ((size (ind_cnot c k n)) <= (cont_size * 4%Z)%Z)%Z.

Axiom ind_cnot_spec1 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) ->
  ((ancillas (ind_cnot c k n)) = 0%Z).

Axiom ind_cnot_spec2 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (x:bitvec),
  ((length x) = n) -> (((flat_ang (ind_cnot c k n)) x) = ang_zero).

Axiom ind_cnot_spec3 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (x:bitvec),
  ((length x) = n) -> (((getbv x) c) = 0%Z) ->
  (((flat_ket (ind_cnot c k n)) x) = x).

Parameter fc27: Z -> bitvec -> Z -> Z.

Axiom fc_def27 :
  forall (k:Z) (x:bitvec) (i:Z),
  ((i = k) -> (((fc27 k x) i) = (1%Z - ((getbv x) i))%Z)) /\
  (~ (i = k) -> (((fc27 k x) i) = ((getbv x) i))).

Axiom ind_cnot_spec4 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (x:bitvec),
  ((length x) = n) -> (((getbv x) c) = 1%Z) ->
  (((flat_ket (ind_cnot c k n)) x) = (make_bv (fc27 k x) n)).

Axiom ind_cnot_spec5 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (ket1:matrix t),
  (is_a_ket_l ket1 n) -> (is_a_ket_basis_elt ket1) ->
  (((getbv (ket_to_bv ket1)) c) = 0%Z) ->
  ((pat_sem (ind_cnot c k n) ket1) = ket1).

Parameter fc28: Z -> (matrix t) -> Z -> Z.

Axiom fc_def28 :
  forall (k:Z) (ket1:matrix t) (i:Z),
  ((i = k) -> (((fc28 k ket1) i) = (1%Z - ((getbv (ket_to_bv ket1)) i))%Z)) /\
  (~ (i = k) -> (((fc28 k ket1) i) = ((getbv (ket_to_bv ket1)) i))).

Axiom ind_cnot_spec6 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (ket1:matrix t),
  (is_a_ket_l ket1 n) -> (is_a_ket_basis_elt ket1) ->
  (((getbv (ket_to_bv ket1)) c) = 1%Z) ->
  ((pat_sem (ind_cnot c k n) ket1) = (bv_to_ket (make_bv (fc28 k ket1) n))).

Axiom ind_cnot_spec7 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> ((width (ind_cnot c k n)) = n).

Axiom sem_ind_cnot :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (ket1:matrix t),
  (is_a_ket_l ket1 n) -> (is_a_ket_basis_elt ket1) ->
  (((getbv (ket_to_bv ket1)) c) = 0%Z) ->
  ((pat_sem (ind_cnot c k n) ket1) = ket1).

Parameter fc29: Z -> (matrix t) -> Z -> Z.

Axiom fc_def29 :
  forall (k:Z) (ket1:matrix t) (i:Z),
  ((i = k) -> (((fc29 k ket1) i) = (1%Z - ((getbv (ket_to_bv ket1)) i))%Z)) /\
  (~ (i = k) -> (((fc29 k ket1) i) = ((getbv (ket_to_bv ket1)) i))).

Axiom sem_ind_cnot1 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (ket1:matrix t),
  (is_a_ket_l ket1 n) -> (is_a_ket_basis_elt ket1) ->
  (((getbv (ket_to_bv ket1)) c) = 1%Z) ->
  ((pat_sem (ind_cnot c k n) ket1) = (bv_to_ket (make_bv (fc29 k ket1) n))).

Parameter ind_neg_cnot: Z -> Z -> Z -> circuit.

Axiom ind_neg_cnot_spec :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) ->
  ((ancillas (ind_neg_cnot c k n)) = 0%Z).

Axiom ind_neg_cnot_spec1 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) ->
  ((size (ind_neg_cnot c k n)) <= ((cont_size * 4%Z)%Z + 8%Z)%Z)%Z.

Axiom ind_neg_cnot_spec2 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (x:bitvec),
  ((length x) = n) -> (((flat_ang (ind_neg_cnot c k n)) x) = ang_zero).

Axiom ind_neg_cnot_spec3 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (x:bitvec),
  ((length x) = n) -> (((getbv x) c) = 1%Z) ->
  (((flat_ket (ind_neg_cnot c k n)) x) = x).

Parameter fc30: Z -> bitvec -> Z -> Z.

Axiom fc_def30 :
  forall (k:Z) (x:bitvec) (i:Z),
  ((i = k) -> (((fc30 k x) i) = (1%Z - ((getbv x) i))%Z)) /\
  (~ (i = k) -> (((fc30 k x) i) = ((getbv x) i))).

Axiom ind_neg_cnot_spec4 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (x:bitvec),
  ((length x) = n) -> (((getbv x) c) = 0%Z) ->
  (((flat_ket (ind_neg_cnot c k n)) x) = (make_bv (fc30 k x) n)).

Axiom ind_neg_cnot_spec5 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) ->
  ((width (ind_neg_cnot c k n)) = n).

Axiom sem_ind_neg_cnot :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z (n - 1%Z)%Z))%Z) ->
  ((pat_sem (ind_neg_cnot 0%Z n (n + 1%Z)%Z)
    (kronecker (ket n i) (ket 1%Z 1%Z)))
   = (kronecker (ket n i) (ket 1%Z 0%Z))).

Axiom sem_ind_neg_cnot1 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (i:Z),
  (((power_ 2%Z (n - 1%Z)%Z) <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((pat_sem (ind_neg_cnot 0%Z n (n + 1%Z)%Z)
    (kronecker (ket n i) (ket 1%Z 0%Z)))
   = (kronecker (ket n i) (ket 1%Z 0%Z))).

Axiom sem_ind_neg_cnot2 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (ket1:matrix t),
  (is_a_ket_l ket1 n) -> (is_a_ket_basis_elt ket1) ->
  (((getbv (ket_to_bv ket1)) c) = 1%Z) ->
  ((pat_sem (ind_neg_cnot c k n) ket1) = ket1).

Parameter fc31: Z -> (matrix t) -> Z -> Z.

Axiom fc_def31 :
  forall (k:Z) (ket1:matrix t) (i:Z),
  ((i = k) -> (((fc31 k ket1) i) = (1%Z - ((getbv (ket_to_bv ket1)) i))%Z)) /\
  (~ (i = k) -> (((fc31 k ket1) i) = ((getbv (ket_to_bv ket1)) i))).

Axiom sem_ind_neg_cnot3 :
  forall (c:Z) (k:Z) (n:Z), ((0%Z <= c)%Z /\ (c < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ (k = c) -> forall (ket1:matrix t),
  (is_a_ket_l ket1 n) -> (is_a_ket_basis_elt ket1) ->
  (((getbv (ket_to_bv ket1)) c) = 0%Z) ->
  ((pat_sem (ind_neg_cnot c k n) ket1) =
   (bv_to_ket (make_bv (fc31 k ket1) n))).

Parameter ind_swap: Z -> Z -> Z -> circuit.

Axiom ind_swap_spec :
  forall (c1:Z) (c2:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ~ (c1 = c2) ->
  ((size (ind_swap c1 c2 n)) <= (cont_size * 12%Z)%Z)%Z.

Axiom ind_swap_spec1 :
  forall (c1:Z) (c2:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ~ (c1 = c2) ->
  ((ancillas (ind_swap c1 c2 n)) = 0%Z).

Axiom ind_swap_spec2 :
  forall (c1:Z) (c2:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ~ (c1 = c2) ->
  ((width (ind_swap c1 c2 n)) = n).

Axiom ind_swap_spec3 :
  forall (c1:Z) (c2:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ~ (c1 = c2) -> flat (ind_swap c1 c2 n).

Axiom ind_swap_spec4 :
  forall (c1:Z) (c2:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ~ (c1 = c2) -> forall (x:bitvec),
  ((length x) = n) -> (((flat_ang (ind_swap c1 c2 n)) x) = ang_zero).

Parameter fc32: Z -> Z -> bitvec -> Z -> Z.

Axiom fc_def32 :
  forall (c1:Z) (c2:Z) (x:bitvec) (i:Z),
  ((i = c1) -> (((fc32 c1 c2 x) i) = ((getbv x) c2))) /\
  (~ (i = c1) ->
   ((i = c2) -> (((fc32 c1 c2 x) i) = ((getbv x) c1))) /\
   (~ (i = c2) -> (((fc32 c1 c2 x) i) = ((getbv x) i)))).

Axiom ind_swap_spec5 :
  forall (c1:Z) (c2:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ~ (c1 = c2) -> forall (x:bitvec),
  ((length x) = n) ->
  (((flat_ket (ind_swap c1 c2 n)) x) = (make_bv (fc32 c1 c2 x) n)).

Parameter swap_lists: Z -> Z -> Z -> Z -> circuit.

Axiom swap_lists_def :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> (l = 1%Z) ->
  ((swap_lists c1 c2 l n) = (ind_swap c1 c2 n)).

Axiom swap_lists_def1 :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> ~ (l = 1%Z) ->
  ((swap_lists c1 c2 l n) =
   (f_sequence (ind_swap c1 c2 n)
    (swap_lists (c1 + 1%Z)%Z (c2 + 1%Z)%Z (l - 1%Z)%Z n))).

Axiom swap_lists_spec :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z ->
  ((size (swap_lists c1 c2 l n)) <=
   (polysquare l 0%Z (cont_size * 12%Z)%Z 0%Z))%Z.

Axiom swap_lists_spec1 :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> ((ancillas (swap_lists c1 c2 l n)) = 0%Z).

Axiom swap_lists_spec2 :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> ((width (swap_lists c1 c2 l n)) = n).

Axiom swap_lists_spec3 :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> flat (swap_lists c1 c2 l n).

Axiom swap_lists_spec4 :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> ((size (swap_lists c1 c2 l n)) = n).

Axiom swap_lists_spec5 :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((flat_ang (swap_lists c1 c2 l n)) x) = ang_zero).

Parameter fc33: Z -> Z -> Z -> bitvec -> Z -> Z.

Axiom fc_def33 :
  forall (c1:Z) (c2:Z) (l:Z) (x:bitvec) (i:Z),
  (((c1 <= i)%Z /\ (i < (c1 + l)%Z)%Z) ->
   (((fc33 c1 c2 l x) i) = ((getbv x) ((c2 + i)%Z - c1)%Z))) /\
  (~ ((c1 <= i)%Z /\ (i < (c1 + l)%Z)%Z) ->
   (((c2 <= i)%Z /\ (i < (c2 + l)%Z)%Z) ->
    (((fc33 c1 c2 l x) i) = ((getbv x) ((c1 + i)%Z - c2)%Z))) /\
   (~ ((c2 <= i)%Z /\ (i < (c2 + l)%Z)%Z) ->
    (((fc33 c1 c2 l x) i) = ((getbv x) i)))).

Axiom swap_lists_spec6 :
  forall (c1:Z) (c2:Z) (l:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  (0%Z < l)%Z -> ((0%Z <= (c2 + l)%Z)%Z /\ ((c2 + l)%Z <= n)%Z) ->
  ((c1 + l)%Z <= c2)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((flat_ket (swap_lists c1 c2 l n)) x) = (make_bv (fc33 c1 c2 l x) n)).

Axiom swap_lists_kets :
  forall (c2:Z) (l:Z) (n:Z),
  ((0%Z < l)%Z /\ ((l <= c2)%Z /\ (c2 = (n - l)%Z))) ->
  forall (x:matrix t) (y:matrix t) (z:matrix t), (is_a_ket_l x l) ->
  (is_a_ket_l z l) -> (is_a_ket_l y (c2 - l)%Z) ->
  ((pat_sem (swap_lists 0%Z c2 l n) (kronecker x (kronecker y z))) =
   (kronecker z (kronecker y x))).

Parameter cc_pre: circuit -> Z -> Z -> Z -> Z -> circuit.

Axiom cc_pre_def :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def1 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def2 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def3 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def4 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def5 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def6 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def7 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def8 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def9 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def10 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def11 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def12 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def13 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def14 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def15 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def16 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def17 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def18 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def19 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def20 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def21 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def22 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def23 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def24 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def25 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def26 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def27 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def28 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def29 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_def30 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ 0%Z (k - c2)%Z ((k - c2)%Z + (size circ))%Z) c1 c2 n)).

Axiom cc_pre_def31 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> ~ (c2 < k)%Z ->
  ((cc_pre circ c1 c2 k n) =
   (cont (cont circ (c2 - k)%Z 0%Z ((c2 - k)%Z + 1%Z)%Z) c1 k n)).

Axiom cc_pre_spec :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec1 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec2 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec3 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec4 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec5 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec6 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec7 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec8 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec9 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec10 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec11 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec12 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec13 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec14 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec15 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec16 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec17 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec18 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec19 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec20 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec21 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec22 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec23 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec24 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec25 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec26 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec27 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec28 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec29 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec30 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec31 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec32 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec33 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec34 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec35 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec36 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec37 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec38 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec39 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec40 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec41 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec42 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec43 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec44 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec45 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec46 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec47 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec48 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec49 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec50 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec51 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec52 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec53 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec54 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec55 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec56 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec57 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec58 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec59 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec60 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec61 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec62 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec63 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec64 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec65 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec66 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec67 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec68 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec69 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec70 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec71 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec72 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec73 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec74 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec75 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec76 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec77 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec78 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec79 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec80 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec81 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec82 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec83 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ~ (c1 = c2) -> ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec84 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec85 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec86 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec87 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec88 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec89 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec90 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec91 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec92 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec93 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec94 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec95 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec96 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec97 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec98 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec99 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec100 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec101 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec102 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec103 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec104 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec105 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((ancillas (cc_pre circ c1 c2 k n)) = 0%Z).

Axiom cc_pre_spec106 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((width (cc_pre circ c1 c2 k n)) = n).

Axiom cc_pre_spec107 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_pre_spec108 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec109 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_pre_spec110 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc_pre circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_pre_spec111 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z -> ~ (c1 = c2) ->
  ((size (cc_pre circ c1 c2 k n)) = n).

Parameter cc: circuit -> Z -> Z -> Z -> Z -> circuit.

Axiom cc_def :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> (c1 = c2) ->
  ((cc circ c1 c2 k n) = (cont circ c1 k n)).

Axiom cc_def1 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ((k < c1)%Z /\ (c1 < c2)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def2 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) -> ~ (k < c1)%Z ->
  ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def3 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) -> ~ (k < c1)%Z ->
  ~ (c2 < c1)%Z -> ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def4 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) -> ~ (k < c1)%Z ->
  ~ (c1 < k)%Z -> ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def5 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) -> ~ (c1 < c2)%Z ->
  ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def6 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) -> ~ (c1 < c2)%Z ->
  ~ (c2 < c1)%Z -> ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def7 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) -> ~ (c1 < c2)%Z ->
  ~ (c1 < k)%Z -> ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def8 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> (c1 = c2) ->
  ((cc circ c1 c2 k n) = (cont circ c1 k n)).

Axiom cc_def9 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 = c2) ->
  ((k < c1)%Z /\ (c1 < c2)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def10 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 = c2) ->
  ~ (k < c1)%Z -> ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def11 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 = c2) ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def12 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 = c2) ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def13 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 = c2) ->
  ~ (c1 < c2)%Z -> ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def14 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 = c2) ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def15 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> ~ (c1 = c2) ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def16 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> (c1 = c2) ->
  ((cc circ c1 c2 k n) = (cont circ c1 k n)).

Axiom cc_def17 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ((k < c1)%Z /\ (c1 < c2)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def18 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ~ (k < c1)%Z -> ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def19 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def20 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def21 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ~ (c1 < c2)%Z -> ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def22 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def23 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> ~ (c1 = c2) ->
  ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def24 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  (c1 = c2) -> ((cc circ c1 c2 k n) = (cont circ c1 k n)).

Axiom cc_def25 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 = c2) -> ((k < c1)%Z /\ (c1 < c2)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def26 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 = c2) -> ~ (k < c1)%Z -> ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def27 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 = c2) -> ~ (k < c1)%Z -> ~ (c2 < c1)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def28 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 = c2) -> ~ (k < c1)%Z -> ~ (c1 < k)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def29 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 = c2) -> ~ (c1 < c2)%Z -> ((c2 < c1)%Z /\ (c1 < k)%Z) ->
  ((cc circ c1 c2 k n) = (cc_pre circ c2 c1 k n)).

Axiom cc_def30 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 = c2) -> ~ (c1 < c2)%Z -> ~ (c2 < c1)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_def31 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ~ (c1 = c2) -> ~ (c1 < c2)%Z -> ~ (c1 < k)%Z ->
  ((cc circ c1 c2 k n) = (cc_pre circ c1 c2 k n)).

Axiom cc_spec :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z ->
  ((size (cc circ c1 c2 k n)) <= ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_spec1 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec2 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec3 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_spec4 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Axiom cc_spec5 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ((size (cc circ c1 c2 k n)) = n).

Axiom cc_spec6 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (cc circ c1 c2 k n)) <= ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_spec7 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec8 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec9 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_spec10 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Axiom cc_spec11 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (cc circ c1 c2 k n)) = n).

Axiom cc_spec12 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  ((size (cc circ c1 c2 k n)) <= ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_spec13 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec14 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec15 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) -> (((getbv bv) c1) = 1%Z) -> (((getbv bv) c2) = 1%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_spec16 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Axiom cc_spec17 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  ((size (cc circ c1 c2 k n)) = n).

Axiom cc_spec18 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (cc circ c1 c2 k n)) <= ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom cc_spec19 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  forall (bv:bitvec), ((length bv) = n) -> (((getbv bv) c1) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec20 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  forall (bv:bitvec), ((length bv) = n) -> (((getbv bv) c1) = 1%Z) ->
  (((getbv bv) c2) = 0%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv) (bv_to_ket bv).

Axiom cc_spec21 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  forall (bv:bitvec), ((length bv) = n) -> (((getbv bv) c1) = 1%Z) ->
  (((getbv bv) c2) = 1%Z) ->
  sem (cc circ c1 c2 k n) (bv_to_ket bv)
  (pat_sem (place circ k n) (bv_to_ket bv)).

Axiom cc_spec22 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  forall (bv:bitvec), ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Axiom cc_spec23 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z),
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (cc circ c1 c2 k n)) = n).

Parameter f_cc: circuit -> Z -> Z -> Z -> Z -> circuit.

Axiom f_cc_def :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z ->
  ((f_cc circ c1 c2 k n) = (cc circ c1 c2 k n)).

Axiom f_cc_def1 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((f_cc circ c1 c2 k n) = (cc circ c1 c2 k n)).

Axiom f_cc_def2 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  ((f_cc circ c1 c2 k n) = (cc circ c1 c2 k n)).

Axiom f_cc_def3 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((f_cc circ c1 c2 k n) = (cc circ c1 c2 k n)).

Axiom f_cc_spec :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z ->
  ((size (f_cc circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom f_cc_spec1 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ((ancillas (f_cc circ c1 c2 k n)) = 0%Z).

Axiom f_cc_spec2 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ((width (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec3 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> flat (f_cc circ c1 c2 k n).

Axiom f_cc_spec4 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> ((size (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec5 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec), ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (f_place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Parameter fc34: circuit -> Z -> bitvec -> Z -> Z.

Axiom fc_def34 :
  forall (circ:circuit) (k:Z) (x:bitvec) (i:Z),
  (((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc34 circ k x) i) =
    ((getbv ((flat_ket circ) (htpart x k (size circ)))) (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc34 circ k x) i) = ((getbv x) i))).

Axiom f_cc_spec6 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = (make_bv (fc34 circ k x) n))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = x)).

Axiom f_cc_spec7 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ~ (k <= c2)%Z -> forall (x:bitvec), ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) =
    ((flat_ang circ) (htpart x k (size circ))))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) = ang_zero)).

Axiom f_cc_spec8 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (f_cc circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom f_cc_spec9 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((ancillas (f_cc circ c1 c2 k n)) = 0%Z).

Axiom f_cc_spec10 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((width (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec11 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  flat (f_cc circ c1 c2 k n).

Axiom f_cc_spec12 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec13 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (f_place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Parameter fc35: circuit -> Z -> bitvec -> Z -> Z.

Axiom fc_def35 :
  forall (circ:circuit) (k:Z) (x:bitvec) (i:Z),
  (((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc35 circ k x) i) =
    ((getbv ((flat_ket circ) (htpart x k (size circ)))) (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc35 circ k x) i) = ((getbv x) i))).

Axiom f_cc_spec14 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> forall (x:bitvec),
  ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = (make_bv (fc35 circ k x) n))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = x)).

Axiom f_cc_spec15 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ~ (k <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z -> forall (x:bitvec),
  ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) =
    ((flat_ang circ) (htpart x k (size circ))))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) = ang_zero)).

Axiom f_cc_spec16 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  ((size (f_cc circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom f_cc_spec17 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  ((ancillas (f_cc circ c1 c2 k n)) = 0%Z).

Axiom f_cc_spec18 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  ((width (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec19 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  flat (f_cc circ c1 c2 k n).

Axiom f_cc_spec20 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z ->
  ((size (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec21 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> forall (bv:bitvec),
  ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (f_place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Parameter fc36: circuit -> Z -> bitvec -> Z -> Z.

Axiom fc_def36 :
  forall (circ:circuit) (k:Z) (x:bitvec) (i:Z),
  (((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc36 circ k x) i) =
    ((getbv ((flat_ket circ) (htpart x k (size circ)))) (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc36 circ k x) i) = ((getbv x) i))).

Axiom f_cc_spec22 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> forall (x:bitvec),
  ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = (make_bv (fc36 circ k x) n))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = x)).

Axiom f_cc_spec23 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ~ (k <= c2)%Z -> forall (x:bitvec),
  ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) =
    ((flat_ang circ) (htpart x k (size circ))))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) = ang_zero)).

Axiom f_cc_spec24 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (f_cc circ c1 c2 k n)) <=
   ((power_ cont_size 2%Z) * (size circ))%Z)%Z.

Axiom f_cc_spec25 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((ancillas (f_cc circ c1 c2 k n)) = 0%Z).

Axiom f_cc_spec26 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((width (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec27 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  flat (f_cc circ c1 c2 k n).

Axiom f_cc_spec28 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  ((size (f_cc circ c1 c2 k n)) = n).

Axiom f_cc_spec29 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  forall (bv:bitvec), ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) =
    (pat_sem (f_place circ k n) (bv_to_ket bv)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (f_cc circ c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Parameter fc37: circuit -> Z -> bitvec -> Z -> Z.

Axiom fc_def37 :
  forall (circ:circuit) (k:Z) (x:bitvec) (i:Z),
  (((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc37 circ k x) i) =
    ((getbv ((flat_ket circ) (htpart x k (size circ)))) (i - k)%Z))) /\
  (~ ((k <= i)%Z /\ (i < (k + (size circ))%Z)%Z) ->
   (((fc37 circ k x) i) = ((getbv x) i))).

Axiom f_cc_spec30 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  forall (x:bitvec), ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = (make_bv (fc37 circ k x) n))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ket (f_cc circ c1 c2 k n)) x) = x)).

Axiom f_cc_spec31 :
  forall (circ:circuit) (c1:Z) (c2:Z) (k:Z) (n:Z), (flat circ) ->
  ((0%Z <= c1)%Z /\ (c1 < n)%Z) -> ((0%Z <= c2)%Z /\ (c2 < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= (k + (size circ))%Z)%Z /\ ((k + (size circ))%Z <= n)%Z) ->
  ((k + (size circ))%Z <= c1)%Z -> ((k + (size circ))%Z <= c2)%Z ->
  forall (x:bitvec), ((length x) = n) ->
  (((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) =
    ((flat_ang circ) (htpart x k (size circ))))) /\
  (~ ((((getbv x) c1) = ((getbv x) c2)) /\ (((getbv x) c2) = 1%Z)) ->
   (((flat_ang (f_cc circ c1 c2 k n)) x) = ang_zero)).

Parameter toffoli: Z -> Z -> Z -> Z -> circuit.

Axiom toffoli_def :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) ->
  ((toffoli c1 c2 k n) = (f_cc (xx tt) c1 c2 k n)).

Axiom toffoli_spec :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) ->
  ((size (toffoli c1 c2 k n)) <= ((power_ cont_size 2%Z) * 4%Z)%Z)%Z.

Axiom toffoli_spec1 :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) ->
  ((ancillas (toffoli c1 c2 k n)) = 0%Z).

Axiom toffoli_spec2 :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) ->
  ((width (toffoli c1 c2 k n)) = n).

Axiom toffoli_spec3 :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) -> flat (toffoli c1 c2 k n).

Parameter fc38: Z -> bitvec -> Z -> Z.

Axiom fc_def38 :
  forall (k:Z) (bv:bitvec) (i:Z),
  ((i = k) -> (((fc38 k bv) i) = (1%Z - ((getbv bv) i))%Z)) /\
  (~ (i = k) -> (((fc38 k bv) i) = ((getbv bv) i))).

Axiom toffoli_spec4 :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (toffoli c1 c2 k n) (bv_to_ket bv)) =
    (bv_to_ket (make_bv (fc38 k bv) n)))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   ((pat_sem (toffoli c1 c2 k n) (bv_to_ket bv)) = (bv_to_ket bv))).

Parameter fc39: Z -> bitvec -> Z -> Z.

Axiom fc_def39 :
  forall (k:Z) (bv:bitvec) (i:Z),
  ((i = k) -> (((fc39 k bv) i) = (1%Z - ((getbv bv) i))%Z)) /\
  (~ (i = k) -> (((fc39 k bv) i) = ((getbv bv) i))).

Axiom toffoli_spec5 :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) ->
  (((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   (((flat_ket (toffoli c1 c2 k n)) bv) = (make_bv (fc39 k bv) n))) /\
  (~ ((((getbv bv) c1) = ((getbv bv) c2)) /\ (((getbv bv) c2) = 1%Z)) ->
   (((flat_ket (toffoli c1 c2 k n)) bv) = bv)).

Axiom toffoli_spec6 :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) -> forall (bv:bitvec),
  ((length bv) = n) -> (((flat_ang (toffoli c1 c2 k n)) bv) = ang_zero).

Axiom toffoli_spec7 :
  forall (c1:Z) (c2:Z) (k:Z) (n:Z), ((0%Z <= c1)%Z /\ (c1 < n)%Z) ->
  ((0%Z <= c2)%Z /\ (c2 < n)%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ~ (k = c1) -> ~ (k = c2) -> ~ (c1 = c2) -> ((size (toffoli c1 c2 k n)) = n).

Parameter cascade_adder_: Z -> Z -> Z -> bitvec -> circuit.

Axiom cascade_adder__def :
  forall (target:Z) (n:Z) (step:Z) (y:bitvec),
  ((0%Z <= target)%Z /\ (target < n)%Z) ->
  ((target <= step)%Z /\ (step < n)%Z) -> ((length y) = n) ->
  (step = target) ->
  ((cascade_adder_ target n step y) =
   (przp (((getbv y) step) * 1%Z)%Z target n)).

Axiom cascade_adder__def1 :
  forall (target:Z) (n:Z) (step:Z) (y:bitvec),
  ((0%Z <= target)%Z /\ (target < n)%Z) ->
  ((target <= step)%Z /\ (step < n)%Z) -> ((length y) = n) ->
  ~ (step = target) ->
  ((cascade_adder_ target n step y) =
   (d_sequence (cascade_adder_ target n (step - 1%Z)%Z y)
    (przp (((getbv y) step) * ((step - target)%Z + 1%Z)%Z)%Z target n))).

Axiom cascade_adder__spec :
  forall (target:Z) (n:Z) (step:Z) (y:bitvec),
  ((0%Z <= target)%Z /\ (target < n)%Z) ->
  ((target <= step)%Z /\ (step < n)%Z) -> ((length y) = n) ->
  ((ancillas (cascade_adder_ target n step y)) = 0%Z).

Axiom cascade_adder__spec1 :
  forall (target:Z) (n:Z) (step:Z) (y:bitvec),
  ((0%Z <= target)%Z /\ (target < n)%Z) ->
  ((target <= step)%Z /\ (step < n)%Z) -> ((length y) = n) ->
  diag (cascade_adder_ target n step y).

Axiom cascade_adder__spec2 :
  forall (target:Z) (n:Z) (step:Z) (y:bitvec),
  ((0%Z <= target)%Z /\ (target < n)%Z) ->
  ((target <= step)%Z /\ (step < n)%Z) -> ((length y) = n) ->
  ((size (cascade_adder_ target n step y)) =
   (2%Z * ((step - target)%Z + 1%Z)%Z)%Z).

Axiom cascade_adder__spec3 :
  forall (target:Z) (n:Z) (step:Z) (y:bitvec),
  ((0%Z <= target)%Z /\ (target < n)%Z) ->
  ((target <= step)%Z /\ (step < n)%Z) -> ((length y) = n) ->
  ((width (cascade_adder_ target n step y)) = n).

Axiom cascade_adder__spec4 :
  forall (target:Z) (n:Z) (step:Z) (y:bitvec),
  ((0%Z <= target)%Z /\ (target < n)%Z) ->
  ((target <= step)%Z /\ (step < n)%Z) -> ((length y) = n) ->
  forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (cascade_adder_ target n step y)) x) =
   (ang_sum
    (fun (k:Z) =>
     (int_to_ang
      ((((getbv y) k) * ((getbv x) target))%Z *
       (power_ 2%Z (((n - k)%Z - 1%Z)%Z + target)%Z))%Z
      n))
    target (step + 1%Z)%Z)).

Parameter pre_adder_const_: Z -> bitvec -> circuit.

Axiom pre_adder_const__spec :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  diag (pre_adder_const_ n y).

Axiom pre_adder_const__spec1 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  ((ancillas (pre_adder_const_ n y)) = 0%Z).

Axiom pre_adder_const__spec2 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  ((size (pre_adder_const_ n y)) <= (polysquare n 2%Z 0%Z 0%Z))%Z.

Axiom pre_adder_const__spec3 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  ((width (pre_adder_const_ n y)) = n).

Axiom pre_adder_const__spec4 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (pre_adder_const_ n y)) x) =
   (ang_sum
    (fun (target:Z) =>
     (ang_sum
      (fun (k:Z) =>
       (int_to_ang
        ((((getbv y) k) * ((getbv x) target))%Z *
         (power_ 2%Z (((n - k)%Z - 1%Z)%Z + target)%Z))%Z
        n))
      target n))
    0%Z n)).

Axiom pre_adder_const__spec5 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (pre_adder_const_ n y)) x) =
   (int_to_ang
    (ind_isum
     (fun (j:Z) =>
      (ind_isum
       (fun (k:Z) =>
        ((((getbv y) k) * ((getbv x) j))%Z *
         (power_ 2%Z (((n - k)%Z - 1%Z)%Z + j)%Z))%Z)
       j n))
     0%Z n)
    n)).

Axiom pre_adder_const__spec6 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  forall (x:bitvec), ((length x) = n) ->
  (((diag_ang (pre_adder_const_ n y)) x) =
   (int_to_ang ((bv_to_int (bv_inversion x)) * (bv_to_int y))%Z n)).

Axiom pre_adder_const__spec7 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  forall (x:bitvec), ((length x) = n) ->
  ((ang_exp ((diag_ang (pre_adder_const_ n y)) x)) = (qft_coeff y x n)).

Axiom pre_adder_const__spec8 :
  forall (n:Z) (y:bitvec), (0%Z < n)%Z -> ((length y) = n) ->
  forall (x:bitvec), ((length x) = n) ->
  ((pat_sem (pre_adder_const_ n y) (bv_to_ket x)) =
   (infix_asdtdt (int_qft_coeff (bv_to_int y) (bv_to_int x) n) (bv_to_ket x))).

Parameter pre_adder_const_apply: Z -> Z -> Z -> matrix t.

Axiom pre_adder_const_apply_def :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) ->
  ((pre_adder_const_apply n i j) =
   (pat_sem (pre_adder_const_ n (int_to_bv j n)) (apply_qft n i))).

Axiom pre_adder_const_apply_spec :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) ->
  ((pre_adder_const_apply n i j) = (apply_qft n (i + j)%Z)).

Axiom pre_adder_const_apply_spec1 :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) ->
  ((ket_length (pre_adder_const_apply n i j)) = n).

Axiom pre_adder_const_add :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) ->
  ((pat_sem (pre_adder_const_ n (int_to_bv j n)) (apply_qft n i)) =
   (apply_qft n (i + j)%Z)).

Parameter pre_subst_const_apply: Z -> Z -> Z -> matrix t.

Axiom pre_subst_const_apply_def :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) -> (j = 0%Z) ->
  ((pre_subst_const_apply n i j) = (pre_adder_const_apply n i 0%Z)).

Axiom pre_subst_const_apply_def1 :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) -> ~ (j = 0%Z) -> (i < j)%Z ->
  ((pre_subst_const_apply n i j) =
   (pre_adder_const_apply n i ((power_ 2%Z n) - j)%Z)).

Axiom pre_subst_const_apply_def2 :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) -> ~ (j = 0%Z) -> ~ (i < j)%Z ->
  ((pre_subst_const_apply n i j) =
   (pre_adder_const_apply n i ((power_ 2%Z n) - j)%Z)).

Axiom pre_subst_const_apply_spec :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) ->
  ((pre_subst_const_apply n i j) = (apply_qft n (i - j)%Z)).

Axiom pre_subst_const_apply_spec1 :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power_ 2%Z n))%Z) ->
  ((ket_length (pre_subst_const_apply n i j)) = n).

Parameter add_pick_b: Z -> Z -> Z -> circuit.

Axiom add_pick_b_def :
  forall (pick:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((add_pick_b pick n b) =
   (pre_adder_const_ (n + 1%Z)%Z (int_to_bv pick (n + 1%Z)%Z))).

Axiom add_pick_b_spec :
  forall (pick:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((ancillas (add_pick_b pick n b)) = 0%Z).

Axiom add_pick_b_spec1 :
  forall (pick:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((size (add_pick_b pick n b)) <= (polysquare (n + 1%Z)%Z 2%Z 0%Z 0%Z))%Z.

Axiom add_pick_b_spec2 :
  forall (pick:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((pat_sem (add_pick_b pick n b) (apply_qft (n + 1%Z)%Z b)) =
   (apply_qft (n + 1%Z)%Z (pick + b)%Z)).

Axiom add_pick_b_spec3 :
  forall (pick:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((width (add_pick_b pick n b)) = (n + 1%Z)%Z).

Parameter add_pick_b_minus_bound: Z -> Z -> Z -> Z -> circuit.

Axiom add_pick_b_minus_bound_def :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) -> (pick < bound)%Z ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((add_pick_b_minus_bound pick bound n b) =
   (sequence (add_pick_b pick n b)
    (pre_adder_const_ (n + 1%Z)%Z
     (int_to_bv ((power_ 2%Z (n + 1%Z)%Z) - bound)%Z (n + 1%Z)%Z)))).

Axiom add_pick_b_minus_bound_spec :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) -> (pick < bound)%Z ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((size (add_pick_b_minus_bound pick bound n b)) <=
   (polysquare (n + 1%Z)%Z 4%Z 0%Z 0%Z))%Z.

Axiom add_pick_b_minus_bound_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) -> (pick < bound)%Z ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((ancillas (add_pick_b_minus_bound pick bound n b)) = 0%Z).

Axiom add_pick_b_minus_bound_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) -> (pick < bound)%Z ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((width (add_pick_b_minus_bound pick bound n b)) = (n + 1%Z)%Z).

Axiom add_pick_b_minus_bound_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) -> (pick < bound)%Z ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((pat_sem (add_pick_b_minus_bound pick bound n b)
    (apply_qft (n + 1%Z)%Z b))
   = (apply_qft (n + 1%Z)%Z ((pick + b)%Z - bound)%Z)).

Axiom add_pick_b_minus_bound_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) -> (pick < bound)%Z ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> forall (b':Z),
  ((0%Z <= (power_ 2%Z n))%Z /\ ((power_ 2%Z n) < bound)%Z) ->
  ((add_pick_b_minus_bound pick bound n b) =
   (sequence (add_pick_b pick n b')
    (pre_adder_const_ (n + 1%Z)%Z
     (int_to_bv ((power_ 2%Z (n + 1%Z)%Z) - bound)%Z (n + 1%Z)%Z)))).

Parameter rev_qft_spec: Z -> Z -> Z -> Z -> circuit.

Axiom rev_qft_spec_def :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((rev_qft_spec pick bound n b) =
   (sequence (add_pick_b_minus_bound pick bound n b) (qft_rev (n + 1%Z)%Z))).

Axiom rev_qft_spec_spec :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((size (rev_qft_spec pick bound n b)) <=
   (polysquare (n + 1%Z)%Z ((cont_size * 3%Z)%Z + 4%Z)%Z 0%Z 0%Z))%Z.

Axiom rev_qft_spec_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((ancillas (rev_qft_spec pick bound n b)) = 0%Z).

Axiom rev_qft_spec_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((width (rev_qft_spec pick bound n b)) = (n + 1%Z)%Z).

Axiom rev_qft_spec_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((pat_sem (rev_qft_spec pick bound n b) (apply_qft (n + 1%Z)%Z b)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
     (power_ 2%Z (n + 1%Z)%Z)))).

Axiom rev_qft_spec_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  forall (b':Z), ((0%Z <= b')%Z /\ (b' < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((rev_qft_spec pick bound n b) =
   (sequence (add_pick_b_minus_bound pick bound n b') (qft_rev (n + 1%Z)%Z))).

Parameter place_rev_qft_spec: Z -> Z -> Z -> Z -> circuit.

Axiom place_rev_qft_spec_def :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((place_rev_qft_spec pick bound n b) =
   (place (rev_qft_spec pick bound n b) 0%Z (n + 2%Z)%Z)).

Axiom place_rev_qft_spec_spec :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((size (place_rev_qft_spec pick bound n b)) <=
   (polysquare (n + 1%Z)%Z ((cont_size * 3%Z)%Z + 4%Z)%Z 0%Z 0%Z))%Z.

Axiom place_rev_qft_spec_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((ancillas (place_rev_qft_spec pick bound n b)) = 0%Z).

Axiom place_rev_qft_spec_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((pat_sem (place_rev_qft_spec pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 0%Z)))
   =
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
      (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))).

Axiom place_rev_qft_spec_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((pat_sem (place_rev_qft_spec pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 1%Z)))
   =
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
      (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 1%Z))).

Axiom place_rev_qft_spec_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  forall (b':Z), ((0%Z <= b')%Z /\ (b' < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((place_rev_qft_spec pick bound n b) =
   (place (rev_qft_spec pick bound n b') 0%Z (n + 2%Z)%Z)).

Axiom place_rev_qft_spec_spec5 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((width (place_rev_qft_spec pick bound n b)) = (n + 2%Z)%Z).

Parameter place_qft_spec: Z -> Z -> circuit.

Axiom place_qft_spec_def :
  forall (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= g)%Z /\ (g < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((place_qft_spec n g) = (place (qft (n + 1%Z)%Z) 0%Z (n + 2%Z)%Z)).

Axiom place_qft_spec_spec :
  forall (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= g)%Z /\ (g < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((size (place_qft_spec n g)) <=
   (polysquare (n + 1%Z)%Z ((cont_size * 3%Z)%Z + 4%Z)%Z 0%Z 0%Z))%Z.

Axiom place_qft_spec_spec1 :
  forall (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= g)%Z /\ (g < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((ancillas (place_qft_spec n g)) = 0%Z).

Axiom place_qft_spec_spec2 :
  forall (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= g)%Z /\ (g < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((pat_sem (place_qft_spec n g)
    (kronecker (ket (n + 1%Z)%Z g) (ket 1%Z 0%Z)))
   = (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 0%Z))).

Axiom place_qft_spec_spec3 :
  forall (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= g)%Z /\ (g < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((pat_sem (place_qft_spec n g)
    (kronecker (ket (n + 1%Z)%Z g) (ket 1%Z 1%Z)))
   = (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 1%Z))).

Axiom place_qft_spec_spec4 :
  forall (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= g)%Z /\ (g < (power_ 2%Z (n + 1%Z)%Z))%Z) -> forall (b':Z),
  ((0%Z <= b')%Z /\ (b' < (power_ 2%Z n))%Z) ->
  ((place_qft_spec n g) = (place (qft (n + 1%Z)%Z) 0%Z (n + 2%Z)%Z)).

Axiom place_qft_spec_spec5 :
  forall (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= g)%Z /\ (g < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((width (place_qft_spec n g)) = (n + 2%Z)%Z).

Parameter c_place_rev_qft_spec: Z -> Z -> Z -> Z -> circuit.

Axiom c_place_rev_qft_spec_def :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((c_place_rev_qft_spec pick bound n b) =
   (sequence (place_rev_qft_spec pick bound n b)
    (ind_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))).

Axiom c_place_rev_qft_spec_spec :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((ancillas (c_place_rev_qft_spec pick bound n b)) = 0%Z).

Axiom c_place_rev_qft_spec_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((size (c_place_rev_qft_spec pick bound n b)) <=
   (polysquare (n + 1%Z)%Z ((cont_size * 3%Z)%Z + 4%Z)%Z 0%Z
    (cont_size * 4%Z)%Z))%Z.

Axiom c_place_rev_qft_spec_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((width (c_place_rev_qft_spec pick bound n b)) = (n + 2%Z)%Z).

Axiom c_place_rev_qft_spec_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z))
   <= (power_ 2%Z n))%Z ->
  ((pat_sem (c_place_rev_qft_spec pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 0%Z)))
   =
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
      (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))).

Axiom c_place_rev_qft_spec_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((power_ 2%Z n) <
   (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (c_place_rev_qft_spec pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 0%Z)))
   =
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
      (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 1%Z))).

Axiom c_place_rev_qft_spec_spec5 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  forall (b':Z), ((0%Z <= b')%Z /\ (b' < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((c_place_rev_qft_spec pick bound n b) =
   (sequence (place_rev_qft_spec pick bound n b')
    (ind_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))).

Parameter c_place_rev_qft_qft: Z -> Z -> Z -> Z -> circuit.

Axiom c_place_rev_qft_qft_def :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((c_place_rev_qft_qft pick bound n b) =
   (sequence (c_place_rev_qft_spec pick bound n b)
    (place_qft_spec n
     (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
      (power_ 2%Z (n + 1%Z)%Z))))).

Axiom c_place_rev_qft_qft_spec :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((size (c_place_rev_qft_qft pick bound n b)) <=
   (polysquare (n + 1%Z)%Z ((cont_size * 6%Z)%Z + 8%Z)%Z 0%Z
    (cont_size * 4%Z)%Z))%Z.

Axiom c_place_rev_qft_qft_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((ancillas (c_place_rev_qft_qft pick bound n b)) = 0%Z).

Axiom c_place_rev_qft_qft_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((width (c_place_rev_qft_qft pick bound n b)) = (n + 2%Z)%Z).

Axiom c_place_rev_qft_qft_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z))
   <= (power_ 2%Z n))%Z ->
  ((pat_sem (c_place_rev_qft_qft pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 0%Z)))
   =
   (kronecker (apply_qft (n + 1%Z)%Z ((pick + b)%Z - bound)%Z) (ket 1%Z 0%Z))).

Axiom c_place_rev_qft_qft_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((power_ 2%Z n) <
   (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (c_place_rev_qft_qft pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 0%Z)))
   =
   (kronecker (apply_qft (n + 1%Z)%Z ((pick + b)%Z - bound)%Z) (ket 1%Z 1%Z))).

Axiom c_place_rev_qft_qft_spec5 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  forall (b':Z), ((0%Z <= b')%Z /\ (b' < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((c_place_rev_qft_qft pick bound n b) =
   (sequence (c_place_rev_qft_spec pick bound n b')
    (place_qft_spec n
     (int.EuclideanDivision.mod1 ((pick + b')%Z - bound)%Z
      (power_ 2%Z (n + 1%Z)%Z))))).

Parameter cont_add_bound: Z -> Z -> Z -> Z -> circuit.

Axiom cont_add_bound_def :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((cont_add_bound pick bound n b) =
   (cont (pre_adder_const_ (n + 1%Z)%Z (int_to_bv bound (n + 1%Z)%Z))
    (n + 1%Z)%Z 0%Z (n + 2%Z)%Z)).

Axiom cont_add_bound_spec :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((size (cont_add_bound pick bound n b)) <=
   (polysquare (n + 1%Z)%Z (cont_size * 2%Z)%Z 0%Z 0%Z))%Z.

Axiom cont_add_bound_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((ancillas (cont_add_bound pick bound n b)) = 0%Z).

Axiom cont_add_bound_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((width (cont_add_bound pick bound n b)) = (n + 2%Z)%Z).

Axiom cont_add_bound_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z))
   <= (power_ 2%Z n))%Z ->
  ((pat_sem (cont_add_bound pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z ((pick + b)%Z - bound)%Z)
     (ket 1%Z 0%Z)))
   =
   (kronecker (apply_qft (n + 1%Z)%Z ((pick + b)%Z - bound)%Z) (ket 1%Z 0%Z))).

Axiom cont_add_bound_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((power_ 2%Z n) <
   (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (cont_add_bound pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z ((pick + b)%Z - bound)%Z)
     (ket 1%Z 1%Z)))
   = (kronecker (apply_qft (n + 1%Z)%Z (pick + b)%Z) (ket 1%Z 1%Z))).

Parameter cont_adder_pre: Z -> Z -> Z -> Z -> circuit.

Axiom cont_adder_pre_def :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((cont_adder_pre pick bound n b) =
   (sequence (c_place_rev_qft_qft pick bound n b)
    (cont_add_bound pick bound n b))).

Axiom cont_adder_pre_spec :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((size (cont_adder_pre pick bound n b)) <=
   (polysquare (n + 1%Z)%Z ((cont_size * 8%Z)%Z + 8%Z)%Z 0%Z
    (cont_size * 4%Z)%Z))%Z.

Axiom cont_adder_pre_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((ancillas (cont_adder_pre pick bound n b)) = 0%Z).

Axiom cont_adder_pre_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((width (cont_adder_pre pick bound n b)) = (n + 2%Z)%Z).

Axiom cont_adder_pre_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z))
   <= (power_ 2%Z n))%Z ->
  ((pat_sem (cont_adder_pre pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 0%Z)))
   =
   (kronecker (apply_qft (n + 1%Z)%Z ((pick + b)%Z - bound)%Z) (ket 1%Z 0%Z))).

Axiom cont_adder_pre_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  ((power_ 2%Z n) <
   (int.EuclideanDivision.mod1 ((pick + b)%Z - bound)%Z
    (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (cont_adder_pre pick bound n b)
    (kronecker (apply_qft (n + 1%Z)%Z b) (ket 1%Z 0%Z)))
   = (kronecker (apply_qft (n + 1%Z)%Z (pick + b)%Z) (ket 1%Z 1%Z))).

Axiom cont_adder_pre_spec5 :
  forall (pick:Z) (bound:Z) (n:Z) (b:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((0%Z <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  ((0%Z <= b)%Z /\ (b < (power_ 2%Z (n + 1%Z)%Z))%Z) -> (pick < bound)%Z ->
  forall (b':Z), ((0%Z <= b')%Z /\ (b' < bound)%Z) ->
  ((cont_adder_pre pick bound n b) =
   (sequence (c_place_rev_qft_qft pick bound n b')
    (cont_add_bound pick bound n b'))).

Parameter subst: Z -> Z -> circuit.

Axiom subst_def :
  forall (pick:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((subst pick n) =
   (pre_adder_const_ (n + 1%Z)%Z
    (int_to_bv
     (int.EuclideanDivision.mod1 (-pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Axiom subst_spec :
  forall (pick:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((size (subst pick n)) <= (polysquare (n + 1%Z)%Z 2%Z 0%Z 0%Z))%Z.

Axiom subst_spec1 :
  forall (pick:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((ancillas (subst pick n)) = 0%Z).

Axiom subst_spec2 :
  forall (pick:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  ((width (subst pick n)) = (n + 1%Z)%Z).

Axiom subst_spec3 :
  forall (pick:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) -> forall (g:Z),
  ((pat_sem (subst pick n) (apply_qft (n + 1%Z)%Z g)) =
   (apply_qft (n + 1%Z)%Z (g - pick)%Z)).

Parameter subst_qft_rev: Z -> Z -> Z -> Z -> circuit.

Axiom subst_qft_rev_def :
  forall (pick:Z) (bound:Z) (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  (((power_ 2%Z (n - 1%Z)%Z) <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  (pick < bound)%Z ->
  ((subst_qft_rev pick bound n g) =
   (sequence (subst pick n) (qft_rev (n + 1%Z)%Z))).

Axiom subst_qft_rev_spec :
  forall (pick:Z) (bound:Z) (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  (((power_ 2%Z (n - 1%Z)%Z) <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  (pick < bound)%Z ->
  ((size (subst_qft_rev pick bound n g)) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z 0%Z))%Z.

Axiom subst_qft_rev_spec1 :
  forall (pick:Z) (bound:Z) (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  (((power_ 2%Z (n - 1%Z)%Z) <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  (pick < bound)%Z -> ((ancillas (subst_qft_rev pick bound n g)) = 0%Z).

Axiom subst_qft_rev_spec2 :
  forall (pick:Z) (bound:Z) (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  (((power_ 2%Z (n - 1%Z)%Z) <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  (pick < bound)%Z -> ((width (subst_qft_rev pick bound n g)) = (n + 1%Z)%Z).

Axiom subst_qft_rev_spec3 :
  forall (pick:Z) (bound:Z) (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  (((power_ 2%Z (n - 1%Z)%Z) <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  (pick < bound)%Z ->
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom subst_qft_rev_spec4 :
  forall (pick:Z) (bound:Z) (n:Z) (g:Z), (0%Z < n)%Z ->
  ((0%Z <= pick)%Z /\ (pick < (power_ 2%Z n))%Z) ->
  (((power_ 2%Z (n - 1%Z)%Z) <= bound)%Z /\ (bound < (power_ 2%Z n))%Z) ->
  (pick < bound)%Z ->
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (bv_to_ket
    (int_to_bv
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Parameter pick: Z.

Parameter bound: Z.

Parameter n: Z.

Parameter g: Z.

Axiom H : (0%Z < n)%Z.

Axiom H1 : (0%Z <= pick)%Z.

Axiom H2 : (pick < (power_ 2%Z n))%Z.

Axiom H3 : ((power_ 2%Z (n - 1%Z)%Z) <= bound)%Z.

Axiom H4 : (bound < (power_ 2%Z n))%Z.

Axiom H5 : (pick < bound)%Z.

Axiom H6 :
  forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z ((n + 1%Z)%Z - 1%Z)%Z))%Z) ->
  ((pat_sem (ind_neg_cnot 0%Z (n + 1%Z)%Z ((n + 1%Z)%Z + 1%Z)%Z)
    (kronecker (ket (n + 1%Z)%Z i) (ket 1%Z 1%Z)))
   = (kronecker (ket (n + 1%Z)%Z i) (ket 1%Z 0%Z))).

Axiom H7 :
  forall (i:Z),
  (((power_ 2%Z ((n + 1%Z)%Z - 1%Z)%Z) <= i)%Z /\
   (i < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((pat_sem (ind_neg_cnot 0%Z (n + 1%Z)%Z ((n + 1%Z)%Z + 1%Z)%Z)
    (kronecker (ket (n + 1%Z)%Z i) (ket 1%Z 0%Z)))
   = (kronecker (ket (n + 1%Z)%Z i) (ket 1%Z 0%Z))).

Axiom H8 :
  forall (ket1:matrix t), (is_a_ket_l ket1 (n + 1%Z)%Z) ->
  (is_a_ket_basis_elt ket1) -> (((getbv (ket_to_bv ket1)) 0%Z) = 1%Z) ->
  ((pat_sem (ind_neg_cnot 0%Z n (n + 1%Z)%Z) ket1) = ket1).

Parameter fc40: (matrix t) -> Z -> Z.

Axiom fc_def40 :
  forall (ket1:matrix t) (i:Z),
  ((i = n) -> (((fc40 ket1) i) = (1%Z - ((getbv (ket_to_bv ket1)) i))%Z)) /\
  (~ (i = n) -> (((fc40 ket1) i) = ((getbv (ket_to_bv ket1)) i))).

Axiom H9 :
  forall (ket1:matrix t), (is_a_ket_l ket1 (n + 1%Z)%Z) ->
  (is_a_ket_basis_elt ket1) -> (((getbv (ket_to_bv ket1)) 0%Z) = 0%Z) ->
  ((pat_sem (ind_neg_cnot 0%Z n (n + 1%Z)%Z) ket1) =
   (bv_to_ket (make_bv (fc40 ket1) (n + 1%Z)%Z))).

Axiom H10 :
  ((size (subst_qft_rev pick bound n g)) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z 0%Z))%Z.

Axiom H11 : ((ancillas (subst_qft_rev pick bound n g)) = 0%Z).

Axiom H12 : ((width (subst_qft_rev pick bound n g)) = (n + 1%Z)%Z).

Axiom H13 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H14 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (bv_to_ket
    (int_to_bv
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Axiom H15 :
  forall (x:matrix t) (y:matrix t),
  (is_a_ket_l x (width (subst_qft_rev pick bound n g))) ->
  (is_a_ket_l y ((n + 2%Z)%Z - (width (subst_qft_rev pick bound n g)))%Z) ->
  ((pat_sem (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
    (kronecker x y))
   = (kronecker (pat_sem (subst_qft_rev pick bound n g) x) y)).

Axiom H16 : ((ancillas (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = 0%Z).

Axiom H17 :
  ((size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) <=
   ((cont_size * 4%Z)%Z + 8%Z)%Z)%Z.

Axiom H18 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) ->
  (((flat_ang (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = ang_zero).

Axiom H19 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 1%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = x).

Parameter fc41: bitvec -> Z -> Z.

Axiom fc_def41 :
  forall (x:bitvec) (i:Z),
  ((i = (n + 1%Z)%Z) -> (((fc41 x) i) = (1%Z - ((getbv x) i))%Z)) /\
  (~ (i = (n + 1%Z)%Z) -> (((fc41 x) i) = ((getbv x) i))).

Axiom H20 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 0%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) =
   (make_bv (fc41 x) (n + 2%Z)%Z)).

Axiom H21 :
  ((width (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = (n + 2%Z)%Z).

Axiom H22 :
  ((size (subst_qft_rev pick bound n g)) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z 0%Z))%Z.

Axiom H23 : ((ancillas (subst_qft_rev pick bound n g)) = 0%Z).

Axiom H24 : ((width (subst_qft_rev pick bound n g)) = (n + 1%Z)%Z).

Axiom H25 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H26 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (bv_to_ket
    (int_to_bv
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Axiom H27 :
  ((ancillas (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (ancillas (subst_qft_rev pick bound n g))).

Axiom H28 :
  ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (size (subst_qft_rev pick bound n g))).

Axiom H29 :
  ((range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (range (subst_qft_rev pick bound n g))).

Axiom H30 :
  ((width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (n + 2%Z)%Z).

Axiom H31 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((0%Z <= i)%Z /\ (i < (n + 2%Z)%Z)%Z) ->
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    = ((getbv x) i))).

Parameter fc42: bitvec -> bitvec -> Z -> Z.

Axiom fc_def42 :
  forall (x:bitvec) (y:bitvec) (i:Z),
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc42 x y) i) =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc42 x y) i) = ((getbv x) i))).

Axiom H32 :
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (make_bv (fc42 x y) (n + 2%Z)%Z)).

Axiom H33 :
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (ang_ind_bound (subst_qft_rev pick bound n g))) ->
  ((ang_ind (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (ang_ind (subst_qft_rev pick bound n g)
    (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y)).

Axiom H34 :
  ((ancillas
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))
   =
   (ZArith.BinInt.Z.max
    (ancillas (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))
    (ancillas (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))).

Axiom H35 :
  ((size
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))
   =
   ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) +
    (size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))%Z).

Axiom H36 :
  ((range
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))
   =
   ((range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) +
    (range (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))%Z).

Axiom H37 :
  ((width
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))
   = (width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))).

Axiom H38 :
  forall (x:bitvec) (y:bitvec),
  ((length x) =
   (width
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((length y) =
   (range
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((basis_ket
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
    x y)
   =
   (basis_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
    (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
    (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))).

Axiom H39 :
  forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) =
   (width
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((length y) =
   (range
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((0%Z <= i)%Z /\
   (i < (width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z) ->
  ((basis_ket_i
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
    x y i)
   =
   (basis_ket_i (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
    (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
    (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))
    i)).

Axiom H40 :
  ((ang_ind_bound
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))
   =
   ((ang_ind_bound (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) +
    (ang_ind_bound (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))%Z).

Axiom H41 :
  forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) =
   (width
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((length y) =
   (range
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((0%Z <= i)%Z /\
   (i <
    (ang_ind_bound
     (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
      (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))))%Z) ->
  ((i <
    (ang_ind_bound (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z ->
   ((ang_ind_i
     (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
      (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
     x y i)
    =
    (ang_ind_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))
     i))) /\
  (~ (i <
      (ang_ind_bound (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z ->
   ((ang_ind_i
     (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
      (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
     x y i)
    =
    (ang_ind_i (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
     (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
      (hpart y
       (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
     (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))
     (i - (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z))).

Axiom H42 :
  forall (x:bitvec) (y:bitvec),
  ((length x) =
   (width
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((length y) =
   (range
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))) ->
  ((ang_ind
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
    x y)
   =
   (ang_add
    (ang_ind (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
    (ang_ind (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
     (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
      (hpart y
       (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
     (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))))).

Axiom H43 :
  ((size
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))
   >= 0%Z)%Z.

Axiom H44 : ((ancillas (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = 0%Z).

Axiom H45 :
  ((size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) <=
   ((cont_size * 4%Z)%Z + 8%Z)%Z)%Z.

Axiom H46 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) ->
  (((flat_ang (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = ang_zero).

Axiom H47 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 1%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = x).

Parameter fc43: bitvec -> Z -> Z.

Axiom fc_def43 :
  forall (x:bitvec) (i:Z),
  ((i = (n + 1%Z)%Z) -> (((fc43 x) i) = (1%Z - ((getbv x) i))%Z)) /\
  (~ (i = (n + 1%Z)%Z) -> (((fc43 x) i) = ((getbv x) i))).

Axiom H48 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 0%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) =
   (make_bv (fc43 x) (n + 2%Z)%Z)).

Axiom H49 :
  ((width (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = (n + 2%Z)%Z).

Axiom H50 : ((size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) >= 0%Z)%Z.

Axiom H51 :
  ((size (subst_qft_rev pick bound n g)) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z 0%Z))%Z.

Axiom H52 : ((ancillas (subst_qft_rev pick bound n g)) = 0%Z).

Axiom H53 : ((width (subst_qft_rev pick bound n g)) = (n + 1%Z)%Z).

Axiom H54 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H55 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (bv_to_ket
    (int_to_bv
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Axiom H56 :
  ((ancillas (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (ancillas (subst_qft_rev pick bound n g))).

Axiom H57 :
  ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (size (subst_qft_rev pick bound n g))).

Axiom H58 :
  ((range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (range (subst_qft_rev pick bound n g))).

Axiom H59 :
  ((width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (n + 2%Z)%Z).

Axiom H60 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((0%Z <= i)%Z /\ (i < (n + 2%Z)%Z)%Z) ->
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    = ((getbv x) i))).

Parameter fc44: bitvec -> bitvec -> Z -> Z.

Axiom fc_def44 :
  forall (x:bitvec) (y:bitvec) (i:Z),
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc44 x y) i) =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc44 x y) i) = ((getbv x) i))).

Axiom H61 :
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (make_bv (fc44 x y) (n + 2%Z)%Z)).

Axiom H62 :
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (ang_ind_bound (subst_qft_rev pick bound n g))) ->
  ((ang_ind (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (ang_ind (subst_qft_rev pick bound n g)
    (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y)).

Axiom H63 :
  ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) >= 0%Z)%Z.

Axiom H64 :
  ((size
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))
   <=
   (polysquare (n + 1%Z)%Z (((3%Z * cont_size)%Z + 2%Z)%Z + 0%Z)%Z
    (0%Z + 0%Z)%Z (0%Z + ((cont_size * 4%Z)%Z + 8%Z)%Z)%Z))%Z.

Axiom H65 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket (ket 1%Z 0%Z).

Axiom H66 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length (ket 1%Z 0%Z)) = 1%Z).

Axiom H67 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (ket 1%Z 0%Z)) = 1%Z).

Axiom H68 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (ket 1%Z 0%Z)) = (power 2%Z 1%Z)).

Axiom H69 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) -> forall (j:Z),
  (valid_index (ket 1%Z 0%Z) j 0%Z) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = (indic j 0%Z)).

Axiom H70 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z), (valid_index (ket 1%Z 0%Z) j 0%Z) -> ~ (0%Z = j) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = tzero).

Axiom H71 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) ->
  ((get (ket 1%Z 0%Z) 0%Z 0%Z) = tone).

Axiom H72 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket
  (ket (n + 1%Z)%Z
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))).

Axiom H73 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (n + 1%Z)%Z).

Axiom H74 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = 1%Z).

Axiom H75 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (power 2%Z (n + 1%Z)%Z)).

Axiom H76 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   =
   (indic j
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H77 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ~ ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) = j) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   = tzero).

Axiom H78 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) 0%Z)
   = tone).

Axiom H79 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z)))
   =
   ((rows
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (rows (ket 1%Z 0%Z)))%Z).

Axiom H80 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z)))
   =
   ((columns
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (columns (ket 1%Z 0%Z)))%Z).

Axiom H81 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (i:Z) (j:Z),
  (valid_index
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))
   i j) ->
  ((get
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z))
    i j)
   =
   (infix_asdt
    (get
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (int.EuclideanDivision.div i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.div j (columns (ket 1%Z 0%Z))))
    (get (ket 1%Z 0%Z) (int.EuclideanDivision.mod1 i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.mod1 j (columns (ket 1%Z 0%Z)))))).

Axiom H82 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket (ket 1%Z 0%Z).

Axiom H83 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length (ket 1%Z 0%Z)) = 1%Z).

Axiom H84 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (ket 1%Z 0%Z)) = 1%Z).

Axiom H85 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (ket 1%Z 0%Z)) = (power 2%Z 1%Z)).

Axiom H86 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) -> forall (j:Z),
  (valid_index (ket 1%Z 0%Z) j 0%Z) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = (indic j 0%Z)).

Axiom H87 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z), (valid_index (ket 1%Z 0%Z) j 0%Z) -> ~ (0%Z = j) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = tzero).

Axiom H88 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) ->
  ((get (ket 1%Z 0%Z) 0%Z 0%Z) = tone).

Axiom H89 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket
  (ket (n + 1%Z)%Z
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))).

Axiom H90 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (n + 1%Z)%Z).

Axiom H91 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = 1%Z).

Axiom H92 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (power 2%Z (n + 1%Z)%Z)).

Axiom H93 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   =
   (indic j
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H94 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ~ ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) = j) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   = tzero).

Axiom H95 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) 0%Z)
   = tone).

Axiom H96 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z)))
   =
   ((rows
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (rows (ket 1%Z 0%Z)))%Z).

Axiom H97 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z)))
   =
   ((columns
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (columns (ket 1%Z 0%Z)))%Z).

Axiom H98 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (i:Z) (j:Z),
  (valid_index
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))
   i j) ->
  ((get
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z))
    i j)
   =
   (infix_asdt
    (get
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (int.EuclideanDivision.div i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.div j (columns (ket 1%Z 0%Z))))
    (get (ket 1%Z 0%Z) (int.EuclideanDivision.mod1 i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.mod1 j (columns (ket 1%Z 0%Z)))))).

Axiom H99 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket (ket 1%Z 0%Z).

Axiom H100 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length (ket 1%Z 0%Z)) = 1%Z).

Axiom H101 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (ket 1%Z 0%Z)) = 1%Z).

Axiom H102 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (ket 1%Z 0%Z)) = (power 2%Z 1%Z)).

Axiom H103 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) -> forall (j:Z),
  (valid_index (ket 1%Z 0%Z) j 0%Z) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = (indic j 0%Z)).

Axiom H104 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z), (valid_index (ket 1%Z 0%Z) j 0%Z) -> ~ (0%Z = j) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = tzero).

Axiom H105 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) ->
  ((get (ket 1%Z 0%Z) 0%Z 0%Z) = tone).

Axiom H106 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket_l (apply_qft (n + 1%Z)%Z g) (n + 1%Z)%Z.

Axiom H107 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((apply_qft (n + 1%Z)%Z g) =
   (pat_sem (qft (n + 1%Z)%Z)
    (ket (n + 1%Z)%Z (int.EuclideanDivision.mod1 g (power_ 2%Z (n + 1%Z)%Z))))).

Axiom H108 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 0%Z))) =
   ((rows (apply_qft (n + 1%Z)%Z g)) * (rows (ket 1%Z 0%Z)))%Z).

Axiom H109 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 0%Z))) =
   ((columns (apply_qft (n + 1%Z)%Z g)) * (columns (ket 1%Z 0%Z)))%Z).

Axiom H110 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (i:Z) (j:Z),
  (valid_index (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 0%Z)) i j) ->
  ((get (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 0%Z)) i j) =
   (infix_asdt
    (get (apply_qft (n + 1%Z)%Z g)
     (int.EuclideanDivision.div i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.div j (columns (ket 1%Z 0%Z))))
    (get (ket 1%Z 0%Z) (int.EuclideanDivision.mod1 i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.mod1 j (columns (ket 1%Z 0%Z)))))).

Axiom H111 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ancillas (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = 0%Z).

Axiom H112 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) <=
   ((cont_size * 4%Z)%Z + 8%Z)%Z)%Z.

Axiom H113 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) ->
  (((flat_ang (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = ang_zero).

Axiom H114 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 1%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = x).

Parameter fc45: bitvec -> Z -> Z.

Axiom fc_def45 :
  forall (x:bitvec) (i:Z),
  ((i = (n + 1%Z)%Z) -> (((fc45 x) i) = (1%Z - ((getbv x) i))%Z)) /\
  (~ (i = (n + 1%Z)%Z) -> (((fc45 x) i) = ((getbv x) i))).

Axiom H115 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 0%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) =
   (make_bv (fc45 x) (n + 2%Z)%Z)).

Axiom H116 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((width (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = (n + 2%Z)%Z).

Axiom H117 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((size (subst_qft_rev pick bound n g)) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z 0%Z))%Z.

Axiom H118 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ancillas (subst_qft_rev pick bound n g)) = 0%Z).

Axiom H119 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((width (subst_qft_rev pick bound n g)) = (n + 1%Z)%Z).

Axiom H120 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H121 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (bv_to_ket
    (int_to_bv
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Axiom H122 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ancillas (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (ancillas (subst_qft_rev pick bound n g))).

Axiom H123 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (size (subst_qft_rev pick bound n g))).

Axiom H124 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (range (subst_qft_rev pick bound n g))).

Axiom H125 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (n + 2%Z)%Z).

Axiom H126 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((0%Z <= i)%Z /\ (i < (n + 2%Z)%Z)%Z) ->
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    = ((getbv x) i))).

Parameter fc46: bitvec -> bitvec -> Z -> Z.

Axiom fc_def46 :
  forall (x:bitvec) (y:bitvec) (i:Z),
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc46 x y) i) =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc46 x y) i) = ((getbv x) i))).

Axiom H127 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (make_bv (fc46 x y) (n + 2%Z)%Z)).

Axiom H128 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (ang_ind_bound (subst_qft_rev pick bound n g))) ->
  ((ang_ind (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (ang_ind (subst_qft_rev pick bound n g)
    (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y)).

Axiom H129 :
  ((power_ 2%Z n) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
    (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 0%Z)))
   =
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))).

Axiom H130 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket (ket 1%Z 0%Z).

Axiom H131 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length (ket 1%Z 0%Z)) = 1%Z).

Axiom H132 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (ket 1%Z 0%Z)) = 1%Z).

Axiom H133 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (ket 1%Z 0%Z)) = (power 2%Z 1%Z)).

Axiom H134 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) -> forall (j:Z),
  (valid_index (ket 1%Z 0%Z) j 0%Z) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = (indic j 0%Z)).

Axiom H135 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z), (valid_index (ket 1%Z 0%Z) j 0%Z) -> ~ (0%Z = j) ->
  ((get (ket 1%Z 0%Z) j 0%Z) = tzero).

Axiom H136 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 0%Z)%Z /\ (0%Z < (power 2%Z 1%Z))%Z) ->
  ((get (ket 1%Z 0%Z) 0%Z 0%Z) = tone).

Axiom H137 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket
  (ket (n + 1%Z)%Z
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))).

Axiom H138 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (n + 1%Z)%Z).

Axiom H139 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = 1%Z).

Axiom H140 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (power 2%Z (n + 1%Z)%Z)).

Axiom H141 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   =
   (indic j
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H142 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ~ ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) = j) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   = tzero).

Axiom H143 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) 0%Z)
   = tone).

Axiom H144 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z)))
   =
   ((rows
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (rows (ket 1%Z 0%Z)))%Z).

Axiom H145 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z)))
   =
   ((columns
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (columns (ket 1%Z 0%Z)))%Z).

Axiom H146 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (i:Z) (j:Z),
  (valid_index
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))
   i j) ->
  ((get
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 0%Z))
    i j)
   =
   (infix_asdt
    (get
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (int.EuclideanDivision.div i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.div j (columns (ket 1%Z 0%Z))))
    (get (ket 1%Z 0%Z) (int.EuclideanDivision.mod1 i (rows (ket 1%Z 0%Z)))
     (int.EuclideanDivision.mod1 j (columns (ket 1%Z 0%Z)))))).

Axiom H147 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket (ket 1%Z 1%Z).

Axiom H148 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length (ket 1%Z 1%Z)) = 1%Z).

Axiom H149 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (ket 1%Z 1%Z)) = 1%Z).

Axiom H150 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (ket 1%Z 1%Z)) = (power 2%Z 1%Z)).

Axiom H151 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 1%Z)%Z /\ (1%Z < (power 2%Z 1%Z))%Z) -> forall (j:Z),
  (valid_index (ket 1%Z 1%Z) j 0%Z) ->
  ((get (ket 1%Z 1%Z) j 0%Z) = (indic j 1%Z)).

Axiom H152 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z), (valid_index (ket 1%Z 1%Z) j 0%Z) -> ~ (1%Z = j) ->
  ((get (ket 1%Z 1%Z) j 0%Z) = tzero).

Axiom H153 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 1%Z)%Z /\ (1%Z < (power 2%Z 1%Z))%Z) ->
  ((get (ket 1%Z 1%Z) 1%Z 0%Z) = tone).

Axiom H154 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket
  (ket (n + 1%Z)%Z
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))).

Axiom H155 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (n + 1%Z)%Z).

Axiom H156 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = 1%Z).

Axiom H157 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
   = (power 2%Z (n + 1%Z)%Z)).

Axiom H158 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   =
   (indic j
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H159 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z),
  (valid_index
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
   j 0%Z) ->
  ~ ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) = j) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    j 0%Z)
   = tzero).

Axiom H160 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <=
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z /\
   ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
    (power 2%Z (n + 1%Z)%Z))%Z) ->
  ((get
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) 0%Z)
   = tone).

Axiom H161 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 1%Z)))
   =
   ((rows
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (rows (ket 1%Z 1%Z)))%Z).

Axiom H162 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 1%Z)))
   =
   ((columns
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))))
    * (columns (ket 1%Z 1%Z)))%Z).

Axiom H163 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (i:Z) (j:Z),
  (valid_index
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 1%Z))
   i j) ->
  ((get
    (kronecker
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (ket 1%Z 1%Z))
    i j)
   =
   (infix_asdt
    (get
     (ket (n + 1%Z)%Z
      (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
     (int.EuclideanDivision.div i (rows (ket 1%Z 1%Z)))
     (int.EuclideanDivision.div j (columns (ket 1%Z 1%Z))))
    (get (ket 1%Z 1%Z) (int.EuclideanDivision.mod1 i (rows (ket 1%Z 1%Z)))
     (int.EuclideanDivision.mod1 j (columns (ket 1%Z 1%Z)))))).

Axiom H164 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket (ket 1%Z 1%Z).

Axiom H165 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ket_length (ket 1%Z 1%Z)) = 1%Z).

Axiom H166 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (ket 1%Z 1%Z)) = 1%Z).

Axiom H167 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (ket 1%Z 1%Z)) = (power 2%Z 1%Z)).

Axiom H168 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 1%Z)%Z /\ (1%Z < (power 2%Z 1%Z))%Z) -> forall (j:Z),
  (valid_index (ket 1%Z 1%Z) j 0%Z) ->
  ((get (ket 1%Z 1%Z) j 0%Z) = (indic j 1%Z)).

Axiom H169 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (j:Z), (valid_index (ket 1%Z 1%Z) j 0%Z) -> ~ (1%Z = j) ->
  ((get (ket 1%Z 1%Z) j 0%Z) = tzero).

Axiom H170 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((0%Z <= 1%Z)%Z /\ (1%Z < (power 2%Z 1%Z))%Z) ->
  ((get (ket 1%Z 1%Z) 1%Z 0%Z) = tone).

Axiom H171 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  is_a_ket_l (apply_qft (n + 1%Z)%Z g) (n + 1%Z)%Z.

Axiom H172 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((apply_qft (n + 1%Z)%Z g) =
   (pat_sem (qft (n + 1%Z)%Z)
    (ket (n + 1%Z)%Z (int.EuclideanDivision.mod1 g (power_ 2%Z (n + 1%Z)%Z))))).

Axiom H173 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((rows (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 1%Z))) =
   ((rows (apply_qft (n + 1%Z)%Z g)) * (rows (ket 1%Z 1%Z)))%Z).

Axiom H174 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((columns (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 1%Z))) =
   ((columns (apply_qft (n + 1%Z)%Z g)) * (columns (ket 1%Z 1%Z)))%Z).

Axiom H175 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (i:Z) (j:Z),
  (valid_index (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 1%Z)) i j) ->
  ((get (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 1%Z)) i j) =
   (infix_asdt
    (get (apply_qft (n + 1%Z)%Z g)
     (int.EuclideanDivision.div i (rows (ket 1%Z 1%Z)))
     (int.EuclideanDivision.div j (columns (ket 1%Z 1%Z))))
    (get (ket 1%Z 1%Z) (int.EuclideanDivision.mod1 i (rows (ket 1%Z 1%Z)))
     (int.EuclideanDivision.mod1 j (columns (ket 1%Z 1%Z)))))).

Axiom H176 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ancillas (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = 0%Z).

Axiom H177 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) <=
   ((cont_size * 4%Z)%Z + 8%Z)%Z)%Z.

Axiom H178 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) ->
  (((flat_ang (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = ang_zero).

Axiom H179 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 1%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = x).

Parameter fc47: bitvec -> Z -> Z.

Axiom fc_def47 :
  forall (x:bitvec) (i:Z),
  ((i = (n + 1%Z)%Z) -> (((fc47 x) i) = (1%Z - ((getbv x) i))%Z)) /\
  (~ (i = (n + 1%Z)%Z) -> (((fc47 x) i) = ((getbv x) i))).

Axiom H180 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 0%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) =
   (make_bv (fc47 x) (n + 2%Z)%Z)).

Axiom H181 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((width (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = (n + 2%Z)%Z).

Axiom H182 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((size (subst_qft_rev pick bound n g)) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z 0%Z))%Z.

Axiom H183 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ancillas (subst_qft_rev pick bound n g)) = 0%Z).

Axiom H184 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((width (subst_qft_rev pick bound n g)) = (n + 1%Z)%Z).

Axiom H185 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H186 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (bv_to_ket
    (int_to_bv
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Axiom H187 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((ancillas (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (ancillas (subst_qft_rev pick bound n g))).

Axiom H188 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (size (subst_qft_rev pick bound n g))).

Axiom H189 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (range (subst_qft_rev pick bound n g))).

Axiom H190 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (n + 2%Z)%Z).

Axiom H191 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((0%Z <= i)%Z /\ (i < (n + 2%Z)%Z)%Z) ->
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    = ((getbv x) i))).

Parameter fc48: bitvec -> bitvec -> Z -> Z.

Axiom fc_def48 :
  forall (x:bitvec) (y:bitvec) (i:Z),
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc48 x y) i) =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc48 x y) i) = ((getbv x) i))).

Axiom H192 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (make_bv (fc48 x y) (n + 2%Z)%Z)).

Axiom H193 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (ang_ind_bound (subst_qft_rev pick bound n g))) ->
  ((ang_ind (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (ang_ind (subst_qft_rev pick bound n g)
    (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y)).

Axiom H194 :
  ~ ((power_ 2%Z n) <=
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z ->
  ((pat_sem
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
    (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 1%Z)))
   =
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))).

Axiom H195 : ((ancillas (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = 0%Z).

Axiom H196 :
  ((size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) <=
   ((cont_size * 4%Z)%Z + 8%Z)%Z)%Z.

Axiom H197 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) ->
  (((flat_ang (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = ang_zero).

Axiom H198 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 1%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) = x).

Parameter fc49: bitvec -> Z -> Z.

Axiom fc_def49 :
  forall (x:bitvec) (i:Z),
  ((i = (n + 1%Z)%Z) -> (((fc49 x) i) = (1%Z - ((getbv x) i))%Z)) /\
  (~ (i = (n + 1%Z)%Z) -> (((fc49 x) i) = ((getbv x) i))).

Axiom H199 :
  forall (x:bitvec), ((length x) = (n + 2%Z)%Z) -> (((getbv x) 0%Z) = 0%Z) ->
  (((flat_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) x) =
   (make_bv (fc49 x) (n + 2%Z)%Z)).

Axiom H200 :
  ((width (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)) = (n + 2%Z)%Z).

Axiom H201 :
  ((size (subst_qft_rev pick bound n g)) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z 0%Z))%Z.

Axiom H202 : ((ancillas (subst_qft_rev pick bound n g)) = 0%Z).

Axiom H203 : ((width (subst_qft_rev pick bound n g)) = (n + 1%Z)%Z).

Axiom H204 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (ket (n + 1%Z)%Z
    (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))).

Axiom H205 :
  ((pat_sem (subst_qft_rev pick bound n g) (apply_qft (n + 1%Z)%Z g)) =
   (bv_to_ket
    (int_to_bv
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z))
     (n + 1%Z)%Z))).

Axiom H206 :
  ((ancillas (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (ancillas (subst_qft_rev pick bound n g))).

Axiom H207 :
  ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (size (subst_qft_rev pick bound n g))).

Axiom H208 :
  ((range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (range (subst_qft_rev pick bound n g))).

Axiom H209 :
  ((width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) =
   (n + 2%Z)%Z).

Axiom H210 :
  forall (x:bitvec) (y:bitvec), forall (i:Z), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((0%Z <= i)%Z /\ (i < (n + 2%Z)%Z)%Z) ->
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   ((basis_ket_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y
     i)
    = ((getbv x) i))).

Parameter fc50: bitvec -> bitvec -> Z -> Z.

Axiom fc_def50 :
  forall (x:bitvec) (y:bitvec) (i:Z),
  (((0%Z <= i)%Z /\ (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc50 x y) i) =
    (basis_ket_i (subst_qft_rev pick bound n g)
     (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y (i - 0%Z)%Z))) /\
  (~ ((0%Z <= i)%Z /\
      (i < (0%Z + (width (subst_qft_rev pick bound n g)))%Z)%Z) ->
   (((fc50 x y) i) = ((getbv x) i))).

Axiom H211 :
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (range (subst_qft_rev pick bound n g))) ->
  ((basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (make_bv (fc50 x y) (n + 2%Z)%Z)).

Axiom H212 :
  forall (x:bitvec) (y:bitvec), ((length x) = (n + 2%Z)%Z) ->
  ((length y) = (ang_ind_bound (subst_qft_rev pick bound n g))) ->
  ((ang_ind (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x y) =
   (ang_ind (subst_qft_rev pick bound n g)
    (htpart x 0%Z (width (subst_qft_rev pick bound n g))) y)).

Parameter result21: circuit.

Axiom result_def21 :
  (result21 =
   (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
    (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))).

Axiom H213 :
  ((ancillas result21) =
   (ZArith.BinInt.Z.max
    (ancillas (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))
    (ancillas (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))).

Axiom H214 :
  ((size result21) =
   ((size (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) +
    (size (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))%Z).

Axiom H215 :
  ((range result21) =
   ((range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) +
    (range (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))%Z).

Axiom H216 :
  ((width result21) =
   (width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))).

Axiom H217 :
  forall (x:bitvec) (y:bitvec), ((length x) = (width result21)) ->
  ((length y) = (range result21)) ->
  ((basis_ket result21 x y) =
   (basis_ket (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
    (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
    (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))).

Axiom H218 :
  forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = (width result21)) -> ((length y) = (range result21)) ->
  ((0%Z <= i)%Z /\
   (i < (width (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z) ->
  ((basis_ket_i result21 x y i) =
   (basis_ket_i (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
    (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
    (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))
    i)).

Axiom H219 :
  ((ang_ind_bound result21) =
   ((ang_ind_bound (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)) +
    (ang_ind_bound (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)))%Z).

Axiom H220 :
  forall (x:bitvec) (y:bitvec), forall (i:Z),
  ((length x) = (width result21)) -> ((length y) = (range result21)) ->
  ((0%Z <= i)%Z /\ (i < (ang_ind_bound result21))%Z) ->
  ((i <
    (ang_ind_bound (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z ->
   ((ang_ind_i result21 x y i) =
    (ang_ind_i (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))
     i))) /\
  (~ (i <
      (ang_ind_bound (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z ->
   ((ang_ind_i result21 x y i) =
    (ang_ind_i (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
     (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
      (hpart y
       (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
     (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))
     (i - (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))%Z))).

Axiom H221 :
  forall (x:bitvec) (y:bitvec), ((length x) = (width result21)) ->
  ((length y) = (range result21)) ->
  ((ang_ind result21 x y) =
   (ang_add
    (ang_ind (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
     (hpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
    (ang_ind (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z)
     (basis_ket (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z) x
      (hpart y
       (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z))))
     (tpart y (range (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)))))).

Axiom H222 :
  ((size result21) <=
   (polysquare (n + 1%Z)%Z ((3%Z * cont_size)%Z + 2%Z)%Z 0%Z
    ((cont_size * 4%Z)%Z + 8%Z)%Z))%Z.

Axiom H223 : ((ancillas result21) = 0%Z).

Axiom H224 : ((width result21) = (n + 2%Z)%Z).

Axiom H225 :
  ((power_ 2%Z (n - 1%Z)%Z) <=
   (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))%Z.

Axiom H226 :
  ((int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)) <
   (power_ 2%Z n))%Z.

(* Why3 goal *)
Theorem VC_place_subst_qft :
  ((pat_sem
    (sequence (place (subst_qft_rev pick bound n g) 0%Z (n + 2%Z)%Z)
     (ind_neg_cnot 0%Z (n + 1%Z)%Z (n + 2%Z)%Z))
    (kronecker (apply_qft (n + 1%Z)%Z g) (ket 1%Z 0%Z)))
   =
   (kronecker
    (ket (n + 1%Z)%Z
     (int.EuclideanDivision.mod1 (g - pick)%Z (power_ 2%Z (n + 1%Z)%Z)))
    (ket 1%Z 0%Z))).
Proof.


Qed.


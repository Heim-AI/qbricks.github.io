(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require map.Map.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

Axiom set : forall (a:Type), Type.
Parameter set_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set a).
Existing Instance set_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> Prop.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom infix_eqeq_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (infix_eqeq s1 s2) <-> forall (x:a), (mem x s1) <-> (mem x s2).

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq s1 s2) -> (s1 = s2).

Parameter subset:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (subset s1 s2) <-> forall (x:a), (mem x s1) -> mem x s2.

Axiom subset_refl :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set a), subset s s.

Axiom subset_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (s3:set a), (subset s1 s2) ->
  (subset s2 s3) -> subset s1 s3.

Parameter is_empty: forall {a:Type} {a_WT:WhyType a}, (set a) -> Prop.

Axiom is_empty_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (is_empty s) <-> forall (x:a), ~ (mem x s).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, set a.

Axiom empty_def : forall {a:Type} {a_WT:WhyType a}, is_empty (empty : set a).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom add_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (add x s)) <-> ((y = x) \/ (mem y s)).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom remove_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (remove x s)) <-> (~ (y = x) /\ (mem y s)).

Axiom add_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), (mem x s) -> ((add x (remove x s)) = s).

Axiom remove_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), ((remove x (add x s)) = (remove x s)).

Axiom subset_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), subset (remove x s) s.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (union s1 s2)) <-> ((mem x s1) \/ (mem x s2)).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom inter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (inter s1 s2)) <-> ((mem x s1) /\ (mem x s2)).

Parameter diff:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom diff_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (diff s1 s2)) <-> ((mem x s1) /\ ~ (mem x s2)).

Axiom subset_diff :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), subset (diff s1 s2) s1.

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom choose_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> mem (choose s) s.

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set a) -> Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (0%Z <= (cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 0%Z) <-> (is_empty s).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), ~ (mem x s) ->
  ((cardinal (add x s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), (mem x s) ->
  ((cardinal s) = (1%Z + (cardinal (remove x s)))%Z).

Axiom cardinal_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) <= (cardinal s2))%Z.

Axiom subset_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) = (cardinal s2)) -> infix_eqeq s1 s2.

Axiom cardinal1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) ->
  (x = (choose s)).

Parameter filter:
  forall {a:Type} {a_WT:WhyType a}, (a -> bool) -> (set a) -> set a.

Axiom filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), forall (x:a),
  (mem x (filter p u)) <-> (((p x) = true) /\ (mem x u)).

Axiom filter_cardinal :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), ((cardinal (filter p u)) <= (cardinal u))%Z.

Parameter map:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> set b.

Axiom map_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (y:b),
  (mem y (map f u)) <-> exists x:a, (mem x u) /\ (y = (f x)).

Axiom map_def2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (x:a), (mem x u) -> mem (f x) (map f u).

Axiom map_cardinal :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((cardinal (map f u)) <= (cardinal u))%Z.

Axiom assert_equal :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a), (a1 = b) -> (a1 = b).

Parameter fir:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a* b)%type ->
  a.

Parameter sec:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a* b)%type ->
  b.

Axiom projections :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (o:(a* b)%type), (o = (fir o, sec o)).

Axiom union_exchange :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ~ (is_empty s') ->
  ((union (add (choose s') s) (remove (choose s') s')) = (union s s')).

Axiom inter_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s) -> is_empty (inter s s').

Axiom inter_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> is_empty (inter s s').

Axiom union_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s) -> ((union s s') = s').

Axiom union_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> ((union s s') = s).

Axiom union_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> ((union s s') = s).

Axiom set_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s':set a) (s:set a), (forall (e:a), (mem e s') -> mem e s) ->
  subset s' s.

Axiom set_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (e:a), ~ (mem e s)) ->
  (s = (empty : set a)) /\ (is_empty s).

Axiom set_equal :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (forall (e:a), (mem e s) -> mem e s') ->
  (forall (e:a), (mem e s') -> mem e s) -> (s = s').

Axiom get_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (s = (empty : set a)) ->
  (forall (e:a), ~ (mem e s)) /\ (is_empty s).

Axiom get_non_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> exists e:a, mem e s.

Axiom set_non_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (exists e:a, mem e s) ->
  ~ (is_empty s) /\ (0%Z < (cardinal s))%Z.

Axiom union_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((union s (add x s')) = (add x (union s s'))).

Axiom union_add_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((add x (union s s')) = (union s (add x s'))).

Axiom remove_add1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:a), ~ (mem x s) -> ((remove x (add x s)) = s).

Axiom add_remove1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:a), (mem x s) -> ((add x (remove x s)) = s).

(* Why3 assumption *)
Definition p_injective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) : Prop :=
  forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
  ~ ((f e) = (f e')).

Axiom map_choose :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a), forall (f:a -> b), ((choose (map f s)) = (f (choose s))).

Axiom set_map_mem :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b),
  (exists a1:a, (mem a1 s) /\ (b1 = (f a1))) -> mem b1 (map f s).

Axiom map_add :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (x:a), ~ (mem x s) ->
  ((map f (add x s)) = (add (f x) (map f s))).

Axiom map_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b) (s:set a),
  (forall (e:a), (mem e s) -> ((f e) = (g e))) -> ((map f s) = (map g s)).

Axiom set_map_mem_el :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b) (a1:a), (mem a1 s) -> (b1 = (f a1)) ->
  mem b1 (map f s).

Axiom set_map_mem_el_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b),
  (exists a1:a, (mem a1 s) /\ (b1 = (f a1))) -> mem b1 (map f s).

Axiom map_antec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b), (mem b1 (map f s)) ->
  exists a1:a, (mem a1 s) /\ (b1 = (f a1)).

Axiom map_antec_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), forall (b1:b), (mem b1 (map f s)) ->
  exists a1:a, (mem a1 s) /\ (b1 = (f a1)).

Axiom map_remove_choose :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b), (p_injective f s) ->
  ((map f (remove (choose s) s)) = (remove (choose (map f s)) (map f s))).

Parameter right_injections:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, a -> (set b) ->
  set (a* b)%type.

Axiom right_injections_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((is_empty s) -> ((right_injections a1 s) = (empty : set (a* b)%type))) /\
  (~ (is_empty s) ->
   ((right_injections a1 s) =
    (add (a1, choose s) (right_injections a1 (remove (choose s) s))))).

Axiom right_injections_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((cardinal (right_injections a1 s)) = (cardinal s)) /\
  ((forall (a':a), forall (b1:b),
    (mem (a', b1) (right_injections a1 s)) <-> ((a' = a1) /\ (mem b1 s))) /\
   ((right_injections a1 s) = (map (fun (b1:b) => (a1, b1)) s))).

Parameter left_injections:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) -> b ->
  set (a* b)%type.

Axiom left_injections_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  ((is_empty s) -> ((left_injections s b1) = (empty : set (a* b)%type))) /\
  (~ (is_empty s) ->
   ((left_injections s b1) =
    (add (choose s, b1) (left_injections (remove (choose s) s) b1)))).

Axiom left_injections_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  (forall (a1:a), forall (b':b),
   (mem (a1, b') (left_injections s b1)) <-> ((mem a1 s) /\ (b' = b1))) /\
  (((cardinal (left_injections s b1)) = (cardinal s)) /\
   ((left_injections s b1) = (map (fun (a1:a) => (a1, b1)) s))).

Axiom right_injections_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((cardinal (right_injections a1 s)) = (cardinal s)) /\
  ((forall (a':a), forall (b1:b),
    (mem (a', b1) (right_injections a1 s)) <-> ((a' = a1) /\ (mem b1 s))) /\
   ((right_injections a1 s) = (map (fun (b1:b) => (a1, b1)) s))).

Axiom left_injections_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  (forall (a1:a), forall (b':b),
   (mem (a1, b') (left_injections s b1)) <-> ((mem a1 s) /\ (b' = b1))) /\
  (((cardinal (left_injections s b1)) = (cardinal s)) /\
   ((left_injections s b1) = (map (fun (a1:a) => (a1, b1)) s))).

Axiom disjoint_injections :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b) (c:b), ~ (b1 = c) ->
  (is_empty (inter (right_injections b1 s) (right_injections c s))) /\
  (is_empty (inter (left_injections s b1) (left_injections s c))).

Axiom induction :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:(set a) -> bool) (t:set a),
  (forall (s:set a), (is_empty s) -> ((p s) = true)) ->
  (forall (s:set a), ((p s) = true) -> forall (t1:a), ~ (mem t1 s) ->
   ((p (add t1 s)) = true)) ->
  ((p t) = true).

Axiom cardinal_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a),
  ((cardinal (union s s')) =
   (((cardinal s) + (cardinal s'))%Z - (cardinal (inter s s')))%Z).

Axiom cardinal_sum_empty_inter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((inter s s') = (empty : set a)) ->
  ((cardinal (union s s')) = ((cardinal s) + (cardinal s'))%Z).

Parameter cartesian_product:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (set b) -> set (a* b)%type.

Axiom cartesian_product_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((cardinal (cartesian_product s1 s2)) = ((cardinal s1) * (cardinal s2))%Z) /\
  ((forall (a1:a), forall (b1:b),
    (mem (a1, b1) (cartesian_product s1 s2)) <-> ((mem a1 s1) /\ (mem b1 s2))) /\
   forall (o:(a* b)%type),
   (mem o (cartesian_product s1 s2)) <->
   ((mem (fir o) s1) /\ (mem (sec o) s2))).

(* Why3 assumption *)
Definition commute {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (o:(a* b)%type) : (b* a)%type :=
  match o with
  | (a1, b1) => (b1, a1)
  end.

Axiom commute_inj :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b), ((a1 = a') -> ~ (b1 = b')) ->
  ~ ((commute (a1, b1)) = (commute (a', b'))).

Axiom commute_inj_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  p_injective (fun (y0:(a* b)%type) => (commute y0))
  (cartesian_product s1 s2).

(* Why3 assumption *)
Definition commute_product {a:Type} {a_WT:WhyType a}
    {b:Type} {b_WT:WhyType b} (s1:set a) (s2:set b) : set (b* a)%type :=
  map (fun (y0:(a* b)%type) => (commute y0)) (cartesian_product s1 s2).

Axiom commute_product_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((commute_product s1 s2) = (cartesian_product s2 s1)).

(* Why3 assumption *)
Definition commute_product_el {a:Type} {a_WT:WhyType a}
    {b:Type} {b_WT:WhyType b} (s1:set a) (s2:set b) : set (b* a)%type :=
  map (fun (y0:(a* b)%type) => (commute y0)) (cartesian_product s1 s2).

Axiom commute_product_el_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type),
  match o with
  | (a1, b1) =>
      ((mem o (cartesian_product s1 s2)) <-> ((mem a1 s1) /\ (mem b1 s2))) /\
      (((mem a1 s1) /\ (mem b1 s2)) <->
       (mem (b1, a1) (commute_product_el s1 s2)))
  end.

Axiom cartesian_product_union :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (s3:set b),
  ((cartesian_product s1 (union s2 s3)) =
   (union (cartesian_product s1 s2) (cartesian_product s1 s3))).

Axiom cartesian_union_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set a) (s3:set b),
  ((cartesian_product (union s1 s2) s3) =
   (union (cartesian_product s1 s3) (cartesian_product s2 s3))).

Axiom cartesian_product_cardone_r :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s1) = 1%Z) ->
  (infix_eqeq (cartesian_product s1 s2) (right_injections (choose s1) s2)) /\
  (infix_eqeq (cartesian_product s1 s2)
   (map (fun (e2:b) => (choose s1, e2)) s2)).

Axiom cartesian_product_cardone_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s2) = 1%Z) ->
  (infix_eqeq (cartesian_product s1 s2) (left_injections s1 (choose s2))) /\
  (infix_eqeq (cartesian_product s1 s2)
   (map (fun (e1:a) => (e1, choose s2)) s1)).

Axiom disjoint_cartesian_product_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set a) (s3:set b),
  ((inter s1 s2) = (empty : set a)) ->
  ((inter (cartesian_product s1 s3) (cartesian_product s2 s3)) =
   (empty : set (a* b)%type)).

Axiom disjoint_cartesian_product_r :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (s3:set b),
  ((inter s2 s3) = (empty : set b)) ->
  ((inter (cartesian_product s1 s2) (cartesian_product s1 s3)) =
   (empty : set (a* b)%type)).

Axiom to_set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (e:a),
  ((cardinal (add e (empty : set a))) = 1%Z) /\
  forall (b:a), (mem b (add e (empty : set a))) -> (b = e).

Parameter to_fset: Z -> Z -> set Z.

Axiom to_fset_spec :
  forall (i:Z) (j:Z),
  ((i < j)%Z -> ((cardinal (to_fset i j)) = (j - i)%Z)) /\
  (((j <= i)%Z -> is_empty (to_fset i j)) /\
   forall (k:Z), (mem k (to_fset i j)) <-> ((i <= k)%Z /\ (k < j)%Z)).

Axiom choose_to_fset :
  forall (i:Z) (j:Z), (i <= j)%Z -> ((choose (to_fset i j)) = i).

Axiom to_fset_unit_ext :
  forall (i:Z) (j:Z), (i < j)%Z ->
  ((to_fset i j) = (add i (to_fset (i + 1%Z)%Z j))).

Axiom to_fset_ext :
  forall (i:Z) (i':Z) (j:Z), ((i <= i')%Z /\ (i' <= j)%Z) ->
  ((to_fset i j) = (union (to_fset i i') (to_fset i' j))).

(* Why3 assumption *)
Definition matrix (a:Type) := Z -> Z -> a.

Parameter rows: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z.

Axiom rows_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (0%Z < (rows m))%Z.

Parameter columns: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z.

Axiom columns_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (0%Z < (columns m))%Z.

(* Why3 assumption *)
Definition valid_index {a:Type} {a_WT:WhyType a} (a1:Z -> Z -> a) (r:Z)
    (c:Z) : Prop :=
  ((0%Z <= r)%Z /\ (r < (rows a1))%Z) /\
  ((0%Z <= c)%Z /\ (c < (columns a1))%Z).

(* Why3 assumption *)
Definition equal_size {a:Type} {a_WT:WhyType a} (a1:Z -> Z -> a)
    (b:Z -> Z -> a) : Prop :=
  ((rows a1) = (rows b)) /\ ((columns a1) = (columns b)).

Axiom Rows_and_columns :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), forall (x:a), forall (i:Z) (j:Z),
  (valid_index m i j) ->
  ((rows (map.Map.set m i (map.Map.set (m i) j x))) = (rows m)) /\
  ((columns (map.Map.set m i (map.Map.set (m i) j x))) = (columns m)).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z -> Z -> a.

Axiom get_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z), (valid_index a1 r c) ->
  ((get a1 r c) = ((a1 r) c)).

Parameter make: forall {a:Type} {a_WT:WhyType a}, Z -> Z -> a -> Z -> Z -> a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (v:a), ((0%Z <= r)%Z /\ (0%Z <= c)%Z) ->
  ((rows (make r c v)) = r) /\
  (((columns (make r c v)) = c) /\
   forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
   ((((make r c v) i) j) = v)).

Parameter set1:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z -> Z -> a ->
  Z -> Z -> a.

Axiom set_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((set1 a1 r c v) = (map.Map.set a1 r (map.Map.set (a1 r) c v))).

Axiom set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((rows (set1 a1 r c v)) = (rows a1)) /\
  (((columns (set1 a1 r c v)) = (columns a1)) /\
   ((forall (i:Z) (j:Z), (valid_index a1 i j) ->
     (((i = r) /\ (j = c)) -> ((((set1 a1 r c v) i) j) = v)) /\
     (~ ((i = r) /\ (j = c)) -> ((((set1 a1 r c v) i) j) = ((a1 i) j)))) /\
    (((((set1 a1 r c v) r) c) = v) /\
     ((forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (i = r) ->
       ((((set1 a1 r c v) i) j) = ((a1 i) j))) /\
      forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (j = c) ->
      ((((set1 a1 r c v) i) j) = ((a1 i) j)))))).

Parameter make_f:
  forall {a:Type} {a_WT:WhyType a}, Z -> Z -> (Z -> Z -> a) -> Z -> Z -> a.

Axiom make_f_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z <= r)%Z -> (0%Z <= c)%Z ->
  ((rows (make_f r c f)) = r) /\
  (((columns (make_f r c f)) = c) /\
   forall (i:Z) (j:Z), (valid_index (make_f r c f) i j) ->
   ((((make_f r c f) i) j) = ((f i) j))).

Axiom assert_make :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((((make_f r c f) i) j) = ((f i) j)).

Axiom assert_make_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((rows (make_f r c f)) = r).

Axiom assert_make_c :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((columns (make_f r c f)) = c).

(* Why3 assumption *)
Definition to_indexes {a:Type} {a_WT:WhyType a} (m:Z -> Z -> a) :
    set (Z* Z)%type :=
  cartesian_product (to_fset 0%Z (rows m)) (to_fset 0%Z (columns m)).

Axiom set_to_indexes_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) -> mem (i, j) (to_indexes m).

Axiom get_to_indexes_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (o:(Z* Z)%type), (mem o (to_indexes m)) ->
  ((0%Z <= (fir o))%Z /\ ((fir o) < (rows m))%Z) /\
  ((0%Z <= (sec o))%Z /\ ((sec o) < (columns m))%Z).

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter tzero: t.

Parameter tone: t.

Parameter infix_asdt: t -> t -> t.

Parameter infix_pldt: t -> t -> t.

Parameter infix_lseqdt: t -> t -> Prop.

Parameter prefix_mn: t -> t.

Axiom Assoc :
  forall (x:t) (y:t) (z:t),
  ((infix_pldt (infix_pldt x y) z) = (infix_pldt x (infix_pldt y z))).

Axiom Unit_def_l : forall (x:t), ((infix_pldt tzero x) = x).

Axiom Unit_def_r : forall (x:t), ((infix_pldt x tzero) = x).

Axiom Inv_def_l : forall (x:t), ((infix_pldt (prefix_mn x) x) = tzero).

Axiom Inv_def_r : forall (x:t), ((infix_pldt x (prefix_mn x)) = tzero).

Axiom Comm : forall (x:t) (y:t), ((infix_pldt x y) = (infix_pldt y x)).

Axiom Assoc1 :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt (infix_asdt x y) z) = (infix_asdt x (infix_asdt y z))).

Axiom Mul_distr_l :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt x (infix_pldt y z)) =
   (infix_pldt (infix_asdt x y) (infix_asdt x z))).

Axiom Mul_distr_r :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt (infix_pldt y z) x) =
   (infix_pldt (infix_asdt y x) (infix_asdt z x))).

Axiom Comm1 : forall (x:t) (y:t), ((infix_asdt x y) = (infix_asdt y x)).

Axiom Unitary : forall (x:t), ((infix_asdt tone x) = x).

Axiom NonTrivialRing : ~ (tzero = tone).

Axiom Refl : forall (x:t), infix_lseqdt x x.

Axiom Trans :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (infix_lseqdt y z) ->
  infix_lseqdt x z.

Axiom Antisymm :
  forall (x:t) (y:t), (infix_lseqdt x y) -> (infix_lseqdt y x) -> (x = y).

(* Why3 assumption *)
Definition infix_mndt (x:t) (y:t) : t := infix_pldt x (prefix_mn y).

(* Why3 assumption *)
Definition infix_lsdt (i:t) (j:t) : Prop := (infix_lseqdt i j) /\ ~ (i = j).

Parameter requal: t -> t -> bool.

Axiom requal_spec : forall (a:t) (b:t), ((requal a b) = true) <-> (a = b).

Axiom invadd :
  forall (i:t), ((prefix_mn i) = (infix_asdt (prefix_mn tone) i)).

Axiom ZeroLessOne : infix_lsdt tzero tone.

Axiom absorbing_zero : forall (i:t), ((infix_asdt i tzero) = tzero).

(* Why3 assumption *)
Definition comparable (a:t) (b:t) : Prop :=
  (infix_lseqdt a b) \/ (infix_lseqdt b a).

Axiom Transitive_comparable :
  forall (x:t) (y:t) (z:t), (comparable x y) -> (comparable y z) ->
  comparable x z.

Axiom Unitary_comparable :
  forall (x:t) (y:t), (comparable x y) ->
  (comparable x tzero) /\ (comparable x tone).

Axiom CompatStrictOrderAdd :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (comparable x z) ->
  infix_lsdt (infix_pldt x z) (infix_pldt y z).

Axiom notZeroAdd :
  forall (x:t) (y:t), ~ (x = tzero) -> ~ ((infix_pldt x y) = y).

Axiom CompatOrderMult :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (infix_lsdt tzero z) ->
  infix_lsdt (infix_asdt x z) (infix_asdt y z).

Axiom compatStrictOrderMultComm :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (infix_lsdt tzero z) ->
  infix_lsdt (infix_asdt z x) (infix_asdt z y).

Axiom compatOrderMult :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (infix_lseqdt tzero z) ->
  infix_lseqdt (infix_asdt x z) (infix_asdt y z).

Axiom compatOrderMultComm :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (infix_lseqdt tzero z) ->
  infix_lseqdt (infix_asdt z x) (infix_asdt z y).

Parameter inv: t -> t.

Axiom Inverse :
  forall (x:t), ~ (x = tzero) -> ((infix_asdt x (inv x)) = tone).

(* Why3 assumption *)
Definition infix_sldt (x:t) (y:t) : t := infix_asdt x (inv y).

Axiom add_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sldt (infix_pldt x y) z) =
   (infix_pldt (infix_sldt x z) (infix_sldt y z))).

Axiom sub_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sldt (infix_mndt x y) z) =
   (infix_mndt (infix_sldt x z) (infix_sldt y z))).

Axiom neg_div :
  forall (x:t) (y:t), ~ (y = tzero) ->
  ((infix_sldt (prefix_mn x) y) = (prefix_mn (infix_sldt x y))).

Axiom assoc_mul_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sldt (infix_asdt x y) z) = (infix_asdt x (infix_sldt y z))).

Axiom assoc_div_mul :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sldt (infix_sldt x y) z) = (infix_sldt x (infix_asdt y z))).

Axiom assoc_div_div :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sldt x (infix_sldt y z)) = (infix_sldt (infix_asdt x z) y)).

Axiom inv_mult :
  forall (x:t) (y:t), ~ (x = tzero) -> ~ (y = tzero) ->
  ((infix_asdt (infix_sldt tone x) (infix_sldt tone y)) =
   (infix_sldt tone (infix_asdt x y))).

Parameter op: forall {im:Type} {im_WT:WhyType im}, im -> im -> im.

Parameter po: forall {im:Type} {im_WT:WhyType im}, im -> im -> im.

Parameter inver: forall {im:Type} {im_WT:WhyType im}, im -> im.

(* Why3 assumption *)
Definition op_neutral_left {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neutral:im) : Prop :=
  forall (e:im), (((op1 neutral) e) = e).

(* Why3 assumption *)
Definition op_neutral_right {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neutral:im) : Prop :=
  forall (e:im), (((op1 e) neutral) = e).

(* Why3 assumption *)
Definition op_assoc {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  forall (a:im) (b:im) (c:im),
  (((op1 ((op1 a) b)) c) = ((op1 a) ((op1 b) c))).

(* Why3 assumption *)
Definition op_neutral_left_comm {im:Type} {im_WT:WhyType im}
    (op1:im -> im -> im) (neutral:im) : Prop :=
  forall (a:im), (forall (b:im), (((op1 a) b) = b)) -> (a = neutral).

(* Why3 assumption *)
Definition commut {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  forall (a:im) (b:im), (((op1 a) b) = ((op1 b) a)).

(* Why3 assumption *)
Definition assoc {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  forall (a:im) (b:im) (c:im),
  (((op1 ((op1 a) b)) c) = ((op1 a) ((op1 b) c))).

(* Why3 assumption *)
Definition opposite_n {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) (neutral:im) : Prop :=
  forall (a:im), (((po1 a) a) = neutral).

(* Why3 assumption *)
Definition inverse {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) (inver1:im -> im) : Prop :=
  forall (a:im) (b:im), (((po1 a) b) = ((op1 a) (inver1 b))).

(* Why3 assumption *)
Definition opposite {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) : Prop :=
  forall (a:im) (b:im), (((op1 ((po1 a) b)) b) = a).

(* Why3 assumption *)
Definition opposite_com {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) : Prop :=
  forall (a:im) (b:im), (((po1 ((op1 a) b)) b) = a).

Axiom refl :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (a:im) (b:im), (commut op1) ->
  (((op1 a) b) = ((op1 b) a)).

(* Why3 assumption *)
Definition neutral {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neut:im) : Prop :=
  (op_neutral_left op1 neut) /\
  ((op_neutral_right op1 neut) /\ (op_assoc op1)).

Axiom set_neutral :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (neut:im), (op_neutral_left op1 neut) ->
  (op_neutral_right op1 neut) -> (op_assoc op1) -> neutral op1 neut.

(* Why3 assumption *)
Definition has_neutral {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) :
    Prop :=
  exists e:im, neutral op1 e.

(* Why3 assumption *)
Definition iterates {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neutral1:im) : Prop :=
  (op_neutral_left op1 neutral1) /\
  ((op_neutral_right op1 neutral1) /\ (op_assoc op1)).

(* Why3 assumption *)
Definition iterable {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  exists e:im, iterates op1 e.

Parameter neutral_elt:
  forall {im:Type} {im_WT:WhyType im}, (im -> im -> im) -> im.

Axiom neutral_elt_spec :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im), forall (e:im),
  (neutral op1 e) <-> ((neutral_elt op1) = e).

(* Why3 assumption *)
Definition inverse_tuple {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) (neutral1:im) : Prop :=
  (opposite_n op1 po1 neutral1) /\
  ((opposite op1 po1) /\ (opposite_com op1 po1)).

Parameter iterate:
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  (im -> im -> im) -> (set a) -> (a -> im) -> im.

Axiom Iterate_def_empty :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im), forall (s:set a), forall (f:a -> im),
  (is_empty s) -> ((iterate op1 (empty : set a) f) = (neutral_elt op1)).

Axiom Iterate_add :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im), forall (s:set a), forall (f:a -> im),
  forall (x:a), ~ (mem x s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom minus_zero :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (a:im), (iterable op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  (((po1 a) (neutral_elt op1)) = a).

Axiom unic :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (a:im) (b:im) (c:im),
  (iterable op1) -> (commut op1) -> (((op1 a) b) = ((op1 a) c)) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) -> (b = c).

Axiom substract_comm :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (a:im) (b:im) (c:im),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  (((po1 ((op1 a) b)) a) = b) /\
  ((((po1 ((op1 b) a)) a) = b) /\
   ((((po1 a) ((po1 b) c)) = ((op1 ((po1 a) b)) c)) /\
    (((po1 ((op1 a) b)) c) = ((op1 a) ((po1 b) c))))).

Parameter int_iterate:
  forall {im:Type} {im_WT:WhyType im}, (im -> im -> im) -> (Z -> im) -> 
  Z -> Z -> im.

Axiom int_iterate_def :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z),
  ((j <= i)%Z -> ((int_iterate op1 f i j) = (neutral_elt op1))) /\
  (~ (j <= i)%Z ->
   ((int_iterate op1 f i j) =
    ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j)))).

Axiom int_iterate_spec :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (j <= i)%Z ->
  ((int_iterate op1 f i j) = (neutral_elt op1)).

Parameter int_int_iterate:
  forall {im:Type} {im_WT:WhyType im}, (im -> im -> im) -> (Z -> Z -> im) ->
  Z -> Z -> Z -> Z -> im.

Axiom int_int_iterate_def :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> Z -> im) (i:Z) (j:Z) (k:Z) (l:Z),
  ((j <= i)%Z -> ((int_int_iterate op1 f i j k l) = (neutral_elt op1))) /\
  (~ (j <= i)%Z ->
   ((int_int_iterate op1 f i j k l) =
    ((op1 (int_iterate op1 ((fun (y0:Z -> im) (y1:Z) => (y0 y1)) (f i)) k l))
     (int_int_iterate op1 f (i + 1%Z)%Z j k l)))).

Parameter element: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom element_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> ((element s) = (choose s)).

Axiom cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  (0%Z < (cardinal s))%Z -> ((cardinal s) = 1%Z) /\ ((element s) = a1).

Axiom set_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (0%Z < (cardinal s))%Z ->
  (exists a1:a, forall (b:a), (mem b s) <-> (b = a1)) -> ((cardinal s) = 1%Z).

Axiom set_cardone_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (0%Z < (cardinal s))%Z ->
  (forall (b:a), (mem b s) <-> (b = a1)) -> ((cardinal s) = 1%Z).

Axiom cardzero :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (b:a), ~ (mem b s)) -> ((cardinal s) = 0%Z).

(* Why3 assumption *)
Definition p_injective_in {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) (s':set b) : Prop :=
  forall (e:a), (mem e s) ->
  (mem (f e) s') /\
  forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
  ~ ((f e1) = (f e')).

Axiom set_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a),
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  p_injective f s.

Axiom image_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), forall (a1:b),
  (mem a1 (map f s)) <->
  exists antec_a:a, (mem antec_a s) /\ (a1 = (f antec_a)).

Axiom card_image :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((cardinal (map f s)) <= (cardinal s))%Z.

Axiom card_image_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) ->
  ((cardinal (map f s)) = (cardinal s)).

Axiom get_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) -> forall (e:a) (e':a),
  (mem e s) -> (mem e' s) -> ~ (e = e') -> ~ ((f e) = (f e')).

Axiom set_injective_in :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  p_injective f s.

Axiom get_injective_in :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_injective_in f s s') ->
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
  ~ ((f e) = (f e')).

(* Why3 assumption *)
Definition p_surjective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) (s':set b) : Prop :=
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e').

Axiom set_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  p_surjective f s s'.

Axiom get_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_surjective f s s') ->
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e').

Axiom image_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_surjective f s s') ->
  ((map f s) = s').

(* Why3 assumption *)
Definition p_bijective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) (s':set b) : Prop :=
  (p_injective_in f s s') /\ (p_surjective f s s').

Axiom bijective_is_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_injective f s.

Axiom bijective_is_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_surjective f s s'.

Axiom set_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  (p_bijective f s s') /\ ((map f s) = s').

Axiom bijective_image :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a) (s':set a), (p_bijective f s s') ->
  ((cardinal s) = (cardinal s')) /\ (s' = (map f s)).

Axiom get_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  ((forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
    ~ ((f e) = (f e'))) /\
   ((forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) /\
    ((cardinal s) = (cardinal s')))).

Axiom iterate_empty :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (is_empty s) ->
  ((iterate op1 s t1) = (neutral_elt op1)).

Axiom iterate_add :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (x:a), ~ (mem x s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom iterate_remove :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (x:a), (commut op1) ->
  (iterable op1) ->
  (inverse_tuple op1 (fun (y0:im) (y1:im) => (po y0 y1)) (neutral_elt op1)) ->
  (mem x s) -> ((iterate op1 (remove x s) f) = (po (iterate op1 s f) (f x))).

Axiom iterate_def_choose :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im), (iterable op1) ->
  ~ (is_empty s) ->
  ((iterate op1 s f) =
   ((op1 (f (choose s))) (iterate op1 (remove (choose s) s) f))).

Axiom choose_any :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (t1:a), (iterable op1) ->
  (mem t1 s) ->
  ((iterate op1 s f) = ((op1 (f t1)) (iterate op1 (remove t1 s) f))).

Axiom iterate_comp_iterate :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (f:a -> im) (g:a -> im),
  (iterable op1) -> (commut op1) -> (assoc op1) ->
  ((iterate op1 s1 (fun (k:a) => ((op1 (f k)) (g k)))) =
   ((op1 (iterate op1 s1 (fun (k:a) => (f k))))
    (iterate op1 s1 (fun (k:a) => (g k))))).

Axiom iterate_comp_iterate_com :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (f:a -> im) (g:a -> im),
  (iterable op1) -> (commut op1) ->
  (((op1 (iterate op1 s1 (fun (k:a) => (f k))))
    (iterate op1 s1 (fun (k:a) => (g k))))
   = (iterate op1 s1 (fun (k:a) => ((op1 (f k)) (g k))))).

Axiom iterate_transitivity :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (s1:set a) (s2:set a)
    (f:a -> im),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  ((iterate op1 (union s1 s2) f) =
   ((po1 ((op1 (iterate op1 s1 f)) (iterate op1 s2 f)))
    (iterate op1 (inter s1 s2) f))).

Axiom iterate_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (s2:set a) (t1:a -> im),
  (iterable op1) -> (commut op1) -> ((inter s1 s2) = (empty : set a)) ->
  ((iterate op1 (union s1 s2) t1) =
   ((op1 (iterate op1 s1 t1)) (iterate op1 s2 t1))).

Axiom iterate_eq :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (g:a -> im),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) ->
  ((iterate op1 s f) = (iterate op1 s g)).

Axiom iterate_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set b) (f:b -> a) (t1:a -> im),
  (iterable op1) -> (p_injective f s) ->
  ((iterate op1 (map f s) t1) = (iterate op1 s (fun (b1:b) => (t1 (f b1))))).

Axiom iterate_cardone :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (iterable op1) ->
  ((cardinal s) = 1%Z) -> ((iterate op1 s t1) = (t1 (element s))).

Axiom iterate_cardzero :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (iterable op1) ->
  ((cardinal s) = 0%Z) -> ((iterate op1 s t1) = (neutral_elt op1)).

Axiom injec_iterate :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (a1:a) (s:set b) (f:a -> b -> im),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s (f a1)) =
   (iterate op1 (cartesian_product (add a1 (empty : set a)) s)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (s2:set b) (f:a -> b -> im),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s1 (fun (a1:a) => (iterate op1 s2 (f a1)))) =
   (iterate op1 (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_eq_func :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f1:a -> im) (f2:a -> im),
  (iterable op1) -> (p_injective f1 s) -> (p_injective f2 s) ->
  ((map f1 s) = (map f2 s)) -> ((iterate op1 s f1) = (iterate op1 s f2)).

Axiom int_iterate_def_empty :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (j <= i)%Z ->
  ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_def_plus_one :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (i < j)%Z ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))).

Axiom int_iterate_cardone :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  (iterable op1) -> ((int_iterate op1 f i j) = (f i)).

Axiom int_iterate_def_plus_one_com :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (i < j)%Z ->
  (((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j)) = (int_iterate op1 f i j)).

Axiom int_iterate_to_iterate :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z),
  ((int_iterate op1 f i j) = (iterate op1 (to_fset i j) f)).

Axiom int_iterate_right_extension :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (assoc op1) ->
  (i < j)%Z ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i (j - 1%Z)%Z)) (f (j - 1%Z)%Z))).

Axiom int_iterate_transitivity :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (k:Z) (j:Z), (assoc op1) ->
  (op_neutral_left op1 (neutral_elt op1)) -> ((i <= k)%Z /\ (k <= j)%Z) ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i k)) (int_iterate op1 f k j))).

Axiom int_iterate_comp_iterate :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (g:Z -> im) (i:Z) (j:Z),
  (assoc op1) -> (op_neutral_right op1 (neutral_elt op1)) -> (commut op1) ->
  ((int_iterate op1 (fun (k:Z) => ((op1 (f k)) (g k))) i j) =
   ((op1 (int_iterate op1 f i j)) (int_iterate op1 g i j))).

Axiom int_iterate_attr_no_f :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (t2:Z -> im2) (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (t2 x)) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (assoc op1) ->
  (assoc op2) -> (forall (i1:Z), ((f (t1 i1)) = (t2 i1))) ->
  ((int_iterate op2 t2 i j) = (f (int_iterate op1 t1 i j))).

Axiom int_iterate_attr :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t1 x))) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (assoc op1) ->
  (assoc op2) ->
  ((int_iterate op2 (fun (e:Z) => (f (t1 e))) i j) =
   (f (int_iterate op1 t1 i j))).

Axiom int_iterate_attr_comm :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t1 x))) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (assoc op1) ->
  (assoc op2) ->
  ((f (int_iterate op1 t1 i j)) =
   (int_iterate op2 (fun (e:Z) => (f (t1 e))) i j)).

Axiom int_iterate_eq :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (g:Z -> im) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((int_iterate op1 f i j) = (int_iterate op1 g i j)).

Axiom int_iterate_left_right :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (l:Z) (k:Z) (h:Z), (assoc op1) ->
  (commut op1) -> ((l <= k)%Z /\ (k <= h)%Z) ->
  ((int_iterate op1 f l k) =
   (int_iterate op1 (fun (a:Z) => (f ((h - (a + 1%Z)%Z)%Z + l)%Z))
    ((h - k)%Z + l)%Z h)).

Axiom int_iterate_eq_func :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (f1:Z -> im) (f2:Z -> im),
  (iterable op1) -> (p_injective f1 (to_fset i j)) ->
  (p_injective f2 (to_fset i j)) ->
  ((map f1 (to_fset i j)) = (map f2 (to_fset i j))) ->
  ((int_iterate op1 f1 i j) = (int_iterate op1 f2 i j)).

Axiom int_iterate_map :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> im),
  (iterable op1) -> (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((int_iterate op1 t1 k l) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Axiom int_iterate_map_auto :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> im),
  (iterable op1) -> (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((int_iterate op1 t1 i j) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Parameter result:
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  (im -> im -> im) -> (a -> im) -> a -> bool.

Axiom result_def :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (t1:a -> im) (e:a),
  (((result op1 t1) e) = true) <-> ~ (neutral op1 (t1 e)).

(* Why3 assumption *)
Definition nonn_part {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im}
    (op1:im -> im -> im) (s:set a) (t1:a -> im) : set a :=
  filter (result op1 t1) s.

Axiom nonn_part_spec :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), forall (e:a),
  (mem e (nonn_part op1 s t1)) <-> ((mem e s) /\ ~ (neutral op1 (t1 e))).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  (im -> im -> im) -> (a -> im) -> a -> bool.

Axiom result_def1 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (t1:a -> im) (e:a),
  (((result1 op1 t1) e) = true) <-> (neutral op1 (t1 e)).

(* Why3 assumption *)
Definition n_part {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im}
    (op1:im -> im -> im) (s:set a) (t1:a -> im) : set a :=
  filter (result1 op1 t1) s.

Axiom n_part_spec :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), forall (e:a),
  (mem e (n_part op1 s t1)) <-> ((mem e s) /\ (neutral op1 (t1 e))).

Axiom nullity_partition :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (commut op1) ->
  (s = (union (nonn_part op1 s t1) (n_part op1 s t1))) /\
  ((inter (nonn_part op1 s t1) (n_part op1 s t1)) = (empty : set a)).

Axiom iterate_neutral :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (iterable op1) ->
  (commut op1) ->
  (forall (a1:a), (mem a1 s) -> ((t1 a1) = (neutral_elt op1))) ->
  ((iterate op1 s t1) = (neutral_elt op1)).

Axiom iterate_nullity_partition :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (iterable op1) ->
  (commut op1) ->
  ((iterate op1 s t1) = (iterate op1 (nonn_part op1 s t1) t1)).

(* Why3 assumption *)
Definition couple {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im:Type} {im_WT:WhyType im} (f:a -> b -> im) (o:(a* b)%type) : im :=
  match o with
  | (a1, b1) => (f a1) b1
  end.

Axiom null_product :
  forall (a:t) (b:t), ((infix_asdt a b) = tzero) ->
  (a = tzero) \/ (b = tzero).

(* Why3 assumption *)
Definition sum {a:Type} {a_WT:WhyType a} (s:set a) (t1:a -> t) : t :=
  iterate (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) s t1.

Axiom sum_iter : iterates (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) tzero.

Axiom sum_iter__ : iterable (fun (y0:t) (y1:t) => (infix_pldt y0 y1)).

Axiom sum_add :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> t) (x:b), ~ (mem x s) ->
  ((sum (add x s) f) = (infix_pldt (f x) (sum s f))).

Axiom map_sum_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> a) (t1:a -> t), (p_injective f s) ->
  ((sum (map f s) t1) = (sum s (fun (b1:b) => (t1 (f b1))))).

Axiom sum_iter_ :
  (opposite_n (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
   (fun (y0:t) (y1:t) => (infix_mndt y0 y1)) tzero) /\
  ((opposite (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
    (fun (y0:t) (y1:t) => (infix_mndt y0 y1))) /\
   ((opposite_com (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
     (fun (y0:t) (y1:t) => (infix_mndt y0 y1))) /\
    (inverse_tuple (fun (y0:t) (y1:t) => (infix_pldt y0 y1))
     (fun (y0:t) (y1:t) => (infix_mndt y0 y1)) tzero))).

Axiom neutral_zero :
  ((neutral_elt (fun (y0:t) (y1:t) => (infix_pldt y0 y1))) = tzero).

Axiom sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (g:a -> t),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> ((sum s f) = (sum s g)).

Axiom sum_const_mult :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (c:t),
  ((sum s (fun (x:a) => (infix_asdt c (f x)))) = (infix_asdt c (sum s f))).

(* Why3 assumption *)
Definition ind_sum (f:Z -> t) (i:Z) (j:Z) : t :=
  int_iterate (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) f i j.

Axiom ind_sum_comp :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  ((ind_sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j) =
   (infix_pldt (ind_sum f i j) (ind_sum g i j))).

Axiom ind_sum_eq :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_sum f i j) = (ind_sum g i j)).

Axiom ind_sum_const_mult :
  forall (f:Z -> t) (i:Z) (j:Z) (c:t),
  ((ind_sum (fun (x:Z) => (infix_asdt c (f x))) i j) =
   (infix_asdt c (ind_sum f i j))).

Axiom ind_sum_to_iterate :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((ind_sum f i j) =
   (iterate (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) (to_fset i j) f)).

Axiom ind_sum_to_sum :
  forall (f:Z -> t) (i:Z) (j:Z), ((ind_sum f i j) = (sum (to_fset i j) f)).

Axiom map_ind_sum_eq :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> t),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_sum t1 k l) = (ind_sum (fun (b:Z) => (t1 (f b))) i j)).

Axiom sum_scal :
  forall (f:Z -> t) (s:set Z) (a:t),
  ((sum s (fun (i:Z) => (infix_asdt a (f i)))) = (infix_asdt a (sum s f))).

Axiom sum_scal_gen :
  forall (f:Z -> t) (s:set Z), forall (a:t),
  ((sum s (fun (i:Z) => (infix_asdt a (f i)))) = (infix_asdt a (sum s f))).

(* Why3 assumption *)
Definition non_tzero {a:Type} {a_WT:WhyType a} (s:set a) (t1:a -> t) : set a :=
  nonn_part (fun (y0:t) (y1:t) => (infix_pldt y0 y1)) s t1.

Axiom non_tzero_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (e:a),
  (mem e (non_tzero s t1)) <-> ((mem e s) /\ ~ ((t1 e) = tzero)).

Axiom non_tzero_member :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  exists result2:set a,
  forall (e:a), (mem e result2) <-> ((mem e s) /\ ~ ((t1 e) = tzero)).

Axiom sum_nullity_partition :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((sum s t1) = (sum (non_tzero s t1) t1)).

Axiom non_null_map :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> a) (t1:a -> t),
  ((non_tzero (map f s) t1) =
   (map f (non_tzero s (fun (b:a) => (t1 (f b)))))).

Axiom map_sum_eq_nonnull :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> a) (t1:a -> t),
  (p_bijective f (non_tzero s (fun (b:a) => (t1 (f b))))
   (non_tzero (map f s) t1)) ->
  ((sum (non_tzero (map f s) t1) t1) =
   (sum (non_tzero s (fun (b:a) => (t1 (f b)))) (fun (b:a) => (t1 (f b))))).

Axiom sum_null_but_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal (non_tzero s t1)) = 1%Z) ->
  ((sum s t1) = (t1 (element (non_tzero s t1)))).

Axiom sum_null :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal (non_tzero s t1)) = 0%Z) ->
  ((sum s t1) = tzero).

Axiom sum_null_but_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (elt:a),
  ((mem elt s) /\ ~ ((t1 elt) = tzero)) ->
  (forall (a1:a), (mem a1 s) -> ~ (a1 = elt) -> ((t1 a1) = tzero)) ->
  ((sum s t1) = (t1 elt)).

Axiom sum_null_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (t1:a -> t) (s:set a) (elt:a), (mem elt s) ->
  (forall (k:a), (mem k s) -> ~ (k = elt) -> ((t1 k) = tzero)) ->
  ((sum s t1) = (t1 elt)).

Axiom ind_sum_null_but_maybe_one_elt :
  forall (t1:Z -> t) (i:Z) (j:Z) (ind:Z), ((i <= ind)%Z /\ (ind < j)%Z) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ~ (k = ind) ->
   ((t1 k) = tzero)) ->
  ((ind_sum t1 i j) = (t1 ind)).

(* Why3 assumption *)
Definition product {a:Type} {a_WT:WhyType a} (s:set a) (t1:a -> t) : t :=
  iterate (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) s t1.

Axiom product_iter :
  (op_neutral_left (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone) /\
  (((op_neutral_right (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone) /\
    (op_assoc (fun (y0:t) (y1:t) => (infix_asdt y0 y1)))) /\
   ((commut (fun (y0:t) (y1:t) => (infix_asdt y0 y1))) /\
    (iterates (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone))).

Axiom product_iter_ : iterable (fun (y0:t) (y1:t) => (infix_asdt y0 y1)).

Axiom neutral_one :
  ((neutral_elt (fun (y0:t) (y1:t) => (infix_asdt y0 y1))) = tone).

(* Why3 assumption *)
Definition ind_product (f:Z -> t) (i:Z) (j:Z) : t :=
  int_iterate (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) f i j.

Axiom ind_product_eq :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_product f i j) = (ind_product g i j)).

Axiom ind_product_right_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_product f i j) =
   (infix_asdt (ind_product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom ind_product_left_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_product f i j) = (infix_asdt (f i) (ind_product f (i + 1%Z)%Z j))).

Axiom ind_product_to_product :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((ind_product f i j) = (product (to_fset i j) f)).

Axiom ind_product_right_extension_comm :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((infix_asdt (ind_product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z)) =
   (ind_product f i j)).

Axiom ind_product_eq_func :
  forall (i:Z) (j:Z) (f1:Z -> t) (f2:Z -> t),
  (p_injective f1 (to_fset i j)) -> (p_injective f2 (to_fset i j)) ->
  ((map f1 (to_fset i j)) = (map f2 (to_fset i j))) ->
  ((ind_product f1 i j) = (ind_product f2 i j)).

Axiom div_plus_one :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (((int.EuclideanDivision.div i j) * j)%Z <= i)%Z /\
  (i < (((int.EuclideanDivision.div i j) + 1%Z)%Z * j)%Z)%Z.

Axiom bound_eq :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < j)%Z) ->
  (i = (int.EuclideanDivision.mod1 i j)).

Axiom unicity_div_mod :
  forall (i:Z) (j:Z) (q:Z) (r:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z ->
  (0%Z <= r)%Z -> (0%Z < j)%Z -> (i = ((q * j)%Z + r)%Z) ->
  ((0%Z <= r)%Z /\ (r < j)%Z) ->
  (q = (int.EuclideanDivision.div i j)) /\
  (r = (int.EuclideanDivision.mod1 i j)).

Axiom bound_mod :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (0%Z <= (int.EuclideanDivision.mod1 i j))%Z /\
  ((int.EuclideanDivision.mod1 i j) < j)%Z.

Axiom decomp :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i =
   ((j * (int.EuclideanDivision.div i j))%Z +
    (int.EuclideanDivision.mod1 i j))%Z).

Axiom div_mod_eq :
  forall (i:Z) (j:Z) (q:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z < q)%Z ->
  ((int.EuclideanDivision.div i q) = (int.EuclideanDivision.div j q)) ->
  ((int.EuclideanDivision.mod1 i q) = (int.EuclideanDivision.mod1 j q)) ->
  (i = j).

Axiom mod_zero :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) = 0%Z) ->
  (i = (j * (int.EuclideanDivision.div i j))%Z).

Axiom div_plus_quotient :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.div (i + j)%Z j) =
   ((int.EuclideanDivision.div i j) + 1%Z)%Z).

Axiom div_plus_fact_gen_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (i + (k * j)%Z)%Z j) =
   ((int.EuclideanDivision.div i j) + k)%Z).

Axiom mod_plus_fact_gen_mod :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z <= k)%Z ->
  ((int.EuclideanDivision.mod1 ((k * j)%Z + i)%Z j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom bound_div :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z ->
  ((0%Z <= ((int.EuclideanDivision.div i q) * q)%Z)%Z /\
   ((((int.EuclideanDivision.div i q) * q)%Z <= i)%Z /\
    (i < (q * ((int.EuclideanDivision.div i q) + 1%Z)%Z)%Z)%Z)) /\
  ((int.EuclideanDivision.div i q) < f)%Z.

Axiom bound_div_gen :
  forall (q:Z) (f:Z), (0%Z <= q)%Z -> (0%Z <= f)%Z -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (q * f)%Z)%Z) ->
  ((int.EuclideanDivision.div i q) < f)%Z.

Axiom mod_invariant :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1
    ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z +
     (int.EuclideanDivision.mod1 i (q * f)%Z))%Z
    q)
   = (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (q * f)%Z) q)).

Axiom mod_mod_left :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mod_mod_right :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mod_mod_rev :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j)) /\
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j)).

Axiom mod_mod_plus :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j + j)%Z) j)).

Axiom mult_assoc :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z =
   ((q * f)%Z * (int.EuclideanDivision.div i (q * f)%Z))%Z).

Axiom div_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (k * j)%Z)) /\
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (j * k)%Z)).

Axiom mod_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.mod1 i (j * k)%Z) j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.div i j) k)).

Axiom inf_mul :
  forall (ia:Z) (ib:Z) (a:Z) (b:Z), ((0%Z <= ia)%Z /\ (ia < a)%Z) ->
  ((0%Z <= ib)%Z /\ (ib < b)%Z) ->
  (((a * ib)%Z + ia)%Z < (a * b)%Z)%Z /\ (((ib * a)%Z + ia)%Z < (b * a)%Z)%Z.

Axiom inf_mul_gen :
  forall (n:Z) (v:Z) (p:Z), ((0%Z <= p)%Z /\ (p < v)%Z) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < n)%Z) -> (((k * v)%Z + p)%Z < (n * v)%Z)%Z.

Axiom inf_mul_comm :
  forall (i:Z) (bi:Z) (quot:Z) (rest:Z), ((0%Z <= i)%Z /\ (i < bi)%Z) ->
  (0%Z < rest)%Z -> (0%Z < quot)%Z -> (bi = (quot * rest)%Z) ->
  ((int.EuclideanDivision.mod1 i rest) < rest)%Z.

Parameter result2:
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  (im -> im -> im) -> (a -> im) -> a -> bool.

Axiom result_def2 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (t1:a -> im) (e:a),
  (((result2 op1 t1) e) = true) <-> ~ (neutral op1 (t1 e)).

(* Why3 assumption *)
Definition nonn_part1 {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im}
    (op1:im -> im -> im) (s:set a) (t1:a -> im) : set a :=
  filter (result2 op1 t1) s.

Axiom nonn_part_spec1 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), forall (e:a),
  (mem e (nonn_part1 op1 s t1)) <-> ((mem e s) /\ ~ (neutral op1 (t1 e))).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  (im -> im -> im) -> (a -> im) -> a -> bool.

Axiom result_def3 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (t1:a -> im) (e:a),
  (((result3 op1 t1) e) = true) <-> (neutral op1 (t1 e)).

(* Why3 assumption *)
Definition n_part1 {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im}
    (op1:im -> im -> im) (s:set a) (t1:a -> im) : set a :=
  filter (result3 op1 t1) s.

Axiom n_part_spec1 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), forall (e:a),
  (mem e (n_part1 op1 s t1)) <-> ((mem e s) /\ (neutral op1 (t1 e))).

Axiom nullity_partition1 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (commut op1) ->
  (s = (union (nonn_part1 op1 s t1) (n_part1 op1 s t1))) /\
  ((inter (nonn_part1 op1 s t1) (n_part1 op1 s t1)) = (empty : set a)).

Axiom iterate_neutral1 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (iterable op1) ->
  (commut op1) ->
  (forall (a1:a), (mem a1 s) -> ((t1 a1) = (neutral_elt op1))) ->
  ((iterate op1 s t1) = (neutral_elt op1)).

Axiom iterate_nullity_partition1 :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t1:a -> im), (iterable op1) ->
  (commut op1) ->
  ((iterate op1 s t1) = (iterate op1 (nonn_part1 op1 s t1) t1)).

Parameter indic: forall {a:Type} {a_WT:WhyType a}, a -> a -> t.

Axiom indic_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic a1 a') = tone)) /\
  (~ (a1 = a') -> ((indic a1 a') = tzero)).

Parameter indic_bool: forall {a:Type} {a_WT:WhyType a}, a -> a -> bool.

Axiom indic_bool_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic_bool a1 a') = true)) /\
  (~ (a1 = a') -> ((indic_bool a1 a') = false)).

Axiom indic_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a), ((indic a1 a') = (indic a' a1)).

Parameter indic_2:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, a -> a -> b ->
  b -> t.

Axiom indic_2_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  (((a1 = a') /\ (b1 = b')) -> ((indic_2 a1 a' b1 b') = tone)) /\
  (~ ((a1 = a') /\ (b1 = b')) -> ((indic_2 a1 a' b1 b') = tzero)).

Axiom indic_2_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (infix_asdt (indic a1 a') (indic b1 b'))) /\
  ((indic_2 a1 a' b1 b') = (indic (a1, b1) (a', b'))).

Axiom indic_2_comm :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (indic_2 a' a1 b1 b')) /\
  (((indic_2 a1 a' b1 b') = (indic_2 a1 a' b' b1)) /\
   ((indic_2 a1 a' b1 b') = (indic_2 a' a1 b' b1))).

(* Why3 assumption *)
Definition sum_indic {a:Type} {a_WT:WhyType a} (s:set a) (t1:a -> t) 
    (i:a) : t :=
  sum s (fun (e:a) => (infix_asdt (t1 e) (indic i e))).

Parameter ind_sum_indic: (Z -> t) -> Z -> Z -> Z -> t.

Axiom ind_sum_indic_def :
  forall (t1:Z -> t) (l:Z) (h:Z) (i:Z), (l < h)%Z ->
  ((ind_sum_indic t1 l h i) =
   (ind_sum (fun (e:Z) => (infix_asdt (t1 e) (indic i e))) l h)).

Axiom ind_sum_indic_spec :
  forall (t1:Z -> t) (l:Z) (h:Z) (i:Z), (l < h)%Z ->
  ((ind_sum_indic t1 l h i) = (sum_indic (to_fset l h) t1 i)).

Axiom sum_indic_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (i:a), (mem i s) ->
  ((sum_indic s t1 i) = (t1 i)).

Axiom sum_indic_ts :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t) (i:a), (mem i s) ->
  ((sum s (fun (e:a) => (infix_asdt (t1 e) (indic i e)))) = (t1 i)).

Axiom ind_sum_indic_t :
  forall (t1:Z -> t) (l:Z) (h:Z) (i:Z), ((l <= i)%Z /\ (i < h)%Z) ->
  ((ind_sum_indic t1 l h i) = (t1 i)) /\
  ((ind_sum (fun (e:Z) => (infix_asdt (t1 e) (indic i e))) l h) = (t1 i)).

Axiom ind_sum_indic_t_quant :
  forall (t1:Z -> t) (l:Z) (h:Z), forall (i:Z), ((l <= i)%Z /\ (i < h)%Z) ->
  ((ind_sum (fun (e:Z) => (infix_asdt (t1 e) (indic i e))) l h) = (t1 i)).

Axiom indic_div_mod :
  forall (i:Z) (j:Z) (q:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z < q)%Z ->
  ((indic i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i q) (int.EuclideanDivision.mod1 j q))
    (indic (int.EuclideanDivision.div i q) (int.EuclideanDivision.div j q)))).

Axiom indic_div_mod_gen :
  forall (q:Z), (0%Z < q)%Z -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (0%Z <= j)%Z) ->
  ((indic i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i q) (int.EuclideanDivision.mod1 j q))
    (indic (int.EuclideanDivision.div i q) (int.EuclideanDivision.div j q)))).

(* Why3 assumption *)
Definition antisym {a:Type} {a_WT:WhyType a} (rel:a -> a -> bool) : Prop :=
  forall (a1:a) (b:a), (((rel a1) b) = true) -> (((rel b) a1) = true) ->
  (a1 = b).

(* Why3 assumption *)
Definition transitive {a:Type} {a_WT:WhyType a} (rel:a -> a -> bool) : Prop :=
  forall (a1:a) (b:a) (c:a), (((rel a1) b) = true) -> (((rel b) c) = true) ->
  (((rel a1) c) = true).

(* Why3 assumption *)
Definition reflexive {a:Type} {a_WT:WhyType a} (rel:a -> a -> bool) : Prop :=
  forall (a1:a), (((rel a1) a1) = true).

(* Why3 assumption *)
Definition pre_order {a:Type} {a_WT:WhyType a} (rel:a -> a -> bool) : Prop :=
  (transitive rel) /\ (reflexive rel).

(* Why3 assumption *)
Definition partial_order {a:Type} {a_WT:WhyType a} (rel:a -> a -> bool) :
    Prop :=
  (antisym rel) /\ (pre_order rel).

(* Why3 assumption *)
Definition recip {a:Type} {a_WT:WhyType a} (rrel:a -> a -> bool)
    (rel:a -> a -> bool) : Prop :=
  forall (a1:a) (b:a), (((rrel a1) b) = true) <-> (((rel b) a1) = true).

(* Why3 assumption *)
Definition strict {a:Type} {a_WT:WhyType a} (srel:a -> a -> bool)
    (rel:a -> a -> bool) : Prop :=
  forall (a1:a) (b:a),
  (((srel a1) b) = true) <-> ((((rel a1) b) = true) /\ ~ (a1 = b)).

(* Why3 assumption *)
Definition compat_order_mult {a:Type} {a_WT:WhyType a} (rel:a -> a -> bool)
    (mul:a -> a -> a) (tzero1:a) : Prop :=
  forall (a1:a) (b:a) (c:a), (((rel a1) b) = true) ->
  (((rel tzero1) c) = true) -> (((rel ((mul a1) c)) ((mul b) c)) = true).

Parameter c_iter:
  forall {a:Type} {a_WT:WhyType a}, (a -> a -> a) -> a -> Z -> a.

Axiom c_iter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (t1:a) (i:Z), (0%Z <= i)%Z ->
  ((c_iter op1 t1 i) =
   (int_iterate op1 ((fun (y0:a) (y1:Z) => y0) t1) 0%Z i)).

Axiom c_iter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (t1:a) (i:Z), (0%Z <= i)%Z ->
  ((c_iter op1 t1 i) =
   (int_iterate op1 ((fun (y0:a) (y1:Z) => y0) t1) 0%Z i)).

Axiom c_iter_transl :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (t1:a) (i:Z) (k:Z), (assoc op1) -> (0%Z <= k)%Z ->
  (0%Z <= i)%Z ->
  ((c_iter op1 t1 i) =
   (int_iterate op1 ((fun (y0:a) (y1:Z) => y0) t1) k (k + i)%Z)).

Axiom c_iter_0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a), (has_neutral op1) ->
  ((c_iter op1 x 0%Z) = (neutral_elt op1)).

Axiom c_iter_1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a), (has_neutral op1) ->
  ((c_iter op1 x 1%Z) = x).

Axiom c_iter_plus_1_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (i:Z), (0%Z <= i)%Z -> (assoc op1) ->
  (has_neutral op1) ->
  ((c_iter op1 x (i + 1%Z)%Z) = ((op1 (c_iter op1 x i)) x)).

Axiom c_iter_plus_1_left :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (i:Z), (0%Z <= i)%Z -> (has_neutral op1) ->
  ((c_iter op1 x (i + 1%Z)%Z) = ((op1 x) (c_iter op1 x i))).

Axiom c_iter_s :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (n:Z), (has_neutral op1) -> (0%Z <= n)%Z ->
  ((c_iter op1 x (n + 1%Z)%Z) = ((op1 x) (c_iter op1 x n))) /\
  ((c_iter op1 x (n + 1%Z)%Z) = ((op1 (c_iter op1 x n)) x)).

Axiom c_iter_s_alt :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (n:Z), (has_neutral op1) -> (0%Z < n)%Z ->
  ((c_iter op1 x n) = ((op1 (c_iter op1 x (n - 1%Z)%Z)) x)) /\
  ((c_iter op1 x n) = ((op1 x) (c_iter op1 x (n - 1%Z)%Z))).

Axiom c_iter_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (n:Z) (m:Z), (has_neutral op1) ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((c_iter op1 x (n + m)%Z) = ((op1 (c_iter op1 x n)) (c_iter op1 x m))).

Axiom c_iter_mult :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (n:Z) (m:Z), (has_neutral op1) ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((c_iter op1 x (n * m)%Z) = (c_iter op1 (c_iter op1 x n) m)).

Axiom c_iter_op_comm1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (y:a) (n:Z), (commut op1) -> (0%Z <= n)%Z ->
  (((op1 (c_iter op1 x n)) y) = ((op1 y) (c_iter op1 x n))).

Axiom c_iter_op_comm2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (y:a) (n:Z), (commut op1) ->
  (iterable op1) -> (0%Z <= n)%Z ->
  ((c_iter op1 ((op1 x) y) n) = ((op1 (c_iter op1 x n)) (c_iter op1 y n))).

Axiom positive_diff : forall (n:Z) (m:Z), (n < m)%Z -> (0%Z < (m - n)%Z)%Z.

Axiom init_c_iter :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (k:a) (tone1:a), (neutral op1 tone1) ->
  ((c_iter op1 k 0%Z) = tone1) /\ ((c_iter op1 k 2%Z) = ((op1 k) k)).

Axiom positive_c_iter :
  forall {a:Type} {a_WT:WhyType a},
  forall (rel:a -> a -> bool) (srel:a -> a -> bool) (op1:a -> a -> a)
    (tone1:a) (tzero1:a) (k:a) (n:Z),
  (compat_order_mult rel op1 tzero1) -> (partial_order rel) ->
  (((rel tone1) k) = true) -> (((srel tzero1) tone1) = true) ->
  (strict srel rel) -> (neutral op1 tone1) -> (0%Z <= n)%Z ->
  (((rel tone1) (c_iter op1 k n)) = true) /\
  ((((srel tzero1) (c_iter op1 k n)) = true) /\
   (((rel (c_iter op1 k n)) (c_iter op1 k (n + 1%Z)%Z)) = true)).

Axiom strict_positive_c_iter :
  forall {a:Type} {a_WT:WhyType a},
  forall (rel:a -> a -> bool) (srel:a -> a -> bool) (op1:a -> a -> a)
    (tone1:a) (tzero1:a) (k:a) (n:Z),
  (compat_order_mult rel op1 tzero1) ->
  (compat_order_mult srel op1 tzero1) -> (((srel tzero1) tone1) = true) ->
  (partial_order rel) -> (neutral op1 tone1) -> (((srel tone1) k) = true) ->
  (strict srel rel) -> (0%Z < n)%Z ->
  (((srel tone1) (c_iter op1 k n)) = true) /\
  ((((srel (c_iter op1 k (n - 1%Z)%Z)) (c_iter op1 k n)) = true) /\
   (((srel (c_iter op1 k n)) (c_iter op1 k (n + 1%Z)%Z)) = true)).

Axiom growing_c_iter :
  forall {a:Type} {a_WT:WhyType a},
  forall (rel:a -> a -> bool) (srel:a -> a -> bool) (op1:a -> a -> a)
    (tone1:a) (tzero1:a) (k:a) (m:Z) (n:Z),
  (compat_order_mult rel op1 tzero1) -> (((srel tzero1) tone1) = true) ->
  (compat_order_mult srel op1 tzero1) -> (partial_order rel) ->
  (neutral op1 tone1) -> (((srel tone1) k) = true) -> (strict srel rel) ->
  (((rel tone1) k) = true) -> ((0%Z <= m)%Z /\ (m <= n)%Z) ->
  (((rel (c_iter op1 k m)) (c_iter op1 k n)) = true).

Axiom strict_growing_c_iter :
  forall {a:Type} {a_WT:WhyType a},
  forall (rel:a -> a -> bool) (srel:a -> a -> bool) (op1:a -> a -> a)
    (tone1:a) (tzero1:a) (k:a) (m:Z) (n:Z),
  (compat_order_mult rel op1 tzero1) ->
  (compat_order_mult srel op1 tzero1) -> (((srel tzero1) tone1) = true) ->
  (partial_order rel) -> (neutral op1 tone1) -> (((srel tone1) k) = true) ->
  (strict srel rel) -> (((srel tone1) k) = true) ->
  ((0%Z <= m)%Z /\ (m < n)%Z) ->
  (((srel (c_iter op1 k m)) (c_iter op1 k n)) = true).

Axiom unicity_c_iter :
  forall {a:Type} {a_WT:WhyType a},
  forall (rel:a -> a -> bool) (srel:a -> a -> bool) (op1:a -> a -> a)
    (tone1:a) (tzero1:a) (k:a) (m:Z) (n:Z),
  (compat_order_mult rel op1 tzero1) ->
  (compat_order_mult srel op1 tzero1) -> (((srel tzero1) tone1) = true) ->
  (partial_order rel) -> (neutral op1 tone1) -> (((srel tone1) k) = true) ->
  (strict srel rel) -> (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((c_iter op1 k m) = (c_iter op1 k n)) <-> (m = n).

Axiom neutrals :
  (0%Z = (neutral_elt (fun (y0:Z) (y1:Z) => (y0 + y1)%Z))) /\
  (1%Z = (neutral_elt (fun (y0:Z) (y1:Z) => (y0 * y1)%Z))).

(* Why3 assumption *)
Definition isum {a:Type} {a_WT:WhyType a} (s:set a) (t1:a -> Z) : Z :=
  iterate (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) s t1.

Axiom isum_iter : iterates (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) 0%Z.

Axiom isum_iter__ : iterable (fun (y0:Z) (y1:Z) => (y0 + y1)%Z).

Axiom isum_iter_ :
  (opposite_n (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
   (fun (y0:Z) (y1:Z) => (y0 - y1)%Z) 0%Z) /\
  ((opposite (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
    (fun (y0:Z) (y1:Z) => (y0 - y1)%Z)) /\
   ((opposite_com (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
     (fun (y0:Z) (y1:Z) => (y0 - y1)%Z)) /\
    (inverse_tuple (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
     (fun (y0:Z) (y1:Z) => (y0 - y1)%Z) 0%Z))).

Axiom neutral_zero1 :
  ((neutral_elt (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)) = 0%Z).

(* Why3 assumption *)
Definition ind_isum (f:Z -> Z) (i:Z) (j:Z) : Z :=
  int_iterate (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) f i j.

Axiom isum_to_iterate :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_isum f i j) = (int_iterate (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) f i j)).

Axiom ind_isum_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum f i j) = ((f i) + (ind_isum f (i + 1%Z)%Z j))%Z).

Axiom ind_isum_const :
  forall (k:Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum ((fun (y0:Z) (y1:Z) => y0) k) i j) = (k * (j - i)%Z)%Z).

Axiom ind_isum_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((ind_isum f i (j + 1%Z)%Z) = ((ind_isum f i j) + (f j))%Z).

Axiom ind_isum_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_isum f i j) = (ind_isum g i j)).

(* Why3 assumption *)
Definition ind_iproduct (f:Z -> Z) (i:Z) (j:Z) : Z :=
  int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) f i j.

Axiom ind_iproduct_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_iproduct f i j) = (ind_iproduct g i j)).

Axiom iproduct_to_iterate :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_iproduct f i j) =
   (int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) f i j)).

Axiom ind_isum_map_auto :
  forall (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((ind_isum t1 i j) = (ind_isum (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_isum_map :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_isum t1 k l) = (ind_isum (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_iproduct_empty :
  forall (f:Z -> Z) (i:Z) (j:Z), (j <= i)%Z -> ((ind_iproduct f i j) = 1%Z).

Axiom ind_iproduct_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_iproduct f i j) = ((f i) * (ind_iproduct f (i + 1%Z)%Z j))%Z).

Axiom ind_iproduct_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_iproduct f i j) =
   ((ind_iproduct f i (j - 1%Z)%Z) * (f (j - 1%Z)%Z))%Z).

Axiom ind_iproduct_right_extension_comm :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (((ind_iproduct f i (j - 1%Z)%Z) * (f (j - 1%Z)%Z))%Z =
   (ind_iproduct f i j)).

Axiom positive_iproduct :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z < (f k))%Z) ->
  (0%Z < (ind_iproduct f i j))%Z.

Axiom ind_iproduct_left_right :
  forall (f:Z -> Z) (l:Z) (k:Z) (h:Z), ((l <= k)%Z /\ (k <= h)%Z) ->
  ((ind_iproduct f l k) =
   (ind_iproduct (fun (a:Z) => (f ((h - (a + 1%Z)%Z)%Z + l)%Z))
    ((h - k)%Z + l)%Z h)).

Axiom iterable_imult : iterable (fun (y0:Z) (y1:Z) => (y0 * y1)%Z).

Axiom ind_iproduct_map_auto :
  forall (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((ind_iproduct t1 i j) = (ind_iproduct (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_iproduct_map :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_iproduct t1 k l) = (ind_iproduct (fun (b:Z) => (t1 (f b))) i j)).

Axiom ind_iproduct_trans :
  forall (f:Z -> Z) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_iproduct f i j) = ((ind_iproduct f i k) * (ind_iproduct f k j))%Z).

Axiom ind_isum_scal :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  ((ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j) = (a * (ind_isum f i j))%Z).

Axiom ind_isum_scal_gen :
  forall (f:Z -> Z) (i:Z) (j:Z), forall (a:Z), ((i <= a)%Z /\ (a < j)%Z) ->
  ((ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j) = (a * (ind_isum f i j))%Z).

Axiom ind_isum_trans :
  forall (f:Z -> Z) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_isum f i j) = ((ind_isum f i k) + (ind_isum f k j))%Z).

Parameter power: Z -> Z -> Z.

Axiom power_def :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) = (c_iter (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) e i)).

Axiom power_spec :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) =
   (int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z)
    ((fun (y0:Z) (y1:Z) => y0) e) 0%Z i)).

Axiom power_to_ind_iproduct :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) = (ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) 0%Z i)).

Axiom power_plus_one :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e (i + 1%Z)%Z) = (e * (power e i))%Z).

Axiom power_transl :
  forall (t1:Z) (i:Z) (k:Z), (0%Z <= k)%Z -> (0%Z <= i)%Z ->
  ((power t1 k) =
   (int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z)
    ((fun (y0:Z) (y1:Z) => y0) t1) i (i + k)%Z)).

Axiom ind_iproduct_to_power :
  forall (e:Z) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) i j) = (power e (j - i)%Z)).

Axiom ind_iproduct_to_power_gen :
  forall (e:Z), forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) i j) = (power e (j - i)%Z)).

Axiom get_power :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) = (c_iter (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) e i)) /\
  ((power e i) = (ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) 0%Z i)).

Parameter infix_ls_closure: Z -> Z -> bool.

Parameter infix_lseq_closure: Z -> Z -> bool.

Axiom infix_ls_closure_def :
  forall (y:Z) (y1:Z), (((infix_ls_closure y) y1) = true) <-> (y < y1)%Z.

Axiom infix_lseq_closure_def :
  forall (y:Z) (y1:Z), (((infix_lseq_closure y) y1) = true) <-> (y <= y1)%Z.

Axiom pre_cond_int :
  (compat_order_mult infix_ls_closure (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) 0%Z) /\
  ((compat_order_mult infix_lseq_closure (fun (y0:Z) (y1:Z) => (y0 * y1)%Z)
    0%Z) /\
   ((0%Z < 1%Z)%Z /\
    ((partial_order infix_lseq_closure) /\
     ((neutral (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) 1%Z) /\
      ((iterable (fun (y0:Z) (y1:Z) => (y0 * y1)%Z)) /\
       (strict infix_ls_closure infix_lseq_closure)))))).

Axiom power_sum :
  forall (x:Z) (n:Z) (m:Z), (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power x (n + m)%Z) = ((power x n) * (power x m))%Z).

Axiom c_iter_comm1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (op1:a -> a -> a) (x:a) (y:a) (n:Z), (commut op1) -> (0%Z <= n)%Z ->
  (((op1 (c_iter op1 x n)) y) = ((op1 y) (c_iter op1 x n))).

Axiom c_iter_op_comm11 :
  forall (x:Z) (y:Z) (n:Z), (0%Z <= n)%Z ->
  (((power x n) * y)%Z = (y * (power x n))%Z).

Axiom c_iter_op_comm21 :
  forall (x:Z) (y:Z) (n:Z), (0%Z <= n)%Z ->
  ((power (x * y)%Z n) = ((power x n) * (power y n))%Z).

Axiom growing_mult :
  forall (n:Z) (m:Z), (0%Z <= n)%Z -> (1%Z <= m)%Z -> (n <= (n * m)%Z)%Z.

Axiom strict_growing_mult :
  forall (n:Z) (m:Z), (1%Z < n)%Z -> (1%Z < m)%Z -> (n < (n * m)%Z)%Z.

Axiom init_exp :
  forall (k:Z),
  ((power k 0%Z) = 1%Z) /\
  (((power k 1%Z) = k) /\ ((power k 2%Z) = (k * k)%Z)).

Axiom positive_int_exp :
  forall (k:Z) (n:Z), (1%Z <= k)%Z -> (0%Z <= n)%Z ->
  (1%Z <= (power k n))%Z /\
  ((0%Z < (power k n))%Z /\ ((power k n) <= (power k (n + 1%Z)%Z))%Z).

Axiom strict_positive_int_exp :
  forall (k:Z) (n:Z), (1%Z < k)%Z -> (0%Z < n)%Z ->
  (1%Z < (power k n))%Z /\
  (((power k (n - 1%Z)%Z) < (power k n))%Z /\
   ((power k n) < (power k (n + 1%Z)%Z))%Z).

Axiom growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z <= k)%Z -> ((0%Z <= m)%Z /\ (m <= n)%Z) ->
  ((power k m) <= (power k n))%Z.

Axiom strict_growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> ((0%Z <= m)%Z /\ (m < n)%Z) ->
  ((power k m) < (power k n))%Z.

Axiom unicity_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((power k m) = (power k n)) <-> (m = n).

Axiom bounded_sum_exp :
  forall (i:Z) (j:Z) (k:Z) (m:Z) (n:Z), (0%Z < k)%Z -> (0%Z <= m)%Z ->
  (0%Z <= n)%Z -> (i < (power 2%Z m))%Z -> (j < (power 2%Z n))%Z ->
  (((i * (power 2%Z n))%Z + j)%Z < (power 2%Z (m + n)%Z))%Z.

Axiom power_to_ind_iproduct_i :
  forall (e:Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((power e (j - i)%Z) = (ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) i j)).

Axiom int_iterate_def_empty1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (j <= i)%Z ->
  ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_def_plus_one1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (i < j)%Z ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))).

Axiom int_iterate_cardone1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  (iterable op1) -> ((int_iterate op1 f i j) = (f i)).

Axiom int_iterate_def_plus_one_com1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (i < j)%Z ->
  (((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j)) = (int_iterate op1 f i j)).

Axiom int_iterate_to_iterate1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z),
  ((int_iterate op1 f i j) = (iterate op1 (to_fset i j) f)).

Axiom int_iterate_right_extension1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (assoc op1) ->
  (i < j)%Z ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i (j - 1%Z)%Z)) (f (j - 1%Z)%Z))).

Axiom int_iterate_transitivity1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (k:Z) (j:Z), (assoc op1) ->
  (op_neutral_left op1 (neutral_elt op1)) -> ((i <= k)%Z /\ (k <= j)%Z) ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i k)) (int_iterate op1 f k j))).

Axiom int_iterate_comp_iterate1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (g:Z -> im) (i:Z) (j:Z),
  (assoc op1) -> (op_neutral_right op1 (neutral_elt op1)) -> (commut op1) ->
  ((int_iterate op1 (fun (k:Z) => ((op1 (f k)) (g k))) i j) =
   ((op1 (int_iterate op1 f i j)) (int_iterate op1 g i j))).

Axiom int_iterate_attr_no_f1 :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (t2:Z -> im2) (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (t2 x)) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (assoc op1) ->
  (assoc op2) -> (forall (i1:Z), ((f (t1 i1)) = (t2 i1))) ->
  ((int_iterate op2 t2 i j) = (f (int_iterate op1 t1 i j))).

Axiom int_iterate_attr1 :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t1 x))) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (assoc op1) ->
  (assoc op2) ->
  ((int_iterate op2 (fun (e:Z) => (f (t1 e))) i j) =
   (f (int_iterate op1 t1 i j))).

Axiom int_iterate_attr_comm1 :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t1 x))) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (assoc op1) ->
  (assoc op2) ->
  ((f (int_iterate op1 t1 i j)) =
   (int_iterate op2 (fun (e:Z) => (f (t1 e))) i j)).

Axiom int_iterate_eq1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (g:Z -> im) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((int_iterate op1 f i j) = (int_iterate op1 g i j)).

Axiom int_iterate_left_right1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (l:Z) (k:Z) (h:Z), (assoc op1) ->
  (commut op1) -> ((l <= k)%Z /\ (k <= h)%Z) ->
  ((int_iterate op1 f l k) =
   (int_iterate op1 (fun (a:Z) => (f ((h - (a + 1%Z)%Z)%Z + l)%Z))
    ((h - k)%Z + l)%Z h)).

Axiom int_iterate_eq_func1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (f1:Z -> im) (f2:Z -> im),
  (iterable op1) -> (p_injective f1 (to_fset i j)) ->
  (p_injective f2 (to_fset i j)) ->
  ((map f1 (to_fset i j)) = (map f2 (to_fset i j))) ->
  ((int_iterate op1 f1 i j) = (int_iterate op1 f2 i j)).

Axiom int_iterate_map1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t1:Z -> im),
  (iterable op1) -> (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((int_iterate op1 t1 k l) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Axiom int_iterate_map_auto1 :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (f:Z -> Z) (t1:Z -> im),
  (iterable op1) -> (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((int_iterate op1 t1 i j) =
   (int_iterate op1 (fun (b:Z) => (t1 (f b))) i j)).

Parameter kth_right: Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom kth_right_def :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (0%Z < (f l))%Z) ->
  ((kth_right i k h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))
    (f (h - k)%Z))).

Axiom kth_right_spec :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (0%Z < (f l))%Z) ->
  (0%Z <= (kth_right i k h f))%Z /\ ((kth_right i k h f) < (f (h - k)%Z))%Z.

Axiom kth_right_trans :
  forall (i:Z) (k:Z) (h:Z) (t1:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (0%Z < (f l))%Z) -> (0%Z <= t1)%Z ->
  ((kth_right (int.EuclideanDivision.div i (ind_iproduct f h (h + t1)%Z)) k h
    f)
   = (kth_right i (k + t1)%Z (h + t1)%Z f)).

Parameter kth_left: Z -> Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom kth_left_def :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  ((0%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) = (kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h f)).

Axiom kth_left_spec :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  ((0%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f (l + k)%Z h))
    (f ((l + k)%Z - 1%Z)%Z))) /\
  ((0%Z <= (kth_left i k l h f))%Z /\
   ((kth_left i k l h f) < (f ((l + k)%Z - 1%Z)%Z))%Z).

Axiom kth_left_eq :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z) (g:Z -> Z), (0%Z <= i)%Z ->
  ((0%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> ((f ind) = (g ind))) ->
  ((kth_left i k l h f) = (kth_left i k l h g)).

Axiom kth_left_to_mod_div :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  ((0%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (l1:Z), (0%Z < (f l1))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f (l + k)%Z h))
    (f ((l + k)%Z - 1%Z)%Z))).

Axiom div_isum_exponents :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power k (n + m)%Z) = ((power k n) * (power k m))%Z) /\
  (((power k (n + 1%Z)%Z) = ((power k n) * k)%Z) /\
   (((power k 1%Z) = k) /\
    (((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n))
       (power k m))
      = (int.EuclideanDivision.div i (power k (n + m)%Z))) /\
     ((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n)) k)
      = (int.EuclideanDivision.div i (power k (n + 1%Z)%Z)))))).

Parameter divp: Z -> Z -> Z.

Axiom divp_def :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((divp i j) = ((int.EuclideanDivision.div i j) * j)%Z).

Axiom divp_spec :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i = ((divp i j) + (int.EuclideanDivision.mod1 i j))%Z) /\
  ((((divp i j) <= i)%Z /\ (i < (((divp i j) + 1%Z)%Z * j)%Z)%Z) /\
   ((j < i)%Z -> (0%Z < (divp i j))%Z)).

Axiom kth_right_div_mod :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((kth_right i k h f) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h))
    (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))).

Axiom kth_head :
  forall (i:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= h)%Z ->
  (forall (k:Z), (0%Z < (f k))%Z) ->
  ((kth_right i 1%Z h f) = (int.EuclideanDivision.mod1 i (f (h - 1%Z)%Z))).

Parameter weighted_kth_right: Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom weighted_kth_right_def :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) -> (1%Z <= k)%Z ->
  ((weighted_kth_right i k h f) =
   ((kth_right i k h f) * (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))%Z).

Axiom weighted_kth_right_ :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (1%Z <= k)%Z -> (0%Z <= i)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h)) =
   ((weighted_kth_right i k h f) +
    (int.EuclideanDivision.mod1 i (ind_iproduct f ((h - k)%Z + 1%Z)%Z h)))%Z).

Axiom kth_right_decomposition :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h)) =
   (ind_isum (fun (a:Z) => (weighted_kth_right i a h f)) 1%Z (k + 1%Z)%Z)).

Axiom kth_left_div_mod :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h))
    (ind_iproduct f (l + k)%Z h))).

Parameter weighted_kth_left: Z -> Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom weighted_kth_left_def :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((weighted_kth_left i k l h f) =
   (weighted_kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h f)).

Axiom weighted_kth_left_ :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h)) =
   ((weighted_kth_left i k l h f) +
    (int.EuclideanDivision.mod1 i (ind_iproduct f (l + k)%Z h)))%Z).

Axiom bounded_kth_left_decomposition :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h)) =
   (ind_isum (fun (a:Z) => (weighted_kth_left i a l h f)) k
    ((h - l)%Z + 1%Z)%Z)).

Axiom kth_left_decomposition :
  forall (i:Z) (l:Z) (h:Z) (f:Z -> Z),
  ((0%Z <= i)%Z /\ (i < (ind_iproduct f l h))%Z) -> (l < h)%Z ->
  (forall (k:Z), (0%Z < (f k))%Z) ->
  (i =
   (ind_isum (fun (a:Z) => (weighted_kth_left i a l h f)) 1%Z
    ((h - l)%Z + 1%Z)%Z)).

(* Why3 assumption *)
Definition int_seq := Z -> Z.

Parameter kth_nit_r: Z -> Z -> Z -> Z.

Axiom kth_nit_r_def :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (1%Z <= k)%Z -> (0%Z < n)%Z ->
  ((kth_nit_r i k n) =
   (kth_right i k (k - 1%Z)%Z ((fun (y0:Z) (y1:Z) => y0) n))).

Axiom kth_nit_r_spec :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (1%Z <= k)%Z -> (0%Z < n)%Z ->
  ((kth_nit_r i k n) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power n (k - 1%Z)%Z)) n)) /\
  forall (h:Z), (k < h)%Z ->
  ((kth_nit_r i k n) = (kth_right i k h ((fun (y0:Z) (y1:Z) => y0) n))).

Parameter kth_nit_l: Z -> Z -> Z -> Z -> Z.

Axiom kth_nit_l_def :
  forall (i:Z) (k:Z) (n:Z) (h:Z), (0%Z <= i)%Z -> (0%Z < n)%Z ->
  ((1%Z <= k)%Z /\ (k <= h)%Z) ->
  ((kth_nit_l i k n h) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power n (h - k)%Z)) n)).

Axiom kth_nit_l_spec :
  forall (i:Z) (k:Z) (n:Z) (h:Z), (0%Z <= i)%Z -> (0%Z < n)%Z ->
  ((1%Z <= k)%Z /\ (k <= h)%Z) ->
  ((kth_nit_l i k n h) = (kth_nit_r i ((h - k)%Z + 1%Z)%Z n)) /\
  (((kth_nit_l i k n h) =
    (kth_right i ((h - k)%Z + 1%Z)%Z (h - k)%Z ((fun (y0:Z) (y1:Z) => y0) n))) /\
   ((kth_nit_l i k n h) =
    (kth_left i 0%Z 0%Z (h - k)%Z ((fun (y0:Z) (y1:Z) => y0) n)))).

Axiom kth_nit_l_val :
  forall (i:Z) (k:Z) (n:Z) (h:Z) (l:Z), (0%Z <= i)%Z -> (0%Z < n)%Z ->
  (0%Z <= l)%Z -> ((1%Z <= k)%Z /\ (k <= h)%Z) ->
  ((kth_nit_l i k n h) =
   (kth_left i k l (h + l)%Z ((fun (y0:Z) (y1:Z) => y0) n))).

Axiom kth_nit_div_mod :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (1%Z <= k)%Z -> (0%Z < n)%Z ->
  ((kth_nit_r i k n) =
   (int.EuclideanDivision.div (int.EuclideanDivision.mod1 i (power n k))
    (power n (k - 1%Z)%Z))).

Parameter weighted_kth_nit_r: Z -> Z -> Z -> Z.

Axiom weighted_kth_nit_r_def :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z < n)%Z -> (0%Z < k)%Z ->
  ((weighted_kth_nit_r i k n) =
   ((kth_nit_r i k n) * (power n (k - 1%Z)%Z))%Z).

Axiom weighted_kth_nit_r_spec :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z < n)%Z -> (0%Z < k)%Z ->
  (((power n (k - 1%Z)%Z) < i)%Z ->
   (0%Z <= (weighted_kth_nit_r i k n))%Z /\
   ((weighted_kth_nit_r i k n) <= i)%Z) /\
  forall (h:Z), (k < h)%Z ->
  ((weighted_kth_nit_r i k n) =
   (weighted_kth_right i k h ((fun (y0:Z) (y1:Z) => y0) n))).

Axiom decreasing_div :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= k)%Z -> (1%Z < n)%Z ->
  ((power n (k + 1%Z)%Z) < i)%Z ->
  ((int.EuclideanDivision.div i (power n k)) =
   (((int.EuclideanDivision.div i (power n (k + 1%Z)%Z)) * n)%Z +
    (kth_nit_r i (k + 1%Z)%Z n))%Z) /\
  ((int.EuclideanDivision.div i (power n (k + 1%Z)%Z)) <
   (int.EuclideanDivision.div i (power n k)))%Z.

Axiom decreasing_div_gen :
  forall (i:Z) (k:Z) (k':Z) (n:Z), (0%Z <= i)%Z -> (1%Z < n)%Z ->
  ((0%Z <= k)%Z /\ (k < k')%Z) -> ((power n k') < i)%Z ->
  ((int.EuclideanDivision.div i (power n k')) <
   (int.EuclideanDivision.div i (power n k)))%Z.

Axiom decreasing_div_n :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z < k)%Z -> (1%Z < n)%Z ->
  ((power n k) < i)%Z -> ((int.EuclideanDivision.div i (power n k)) <= i)%Z.

Parameter nary_length: Z -> Z -> Z.

Axiom nary_length_spec :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z ->
  ((0%Z < i)%Z ->
   ((power n ((nary_length i n) - 1%Z)%Z) <= i)%Z /\
   (i < (power n (nary_length i n)))%Z) /\
  (((i < n)%Z -> ((nary_length i n) = 1%Z)) /\
   ((1%Z <= (nary_length i n))%Z /\
    (i = (int.EuclideanDivision.mod1 i (power n (nary_length i n)))))).

Parameter weighted_kth_nit_l: Z -> Z -> Z -> Z -> Z.

Axiom weighted_kth_nit_l_def :
  forall (i:Z) (k:Z) (n:Z) (h:Z), (0%Z <= i)%Z ->
  ((0%Z < k)%Z /\ (k <= h)%Z) -> (0%Z < n)%Z -> ((nary_length i n) <= h)%Z ->
  ((weighted_kth_nit_l i k n h) =
   ((kth_nit_l i k n h) * (power n (h - k)%Z))%Z).

Axiom weighted_kth_nit_l_spec :
  forall (i:Z) (k:Z) (n:Z) (h:Z), (0%Z <= i)%Z ->
  ((0%Z < k)%Z /\ (k <= h)%Z) -> (0%Z < n)%Z -> ((nary_length i n) <= h)%Z ->
  ((weighted_kth_nit_l i k n h) =
   (weighted_kth_nit_r i ((h - k)%Z + 1%Z)%Z n)) /\
  (((1%Z < k)%Z ->
    ((weighted_kth_nit_l i k n h) =
     (weighted_kth_right i ((h - k)%Z + 1%Z)%Z h
      ((fun (y0:Z) (y1:Z) => y0) n)))) /\
   (((power n (n - k)%Z) < i)%Z ->
    (0%Z <= (weighted_kth_nit_l i k n h))%Z /\
    ((weighted_kth_nit_l i k n h) <= i)%Z)).

Parameter weighted_kth_left1: Z -> Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom weighted_kth_left_def1 :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((weighted_kth_left1 i k l h f) =
   (weighted_kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h f)).

Axiom no_rest_length :
  forall (i:Z) (l:Z) (n:Z), (0%Z < i)%Z -> (1%Z < n)%Z -> (0%Z <= l)%Z ->
  (i = (power n l)) -> ((nary_length i n) = (l + 1%Z)%Z).

Axiom mod_nary :
  forall (i:Z) (l:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (1%Z < n)%Z ->
  ((1%Z <= k)%Z /\ (k <= l)%Z) ->
  ((kth_nit_r (int.EuclideanDivision.mod1 i (power n l)) k n) =
   (kth_nit_r i k n)).

Axiom mod_nary_comm :
  forall (i:Z) (l:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  (1%Z < n)%Z -> ((1%Z <= k)%Z /\ (k <= l)%Z) ->
  ((kth_nit_r i k n) =
   (kth_nit_r (int.EuclideanDivision.mod1 i (power n l)) k n)).

Parameter fc: Z -> Z -> Z -> Z.

Axiom fc_def :
  forall (i:Z) (n:Z) (l:Z),
  ((1%Z <= l)%Z ->
   (((fc i n) l) = ((kth_nit_r i l n) * (power n (l - 1%Z)%Z))%Z)) /\
  (~ (1%Z <= l)%Z -> (((fc i n) l) = 0%Z)).

Axiom nary_decomposition_pre :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z < n)%Z -> (1%Z <= k)%Z ->
  ((int.EuclideanDivision.mod1 i (power n k)) =
   (ind_isum (fc i n) 1%Z (k + 1%Z)%Z)) /\
  ((int.EuclideanDivision.mod1 i (power n k)) =
   (ind_isum (fun (l:Z) => ((kth_nit_r i l n) * (power n (l - 1%Z)%Z))%Z) 1%Z
    (k + 1%Z)%Z)).

Axiom nary_decomposition :
  forall (i:Z) (n:Z) (h:Z), (0%Z <= i)%Z -> (1%Z < n)%Z ->
  ((nary_length i n) <= h)%Z ->
  (i =
   (ind_isum (fun (l:Z) => ((kth_nit_r i l n) * (power n (l - 1%Z)%Z))%Z) 1%Z
    (h + 1%Z)%Z)) /\
  (i = (ind_isum (fun (l:Z) => (weighted_kth_nit_r i l n)) 1%Z (h + 1%Z)%Z)).

Axiom nary_decomposition_l :
  forall (i:Z) (n:Z) (h:Z), (0%Z <= i)%Z -> (1%Z < n)%Z ->
  ((nary_length i n) <= h)%Z ->
  (i =
   (ind_isum (fun (l:Z) => (weighted_kth_nit_l i l n h)) 1%Z (h + 1%Z)%Z)) /\
  (i =
   (ind_isum (fun (l:Z) => ((kth_nit_l i l n h) * (power n (h - l)%Z))%Z) 1%Z
    (h + 1%Z)%Z)).

(* Why3 assumption *)
Definition is_nary (t1:Z -> Z) (i:Z) (j:Z) (n:Z) : Prop :=
  forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) ->
  (0%Z <= (t1 k))%Z /\ ((t1 k) < n)%Z.

Axiom is_nary_kth_nit_r :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z < n)%Z ->
  is_nary (fun (j:Z) => (kth_nit_r i j n)) 1%Z (k + 1%Z)%Z n.

Axiom subset_closure_naries :
  forall (i:Z) (j:Z) (k:Z) (m:Z) (n:Z) (t1:Z -> Z),
  ((i <= k)%Z /\ ((k < m)%Z /\ (m < j)%Z)) -> (0%Z < n)%Z ->
  (is_nary t1 i j n) -> is_nary t1 k m n.

(* Why3 assumption *)
Definition int_seq1 := Z -> Z.

Parameter kth_bit_r: Z -> Z -> Z.

Axiom kth_bit_r_def :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  ((kth_bit_r i k) = (kth_nit_r i k 2%Z)).

Axiom kth_bit_r_spec :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  ((kth_bit_r i k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power 2%Z (k - 1%Z)%Z)) 2%Z)).

Parameter kth_bit_l: Z -> Z -> Z -> Z.

Axiom kth_bit_l_def :
  forall (i:Z) (h:Z) (k:Z), (0%Z <= i)%Z -> ((1%Z <= k)%Z /\ (k <= h)%Z) ->
  ((kth_bit_l i h k) = (kth_nit_l i k 2%Z h)).

Axiom kth_bit_l_spec :
  forall (i:Z) (h:Z) (k:Z), (0%Z <= i)%Z -> ((1%Z <= k)%Z /\ (k <= h)%Z) ->
  ((kth_bit_l i h k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power 2%Z (h - k)%Z)) 2%Z)) /\
  (((kth_bit_l i h k) = (kth_bit_r i ((h - k)%Z + 1%Z)%Z)) /\
   (((kth_bit_l i h k) =
     (kth_right i ((h - k)%Z + 1%Z)%Z (h - k)%Z
      ((fun (y0:Z) (y1:Z) => y0) 2%Z))) /\
    ((kth_bit_l i h k) =
     (kth_left i 0%Z 0%Z (h - k)%Z ((fun (y0:Z) (y1:Z) => y0) 2%Z))))).

Axiom kth_bit_div_mod :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  ((kth_bit_r i k) =
   (int.EuclideanDivision.div (int.EuclideanDivision.mod1 i (power 2%Z k))
    (power 2%Z (k - 1%Z)%Z))).

Axiom kth_bit_l_mod_div :
  forall (i:Z) (h:Z) (k:Z), (0%Z <= i)%Z -> ((1%Z <= k)%Z /\ (k <= h)%Z) ->
  ((kth_bit_l i h k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power 2%Z (h - k)%Z)) 2%Z)).

Axiom kth_bit_l_div_mod :
  forall (i:Z) (h:Z) (k:Z), (0%Z <= i)%Z -> ((1%Z <= k)%Z /\ (k <= h)%Z) ->
  ((kth_bit_l i h k) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (power 2%Z ((h - k)%Z + 1%Z)%Z))
    (power 2%Z (h - k)%Z))).

Axiom kth_bit_l_transl :
  forall (i:Z) (l:Z) (k:Z) (n:Z), (0%Z <= i)%Z ->
  ((1%Z <= k)%Z /\ ((k < l)%Z /\ (l <= n)%Z)) ->
  ((kth_bit_l i n l) =
   (kth_bit_l (int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z)) (n - k)%Z
    (l - k)%Z)).

Axiom kth_bit_l_transl_gen :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> ((1%Z <= k)%Z /\ (k < n)%Z) ->
  forall (l:Z), ((k < l)%Z /\ (l <= n)%Z) ->
  ((kth_bit_l i n l) =
   (kth_bit_l (int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z)) (n - k)%Z
    (l - k)%Z)).

Parameter head_bit: Z -> Z -> Z.

Axiom head_bit_def :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((head_bit i k) = (int.EuclideanDivision.div i (power 2%Z (k - 1%Z)%Z))).

Axiom head_bit_spec :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((0%Z <= (head_bit i k))%Z /\ ((head_bit i k) <= 1%Z)%Z) /\
  ((head_bit i k) = (kth_bit_l i k 1%Z)).

Parameter tail_bits: Z -> Z -> Z.

Axiom tail_bits_def :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((tail_bits i k) = (int.EuclideanDivision.mod1 i (power 2%Z (k - 1%Z)%Z))).

Axiom tail_bits_spec :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  (0%Z <= (tail_bits i k))%Z /\
  ((tail_bits i k) <= (power 2%Z (k - 1%Z)%Z))%Z.

Parameter ht_to_int: Z -> Z -> Z -> Z.

Axiom ht_to_int_def :
  forall (hi:Z) (ti:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= hi)%Z /\ (hi < 2%Z)%Z) ->
  ((0%Z <= ti)%Z /\ (ti < (power 2%Z (k - 1%Z)%Z))%Z) ->
  ((ht_to_int hi ti k) = ((hi * (power 2%Z (k - 1%Z)%Z))%Z + ti)%Z).

Axiom head_tail_inv :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((ht_to_int (head_bit i k) (tail_bits i k) k) = i).

Parameter kth_weigh: Z -> Z -> Z.

Axiom kth_weigh_def :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  ((kth_weigh i k) = (weighted_kth_nit_r i k 2%Z)).

Axiom kth_weigh_spec :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  ((power 2%Z (k - 1%Z)%Z) < i)%Z ->
  (0%Z <= (kth_weigh i k))%Z /\ ((kth_weigh i k) <= i)%Z.

Parameter binary_length: Z -> Z.

Axiom binary_length_def :
  forall (i:Z), (0%Z <= i)%Z -> ((binary_length i) = (nary_length i 2%Z)).

Axiom binary_length_spec :
  forall (i:Z), (0%Z <= i)%Z ->
  ((0%Z < i)%Z ->
   ((power 2%Z ((binary_length i) - 1%Z)%Z) <= i)%Z /\
   (i < (power 2%Z (binary_length i)))%Z) /\
  (((i < 2%Z)%Z -> ((binary_length i) = 1%Z)) /\
   ((1%Z <= (binary_length i))%Z /\
    (i = (int.EuclideanDivision.mod1 i (power 2%Z (binary_length i)))))).

Axiom set_binary_length :
  forall (i:Z) (k:Z), (0%Z <= i)%Z ->
  ((0%Z < i)%Z -> ((power 2%Z (k - 1%Z)%Z) <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((i < 2%Z)%Z -> (k = 1%Z)) -> (k = (binary_length i)).

Axiom set_binary_length_b :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < k)%Z -> (i < (power 2%Z k))%Z ->
  ((binary_length i) <= k)%Z.

Axiom no_rest_bin_length :
  forall (i:Z) (l:Z), (0%Z < i)%Z -> (0%Z <= l)%Z -> (i = (power 2%Z l)) ->
  ((binary_length i) = (l + 1%Z)%Z).

Axiom mod_binary :
  forall (i:Z) (l:Z) (k:Z), (0%Z <= i)%Z -> ((1%Z <= k)%Z /\ (k <= l)%Z) ->
  ((kth_bit_r (int.EuclideanDivision.mod1 i (power 2%Z l)) k) =
   (kth_bit_r i k)).

Axiom mod_binary_comm :
  forall (i:Z) (l:Z) (k:Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= l)%Z) -> ((0%Z <= k)%Z /\ (k < l)%Z) ->
  ((kth_bit_r i k) =
   (kth_bit_r (int.EuclideanDivision.mod1 i (power 2%Z l)) k)).

Axiom binary_decomposition :
  forall (i:Z), (0%Z <= i)%Z ->
  (i =
   (ind_isum (fun (l:Z) => ((kth_bit_r i l) * (power 2%Z (l - 1%Z)%Z))%Z) 1%Z
    ((binary_length i) + 1%Z)%Z)).

Axiom binary_decomposition_l :
  forall (i:Z) (n:Z), (0%Z <= i)%Z -> ((binary_length i) <= n)%Z ->
  (i =
   (ind_isum (fun (l:Z) => ((kth_bit_l i n l) * (power 2%Z (n - l)%Z))%Z) 1%Z
    (n + 1%Z)%Z)).

Axiom binary_decomposition_l_mod :
  forall (i:Z) (k:Z) (n:Z), ((1%Z <= k)%Z /\ (k < n)%Z) -> (0%Z <= i)%Z ->
  ((binary_length i) <= n)%Z -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z)) =
   (ind_isum (fun (l:Z) => ((kth_bit_l i n l) * (power 2%Z (n - l)%Z))%Z)
    (k + 1%Z)%Z (n + 1%Z)%Z)).

Axiom binary_decomposition_l_mod_gen :
  forall (k:Z) (n:Z), ((1%Z <= k)%Z /\ (k < n)%Z) ->
  ((0%Z <= k)%Z /\ (k < n)%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z)) =
   (ind_isum (fun (l:Z) => ((kth_bit_l i n l) * (power 2%Z (n - l)%Z))%Z)
    (k + 1%Z)%Z (n + 1%Z)%Z)).

Axiom tail_bits_mod :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z ->
  ((binary_length i) <= n)%Z ->
  ((tail_bits i n) =
   (ind_isum (fun (l:Z) => ((kth_bit_l i n l) * (power 2%Z (n - l)%Z))%Z) 2%Z
    (n + 1%Z)%Z)).

(* Why3 assumption *)
Definition is_binary (t1:Z -> Z) (i:Z) (j:Z) : Prop :=
  forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) ->
  (0%Z <= (t1 k))%Z /\ ((t1 k) < 2%Z)%Z.

(* Why3 assumption *)
Definition is_all_binary (t1:Z -> Z) : Prop :=
  forall (k:Z), (0%Z <= (t1 k))%Z /\ ((t1 k) < 2%Z)%Z.

Axiom binary_to_nary :
  forall (t1:Z -> Z) (i:Z) (j:Z), (is_binary t1 i j) -> is_nary t1 i j 2%Z.

Axiom lambda_int_seq :
  forall (t1:Z -> Z) (i:Z), (((fun (k:Z) => (t1 k)) i) = (t1 i)).

Axiom lambda_int_seq_comm :
  forall (t1:Z -> Z) (i:Z), ((t1 i) = ((fun (k:Z) => (t1 k)) i)).

Axiom is_binary_kth_bit_r :
  forall (i:Z) (k:Z), (0%Z <= i)%Z ->
  is_binary (fun (j:Z) => (kth_bit_r i j)) 1%Z (k + 1%Z)%Z.

Axiom subset_closure_binaries :
  forall (i:Z) (j:Z) (k:Z) (m:Z) (t1:Z -> Z),
  ((i <= k)%Z /\ ((k < m)%Z /\ (m < j)%Z)) -> (is_binary t1 i j) ->
  is_binary t1 k m.

Parameter bin_and: Z -> Z -> Z.

Axiom bin_and_def :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < 2%Z)%Z) ->
  (((i = 1%Z) /\ (j = 1%Z)) -> ((bin_and i j) = 1%Z)) /\
  (~ ((i = 1%Z) /\ (j = 1%Z)) -> ((bin_and i j) = 0%Z)).

Axiom bin_and_spec :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < 2%Z)%Z) ->
  ((0%Z <= (bin_and i j))%Z /\ ((bin_and i j) < 2%Z)%Z) /\
  ((((bin_and i j) = 1%Z) <-> ((i = 1%Z) /\ (j = 1%Z))) /\
   (((bin_and i j) = 0%Z) <-> ((i = 0%Z) \/ (j = 0%Z)))).

Axiom bin_and_mod :
  forall (i:Z) (j:Z) (k:Z) (l:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((0%Z <= k)%Z /\ ((k < k)%Z /\ (k <= l)%Z)) ->
  ((bin_and (kth_bit_r (int.EuclideanDivision.mod1 i (power 2%Z l)) k)
    (kth_bit_r (int.EuclideanDivision.mod1 j (power 2%Z l)) k))
   = (bin_and (kth_bit_r i k) (kth_bit_r j k))).

Axiom binary_bin_and :
  forall (t1:Z -> Z) (u:Z -> Z) (i:Z) (j:Z), (is_binary t1 i j) ->
  (is_binary u i j) -> is_binary (fun (k:Z) => (bin_and (t1 k) (u k))) i j.

Axiom lambda_bin_and :
  forall (l:Z) (i:Z) (j:Z), (0%Z <= l)%Z -> ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < 2%Z)%Z) ->
  ((bin_and (kth_bit_r i l) (kth_bit_r j l)) =
   ((fun (k:Z) => (bin_and (kth_bit_r i k) (kth_bit_r j k))) l)).

Parameter popcount: (Z -> Z) -> Z -> Z -> Z.

Axiom popcount_def :
  forall (t1:Z -> Z) (i:Z) (j:Z), (i <= j)%Z -> (is_binary t1 i j) ->
  ((j <= i)%Z -> ((popcount t1 i j) = 0%Z)) /\
  (~ (j <= i)%Z ->
   ((popcount t1 i j) = ((t1 i) + (popcount t1 (i + 1%Z)%Z j))%Z)).

Axiom popcount_spec :
  forall (t1:Z -> Z) (i:Z) (j:Z), (i <= j)%Z -> (is_binary t1 i j) ->
  ((popcount t1 i j) = (ind_isum t1 i j)) /\ (0%Z <= (popcount t1 i j))%Z.

Axiom positive_popcount :
  forall (t1:Z -> Z) (i:Z) (j:Z), (i <= j)%Z -> (is_binary t1 i j) ->
  (0%Z <= (popcount t1 i j))%Z.

Axiom popcount_right_extension :
  forall (t1:Z -> Z) (i:Z) (j:Z), (i < j)%Z -> (is_binary t1 i j) ->
  ((popcount t1 i j) = ((popcount t1 i (j - 1%Z)%Z) + (t1 (j - 1%Z)%Z))%Z).

Axiom popcount_right_extension_comm :
  forall (t1:Z -> Z) (i:Z) (j:Z), (i < j)%Z -> (is_binary t1 i j) ->
  (((popcount t1 i (j - 1%Z)%Z) + (t1 (j - 1%Z)%Z))%Z = (popcount t1 i j)).

Parameter equal:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> (Z -> Z -> a) -> Prop.

Axiom equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a),
  (equal m n) <->
  ((((rows m) = (rows n)) /\ ((columns m) = (columns n))) /\
   forall (i:Z) (j:Z), (valid_index m i j) -> (((m i) j) = ((n i) j))).

Axiom equality :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a), (equal m n) <-> (m = n).

Axiom mat_equality :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (forall (i:Z) (j:Z), (valid_index m i j) -> (((m i) j) = ((n i) j))) ->
  equal m n.

Parameter square: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Prop.

Axiom square_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (square m) <-> ((rows m) = (columns m)).

Axiom equal_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a), (equal m n) <-> (equal n m).

Axiom equal_rex :
  forall {a:Type} {a_WT:WhyType a}, forall (m:Z -> Z -> a), equal m m.

Axiom equal_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a) (o:Z -> Z -> a), (equal m n) ->
  (equal n o) -> equal m o.

Parameter equal_funct:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> Z -> a) ->
  (Z -> Z -> Z -> a) -> Prop.

Axiom equal_mat_funct :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> Z -> Z -> a) (g:Z -> Z -> Z -> a), forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < j)%Z) ->
  (equal_funct f g) <->
  forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> equal (f k) (g k).

Axiom set_equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (forall (i:Z) (j:Z), (valid_index m i j) -> (((m i) j) = ((n i) j))) ->
  (m = n).

Axiom set_equal_mat_make :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (g:Z -> Z -> a), (0%Z <= r)%Z ->
  (0%Z <= c)%Z ->
  (forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
   ((0%Z <= j)%Z /\ (j < c)%Z) -> (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r c g)).

Axiom set_equal_mat_make_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (r':Z) (c:Z) (c':Z) (f:Z -> Z -> a) (g:Z -> Z -> a),
  (0%Z <= r)%Z -> (0%Z <= c)%Z -> (r = r') -> (c = c') ->
  (forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
   ((0%Z <= j)%Z /\ (j < c)%Z) -> (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r' c' g)).

Axiom get_equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a), (equal m n) ->
  ((rows m) = (rows n)) /\
  (((columns m) = (columns n)) /\
   forall (i:Z) (j:Z), (valid_index m i j) -> (((m i) j) = ((n i) j))).

Axiom equal_functions :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (g:Z -> Z -> a), (0%Z < r)%Z ->
  (0%Z < c)%Z ->
  (forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
   (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r c g)).

Axiom equal_functions_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> Z -> a) (m:Z -> Z -> a),
  (forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < (rows m))%Z) /\
    ((0%Z <= j)%Z /\ (j < (columns m))%Z)) ->
   (((f i) j) = ((m i) j))) ->
  (m = (make_f (rows m) (columns m) f)).

Axiom mat_make :
  forall (m:Z -> Z -> t), (m = (make_f (rows m) (columns m) m)).

Parameter kronecker_neutral: Z -> Z -> t.

Axiom kronecker_neutral1 : (kronecker_neutral = (make 1%Z 1%Z tone)).

(* Why3 assumption *)
Definition kronecker (m:Z -> Z -> t) (n:Z -> Z -> t) : Z -> Z -> t :=
  make_f ((rows m) * (rows n))%Z ((columns m) * (columns n))%Z
  (fun (i:Z) (j:Z) =>
   (infix_asdt
    ((m (int.EuclideanDivision.div i (rows n)))
     (int.EuclideanDivision.div j (columns n)))
    ((n (int.EuclideanDivision.mod1 i (rows n)))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t),
  ((rows (kronecker m n)) = ((rows m) * (rows n))%Z) /\
  (((columns (kronecker m n)) = ((columns m) * (columns n))%Z) /\
   forall (i:Z) (j:Z), (valid_index (kronecker m n) i j) ->
   ((((kronecker m n) i) j) =
    (infix_asdt
     ((m (int.EuclideanDivision.div i (rows n)))
      (int.EuclideanDivision.div j (columns n)))
     ((n (int.EuclideanDivision.mod1 i (rows n)))
      (int.EuclideanDivision.mod1 j (columns n)))))).

Axiom get_kronecker :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t),
  ((kronecker m n) =
   (make_f ((rows m) * (rows n))%Z ((columns m) * (columns n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      ((m (int.EuclideanDivision.div i (rows n)))
       (int.EuclideanDivision.div j (columns n)))
      ((n (int.EuclideanDivision.mod1 i (rows n)))
       (int.EuclideanDivision.mod1 j (columns n))))))).

Axiom kronecker_values :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((((kronecker m n) i) j) =
   (infix_asdt
    ((m (int.EuclideanDivision.div i (rows n)))
     (int.EuclideanDivision.div j (columns n)))
    ((n (int.EuclideanDivision.mod1 i (rows n)))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_values_gen :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), forall (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((((kronecker m n) i) j) =
   (infix_asdt
    ((m (int.EuclideanDivision.div i (rows n)))
     (int.EuclideanDivision.div j (columns n)))
    ((n (int.EuclideanDivision.mod1 i (rows n)))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_mod_values :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((((kronecker m n) i) j) =
   (infix_asdt
    ((m
      (int.EuclideanDivision.div
       (int.EuclideanDivision.mod1 i (rows (kronecker m n))) (rows n)))
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 j (columns (kronecker m n))) (columns n)))
    ((n
      (int.EuclideanDivision.mod1
       (int.EuclideanDivision.mod1 i (rows (kronecker m n))) (rows n)))
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.mod1 j (columns (kronecker m n))) (columns n))))).

Axiom kronecker_indexes :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z),
  (valid_index m i j) -> (valid_index n k l) ->
  valid_index (kronecker m n) ((i * (rows n))%Z + k)%Z
  ((j * (columns n))%Z + l)%Z.

Axiom kronecker_indexes_com :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  (valid_index m (int.EuclideanDivision.div i (rows n))
   (int.EuclideanDivision.div j (columns n))) /\
  (valid_index n (int.EuclideanDivision.mod1 i (rows n))
   (int.EuclideanDivision.mod1 j (columns n))).

Axiom kronecker_assoc_pre :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (((rows m) * (rows n))%Z * (rows o))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < (((columns m) * (columns n))%Z * (columns o))%Z)%Z) ->
  ((((kronecker (kronecker m n) o) i) j) =
   (((kronecker m (kronecker n o)) i) j)).

Axiom kronecker_assoc :
  op_assoc (fun (y0:Z -> Z -> t) (y1:Z -> Z -> t) => (kronecker y0 y1)).

Axiom neutral_ :
  forall (m:Z -> Z -> t),
  ((kronecker m kronecker_neutral) = m) /\
  ((kronecker kronecker_neutral m) = m).

Axiom neutral1 :
  (kronecker_neutral =
   (neutral_elt (fun (y0:Z -> Z -> t) (y1:Z -> Z -> t) => (kronecker y0 y1)))) /\
  (has_neutral (fun (y0:Z -> Z -> t) (y1:Z -> Z -> t) => (kronecker y0 y1))).

Axiom kronecker_equal :
  forall (m:Z -> Z -> t) (ml:Z -> Z -> t) (n:Z -> Z -> t) (nl:Z -> Z -> t),
  (equal m ml) -> (equal n nl) -> equal (kronecker m n) (kronecker ml nl).

(* Why3 assumption *)
Definition frows (f:Z -> Z -> Z -> t) (k:Z) : Z := rows (f k).

Axiom frows_spec : forall (f:Z -> Z -> Z -> t) (k:Z), (0%Z < (frows f k))%Z.

(* Why3 assumption *)
Definition fcolumns (f:Z -> Z -> Z -> t) (k:Z) : Z := columns (f k).

Axiom fcolumns_spec :
  forall (f:Z -> Z -> Z -> t) (k:Z), (0%Z < (fcolumns f k))%Z.

Axiom const_fcol :
  forall (m:Z -> Z -> t) (k:Z),
  ((fcolumns ((fun (y0:Z -> Z -> t) (y1:Z) => y0) m) k) = (columns m)).

Axiom const_frows :
  forall (m:Z -> Z -> t) (k:Z),
  ((frows ((fun (y0:Z -> Z -> t) (y1:Z) => y0) m) k) = (rows m)).

Parameter k_iter: (Z -> Z -> Z -> t) -> Z -> Z -> Z -> Z -> t.

Axiom k_iter_def :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (i <= j)%Z ->
  ((k_iter f i j) =
   (int_iterate (fun (y0:Z -> Z -> t) (y1:Z -> Z -> t) => (kronecker y0 y1))
    f i j)).

Axiom k_iter_spec :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (i <= j)%Z ->
  ((rows (k_iter f i j)) =
   (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f) i j)) /\
  ((columns (k_iter f i j)) =
   (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f) i
    j)).

Axiom iterable_kronecker :
  iterable (fun (y0:Z -> Z -> t) (y1:Z -> Z -> t) => (kronecker y0 y1)).

Axiom k_iter_cardone :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((k_iter f i j) = (f i)).

Axiom k_iter_right_extension :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((k_iter f i j) = (kronecker (k_iter f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom k_iter_left_extension :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((k_iter f i j) = (kronecker (f i) (k_iter f (i + 1%Z)%Z j))).

Parameter kproj: (Z -> Z -> Z -> t) -> Z -> Z -> Z -> Z -> Z -> t.

Axiom kproj_def :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  (0%Z <= j)%Z -> (l < h)%Z -> ((0%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj f i j k l h) =
   (((f ((l + k)%Z - 1%Z)%Z)
     (kth_left i k l h
      ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)))
    (kth_left j k l h
     ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)))).

Axiom kproj_const :
  forall (c:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  (0%Z <= j)%Z -> (0%Z <= l)%Z -> ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj ((fun (y0:Z -> Z -> t) (y1:Z) => y0) c) i j k l h) =
   ((c (kth_nit_l i k (rows c) (h - l)%Z))
    (kth_nit_l j k (columns c) (h - l)%Z))).

Axiom kproj_const_prod :
  forall (c:Z -> Z -> t) (i:Z) (j:Z) (l:Z) (h:Z), (1%Z <= l)%Z ->
  (0%Z <= i)%Z -> (0%Z <= j)%Z -> (1%Z <= (h - l)%Z)%Z ->
  ((ind_product
    (fun (k:Z) => (kproj ((fun (y0:Z -> Z -> t) (y1:Z) => y0) c) i j k l h))
    1%Z ((h - l)%Z + 1%Z)%Z)
   =
   (ind_product
    (fun (k:Z) =>
     ((c (kth_nit_l i k (rows c) (h - l)%Z))
      (kth_nit_l j k (columns c) (h - l)%Z)))
    1%Z ((h - l)%Z + 1%Z)%Z)).

Parameter kproj_kth_right:
  (Z -> Z -> Z -> t) -> Z -> Z -> Z -> Z -> Z -> unit.

Axiom kproj_kth_right_def :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  (l < h)%Z -> (0%Z <= j)%Z -> ((0%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj_kth_right f i j k l h) = tt).

Axiom kproj_kth_right_spec :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  (l < h)%Z -> (0%Z <= j)%Z -> ((0%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj f i j k l h) =
   (((f ((l + k)%Z - 1%Z)%Z)
     (kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h
      ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)))
    (kth_right j (((h - l)%Z - k)%Z + 1%Z)%Z h
     ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)))).

Axiom kproj_div_mod :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  (l < h)%Z -> (0%Z <= j)%Z -> ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj f i j k l h) =
   (((f ((l + k)%Z - 1%Z)%Z)
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i
       (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)
        ((l + k)%Z - 1%Z)%Z h))
      (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)
       (l + k)%Z h)))
    (int.EuclideanDivision.div
     (int.EuclideanDivision.mod1 j
      (ind_iproduct
       ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
       ((l + k)%Z - 1%Z)%Z h))
     (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
      (l + k)%Z h)))).

Axiom kproj_const_div_mod :
  forall (c:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  ((0%Z <= l)%Z /\ (l < h)%Z) -> (0%Z <= j)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj ((fun (y0:Z -> Z -> t) (y1:Z) => y0) c) i j k l h) =
   ((c
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i
       (power (rows c) (((h - l)%Z - k)%Z + 1%Z)%Z))
      (power (rows c) ((h - l)%Z - k)%Z)))
    (int.EuclideanDivision.div
     (int.EuclideanDivision.mod1 j
      (power (columns c) (((h - l)%Z - k)%Z + 1%Z)%Z))
     (power (columns c) ((h - l)%Z - k)%Z)))).

Axiom kproj_const_transl :
  forall (c:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (t1:Z) (l:Z) (h:Z),
  (1%Z <= l)%Z -> (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z <= t1)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj ((fun (y0:Z -> Z -> t) (y1:Z) => y0) c) i j k l h) =
   (kproj ((fun (y0:Z -> Z -> t) (y1:Z) => y0) c) i j k (l + t1)%Z
    (h + t1)%Z)).

Axiom kproj_const_transl_gen :
  forall (c:Z -> Z -> t) (i:Z) (j:Z) (t1:Z) (l:Z) (h:Z), (1%Z <= l)%Z ->
  (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z <= t1)%Z -> forall (k:Z),
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj ((fun (y0:Z -> Z -> t) (y1:Z) => y0) c) i j k l h) =
   (kproj ((fun (y0:Z -> Z -> t) (y1:Z) => y0) c) i j k (l + t1)%Z
    (h + t1)%Z)).

Axiom kproj_div_mod_genk :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  (l < h)%Z -> (0%Z <= j)%Z -> forall (k:Z),
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj f i j k l h) =
   (((f ((l + k)%Z - 1%Z)%Z)
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i
       (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)
        ((l + k)%Z - 1%Z)%Z h))
      (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)
       (l + k)%Z h)))
    (int.EuclideanDivision.div
     (int.EuclideanDivision.mod1 j
      (ind_iproduct
       ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
       ((l + k)%Z - 1%Z)%Z h))
     (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
      (l + k)%Z h)))).

Axiom kproj_trans :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z) (t1:Z),
  (0%Z <= i)%Z -> (l < h)%Z -> (0%Z <= j)%Z ->
  ((0%Z <= t1)%Z /\ (t1 <= k)%Z) -> ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  ((kproj f
    (int.EuclideanDivision.div i
     (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f) h
      (h + t1)%Z))
    (int.EuclideanDivision.div j
     (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
      h (h + t1)%Z))
    k l h)
   = (kproj f i j (k - t1)%Z (l + t1)%Z (h + t1)%Z)).

Axiom kproj_transl_minus_one :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z) (h:Z), (0%Z <= i)%Z ->
  (l < h)%Z -> (0%Z <= j)%Z -> ((0%Z <= k)%Z /\ (k < (h - l)%Z)%Z) ->
  ((kproj f (int.EuclideanDivision.div i (frows f (h - 1%Z)%Z))
    (int.EuclideanDivision.div j (fcolumns f (h - 1%Z)%Z)) (k + 1%Z)%Z
    (l - 1%Z)%Z (h - 1%Z)%Z)
   = (kproj f i j k l h)).

Axiom k_iter_values_pre :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (l:Z) (h:Z),
  ((0%Z <= i)%Z /\
   (i <
    (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f) l
     h))%Z) ->
  ((0%Z <= j)%Z /\
   (j <
    (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
     l h))%Z) ->
  (l < h)%Z -> (1%Z <= h)%Z ->
  ((((k_iter f l h) i) j) =
   (infix_asdt
    (((k_iter f l (h - 1%Z)%Z)
      (int.EuclideanDivision.div i (frows f (h - 1%Z)%Z)))
     (int.EuclideanDivision.div j (fcolumns f (h - 1%Z)%Z)))
    (((f (h - 1%Z)%Z)
      (kth_right i 1%Z h
       ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)))
     (kth_right j 1%Z h
      ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f))))) /\
  ((((k_iter f l h) i) j) =
   (infix_asdt
    (((k_iter f l (h - 1%Z)%Z)
      (int.EuclideanDivision.div i (frows f (h - 1%Z)%Z)))
     (int.EuclideanDivision.div j (fcolumns f (h - 1%Z)%Z)))
    (((f (h - 1%Z)%Z)
      (kth_left i (h - l)%Z l h
       ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f)))
     (kth_left j (h - l)%Z l h
      ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f))))).

Axiom k_iter_values_pre_proj :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (l:Z) (h:Z),
  ((0%Z <= i)%Z /\
   (i <
    (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f) l
     h))%Z) ->
  ((0%Z <= j)%Z /\
   (j <
    (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
     l h))%Z) ->
  (l < h)%Z -> (1%Z <= h)%Z ->
  ((((k_iter f l h) i) j) =
   (infix_asdt
    (((k_iter f l (h - 1%Z)%Z)
      (int.EuclideanDivision.div i (frows f (h - 1%Z)%Z)))
     (int.EuclideanDivision.div j (fcolumns f (h - 1%Z)%Z)))
    (kproj f i j (h - l)%Z l h))).

Axiom k_iter_values_guarded :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (l:Z) (h:Z),
  ((0%Z <= i)%Z /\
   (i <
    (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (frows y0 y1)) f) l
     h))%Z) ->
  ((0%Z <= j)%Z /\
   (j <
    (ind_iproduct ((fun (y0:Z -> Z -> Z -> t) (y1:Z) => (fcolumns y0 y1)) f)
     l h))%Z) ->
  (1%Z <= (h - l)%Z)%Z -> (0%Z <= l)%Z ->
  ((((k_iter f l h) i) j) =
   (ind_product (fun (k:Z) => (kproj f i j k l h)) 1%Z ((h - l)%Z + 1%Z)%Z)).

Axiom k_iter_values :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z) (l:Z) (h:Z),
  (valid_index (k_iter f l h) i j) -> ((0%Z <= l)%Z /\ (l < h)%Z) ->
  ((((k_iter f l h) i) j) =
   (ind_product (fun (k:Z) => (kproj f i j k l h)) 1%Z ((h - l)%Z + 1%Z)%Z)).

Axiom k_iter_values_gen :
  forall (f:Z -> Z -> Z -> t) (l:Z) (h:Z), ((0%Z <= l)%Z /\ (l < h)%Z) ->
  forall (i:Z) (j:Z), (valid_index (k_iter f l h) i j) ->
  ((((k_iter f l h) i) j) =
   (ind_product (fun (k:Z) => (kproj f i j k l h)) 1%Z ((h - l)%Z + 1%Z)%Z)).

Parameter mat_mult_no_bound: (Z -> Z -> t) -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom mat_mult_no_bound_def :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t),
  (((columns m) = (rows n)) ->
   ((mat_mult_no_bound m n) =
    (make_f (rows m) (columns n)
     (fun (i:Z) (j:Z) =>
      (ind_sum (fun (k:Z) => (infix_asdt ((m i) k) ((n k) j))) 0%Z
       (columns m)))))) /\
  (~ ((columns m) = (rows n)) ->
   ((mat_mult_no_bound m n) = (make_f 0%Z 0%Z (fun (i:Z) (j:Z) => tzero)))).

Axiom mat_mult_no_bound_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t),
  (((columns m) = (rows n)) -> ((rows (mat_mult_no_bound m n)) = (rows m))) /\
  ((((columns m) = (rows n)) ->
    ((columns (mat_mult_no_bound m n)) = (columns n))) /\
   (((columns m) = (rows n)) -> forall (i:Z) (j:Z),
    (valid_index (mat_mult_no_bound m n) i j) ->
    ((((mat_mult_no_bound m n) i) j) =
     (ind_sum (fun (k:Z) => (infix_asdt ((m i) k) ((n k) j))) 0%Z
      (columns m))))).

Parameter mat_mult: (Z -> Z -> t) -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom mat_mult_def :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((columns m) = (rows n)) ->
  ((mat_mult m n) = (mat_mult_no_bound m n)).

Axiom mat_mult_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((columns m) = (rows n)) ->
  ((rows (mat_mult m n)) = (rows m)) /\
  (((columns (mat_mult m n)) = (columns n)) /\
   forall (i:Z) (j:Z), (valid_index (mat_mult m n) i j) ->
   ((((mat_mult m n) i) j) =
    (ind_sum (fun (k:Z) => (infix_asdt ((m i) k) ((n k) j))) 0%Z (columns m)))).

Axiom mat_mult_values :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (i:Z) (j:Z),
  ((columns m) = (rows n)) -> (valid_index (mat_mult m n) i j) ->
  ((((mat_mult m n) i) j) =
   (ind_sum (fun (k:Z) => (infix_asdt ((m i) k) ((n k) j))) 0%Z (columns m))).

Axiom mat_mult_values_quant :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((columns m) = (rows n)) ->
  forall (i:Z) (j:Z), (valid_index (mat_mult m n) i j) ->
  ((((mat_mult m n) i) j) =
   (ind_sum (fun (k:Z) => (infix_asdt ((m i) k) ((n k) j))) 0%Z (columns m))).

Parameter int_mat_prod: (Z -> Z -> Z -> t) -> Z -> Z -> Z -> Z -> t.

Axiom int_mat_prod_def :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  (((j - i)%Z = 0%Z) -> ((int_mat_prod f i j) = (f i))) /\
  (~ ((j - i)%Z = 0%Z) ->
   ((int_mat_prod f i j) =
    (mat_mult_no_bound (int_mat_prod f i (j - 1%Z)%Z) (f j)))).

Axiom int_mat_prod_zero :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z),
  ((rows (f i)) = (columns (f i))) -> (i = j) ->
  ((int_mat_prod f i j) = (f i)).

Parameter int_mat_prod_plus_one: (Z -> Z -> Z -> t) -> Z -> Z -> unit.

Axiom int_mat_prod_plus_one_def :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((int_mat_prod_plus_one f i j) = tt).

Axiom int_mat_prod_plus_one_spec :
  forall (f:Z -> Z -> Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((int_mat_prod f i j) = (mat_mult (int_mat_prod f i (j - 1%Z)%Z) (f j))).

Axiom int_mat_prod_eq :
  forall (f:Z -> Z -> Z -> t) (g:Z -> Z -> Z -> t) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z), ((i <= k)%Z /\ (k <= j)%Z) ->
   ((i <= k')%Z /\ (k' <= j)%Z) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  (forall (k:Z), ((i <= k)%Z /\ (k <= j)%Z) -> ((f k) = (g k))) ->
  ((int_mat_prod f i j) = (int_mat_prod g i j)).

Parameter add_mat: (Z -> Z -> t) -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom add_mat_def :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((add_mat m n) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_pldt ((m i) j) ((n i) j))))).

Axiom add_mat_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (((columns (add_mat m n)) = (columns m)) /\ ((columns m) = (columns n))) /\
  ((((rows (add_mat m n)) = (rows m)) /\ ((rows m) = (rows n))) /\
   forall (i:Z) (j:Z), (valid_index (add_mat m n) i j) ->
   ((((add_mat m n) i) j) = (infix_pldt ((m i) j) ((n i) j)))).

Axiom add_value :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((columns m) = (columns n)) ->
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((((add_mat m n) i) j) = (infix_pldt ((m i) j) ((n i) j))).

Parameter add_neutral: unit -> Z -> Z -> t.

Axiom add_neutral_spec :
  forall (us:unit),
  (forall (i:Z) (j:Z), (valid_index (add_neutral us) i j) ->
   ((((add_neutral us) i) j) = tzero)) /\
  ((0%Z < (rows (add_neutral us)))%Z /\ (0%Z < (columns (add_neutral us)))%Z).

Axiom distr_1_pre :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t) (i:Z) (j:Z),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns o))%Z) ->
  ((((mat_mult (add_mat m n) o) i) j) =
   (((add_mat (mat_mult m o) (mat_mult n o)) i) j)) /\
  (equal (mat_mult (add_mat m n) o) (add_mat (mat_mult m o) (mat_mult n o))).

Axiom distr_l :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) ->
  ((mat_mult (add_mat m n) o) = (add_mat (mat_mult m o) (mat_mult n o))).

Axiom distr_2_pre :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t) (i:Z) (j:Z),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  (valid_index (mat_mult m (add_mat n o)) i j) /\
  (((((mat_mult m (add_mat n o)) i) j) =
    (((add_mat (mat_mult m n) (mat_mult m o)) i) j)) /\
   (equal (mat_mult m (add_mat n o)) (add_mat (mat_mult m n) (mat_mult m o)))).

Axiom distr_r :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) ->
  ((mat_mult m (add_mat n o)) = (add_mat (mat_mult m n) (mat_mult m o))).

Parameter infix_asdtdt: t -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom infix_asdtdt_spec :
  forall (s:t) (m:Z -> Z -> t),
  ((columns (infix_asdtdt s m)) = (columns m)) /\
  (((rows (infix_asdtdt s m)) = (rows m)) /\
   ((forall (i:Z) (j:Z), (valid_index (infix_asdtdt s m) i j) ->
     ((((infix_asdtdt s m) i) j) = (infix_asdt s ((m i) j)))) /\
    forall (i:Z) (j:Z),
    (valid_index (infix_asdtdt s m) i j) <-> (valid_index m i j))).

(* Why3 assumption *)
Definition mat_terms := Z -> Z -> Z -> t.

(* Why3 assumption *)
Definition mat_terms_bis := Z -> Z -> Z -> Z -> t.

(* Why3 assumption *)
Definition mat_sterms (a:Type) := a -> Z -> Z -> t.

(* Why3 assumption *)
Definition constant_size {a:Type} {a_WT:WhyType a} (s:set a)
    (f:a -> Z -> Z -> t) : Prop :=
  forall (e:a), (mem e s) ->
  ((rows (f e)) = (rows (f (choose s)))) /\
  ((columns (f e)) = (columns (f (choose s)))).

Axiom set_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t),
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((rows (f e)) = (rows (f e')))) ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((columns (f e)) = (columns (f e')))) ->
  constant_size s f.

Axiom set_constant_size_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (r:Z) (c:Z),
  (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) -> constant_size s f.

Parameter fc1:
  forall {a:Type} {a_WT:WhyType a}, (a -> Z -> Z -> t) -> (a -> bool) ->
  (Z -> Z -> t) -> a -> Z -> Z -> t.

Axiom fc_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> Z -> Z -> t) (p:a -> bool) (m:Z -> Z -> t) (j:a),
  (((p j) = true) -> (((fc1 f p m) j) = (f j))) /\
  (~ ((p j) = true) -> (((fc1 f p m) j) = m)).

Axiom guarded_set_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (p:a -> bool) (m:Z -> Z -> t),
  (constant_size s f) -> (forall (e:a), (mem e s) -> ((p e) = true)) ->
  constant_size s (fc1 f p m).

Axiom set_constant_size_set :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (m:Z -> Z -> t) (i:Z) (j:Z),
  (valid_index m i j) -> constant_size s (fun (e:a) => (set1 m i j (f e))).

Axiom set_constant_size_scal :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (a1:t), (constant_size s f) ->
  constant_size s (fun (j:a) => (infix_asdtdt a1 (f j))).

Axiom get_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((rows (f e)) = (rows (f e')))) /\
  forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
  ((columns (f e)) = (columns (f e'))).

Parameter s_rows:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z -> Z -> t) -> Z.

Axiom s_rows_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  ((s_rows s f) = (rows (f (choose s)))).

Axiom s_rows_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  (0%Z < (s_rows s f))%Z /\
  ((forall (e:a), (mem e s) -> ((rows (f e)) = (s_rows s f))) /\
   forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((rows (f e)) = (rows (f e')))).

Parameter s_columns:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z -> Z -> t) -> Z.

Axiom s_columns_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  ((s_columns s f) = (columns (f (choose s)))).

Axiom s_columns_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  (0%Z < (s_columns s f))%Z /\
  ((forall (e:a), (mem e s) -> ((columns (f e)) = (s_columns s f))) /\
   forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((columns (f e)) = (columns (f e')))).

Axiom subset_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  ~ (is_empty s') -> (subset s' s) ->
  (constant_size s' f) /\
  (((s_rows s' f) = (s_rows s f)) /\ ((s_columns s' f) = (s_columns s f))).

Parameter mat_sum:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z -> Z -> t) ->
  Z -> Z -> t.

Axiom mat_sum_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  (((cardinal s) = 0%Z) -> ((mat_sum s f) = (make 0%Z 0%Z tzero))) /\
  (~ ((cardinal s) = 0%Z) ->
   (((cardinal s) = 1%Z) -> ((mat_sum s f) = (f (element s)))) /\
   (~ ((cardinal s) = 1%Z) ->
    ((mat_sum s f) =
     (add_mat (f (choose s)) (mat_sum (remove (choose s) s) f))))).

Axiom mat_sum_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  ((rows (mat_sum s f)) = (s_rows s f)) /\
  (((columns (mat_sum s f)) = (s_columns s f)) /\
   ((forall (e:a), (mem e s) -> ((rows (f e)) = (s_rows s f))) /\
    ((forall (e:a), (mem e s) -> ((columns (f e)) = (s_columns s f))) /\
     ((columns (mat_sum s f)) = (s_columns s f))))).

Axiom columns_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (n:Z), (constant_size s f) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = n)) ->
  ((columns (mat_sum s f)) = n).

Axiom rows_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (n:Z), (constant_size s f) ->
  (forall (e:a), (mem e s) -> ((rows (f e)) = n)) ->
  ((rows (mat_sum s f)) = n).

Axiom mat_sum_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (x:a), ~ (mem x s) ->
  ((mat_sum (add x s) f) = (add_mat (f x) (mat_sum s f))).

Axiom mat_sum_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), ((cardinal s) = 1%Z) ->
  ((mat_sum s f) = (f (element s))).

Axiom mat_sum_to_sum_pre :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (i:Z) (j:Z), (constant_size s f) ->
  (0%Z < (cardinal s))%Z -> ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
  ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
  ((((mat_sum s f) i) j) = (sum s (fun (e:a) => (((f e) i) j)))).

Axiom mat_sum_to_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  (0%Z < (cardinal s))%Z ->
  ((mat_sum s f) =
   (make_f (s_rows s f) (s_columns s f)
    (fun (i:Z) (j:Z) => (sum s (fun (e:a) => (((f e) i) j)))))).

Axiom mat_sum_scalar :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (a1:t), (constant_size s f) ->
  (0%Z < (cardinal s))%Z ->
  ((mat_sum s (fun (k:a) => (infix_asdtdt a1 (f k)))) =
   (infix_asdtdt a1 (mat_sum s f))).

Axiom mat_sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t) (g:a -> Z -> Z -> t),
  (constant_size s f) -> (forall (a1:a), (mem a1 s) -> ((f a1) = (g a1))) ->
  ((mat_sum s f) = (mat_sum s g)).

Axiom map_mat_sum :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> Z -> Z -> t) (s:set a) (t1:a -> b),
  (constant_size s (fun (a1:a) => (f (t1 a1)))) ->
  (constant_size (map t1 s) f) -> (p_injective t1 s) ->
  ((mat_sum (map t1 s) f) = (mat_sum s (fun (a1:a) => (f (t1 a1))))).

Axiom mat_sum_id :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> Z -> Z -> t) (s:set a), (constant_size s f) ->
  (constant_size (map f s) (fun (y0:Z -> Z -> t) => y0)) ->
  ((mat_sum (map f s) (fun (y0:Z -> Z -> t) => y0)) = (mat_sum s f)).

Parameter nonn_mat_subset:
  forall {a:Type} {a_WT:WhyType a}, (a -> Z -> Z -> t) -> (set a) -> set a.

Parameter result4:
  forall {a:Type} {a_WT:WhyType a}, (a -> Z -> Z -> t) -> (set a) ->
  a -> bool.

Axiom result_def4 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> Z -> Z -> t) (s:set a) (e:a),
  (((result4 f s) e) = true) <->
  ~ (equal (f e) (make (s_rows s f) (s_columns s f) tzero)).

Axiom nonn_mat_subset_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> Z -> Z -> t) (s:set a), (constant_size s f) ->
  ((nonn_mat_subset f s) = (filter (result4 f s) s)).

Axiom nonn_mat_subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> Z -> Z -> t) (s:set a), (constant_size s f) ->
  subset (nonn_mat_subset f s) s.

Axiom nonn_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> Z -> Z -> t) (s:set a), (constant_size s f) ->
  ((mat_sum s f) = (mat_sum (nonn_mat_subset f s) f)).

Parameter inv_func:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv_func_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e':b), (p_bijective f s s') ->
  (mem e' s') ->
  ((inv_func f s s' e') =
   (element (filter (fun (e:a) => (indic_bool (f e) e')) s))).

Axiom inv_func_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e':b), (p_bijective f s s') ->
  (mem e' s') ->
  (mem (inv_func f s s' e') s) /\ ((f (inv_func f s s' e')) = e').

Parameter inv_:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv__def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e:b), (p_bijective f s s') ->
  (mem e s') -> ((inv_ f s s' e) = (inv_func f s s' e)).

Axiom inv__spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e:b), (p_bijective f s s') ->
  (mem e s') -> (mem (inv_ f s s' e) s) /\ ((f (inv_ f s s' e)) = e).

Axiom inv_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_bijective
  ((((fun (y0:a -> b) (y1:set a) (y2:set b) (y3:b) => (inv_ y0 y1 y2 y3)) f)
    s)
   s')
  s' s.

Axiom set_bijective_inv :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a) (b1:b), (mem b1 (map f s)) ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  (p_bijective f s (map f s)) /\ ((inv_func f s (map f s) b1) = (g b1)).

Axiom set_bij_inv :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a),
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  (p_bijective f s (map f s)) /\
  forall (b1:b), (mem b1 (map f s)) -> ((inv_func f s (map f s) b1) = (g b1)).

(* Why3 assumption *)
Definition bvlength (bv:Z -> Z) (i:Z) : Prop := is_binary bv 1%Z (i + 1%Z)%Z.

Parameter length: (Z -> Z) -> Z.

Axiom length_spec :
  forall (bv:Z -> Z), (0%Z <= (length bv))%Z /\ (bvlength bv (length bv)).

Axiom set_bv_to :
  forall (bv:Z -> Z) (i:Z), (0%Z < i)%Z ->
  (forall (j:Z), ((1%Z <= j)%Z /\ (j <= i)%Z) ->
   (0%Z <= (bv j))%Z /\ ((bv j) <= 1%Z)%Z) ->
  bvlength bv i.

Axiom bvlengthm :
  forall (bv:Z -> Z) (i:Z), ((1%Z <= i)%Z /\ (i <= (length bv))%Z) ->
  bvlength bv i.

(* Why3 assumption *)
Definition in_range (bv:Z -> Z) (r:Z) : Prop :=
  (1%Z <= r)%Z /\ (r <= (length bv))%Z.

Axiom binary_bv :
  forall (bv:Z -> Z) (i:Z), (in_range bv i) ->
  (0%Z <= (bv i))%Z /\ ((bv i) <= 1%Z)%Z.

Axiom equal_bv :
  forall (m:Z -> Z) (n:Z -> Z),
  (m = n) <->
  (((length m) = (length n)) /\
   forall (i:Z), (in_range m i) -> ((m i) = (n i))).

Axiom set_equal_bv :
  forall (bv:Z -> Z) (bv':Z -> Z), ((length bv) = (length bv')) ->
  (forall (i:Z), ((1%Z <= i)%Z /\ (i <= (length bv))%Z) ->
   ((bv i) = (bv' i))) ->
  (bv = bv').

Parameter make_bv: (Z -> Z) -> Z -> Z -> Z.

Axiom make_bv_spec :
  forall (f:Z -> Z) (s:Z), (bvlength f s) -> (0%Z <= s)%Z ->
  ((length (make_bv f s)) = s) /\
  forall (i:Z), (in_range (make_bv f s) i) -> (((make_bv f s) i) = (f i)).

Parameter head: (Z -> Z) -> Z.

Axiom head_def :
  forall (bv:Z -> Z), (1%Z <= (length bv))%Z -> ((head bv) = (bv 1%Z)).

Axiom head_spec :
  forall (bv:Z -> Z), (1%Z <= (length bv))%Z ->
  (0%Z <= (head bv))%Z /\ ((head bv) <= 1%Z)%Z.

Parameter tail: (Z -> Z) -> Z -> Z.

Axiom tail_def :
  forall (bv:Z -> Z), (1%Z <= (length bv))%Z ->
  ((tail bv) =
   (make_bv (fun (i:Z) => (bv (i + 1%Z)%Z)) ((length bv) - 1%Z)%Z)).

Axiom tail_spec :
  forall (bv:Z -> Z), (1%Z <= (length bv))%Z ->
  ((length (tail bv)) = ((length bv) - 1%Z)%Z) /\
  forall (i:Z), (in_range (tail bv) i) -> (((tail bv) i) = (bv (i + 1%Z)%Z)).

Parameter concat_l: (Z -> Z) -> Z -> Z -> Z.

Parameter result5: (Z -> Z) -> Z -> Z -> Z.

Axiom result_def5 :
  forall (bv:Z -> Z) (i:Z) (k:Z),
  ((k = 1%Z) -> (((result5 bv i) k) = i)) /\
  (~ (k = 1%Z) -> (((result5 bv i) k) = (bv (k - 1%Z)%Z))).

Axiom concat_l_def :
  forall (bv:Z -> Z) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((concat_l bv i) = (make_bv (result5 bv i) ((length bv) + 1%Z)%Z)).

Axiom concat_l_spec :
  forall (bv:Z -> Z) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((length (concat_l bv i)) = ((length bv) + 1%Z)%Z) /\
  ((((concat_l bv i) 1%Z) = i) /\
   forall (j:Z), (in_range bv j) -> (((concat_l bv i) (j + 1%Z)%Z) = (bv j))).

Axiom concat_ht :
  forall (bv:Z -> Z), (1%Z <= (length bv))%Z ->
  (bv = (concat_l (tail bv) (head bv))).

Axiom concat_ht_union :
  forall (bv:Z -> Z), (2%Z <= (length bv))%Z ->
  ~ (bv = (concat_l (tail bv) 0%Z)) -> (bv = (concat_l (tail bv) 1%Z)).

Parameter result6: (Z -> Z) -> Z -> Z.

Axiom result_def6 :
  forall (bv:Z -> Z) (k:Z),
  ((in_range bv k) ->
   (((result6 bv) k) =
    ((bv (((length bv) - k)%Z + 1%Z)%Z) * (power 2%Z (k - 1%Z)%Z))%Z)) /\
  (~ (in_range bv k) -> (((result6 bv) k) = 1%Z)).

(* Why3 assumption *)
Definition bv_to_int (bv:Z -> Z) : Z :=
  ind_isum (result6 bv) 1%Z ((length bv) + 1%Z)%Z.

Axiom bv_to_int_spec :
  forall (bv:Z -> Z),
  ((bv_to_int bv) =
   (ind_isum
    (fun (k:Z) =>
     ((bv (((length bv) - k)%Z + 1%Z)%Z) * (power 2%Z (k - 1%Z)%Z))%Z)
    1%Z ((length bv) + 1%Z)%Z)).

Parameter int_to_bv: Z -> Z -> Z -> Z.

Axiom int_to_bv_def :
  forall (i:Z) (n:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  ((int_to_bv i n) =
   (make_bv (((fun (y0:Z) (y1:Z) (y2:Z) => (kth_bit_l y0 y1 y2)) i) n) n)).

Axiom int_to_bv_spec :
  forall (i:Z) (n:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  (i =
   (ind_isum (fun (k:Z) => (((int_to_bv i n) k) * (power 2%Z (k - 1%Z)%Z))%Z)
    1%Z (n + 1%Z)%Z)).

Axiom concat_to_int :
  forall (bv:Z -> Z) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((bv_to_int (concat_l bv i)) =
   ((bv_to_int bv) + (i * (power 2%Z (length bv)))%Z)%Z).

Axiom bounded_to_int :
  forall (bv:Z -> Z), ((bv_to_int bv) < (power 2%Z (length bv)))%Z.

Axiom to_int_head_tail :
  forall (bv:Z -> Z), (1%Z <= (length bv))%Z ->
  ((bv_to_int bv) =
   ((bv_to_int (tail bv)) + ((head bv) * (power 2%Z (length bv)))%Z)%Z) /\
  ((bv_to_int (tail bv)) =
   (int.EuclideanDivision.mod1 (bv_to_int (tail bv))
    (power 2%Z ((length bv) - 1%Z)%Z))).

Parameter n_bvs: Z -> set (Z -> Z).

Axiom n_bvs_def :
  forall (n:Z), (0%Z <= n)%Z ->
  ((n = 0%Z) ->
   ((n_bvs n) =
    (add (make_bv (fun (i:Z) => 0%Z) 0%Z) (empty : set (Z -> Z))))) /\
  (~ (n = 0%Z) ->
   ((n_bvs n) =
    (union (map (fun (bv:Z -> Z) => (concat_l bv 0%Z)) (n_bvs (n - 1%Z)%Z))
     (map (fun (bv:Z -> Z) => (concat_l bv 1%Z)) (n_bvs (n - 1%Z)%Z))))).

Axiom n_bvs_spec :
  forall (n:Z), (0%Z <= n)%Z -> forall (f:Z -> Z),
  (mem f (n_bvs n)) <-> ((length f) = n).

Axiom injective_bv_to_int :
  forall (n:Z), (0%Z <= n)%Z ->
  p_injective (fun (y0:Z -> Z) => (bv_to_int y0)) (n_bvs n).

Axiom bijective_to_int :
  forall (n:Z), (0%Z <= n)%Z ->
  p_bijective (fun (y0:Z -> Z) => (bv_to_int y0)) (n_bvs n)
  (to_fset 0%Z (power 2%Z n)).

Axiom sum_concat :
  forall (f:(Z -> Z) -> Z -> Z -> t) (i:Z),
  ((mat_sum (n_bvs i)
    (fun (bv:Z -> Z) =>
     (add_mat (f (concat_l bv 0%Z)) (f (concat_l bv 1%Z)))))
   = (mat_sum (n_bvs (i + 1%Z)%Z) f)).

Axiom k_iter_sums :
  forall (f:Z -> Z -> Z -> Z -> t) (n:Z),
  ((k_iter (fun (i:Z) => (add_mat ((f i) 0%Z) ((f i) 1%Z))) 1%Z n) =
   (mat_sum (n_bvs n)
    (fun (bv:Z -> Z) => (k_iter (fun (i:Z) => ((f i) (bv i))) 1%Z n)))).

(* Why3 assumption *)
Definition bv_inversion (bv:Z -> Z) : Z -> Z :=
  make_bv (fun (k:Z) => (bv (((length bv) - k)%Z + 1%Z)%Z)) (length bv).

Axiom bv_inversion_spec :
  forall (bv:Z -> Z),
  ((length (bv_inversion bv)) = (length bv)) /\
  forall (k:Z), (in_range (bv_inversion bv) k) ->
  (((bv_inversion bv) k) = (bv (((length bv) - k)%Z + 1%Z)%Z)).

Parameter int_bit_inversion: Z -> Z -> Z.

Axiom int_bit_inversion_def :
  forall (i:Z) (n:Z), (0%Z < n)%Z -> (0%Z <= i)%Z ->
  ((int_bit_inversion i n) = (bv_to_int (bv_inversion (int_to_bv i n)))).

Axiom int_bit_inversion_spec :
  forall (i:Z) (n:Z), (0%Z < n)%Z -> (0%Z <= i)%Z ->
  (0%Z <= (int_bit_inversion i n))%Z.

Axiom int_bit_inversion_ht :
  forall (i:Z) (n:Z), (0%Z < n)%Z -> (0%Z <= i)%Z ->
  ((int_bit_inversion i n) =
   ((2%Z * (int_bit_inversion (tail_bits i n) (n - 1%Z)%Z))%Z +
    (head_bit i n))%Z).

Parameter cpower: t -> Z -> t.

Axiom cpower_def :
  forall (e:t) (i:Z), (0%Z <= i)%Z ->
  ((cpower e i) = (c_iter (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) e i)).

Axiom cpower_spec :
  forall (e:t) (i:Z), (0%Z <= i)%Z ->
  ((cpower e i) =
   (int_iterate (fun (y0:t) (y1:t) => (infix_asdt y0 y1))
    ((fun (y0:t) (y1:Z) => y0) e) 0%Z i)).

Axiom cpower_zero : forall (e:t), ((cpower e 0%Z) = tone).

Axiom cpower_plus_one :
  forall (e:t) (i:Z), (0%Z < i)%Z ->
  ((cpower e i) = (infix_asdt e (cpower e (i - 1%Z)%Z))) /\
  ((cpower e i) = (infix_asdt (cpower e (i - 1%Z)%Z) e)).

Parameter infix_lsdt_closure: t -> t -> bool.

Parameter infix_lseqdt_closure: t -> t -> bool.

Axiom infix_lsdt_closure_def :
  forall (y:t) (y1:t),
  (((infix_lsdt_closure y) y1) = true) <-> (infix_lsdt y y1).

Axiom infix_lseqdt_closure_def :
  forall (y:t) (y1:t),
  (((infix_lseqdt_closure y) y1) = true) <-> (infix_lseqdt y y1).

Axiom pre_cond_int1 :
  (compat_order_mult infix_lsdt_closure
   (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tzero) /\
  ((compat_order_mult infix_lseqdt_closure
    (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tzero) /\
   ((infix_lsdt tzero tone) /\
    ((partial_order infix_lseq_closure) /\
     ((neutral (fun (y0:t) (y1:t) => (infix_asdt y0 y1)) tone) /\
      ((iterable (fun (y0:t) (y1:t) => (infix_asdt y0 y1))) /\
       (strict infix_lsdt_closure infix_lseqdt_closure)))))).

Axiom cpower_sum :
  forall (x:t) (n:Z) (m:Z), (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((cpower x (n + m)%Z) = (infix_asdt (cpower x n) (cpower x m))).

Axiom c_iter_comm11 :
  forall (op1:t -> t -> t) (x:t) (y:t) (n:Z), (commut op1) -> (0%Z <= n)%Z ->
  (((op1 (c_iter op1 x n)) y) = ((op1 y) (c_iter op1 x n))).

Axiom c_iter_op_comm12 :
  forall (x:t) (y:t) (n:Z), (0%Z <= n)%Z ->
  ((infix_asdt (cpower x n) y) = (infix_asdt y (cpower x n))).

Axiom c_iter_op_comm22 :
  forall (x:t) (y:t) (n:Z), (0%Z <= n)%Z ->
  ((cpower (infix_asdt x y) n) = (infix_asdt (cpower x n) (cpower y n))).

Axiom growing_mult1 :
  forall (n:t) (m:t), (infix_lseqdt tzero n) -> (infix_lseqdt tone m) ->
  infix_lseqdt n (infix_asdt n m).

Axiom c_power_mult :
  forall (x:t) (n:Z) (m:Z), (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((cpower x (n * m)%Z) = (cpower (cpower x n) m)).

Axiom strict_growing_mult1 :
  forall (n:t) (m:t), (infix_lsdt tone n) -> (infix_lsdt tone m) ->
  infix_lsdt n (infix_asdt n m).

Axiom init_exp1 :
  forall (k:t),
  ((cpower k 0%Z) = tone) /\
  (((cpower k 1%Z) = k) /\ ((cpower k 2%Z) = (infix_asdt k k))).

Axiom positive_int_exp1 :
  forall (k:t) (n:Z), (infix_lseqdt tone k) -> (0%Z <= n)%Z ->
  (infix_lseqdt tone (cpower k n)) /\
  ((infix_lsdt tzero (cpower k n)) /\
   (infix_lseqdt (cpower k n) (cpower k (n + 1%Z)%Z))).

Axiom strict_positive_int_exp1 :
  forall (k:t) (n:Z), (infix_lsdt tone k) -> (0%Z < n)%Z ->
  (infix_lsdt tone (cpower k n)) /\
  ((infix_lsdt (cpower k (n - 1%Z)%Z) (cpower k n)) /\
   (infix_lsdt (cpower k n) (cpower k (n + 1%Z)%Z))).

Axiom growing_exp1 :
  forall (k:t) (m:Z) (n:Z), (infix_lseqdt tone k) ->
  ((0%Z <= m)%Z /\ (m <= n)%Z) -> infix_lseqdt (cpower k m) (cpower k n).

Axiom strict_growing_exp1 :
  forall (k:t) (m:Z) (n:Z), (infix_lsdt tone k) ->
  ((0%Z <= m)%Z /\ (m < n)%Z) -> infix_lsdt (cpower k m) (cpower k n).

Axiom unicity_exp1 :
  forall (k:t) (m:Z) (n:Z), (infix_lsdt tone k) -> (0%Z <= m)%Z ->
  (0%Z <= n)%Z -> ((cpower k m) = (cpower k n)) <-> (m = n).

Parameter unity_rt: Z -> t.

Axiom unity_rt_spec :
  forall (n:Z), (0%Z <= n)%Z ->
  ((cpower (unity_rt n) n) = tone) /\ ~ ((unity_rt n) = tzero).

Axiom ax_unity_rt_trans :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((unity_rt n) = (cpower (unity_rt (n * k)%Z) k)).

Axiom Unity_rt_two : ((unity_rt 2%Z) = (prefix_mn tone)).

Parameter p_unity: Z -> Z -> t.

Axiom p_unity_def :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((p_unity n k) = (cpower (unity_rt n) k)).

Axiom unity_rt_trans :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((unity_rt n) = (cpower (unity_rt (n * k)%Z) k)).

Axiom p_unity_sum :
  forall (n:Z) (k:Z) (k':Z), (0%Z <= n)%Z -> (0%Z <= k)%Z -> (0%Z <= k')%Z ->
  ((p_unity n (k + k')%Z) = (infix_asdt (p_unity n k) (p_unity n k'))).

Axiom p_unity_neut :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((p_unity n (n * k)%Z) = tone).

Axiom p_unity_mod :
  forall (n:Z) (k:Z), (0%Z < n)%Z -> (0%Z <= k)%Z ->
  ((p_unity n k) = (p_unity n (int.EuclideanDivision.mod1 k n))).

Parameter omega: Z -> t.

Axiom omega_def :
  forall (n:Z), (0%Z <= n)%Z -> ((omega n) = (unity_rt (power 2%Z n))).

Parameter p_omega: Z -> Z -> t.

Axiom p_omega_def :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((p_omega n k) = (cpower (omega n) k)).

Axiom p_omega_spec :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((p_omega n k) = (p_unity (power 2%Z n) k)).

Axiom p_omega_sum :
  forall (n:Z) (k:Z) (k':Z), (0%Z <= n)%Z -> (0%Z <= k)%Z -> (0%Z <= k')%Z ->
  ((p_omega n (k + k')%Z) = (infix_asdt (p_omega n k) (p_omega n k'))).

Axiom p_omega_neut :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((p_omega n ((power 2%Z n) * k)%Z) = tone).

Axiom p_omega_mod :
  forall (n:Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((p_omega n k) = (p_omega n (int.EuclideanDivision.mod1 k (power 2%Z n)))).

Axiom p_omega_mod_rest :
  forall (n:Z) (k:Z) (i:Z), (0%Z <= n)%Z -> (0%Z <= k)%Z ->
  ((p_omega n ((k * (power 2%Z n))%Z + i)%Z) = (p_omega n i)).

Axiom omega_transl :
  forall (n:Z) (n':Z), (0%Z <= n)%Z -> (0%Z <= n')%Z -> (n <= n')%Z ->
  ((omega n) = (p_omega n' (power 2%Z (n' - n)%Z))).

Axiom p_omega_transl :
  forall (n:Z) (n':Z) (k:Z), (0%Z <= n)%Z -> (0%Z <= n')%Z -> (0%Z <= k)%Z ->
  (n <= n')%Z ->
  ((p_omega n k) = (p_omega n' (k * (power 2%Z (n' - n)%Z))%Z)).

Axiom unity_rt_two :
  forall (n:Z), (0%Z < n)%Z ->
  ((p_omega n (power 2%Z (n - 1%Z)%Z)) = (prefix_mn tone)).

Axiom p_omega_sum_units :
  forall (n:Z) (n':Z), (0%Z <= n)%Z -> (0%Z <= n')%Z -> (n <= n')%Z ->
  ((infix_asdt (omega n) (omega n')) =
   (p_omega n' (1%Z + (power 2%Z (n' - n)%Z))%Z)).

Axiom p_omega_add :
  forall (n:Z) (k:Z) (n':Z) (k':Z), ((n <= n')%Z /\ (0%Z <= n)%Z) ->
  (0%Z <= k)%Z -> (0%Z <= k')%Z ->
  ((infix_asdt (p_omega n k) (p_omega n' k')) =
   (p_omega n' (k' + (k * (power 2%Z (n' - n)%Z))%Z)%Z)).

Axiom omega_sum_to_prod :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Z) (f:a -> Z) (s:set a), (0%Z <= n)%Z ->
  (forall (e:a), (mem e s) -> (0%Z <= (f e))%Z) ->
  ((p_omega n (isum s f)) = (product s (fun (k:a) => (p_omega n (f k))))) /\
  (0%Z <= (isum s f))%Z.

Parameter fc2: Z -> (Z -> Z) -> Z -> Z -> Z -> t.

Axiom fc_def2 :
  forall (n:Z) (f:Z -> Z) (i:Z) (j:Z) (k:Z),
  (((i <= k)%Z /\ (k < j)%Z) -> (((fc2 n f i j) k) = (p_omega n (f k)))) /\
  (~ ((i <= k)%Z /\ (k < j)%Z) -> (((fc2 n f i j) k) = tone)).

Axiom omega_ind_sum_to_prod :
  forall (n:Z) (f:Z -> Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (0%Z <= n)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z <= (f k))%Z) ->
  ((p_omega n (ind_isum f i j)) = (ind_product (fc2 n f i j) i j)) /\
  (0%Z <= (isum (to_fset i j) f))%Z.

Parameter pow: (Z -> Z -> t) -> Z -> Z -> Z -> t.

Axiom pow_def :
  forall (m:Z -> Z -> t) (n:Z), (0%Z <= n)%Z ->
  ((pow m n) = (k_iter ((fun (y0:Z -> Z -> t) (y1:Z) => y0) m) 0%Z n)).

Axiom pow_spec :
  forall (m:Z -> Z -> t) (n:Z), (0%Z <= n)%Z ->
  ((rows (pow m n)) = (power (rows m) n)) /\
  (((columns (pow m n)) = (power (columns m) n)) /\
   ((pow m n) =
    (c_iter (fun (y0:Z -> Z -> t) (y1:Z -> Z -> t) => (kronecker y0 y1)) m n))).

Axiom pow_transl :
  forall (m:Z -> Z -> t) (i:Z) (k:Z), (0%Z <= k)%Z -> (0%Z <= i)%Z ->
  ((pow m k) = (k_iter ((fun (y0:Z -> Z -> t) (y1:Z) => y0) m) i (k + i)%Z)).

Axiom pow_plus_one :
  forall (m:Z -> Z -> t) (n:Z), (0%Z < n)%Z ->
  ((pow m n) = (kronecker m (pow m (n - 1%Z)%Z))).

Axiom pow_values :
  forall (m:Z -> Z -> t) (i:Z) (j:Z) (n:Z), (valid_index (pow m n) i j) ->
  (0%Z < n)%Z ->
  ((((pow m n) i) j) =
   (ind_product
    (fun (k:Z) =>
     ((m (kth_nit_l i k (rows m) n)) (kth_nit_l j k (columns m) n)))
    1%Z (n + 1%Z)%Z)).

Parameter diag_mat: Z -> (Z -> t) -> Z -> Z -> t.

Axiom diag_mat_def :
  forall (n:Z) (f:Z -> t), (0%Z <= n)%Z ->
  ((diag_mat n f) =
   (make_f n n (fun (i:Z) (j:Z) => (infix_asdt (f i) (indic i j))))).

Axiom diag_mat_spec :
  forall (n:Z) (f:Z -> t), (0%Z <= n)%Z ->
  (forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < n)%Z) /\ ((0%Z <= j)%Z /\ (j < n)%Z)) ->
   ~ (i = j) -> ((((diag_mat n f) i) j) = tzero)) /\
  forall (i:Z) (j:Z),
  (((0%Z <= i)%Z /\ (i < n)%Z) /\ ((0%Z <= j)%Z /\ (j < n)%Z)) -> (i = j) ->
  ((((diag_mat n f) i) j) = (f i)).

Axiom diag_mat_eq :
  forall (f:Z -> t) (g:Z -> t) (n:Z), (0%Z <= n)%Z ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ((f i) = (g i))) ->
  ((diag_mat n f) = (diag_mat n g)).

Axiom mat_mult_diag :
  forall (m:Z -> Z -> t) (f:Z -> t),
  ((mat_mult m (diag_mat (columns m) f)) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_asdt ((m i) j) (f j))))).

Axiom diag_mult_mat :
  forall (m:Z -> Z -> t) (f:Z -> t),
  ((mat_mult (diag_mat (rows m) f) m) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_asdt ((m i) j) (f i))))).

Axiom diag_mult_diag :
  forall (f:Z -> t) (g:Z -> t) (n:Z), (0%Z <= n)%Z ->
  ((mat_mult (diag_mat n f) (diag_mat n g)) =
   (diag_mat n (fun (i:Z) => (infix_asdt (f i) (g i))))).

Axiom int_mat_diag_prod :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z -> (i <= j)%Z ->
  ((int_mat_prod (fun (k:Z) => (diag_mat n (f k))) i j) =
   (diag_mat n
    (fun (k:Z) => (ind_product (fun (i1:Z) => ((f i1) k)) i (j + 1%Z)%Z)))).

Parameter mat_id: Z -> Z -> Z -> t.

Axiom mat_id_def :
  forall (n:Z), (0%Z <= n)%Z ->
  ((mat_id n) = (diag_mat n ((fun (y0:t) (y1:Z) => y0) tone))).

Axiom mat_id_spec :
  forall (n:Z), (0%Z <= n)%Z ->
  ((rows (mat_id n)) = n) /\
  (((columns (mat_id n)) = n) /\
   ((mat_id n) = (make_f n n (fun (y0:Z) (y1:Z) => (indic y0 y1))))).

Axiom mat_mult_id :
  forall (m:Z -> Z -> t), ((mat_mult m (mat_id (columns m))) = m).

Axiom id_mult_mat :
  forall (m:Z -> Z -> t), ((mat_mult (mat_id (rows m)) m) = m).

Parameter diag_two_mat: Z -> (Z -> Z -> Z -> t) -> Z -> Z -> t.

Parameter result7: Z -> (Z -> Z -> Z -> t) -> Z -> Z -> t.

Axiom result_def7 :
  forall (n:Z) (f:Z -> Z -> Z -> t) (i:Z) (j:Z),
  ((((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
    ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result7 n f) i) j) =
    (infix_asdt (indic (tail_bits i n) (tail_bits j n))
     (((f (head_bit i n)) (head_bit j n)) (tail_bits i n))))) /\
  (~ (((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
      ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result7 n f) i) j) = tzero)).

Axiom diag_two_mat_def :
  forall (n:Z) (f:Z -> Z -> Z -> t), (2%Z <= n)%Z ->
  ((diag_two_mat n f) = (make_f (power 2%Z n) (power 2%Z n) (result7 n f))).

Axiom diag_two_mat_spec :
  forall (n:Z) (f:Z -> Z -> Z -> t), (2%Z <= n)%Z ->
  ((rows (diag_two_mat n f)) = (power 2%Z n)) /\
  (((columns (diag_two_mat n f)) = (power 2%Z n)) /\
   ((diag_two_mat n f) =
    (make_f (power 2%Z n) (power 2%Z n)
     (fun (i:Z) (j:Z) =>
      (infix_asdt (indic (tail_bits i n) (tail_bits j n))
       (((f (head_bit i n)) (head_bit j n)) (tail_bits i n))))))).

Parameter two_bloc_diag_mat: Z -> (Z -> Z -> Z -> t) -> Z -> Z -> t.

Parameter result8: Z -> (Z -> Z -> Z -> t) -> Z -> Z -> t.

Axiom result_def8 :
  forall (n:Z) (f:Z -> Z -> Z -> t) (i:Z) (j:Z),
  ((((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
    ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result8 n f) i) j) =
    (infix_asdt (indic (head_bit i n) (head_bit j n))
     (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n))))) /\
  (~ (((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
      ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
   ((((result8 n f) i) j) = tzero)).

Axiom two_bloc_diag_mat_def :
  forall (n:Z) (f:Z -> Z -> Z -> t), (2%Z <= n)%Z ->
  ((two_bloc_diag_mat n f) =
   (make_f (power 2%Z n) (power 2%Z n) (result8 n f))).

Axiom two_bloc_diag_mat_spec :
  forall (n:Z) (f:Z -> Z -> Z -> t), (2%Z <= n)%Z ->
  ((rows (two_bloc_diag_mat n f)) = (power 2%Z n)) /\
  (((columns (two_bloc_diag_mat n f)) = (power 2%Z n)) /\
   ((two_bloc_diag_mat n f) =
    (make_f (power 2%Z n) (power 2%Z n)
     (fun (i:Z) (j:Z) =>
      (infix_asdt (indic (head_bit i n) (head_bit j n))
       (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n))))))).

Axiom two_bloc_diag_two_val :
  forall (n:Z) (f:Z -> Z -> Z -> t) (g:Z -> Z -> Z -> t) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) -> (2%Z <= n)%Z ->
  ((((mat_mult (two_bloc_diag_mat n f) (diag_two_mat n g)) i) j) =
   (infix_asdt (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n))
    (((g (head_bit i n)) (head_bit j n)) (tail_bits j n)))).

Axiom two_bloc_diag_two :
  forall (n:Z) (f:Z -> Z -> Z -> t) (g:Z -> Z -> Z -> t), (2%Z <= n)%Z ->
  ((mat_mult (two_bloc_diag_mat n f) (diag_two_mat n g)) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt (((f (head_bit i n)) (tail_bits i n)) (tail_bits j n))
      (((g (head_bit i n)) (head_bit j n)) (tail_bits i n)))))).

Axiom two_bloc_mult_diag :
  forall (n:Z) (f:Z -> Z -> Z -> t) (g:Z -> t), (2%Z <= n)%Z ->
  ((mat_mult (two_bloc_diag_mat n f) (diag_mat (power 2%Z n) g)) =
   (two_bloc_diag_mat n
    (fun (hi:Z) (ti:Z) (tj:Z) =>
     (infix_asdt (((f hi) ti) tj) (g (ht_to_int hi ti n)))))).

Parameter qbit_id: Z -> Z -> t.

Axiom ident_atom :
  (qbit_id = (make_f 2%Z 2%Z (fun (y0:Z) (y1:Z) => (indic y0 y1)))).

Parameter identity: Z -> Z -> Z -> t.

Axiom identity_def :
  forall (n:Z), (0%Z < n)%Z -> ((identity n) = (pow qbit_id n)).

Axiom identity_indic :
  forall (n:Z), (0%Z < n)%Z ->
  ((rows (identity n)) = (power 2%Z n)) /\
  (((columns (identity n)) = (power 2%Z n)) /\
   forall (i:Z) (j:Z), (valid_index (identity n) i j) ->
   ((((identity n) i) j) = (indic i j))).

Axiom diag_identity :
  forall (n:Z), (0%Z < n)%Z ->
  ((identity n) = (diag_mat (power 2%Z n) ((fun (y0:t) (y1:Z) => y0) tone))).

Axiom identity_product_left :
  forall (n:Z) (m:Z -> Z -> t), (0%Z < n)%Z -> ((rows m) = (power 2%Z n)) ->
  ((mat_mult (identity n) m) = m).

Axiom identity_product_right :
  forall (n:Z) (m:Z -> Z -> t), (0%Z < n)%Z ->
  ((columns m) = (power 2%Z n)) -> ((mat_mult m (identity n)) = m).

Parameter sqrt: t -> t.

Axiom sqrt_spec :
  forall (t1:t), ((cpower (sqrt t1) 2%Z) = (infix_pldt tone tone)).

Axiom neg_h_coeff_ :
  ((prefix_mn (infix_sldt tone (sqrt (infix_pldt tone tone)))) =
   (infix_asdt (prefix_mn tone)
    (infix_sldt tone (sqrt (infix_pldt tone tone))))) /\
  ((infix_asdt (prefix_mn tone)
    (infix_sldt tone (sqrt (infix_pldt tone tone))))
   =
   (infix_asdt (infix_sldt tone (sqrt (infix_pldt tone tone)))
    (prefix_mn tone))).

(* Why3 assumption *)
Definition hadamard : Z -> Z -> t :=
  make_f 2%Z 2%Z
  (fun (i:Z) (j:Z) =>
   (infix_asdt (infix_sldt tone (sqrt (infix_pldt tone tone)))
    (cpower (prefix_mn tone) ((head_bit i 1%Z) * (head_bit j 1%Z))%Z))).

Axiom had_values :
  forall (i:Z) (j:Z), (valid_index hadamard i j) ->
  (((i = j) /\ (j = 1%Z)) ->
   (((hadamard i) j) =
    (prefix_mn (infix_sldt tone (sqrt (infix_pldt tone tone)))))) /\
  (~ ((i = j) /\ (j = 1%Z)) ->
   (((hadamard i) j) = (infix_sldt tone (sqrt (infix_pldt tone tone))))).

Axiom had_values_omega :
  forall (n:Z) (i:Z) (j:Z), (0%Z < n)%Z -> (valid_index hadamard i j) ->
  (((hadamard i) j) =
   (infix_asdt (infix_sldt tone (sqrt (infix_pldt tone tone)))
    (p_omega n ((i * j)%Z * (power 2%Z (n - 1%Z)%Z))%Z))).

Axiom had_values_omega_gen :
  forall (n:Z), (0%Z < n)%Z -> forall (i:Z) (j:Z),
  (valid_index hadamard i j) ->
  (((hadamard i) j) =
   (infix_asdt (infix_sldt tone (sqrt (infix_pldt tone tone)))
    (p_omega n ((i * j)%Z * (power 2%Z (n - 1%Z)%Z))%Z))).

Parameter qqft: Z -> Z -> Z -> t.

Parameter result9: Z -> Z -> Z -> t.

Axiom result_def9 :
  forall (n:Z) (i:Z) (j:Z),
  (((0%Z <= i)%Z /\ (0%Z <= j)%Z) ->
   ((((result9 n) i) j) =
    (infix_asdt (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) n)
     (p_omega n ((int_bit_inversion i n) * j)%Z)))) /\
  (~ ((0%Z <= i)%Z /\ (0%Z <= j)%Z) -> ((((result9 n) i) j) = tone)).

Axiom qqft_def :
  forall (n:Z), (0%Z < n)%Z ->
  ((qqft n) = (make_f (power 2%Z n) (power 2%Z n) (result9 n))).

Axiom qqft_spec :
  forall (n:Z), (0%Z < n)%Z ->
  ((qqft n) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) n)
      (p_omega n ((int_bit_inversion i n) * j)%Z))))).

Axiom ht_qbit_id :
  forall (n:Z), (0%Z < n)%Z -> forall (i:Z) (j:Z),
  (((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\
   ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z)) ->
  (((qbit_id (int.EuclideanDivision.div i (power 2%Z (n - 1%Z)%Z)))
    (int.EuclideanDivision.div j (power 2%Z (n - 1%Z)%Z)))
   = (indic (head_bit i n) (head_bit j n))).

Axiom qqft_val :
  forall (n:Z), (0%Z < n)%Z -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((((qqft n) i) j) =
   (infix_asdt (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) n)
    (p_omega n ((int_bit_inversion i n) * j)%Z))).

Parameter id_qqft: Z -> Z -> Z -> t.

Axiom id_qqft_def :
  forall (n:Z), (1%Z < n)%Z ->
  ((id_qqft n) = (kronecker qbit_id (qqft (n - 1%Z)%Z))).

Axiom id_qqft_spec :
  forall (n:Z), (1%Z < n)%Z ->
  ((id_qqft n) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (infix_asdt
       (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) (n - 1%Z)%Z)
       (indic (head_bit i n) (head_bit j n)))
      (p_omega (n - 1%Z)%Z
       ((int_bit_inversion (tail_bits i n) (n - 1%Z)%Z) * (tail_bits j n))%Z))))).

Axiom id_qqft_bloc_diag :
  forall (n:Z), (1%Z < n)%Z ->
  ((id_qqft n) =
   (two_bloc_diag_mat n
    (fun (hi:Z) (ti:Z) (tj:Z) =>
     (infix_asdt
      (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) (n - 1%Z)%Z)
      (p_omega (n - 1%Z)%Z ((int_bit_inversion ti (n - 1%Z)%Z) * tj)%Z))))).

Parameter fc3: Z -> Z -> Z -> Z -> t.

Axiom fc_def3 :
  forall (n:Z) (hi:Z) (ti:Z) (tj:Z),
  (((0%Z <= ti)%Z /\ (0%Z <= tj)%Z) ->
   (((((fc3 n) hi) ti) tj) =
    (infix_asdt
     (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) (n - 1%Z)%Z)
     (p_omega (n - 1%Z)%Z ((int_bit_inversion ti (n - 1%Z)%Z) * tj)%Z)))) /\
  (~ ((0%Z <= ti)%Z /\ (0%Z <= tj)%Z) -> (((((fc3 n) hi) ti) tj) = tone)).

Axiom id_qqft_bloc_diag_guarded :
  forall (n:Z), (1%Z < n)%Z -> ((id_qqft n) = (two_bloc_diag_mat n (fc3 n))).

Parameter ctrlR: Z -> Z -> Z -> Z -> t.

Parameter result10: Z -> Z -> Z -> t.

Axiom result_def10 :
  forall (t1:Z) (n:Z) (i:Z),
  (((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
   (((result10 t1 n) i) =
    (p_omega t1 ((head_bit i n) * (kth_bit_l i n t1))%Z))) /\
  (~ ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
   (((result10 t1 n) i) = tzero)).

Axiom ctrlR_def :
  forall (t1:Z) (n:Z), ((1%Z <= t1)%Z /\ (t1 <= n)%Z) ->
  ((ctrlR t1 n) = (diag_mat (power 2%Z n) (result10 t1 n))).

Axiom ctrlR_spec :
  forall (t1:Z) (n:Z), ((1%Z <= t1)%Z /\ (t1 <= n)%Z) ->
  ((ctrlR t1 n) =
   (diag_mat (power 2%Z n)
    (fun (i:Z) => (p_omega t1 ((head_bit i n) * (kth_bit_l i n t1))%Z)))) /\
  (((ctrlR t1 n) =
    (diag_mat (power 2%Z n)
     (fun (i:Z) =>
      (p_omega n
       ((head_bit i n) * ((kth_bit_l i n t1) * (power 2%Z (n - t1)%Z))%Z)%Z)))) /\
   (((rows (ctrlR t1 n)) = (power 2%Z n)) /\
    ((columns (ctrlR t1 n)) = (power 2%Z n)))).

Parameter casCtrlR: Z -> Z -> Z -> t.

Parameter result11: Z -> Z -> Z -> Z -> t.

Axiom result_def11 :
  forall (n:Z) (k:Z),
  (((1%Z <= k)%Z /\ (k <= n)%Z) -> (((result11 n) k) = (ctrlR k n))) /\
  (~ ((1%Z <= k)%Z /\ (k <= n)%Z) -> (((result11 n) k) = qbit_id)).

Axiom casCtrlR_def :
  forall (n:Z), (1%Z <= n)%Z -> (2%Z <= n)%Z ->
  ((casCtrlR n) = (int_mat_prod (result11 n) 2%Z n)).

Axiom casCtrlR_spec :
  forall (n:Z), (1%Z <= n)%Z -> (2%Z <= n)%Z ->
  ((casCtrlR n) =
   (diag_mat (power 2%Z n)
    (fun (i:Z) =>
     (ind_product
      (fun (k:Z) =>
       (p_omega n
        ((head_bit i n) * ((kth_bit_l i n k) * (power 2%Z (n - k)%Z))%Z)%Z))
      2%Z (n + 1%Z)%Z)))).

Axiom cas_coeffs :
  forall (n:Z) (i:Z), (2%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((ind_product
    (fun (k:Z) =>
     (p_omega n
      ((head_bit i n) * ((kth_bit_l i n k) * (power 2%Z (n - k)%Z))%Z)%Z))
    2%Z (n + 1%Z)%Z)
   = (p_omega n ((head_bit i n) * (tail_bits i n))%Z)).

Axiom casCtrlR_rew :
  forall (n:Z), (2%Z <= n)%Z ->
  ((casCtrlR n) =
   (diag_mat (power 2%Z n)
    (fun (i:Z) => (p_omega n ((head_bit i n) * (tail_bits i n))%Z)))).

Parameter fc4: Z -> Z -> t.

Axiom fc_def4 :
  forall (n:Z) (i:Z),
  (((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
   (((fc4 n) i) = (p_omega n ((head_bit i n) * (tail_bits i n))%Z))) /\
  (~ ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (((fc4 n) i) = tone)).

Axiom casCtrlR_rew_guarded :
  forall (n:Z), (2%Z <= n)%Z ->
  ((casCtrlR n) = (diag_mat (power 2%Z n) (fc4 n))).

Parameter id_qqft_cas: Z -> Z -> Z -> t.

Axiom id_qqft_cas_def :
  forall (n:Z), (1%Z < n)%Z ->
  ((id_qqft_cas n) = (mat_mult (id_qqft n) (casCtrlR n))).

Axiom id_qqft_cas_spec :
  forall (n:Z), (1%Z < n)%Z ->
  ((id_qqft_cas n) =
   (two_bloc_diag_mat n
    (fun (hj:Z) (ti:Z) (tj:Z) =>
     (infix_asdt
      (infix_asdt
       (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) (n - 1%Z)%Z)
       (p_omega (n - 1%Z)%Z ((int_bit_inversion ti (n - 1%Z)%Z) * tj)%Z))
      (p_omega n (hj * tj)%Z))))).

Parameter had_identity: Z -> Z -> Z -> t.

Axiom had_identity_def :
  forall (n:Z), (1%Z < n)%Z ->
  ((had_identity n) = (kronecker hadamard (identity (n - 1%Z)%Z))).

Axiom had_identity_spec :
  forall (n:Z), (1%Z < n)%Z ->
  ((had_identity n) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (infix_asdt (indic (tail_bits i n) (tail_bits j n))
       (infix_sldt tone (sqrt (infix_pldt tone tone))))
      (p_omega n
       (((head_bit i n) * (head_bit j n))%Z * (power 2%Z (n - 1%Z)%Z))%Z))))).

Axiom had_identity_diag_two :
  forall (n:Z), (1%Z < n)%Z ->
  ((had_identity n) =
   (diag_two_mat n
    (fun (hi:Z) (hj:Z) (ti:Z) =>
     (infix_asdt (infix_sldt tone (sqrt (infix_pldt tone tone)))
      (p_omega n ((hi * hj)%Z * (power 2%Z (n - 1%Z)%Z))%Z))))).

Axiom qqft_rec :
  forall (n:Z), (1%Z < n)%Z ->
  ((mat_mult (id_qqft_cas n) (had_identity n)) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (infix_asdt
       (infix_asdt (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) n)
        (p_omega (n - 1%Z)%Z
         ((int_bit_inversion (tail_bits i n) (n - 1%Z)%Z) *
          (tail_bits j n))%Z))
       (p_omega n ((head_bit i n) * (tail_bits j n))%Z))
      (p_omega n
       (((head_bit i n) * (head_bit j n))%Z * (power 2%Z (n - 1%Z)%Z))%Z))))).

Axiom indexes_prod :
  forall (i:Z) (j:Z) (n:Z), (1%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  (((int_bit_inversion i n) * j)%Z =
   ((((((int_bit_inversion (tail_bits i n) (n - 1%Z)%Z) * 2%Z)%Z *
       ((power 2%Z (n - 1%Z)%Z) * (head_bit j n))%Z)%Z
      +
      (((int_bit_inversion (tail_bits i n) (n - 1%Z)%Z) * 2%Z)%Z *
       (tail_bits j n))%Z)%Z
     + (((head_bit i n) * (head_bit j n))%Z * (power 2%Z (n - 1%Z)%Z))%Z)%Z
    + ((head_bit i n) * (tail_bits j n))%Z)%Z).

Axiom omega_indexes_prod :
  forall (i:Z) (j:Z) (n:Z), (1%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((p_omega n ((int_bit_inversion i n) * j)%Z) =
   (p_omega n
    (((((int_bit_inversion (tail_bits i n) (n - 1%Z)%Z) * 2%Z)%Z *
       (tail_bits j n))%Z
      + (((head_bit i n) * (head_bit j n))%Z * (power 2%Z (n - 1%Z)%Z))%Z)%Z
     + ((head_bit i n) * (tail_bits j n))%Z)%Z)).

Axiom qft_indexes_rew :
  forall (i:Z) (j:Z) (n:Z), (1%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((infix_asdt
    (infix_asdt
     (p_omega (n - 1%Z)%Z
      ((int_bit_inversion (tail_bits i n) (n - 1%Z)%Z) * (tail_bits j n))%Z)
     (p_omega n ((head_bit i n) * (tail_bits j n))%Z))
    (p_omega n
     (((head_bit i n) * (head_bit j n))%Z * (power 2%Z (n - 1%Z)%Z))%Z))
   = (p_omega n ((int_bit_inversion i n) * j)%Z)).

Axiom qqft_plus_one_indexes :
  forall (n:Z), (1%Z < n)%Z ->
  ((mat_mult (id_qqft_cas n) (had_identity n)) =
   (make_f (power 2%Z n) (power 2%Z n)
    (fun (i:Z) (j:Z) =>
     (infix_asdt (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) n)
      (p_omega n ((int_bit_inversion i n) * j)%Z))))).

Axiom qqft_plus_one :
  forall (n:Z), (1%Z < n)%Z ->
  ((mat_mult (id_qqft_cas n) (had_identity n)) = (qqft n)).

Axiom H :
  ((qqft 1%Z) =
   (make_f (power 2%Z 1%Z) (power 2%Z 1%Z)
    (fun (i:Z) (j:Z) =>
     (infix_asdt (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) 1%Z)
      (p_omega 1%Z ((int_bit_inversion i 1%Z) * j)%Z))))).

Axiom H1 : ((rows (qqft 1%Z)) = (rows hadamard)).

Axiom H2 : ((columns (qqft 1%Z)) = (columns hadamard)).

Parameter i: Z.

Parameter j: Z.

Axiom H3 : valid_index (qqft 1%Z) i j.

Axiom h : (i = 0%Z).

Axiom h1 : ~ (j = 0%Z).

(* Why3 goal *)
Theorem G :
  ((((0%Z < i)%Z \/ (0%Z = i)) /\ ((0%Z < j)%Z \/ (0%Z = j))) ->
   ((infix_asdt (cpower (infix_sldt tone (sqrt (infix_pldt tone tone))) 1%Z)
     (p_omega 1%Z ((int_bit_inversion i 1%Z) * j)%Z))
    = (infix_asdt tone (inv (sqrt (infix_pldt tone tone)))))) /\
  (~ (((0%Z < i)%Z \/ (0%Z = i)) /\ ((0%Z < j)%Z \/ (0%Z = j))) ->
   (tone = (infix_asdt tone (inv (sqrt (infix_pldt tone tone)))))).
Proof.


Qed.


;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: real arithmetic
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun prefix_mndt (t) t)

(declare-fun infix_pldt (t t) t)

(declare-fun infix_asdt (t t) t)

;; Mul_distr_l
  (assert
  (forall ((x t) (y t) (z t))
  (= (infix_asdt x (infix_pldt y z)) (infix_pldt (infix_asdt x y)
                                     (infix_asdt x z)))))

;; Comm
  (assert (forall ((x t) (y t)) (= (infix_asdt x y) (infix_asdt y x))))

(declare-fun infix_mndt (t t) t)

;; infix -._def
  (assert
  (forall ((x t) (y t)) (= (infix_mndt x y) (infix_pldt x (prefix_mndt y)))))

;; opposite
  (assert (forall ((a t)) (= (infix_mndt a a) tzero)))

;; minus_tone
  (assert
  (forall ((a t)) (= (prefix_mndt a) (infix_asdt (prefix_mndt tone) a))))

;; notZeroAdd
  (assert
  (forall ((x t) (y t)) (=> (not (= x tzero)) (not (= (infix_pldt x y) y)))))

(declare-fun im () t)

;; im_Def
  (assert (= (infix_asdt im im) (prefix_mndt tone)))

(declare-fun r_to_t (Real) t)

;; r_to_t_zero
  (assert (= (r_to_t 0.0) tzero))

;; r_to_t_one
  (assert (= (r_to_t 1.0) tone))

(declare-fun real_part (t) Real)

(declare-fun im_part (t) Real)

;; Real_part_opposite
  (assert (forall ((i t)) (= (real_part (prefix_mndt i)) (- (real_part i)))))

(declare-fun real_ (t) Bool)

;; real__def
  (assert (forall ((x t)) (= (real_ x) (= (im_part x) 0.0))))

(declare-fun pi1 () t)

(declare-fun infix_lseqdt (t t) Bool)

;; Inf_eq_def
  (assert
  (forall ((x t) (y t))
  (= (infix_lseqdt x y)
  (or (and (real_ x) (and (real_ y) (<= (real_part x) (real_part y))))
  (= x y)))))

(declare-fun infix_lsdt (t t) Bool)

(declare-fun infix_gteqdt (t t) Bool)

(declare-fun infix_gtdt (t t) Bool)

;; r_to_t_inf
  (assert
  (forall ((i Real) (j Real))
  (= (infix_lseqdt (r_to_t i) (r_to_t j)) (<= i j))))

(declare-fun t_real_part (t) t)

;; t_real_part_def
  (assert (forall ((x t)) (= (t_real_part x) (r_to_t (real_part x)))))

;; compat_mult_sup_eq_right
  (assert
  (forall ((a t) (b t) (c t))
  (=> (infix_lseqdt b c) (infix_lseqdt (infix_asdt a b) (infix_asdt a c)))))

(declare-fun t_im_part (t) t)

;; t_im_part_def
  (assert (forall ((x t)) (= (t_im_part x) (r_to_t (im_part x)))))

(declare-fun set (ty) ty)

(declare-fun abs1 (Int) Int)

;; abs_def
  (assert
  (forall ((x Int)) (ite (<= 0 x) (= (abs1 x) x) (= (abs1 x) (- x)))))

(declare-fun infix_mngt (ty ty) ty)

(declare-fun infix_at (ty ty uni uni) uni)

;; infix @_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

(declare-fun map1 (ty ty uni uni) uni)

;; map_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (set b) (map1 b a x x1)))))

(declare-fun op_neutral_left (ty uni uni) Bool)

;; op_neutral_left_def
  (assert
  (forall ((im1 ty))
  (forall ((op uni) (neutral uni))
  (= (op_neutral_left im1 op neutral)
  (forall ((e uni))
  (=> (sort im1 e)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op neutral) e) e)))))))

(declare-fun op_neutral_right (ty uni uni) Bool)

;; op_neutral_right_def
  (assert
  (forall ((im1 ty))
  (forall ((op uni) (neutral uni))
  (= (op_neutral_right im1 op neutral)
  (forall ((e uni))
  (=> (sort im1 e)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op e) neutral) e)))))))

(declare-fun op_assoc (ty uni) Bool)

;; op_assoc_def
  (assert
  (forall ((im1 ty))
  (forall ((op uni))
  (and
  (=> (op_assoc im1 op)
  (forall ((a uni) (b uni) (c uni))
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op a) b)) c) 
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op a)
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op b) c)))))
  (=>
  (forall ((a uni) (b uni) (c uni))
  (=> (sort im1 a)
  (=> (sort im1 b)
  (=> (sort im1 c)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op a) b)) c) 
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op a)
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op b) c)))))))
  (op_assoc im1 op))))))

(declare-fun neutral (ty uni uni) Bool)

;; neutral_def
  (assert
  (forall ((im1 ty))
  (forall ((op uni) (neut uni))
  (= (neutral im1 op neut)
  (and (op_neutral_left im1 op neut)
  (and (op_neutral_right im1 op neut) (op_assoc im1 op)))))))

(declare-fun set1 (ty ty uni uni uni) uni)

;; set_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (infix_mngt a b)
  (set1 b a x x1 x2)))))

(declare-sort matrix 1)

(declare-fun matrix1 (ty) ty)

(declare-fun make_f (ty Int Int uni) uni)

;; make_f_sort
  (assert
  (forall ((a ty))
  (forall ((x Int) (x1 Int) (x2 uni)) (sort (matrix1 a) (make_f a x x1 x2)))))

(declare-fun kronecker_neutral () (matrix t))

(declare-fun bitvec () ty)

(declare-fun cpower (t Int) t)

(declare-fun angle () ty)

(declare-fun ang_inv (uni) uni)

;; ang_inv_sort
  (assert (forall ((x uni)) (sort angle (ang_inv x))))

(declare-fun ang_add (uni uni) uni)

;; ang_add_sort
  (assert (forall ((x uni) (x1 uni)) (sort angle (ang_add x x1))))

(declare-fun ang_zero () uni)

;; ang_zero_sort
  (assert (sort angle ang_zero))

(declare-fun exp (t) t)

(declare-fun get_ket_bv ((matrix t) uni) t)

(declare-sort plan 0)

(declare-fun plan1 () ty)

(declare-fun v_sine (plan (matrix t)) t)

(declare-fun complex_plan () plan)

(declare-fun complex_as_a_vector (t) (matrix t))

(declare-fun result (t) (Array Int (Array Int t)))

(declare-fun t2tb (t) uni)

;; t2tb_sort
  (assert (forall ((x t)) (sort t1 (t2tb x))))

(declare-fun tb2t (uni) t)

;; BridgeL
  (assert (forall ((i t)) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort t1 j) (= (t2tb (tb2t j)) j)) :pattern ((t2tb (tb2t j))) )))

(declare-fun t2tb1 ((Array Int t)) uni)

;; t2tb_sort
  (assert (forall ((x (Array Int t))) (sort (infix_mngt int t1) (t2tb1 x))))

(declare-fun tb2t1 (uni) (Array Int t))

;; BridgeL
  (assert
  (forall ((i (Array Int t)))
  (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt int t1) j) (= (t2tb1 (tb2t1 j)) j)) :pattern (
  (t2tb1 (tb2t1 j))) )))

(declare-fun t2tb2 (Int) uni)

;; t2tb_sort
  (assert (forall ((x Int)) (sort int (t2tb2 x))))

(declare-fun tb2t2 (uni) Int)

;; BridgeL
  (assert
  (forall ((i Int)) (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb2 (tb2t2 j)) j) :pattern ((t2tb2 (tb2t2 j))) )))

(declare-fun t2tb3 ((Array Int (Array Int t))) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array Int (Array Int t)))) (sort
  (infix_mngt int (infix_mngt int t1)) (t2tb3 x))))

(declare-fun tb2t3 (uni) (Array Int (Array Int t)))

;; BridgeL
  (assert
  (forall ((i (Array Int (Array Int t))))
  (! (= (tb2t3 (t2tb3 i)) i) :pattern ((t2tb3 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt int (infix_mngt int t1)) j)
     (= (t2tb3 (tb2t3 j)) j)) :pattern ((t2tb3 (tb2t3 j))) )))

;; result_def
  (assert
  (forall ((x t) (i Int) (us Int))
  (= (tb2t
     (infix_at t1 int
     (infix_at (infix_mngt int t1) int (t2tb3 (result x)) (t2tb2 i))
     (t2tb2 us))) (ite (= i 0) (t_real_part x) (t_im_part x)))))

(declare-fun t2tb4 ((matrix t)) uni)

;; t2tb_sort
  (assert (forall ((x (matrix t))) (sort (matrix1 t1) (t2tb4 x))))

(declare-fun tb2t4 (uni) (matrix t))

;; BridgeL
  (assert
  (forall ((i (matrix t))) (! (= (tb2t4 (t2tb4 i)) i) :pattern ((t2tb4 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (matrix1 t1) j) (= (t2tb4 (tb2t4 j)) j)) :pattern ((t2tb4
                                                                  (tb2t4 j))) )))

;; complex_as_a_vector_def
  (assert
  (forall ((x t))
  (= (complex_as_a_vector x) (tb2t4 (make_f t1 2 0 (t2tb3 (result x)))))))

(declare-fun sin1 (t) t)

;; sin_spec
  (assert
  (forall ((x t))
  (=> (real_ x)
  (= (sin1 x) (v_sine complex_plan
              (complex_as_a_vector (exp (infix_asdt im x))))))))

(declare-fun cos1 (t) t)

;; sin_pi
  (assert (= (sin1 pi1) (prefix_mndt tzero)))

;; euler_real
  (assert
  (forall ((x t))
  (=> (real_ x) (= (cos1 x) (t_real_part (exp (infix_asdt im x)))))))

(assert
;; h
  (not false))
(check-sat)

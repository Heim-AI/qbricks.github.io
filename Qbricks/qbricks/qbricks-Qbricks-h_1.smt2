;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-sort set 1)

(declare-fun set1 (ty) ty)

(declare-fun mem (ty uni uni) Bool)

(declare-fun infix_eqeq (ty uni uni) Bool)

;; infix ==_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (and
  (=> (infix_eqeq a s1 s2) (forall ((x uni)) (= (mem a x s1) (mem a x s2))))
  (=> (forall ((x uni)) (=> (sort a x) (= (mem a x s1) (mem a x s2))))
  (infix_eqeq a s1 s2))))))

(declare-fun is_empty (ty uni) Bool)

(declare-fun add (ty uni uni) uni)

;; add_sort
  (assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (set1 a) (add a x x1)))))

(declare-fun remove (ty uni uni) uni)

;; remove_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (remove a x x1)))))

;; remove_add
  (assert
  (forall ((a ty))
  (forall ((x uni) (s uni)) (= (remove a x (add a x s)) (remove a x s)))))

(declare-fun union1 (ty uni uni) uni)

;; union_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (union1 a x x1)))))

(declare-fun choose (ty uni) uni)

;; choose_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (choose a x)))))

(declare-fun cardinal (ty uni) Int)

(declare-fun infix_mngt (ty ty) ty)

;; union_exchange
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (not (is_empty a sqt))
  (= (union1 a (add a (choose a sqt) s) (remove a (choose a sqt) sqt)) 
  (union1 a s sqt))))))

;; union_empty
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (sort (set1 a) sqt) (=> (is_empty a s) (= (union1 a s sqt) sqt))))))

;; union_comm
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (sort (set1 a) s) (=> (is_empty a sqt) (= (union1 a s sqt) s))))))

(declare-fun to_fset (Int Int) (set Int))

(declare-fun t2tb ((set Int)) uni)

;; t2tb_sort
  (assert (forall ((x (set Int))) (sort (set1 int) (t2tb x))))

(declare-fun tb2t (uni) (set Int))

;; BridgeL
  (assert
  (forall ((i (set Int))) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

(declare-fun t2tb1 (Int) uni)

;; t2tb_sort
  (assert (forall ((x Int)) (sort int (t2tb1 x))))

(declare-fun tb2t1 (uni) Int)

;; BridgeL
  (assert
  (forall ((i Int)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb1 (tb2t1 j)) j) :pattern ((t2tb1 (tb2t1 j))) )))

;; to_fset_spec
  (assert
  (forall ((i Int) (j Int))
  (and (=> (< i j) (= (cardinal int (t2tb (to_fset i j))) (- j i)))
  (and (=> (<= j i) (is_empty int (t2tb (to_fset i j))))
  (forall ((k Int))
  (= (mem int (t2tb1 k) (t2tb (to_fset i j))) (and (<= i k) (< k j))))))))

;; choose_to_fset
  (assert
  (forall ((i Int) (j Int))
  (=> (<= i j) (= (tb2t1 (choose int (t2tb (to_fset i j)))) i))))

(assert
;; h
  (not false))
(check-sat)

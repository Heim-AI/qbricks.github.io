(set-logic AUFNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: real arithmetic
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun real () ty)

(declare-fun infix_eqeq (ty uni uni) Bool)

;; infix ==_spec
  (assert
  (forall ((a ty))
  (forall ((a1 uni) (b uni))
  (=> (sort a a1) (=> (sort a b) (= (infix_eqeq a a1 b) (= a1 b)))))))

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun prefix_mndt (t) t)

(declare-fun infix_pldt (t t) t)

(declare-fun infix_asdt (t t) t)

;; Comm
  (assert (forall ((x t) (y t)) (= (infix_asdt x y) (infix_asdt y x))))

(declare-fun infix_mndt (t t) t)

;; infix -._def
  (assert
  (forall ((x t) (y t)) (= (infix_mndt x y) (infix_pldt x (prefix_mndt y)))))

(declare-fun infix_sldt (t t) t)

;; opposite
  (assert (forall ((a t)) (= (infix_mndt a a) tzero)))

(declare-fun im () t)

(declare-fun r_to_t (Real) t)

;; r_to_t_zero
  (assert (= (r_to_t 0.0) tzero))

;; r_to_t_one
  (assert (= (r_to_t 1.0) tone))

(declare-fun real_part (t) Real)

(declare-fun im_part (t) Real)

(declare-fun real_ (t) Bool)

(declare-fun t2tb (Real) uni)

;; t2tb_sort
  (assert (forall ((x Real)) (sort real (t2tb x))))

(declare-fun tb2t (uni) Real)

;; BridgeL
  (assert (forall ((i Real)) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

;; real__def
  (assert
  (forall ((x t))
  (= (real_ x) (infix_eqeq real (t2tb (im_part x)) (t2tb 0.0)))))

(declare-fun infix_lseqdt (t t) Bool)

(declare-fun t2tb1 (t) uni)

;; t2tb_sort
  (assert (forall ((x t)) (sort t1 (t2tb1 x))))

(declare-fun tb2t1 (uni) t)

;; BridgeL
  (assert (forall ((i t)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort t1 j) (= (t2tb1 (tb2t1 j)) j)) :pattern ((t2tb1 (tb2t1 j))) )))

;; infix <=._def
  (assert
  (forall ((x t) (y t))
  (= (infix_lseqdt x y)
  (or (and (real_ x) (and (real_ y) (<= (real_part x) (real_part y))))
  (infix_eqeq t1 (t2tb1 x) (t2tb1 y))))))

(declare-fun infix_lsdt (t t) Bool)

;; infix <._def
  (assert
  (forall ((x t) (y t))
  (= (infix_lsdt x y)
  (and (infix_lseqdt x y) (not (infix_eqeq t1 (t2tb1 x) (t2tb1 y)))))))

(declare-fun infix_gtdt (t t) Bool)

;; infix >._def
  (assert
  (forall ((x t) (y t))
  (= (infix_gtdt x y)
  (and (infix_lseqdt y x) (not (infix_eqeq t1 (t2tb1 x) (t2tb1 y)))))))

;; Trans
  (assert
  (forall ((x t) (y t) (z t))
  (=> (infix_lseqdt x y) (=> (infix_lseqdt y z) (infix_lseqdt x z)))))

;; Trans
  (assert
  (forall ((x t) (y t) (z t))
  (=> (infix_lseqdt y x) (=> (infix_lseqdt z y) (infix_lseqdt z x)))))

;; r_to_t_inf
  (assert
  (forall ((i Real) (j Real))
  (= (infix_lseqdt (r_to_t i) (r_to_t j)) (<= i j))))

;; inf_to_non_sup_eq
  (assert
  (forall ((x t) (y t))
  (=> (real_ x)
  (=> (real_ y) (=> (infix_lsdt x y) (not (infix_lseqdt y x)))))))

;; sup_eq_to_non_inf
  (assert
  (forall ((x t) (y t))
  (=> (real_ x)
  (=> (real_ y) (=> (infix_lseqdt y x) (not (infix_lsdt x y)))))))

;; sup_to_non_inf_eq
  (assert
  (forall ((x t) (y t))
  (=> (real_ x)
  (=> (real_ y) (=> (infix_gtdt x y) (not (infix_lseqdt x y)))))))

;; compat_r_to_t_supeq
  (assert
  (forall ((a Real) (b Real))
  (=> (<= b a) (infix_lseqdt (r_to_t b) (r_to_t a)))))

;; inf_eq_def
  (assert
  (forall ((x t) (y t))
  (= (infix_lseqdt x y)
  (or (and (real_ x) (and (real_ y) (<= (real_part x) (real_part y))))
  (= x y)))))

;; simpl_leq_mult_div
  (assert
  (forall ((a t) (b t) (c t))
  (=> (infix_lsdt tzero b)
  (=> (infix_lseqdt (infix_asdt a b) c) (infix_lseqdt a
  (infix_asdt (infix_sldt tone b) c))))))

;; mult_leq_tone_leq
  (assert
  (forall ((a t) (b t))
  (=> (infix_lseqdt tzero a)
  (=> (and (infix_lseqdt tzero b) (infix_lseqdt b tone)) (infix_lseqdt
  (infix_asdt a b) a)))))

;; mult_leq_tone_rev
  (assert
  (forall ((a t) (b t))
  (=> (infix_lseqdt tzero a)
  (=> (infix_lseqdt tzero b)
  (=> (infix_lseqdt (infix_asdt a b) tone) (= a (infix_sldt tone b)))))))

;; transitive_infeq_inf
  (assert
  (forall ((a t) (b t) (c t))
  (=> (infix_lseqdt a b) (=> (infix_lsdt b c) (infix_lsdt a c)))))

(declare-fun set (ty) ty)

(declare-fun infix_mngt (ty ty) ty)

(declare-fun infix_at (ty ty uni uni) uni)

;; infix @_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

;; im_dec
  (assert (and (= (real_part im) 0.0) (= (im_part im) 1.0)))

(assert
;; h
  (not false))
(check-sat)

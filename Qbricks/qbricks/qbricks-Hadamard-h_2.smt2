(set-logic AUFNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: real arithmetic
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun infix_asdt (t t) t)

;; NonTrivialRing
  (assert (not (= tzero tone)))

(declare-fun inv (t) t)

;; Inverse
  (assert
  (forall ((x t)) (=> (not (= x tzero)) (= (infix_asdt x (inv x)) tone))))

(declare-fun infix_sldt (t t) t)

;; infix /._spec
  (assert
  (forall ((x t) (y t))
  (=> (not (= y tzero)) (= (infix_sldt x y) (infix_asdt x (inv y))))))

(declare-fun from_int (Int) Real)

;; One
  (assert (= (from_int 1) 1.0))

(declare-fun r_to_t (Real) t)

;; r_to_t_one
  (assert (= (r_to_t 1.0) tone))

(declare-fun infix_mngt (ty ty) ty)

(declare-fun i_to_t (Int) t)

;; i_to_t_def
  (assert (forall ((i Int)) (= (i_to_t i) (r_to_t (from_int i)))))

(declare-fun power (Int Int) Int)

;; Power_zero
  (assert (forall ((i Int)) (= (power i 0) 1)))

(declare-sort d_frac 0)

(declare-fun d_frac1 () ty)

(declare-fun arg (d_frac) t)

(declare-fun value (d_frac) t)

;; equal_d_frac
  (assert
  (forall ((d d_frac) (dqt d_frac)) (=> (= (value d) (value dqt)) (= d dqt))))

(declare-fun zero_d () d_frac)

;; zero_d_def
  (assert (= (arg zero_d) tzero))

;; value_zero
  (assert (= (value zero_d) tone))

(declare-fun dyadic (Int Int) d_frac)

;; dyadic_spec
  (assert
  (forall ((k Int) (n Int))
  (=> (<= 0 n)
  (= (arg (dyadic k n)) (infix_sldt (i_to_t k) (i_to_t (power 2 n)))))))

;; omega_d10
  (assert (= (value (dyadic 1 0)) tone))

(assert
;; h
  (not false))
(check-sat)

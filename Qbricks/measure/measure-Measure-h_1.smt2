(set-logic AUFNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun infix_mngt (ty ty) ty)

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun infix_pldt (t t) t)

(declare-fun infix_asdt (t t) t)

(declare-fun inv (t) t)

;; Comm
  (assert (forall ((x t) (y t)) (= (infix_asdt x y) (infix_asdt y x))))

;; NonTrivialRing
  (assert (not (= tzero tone)))

(declare-fun infix_sldt (t t) t)

;; infix /._def
  (assert
  (forall ((x t) (y t))
  (=> (not (= y tzero)) (= (infix_sldt x y) (infix_asdt x (inv y))))))

(declare-fun from_int (Int) Real)

;; notZeroAdd
  (assert
  (forall ((x t) (y t)) (=> (not (= x tzero)) (not (= (infix_pldt x y) y)))))

(declare-fun r_to_t (Real) t)

(declare-fun square_rt (t) t)

;; square_rt_spec
  (assert (forall ((x t)) (= (infix_asdt (square_rt x) (square_rt x)) x)))

;; square_rt_mult
  (assert
  (forall ((t2 t) (tqt t))
  (= (infix_asdt (square_rt t2) (square_rt t2)) (square_rt
                                                (infix_asdt t2 tqt)))))

(declare-fun i_to_t (Int) t)

;; i_to_t_def
  (assert (forall ((i Int)) (= (i_to_t i) (r_to_t (from_int i)))))

;; i_to_t_one
  (assert (= (i_to_t 1) tone))

;; i_to_t_ttwo
  (assert (= (i_to_t 2) (infix_pldt tone tone)))

;; i_to_t_div
  (assert
  (forall ((i Int) (j Int))
  (=> (not (= j 0)) (= (infix_sldt (i_to_t (* i j)) (i_to_t j)) (i_to_t i)))))

(assert
;; h
  (not false))
(check-sat)

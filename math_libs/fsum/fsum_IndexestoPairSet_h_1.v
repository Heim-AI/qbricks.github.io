(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

(* Why3 assumption *)
Definition terms := Z -> t.

Axiom set : forall (a:Type), Type.
Parameter set_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set a).
Existing Instance set_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> Prop.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom infix_eqeq_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (infix_eqeq s1 s2) <-> forall (x:a), (mem x s1) <-> (mem x s2).

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq s1 s2) -> (s1 = s2).

Parameter subset:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (subset s1 s2) <-> forall (x:a), (mem x s1) -> mem x s2.

Axiom subset_refl :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set a), subset s s.

Axiom subset_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (s3:set a), (subset s1 s2) ->
  (subset s2 s3) -> subset s1 s3.

Parameter is_empty: forall {a:Type} {a_WT:WhyType a}, (set a) -> Prop.

Axiom is_empty_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (is_empty s) <-> forall (x:a), ~ (mem x s).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, set a.

Axiom empty_def : forall {a:Type} {a_WT:WhyType a}, is_empty (empty : set a).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom add_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (add x s)) <-> ((y = x) \/ (mem y s)).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom remove_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (remove x s)) <-> (~ (y = x) /\ (mem y s)).

Axiom add_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), (mem x s) -> ((add x (remove x s)) = s).

Axiom remove_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), ((remove x (add x s)) = (remove x s)).

Axiom subset_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), subset (remove x s) s.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (union s1 s2)) <-> ((mem x s1) \/ (mem x s2)).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom inter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (inter s1 s2)) <-> ((mem x s1) /\ (mem x s2)).

Parameter diff:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom diff_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (diff s1 s2)) <-> ((mem x s1) /\ ~ (mem x s2)).

Axiom subset_diff :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), subset (diff s1 s2) s1.

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom choose_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> mem (choose s) s.

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set a) -> Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (0%Z <= (cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 0%Z) <-> (is_empty s).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), ~ (mem x s) ->
  ((cardinal (add x s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), (mem x s) ->
  ((cardinal s) = (1%Z + (cardinal (remove x s)))%Z).

Axiom cardinal_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) <= (cardinal s2))%Z.

Axiom subset_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) = (cardinal s2)) -> infix_eqeq s1 s2.

Axiom cardinal1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) ->
  (x = (choose s)).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

(* Why3 assumption *)
Definition terms1 (a:Type) := a -> Z.

Parameter tzero: Z.

Parameter addition: Z -> Z -> Z.

Parameter substract: Z -> Z -> Z.

Axiom add_tzero_left : forall (a:Z), ((addition tzero a) = a).

Axiom add_tzero_left_c :
  forall (a:Z) (b:Z), ((addition a b) = a) -> (b = tzero).

Axiom add_tzero_right : forall (a:Z), ((addition a tzero) = a).

Axiom add_assoc :
  forall (a:Z) (b:Z) (c:Z),
  ((addition (addition a b) c) = (addition a (addition b c))).

Axiom add_refl : forall (a:Z) (b:Z), ((addition a b) = (addition b a)).

Axiom substract1 : forall (a:Z) (b:Z), ((addition a (substract b a)) = b).

Axiom unic :
  forall (a:Z) (b:Z) (c:Z), ((addition a b) = (addition a c)) -> (b = c).

Axiom substract_comm :
  forall (a:Z) (b:Z),
  ((substract (addition a b) a) = b) /\ ((substract (addition b a) a) = b).

Parameter sum: forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z) -> Z.

Axiom Sum_def_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> Z), ((sum (empty : set a) f) = tzero).

Axiom sum_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> Z), ((cardinal s) = 0%Z) -> ((sum s t1) = tzero).

Axiom Sum_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), forall (f:a -> Z), forall (x:a), ~ (mem x s) ->
  ((sum (add x s) f) = (addition (sum s f) (f x))).

Axiom induction :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:(set a) -> bool) (t1:set a),
  (forall (s:set a), (is_empty s) -> ((p s) = true)) ->
  (forall (s:set a), ((p s) = true) -> forall (t2:a), ~ (mem t2 s) ->
   ((p (add t2 s)) = true)) ->
  ((p t1) = true).

Axiom sum_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z) (x:a), (mem x s) ->
  ((sum (remove x s) f) = (substract (sum s f) (f x))).

Axiom sum_def_choose :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z), ~ (is_empty s) ->
  ((sum s f) = (addition (f (choose s)) (sum (remove (choose s) s) f))).

Axiom choose_any :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z) (t1:a), (mem t1 s) ->
  ((sum s f) = (addition (f t1) (sum (remove t1 s) f))).

Axiom sum_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (f:a -> Z),
  ((sum (union s1 s2) f) =
   (substract (addition (sum s1 f) (sum s2 f)) (sum (inter s1 s2) f))).

Axiom sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z) (g:a -> Z),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> ((sum s f) = (sum s g)).

Axiom union_exchange :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ~ (is_empty s') ->
  ((union (add (choose s') s) (remove (choose s') s')) = (union s s')).

Axiom union_empty_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((cardinal s') = 0%Z) -> ((union s s') = s).

Axiom union_empty_left :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((cardinal s) = 0%Z) -> ((union s s') = s').

Parameter union_bui:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_bui_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((union_bui s s') = (union s s')).

Axiom union_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((union s (add x s')) = (add x (union s s'))).

Axiom union_add_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((add x (union s s')) = (union s (add x s'))).

Axiom inter_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (s = (empty : set a)) ->
  ((inter s s') = (empty : set a)).

Axiom inter_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (s' = (empty : set a)) ->
  ((inter s s') = (empty : set a)).

Parameter to_fset: Z -> Z -> set Z.

Axiom to_fset_spec :
  forall (i:Z) (j:Z),
  ((i <= j)%Z -> ((cardinal (to_fset i j)) = (j - i)%Z)) /\
  (((j < i)%Z -> ((cardinal (to_fset i j)) = 0%Z)) /\
   forall (k:Z), (mem k (to_fset i j)) <-> ((i <= k)%Z /\ (k < j)%Z)).

Axiom to_fset_unit_ext :
  forall (i:Z) (j:Z), (i < j)%Z ->
  ((to_fset i j) = (add i (to_fset (i + 1%Z)%Z j))).

Axiom to_fset_ext :
  forall (i:Z) (i':Z) (j:Z), ((i <= i')%Z /\ (i' <= j)%Z) ->
  ((to_fset i j) = (union (to_fset i i') (to_fset i' j))).

Axiom a : Type.
Parameter a_WhyType : WhyType a.
Existing Instance a_WhyType.

Parameter s: set a.

Parameter s': set a.

Axiom H : ((inter s s') = (empty : set a)).

Parameter o: (set a) -> bool.

Axiom o_def :
  forall (set1:set a),
  (((o set1) = true) -> (infix_eqeq (inter s set1) (empty : set a)) ->
   ((cardinal (union s set1)) = ((cardinal s) + (cardinal set1))%Z)) /\
  ((((infix_eqeq (inter s set1) (empty : set a)) /\
     ((cardinal (union s set1)) = ((cardinal s) + (cardinal set1))%Z)) \/
    ~ (infix_eqeq (inter s set1) (empty : set a))) ->
   ((o set1) = true)).

Axiom H1 : forall (s1:set a), (is_empty s1) -> ((o s1) = true).

Parameter s1: set a.

Axiom H2 : ((o s1) = true).

Parameter t1: a.

Axiom H3 : ~ (mem t1 s1).

Axiom h : ((inter s (add t1 s1)) = (empty : set a)).

Axiom h1 : ~ (mem t1 s1).

Axiom h2 : ((cardinal (add t1 s1)) = ((cardinal s1) + 1%Z)%Z).

(* Why3 goal *)
Theorem h3 : ((cardinal (union s s1)) = ((cardinal s) + (cardinal s1))%Z).
Proof.


Qed.


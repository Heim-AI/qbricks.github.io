;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-sort set 1)

(declare-fun set1 (ty) ty)

(declare-fun mem (ty uni uni) Bool)

(declare-fun infix_eqeq (ty uni uni) Bool)

;; infix ==_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (and
  (=> (infix_eqeq a s1 s2) (forall ((x uni)) (= (mem a x s1) (mem a x s2))))
  (=> (forall ((x uni)) (=> (sort a x) (= (mem a x s1) (mem a x s2))))
  (infix_eqeq a s1 s2))))))

(declare-fun is_empty (ty uni) Bool)

(declare-fun add (ty uni uni) uni)

;; add_sort
  (assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (set1 a) (add a x x1)))))

(declare-fun remove (ty uni uni) uni)

;; remove_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (remove a x x1)))))

;; add_remove
  (assert
  (forall ((a ty))
  (forall ((x uni) (s uni))
  (=> (sort (set1 a) s) (=> (mem a x s) (= (add a x (remove a x s)) s))))))

(declare-fun choose (ty uni) uni)

;; choose_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (choose a x)))))

(declare-fun cardinal (ty uni) Int)

(declare-fun infix_mngt (ty ty) ty)

(declare-fun choose_ (ty uni) uni)

;; choose__sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (choose_ a x)))))

;; Add_choose
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (forall ((e uni)) (=> (sort a e) (= e (choose_ a (add a e s))))))))

(declare-fun to_fset (Int Int) (set Int))

(declare-fun t2tb ((set Int)) uni)

;; t2tb_sort
  (assert (forall ((x (set Int))) (sort (set1 int) (t2tb x))))

(declare-fun tb2t (uni) (set Int))

;; BridgeL
  (assert
  (forall ((i (set Int))) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

(declare-fun t2tb1 (Int) uni)

;; t2tb_sort
  (assert (forall ((x Int)) (sort int (t2tb1 x))))

(declare-fun tb2t1 (uni) Int)

;; BridgeL
  (assert
  (forall ((i Int)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb1 (tb2t1 j)) j) :pattern ((t2tb1 (tb2t1 j))) )))

;; to_fset_spec
  (assert
  (forall ((i Int) (j Int))
  (and (=> (< i j) (= (cardinal int (t2tb (to_fset i j))) (- j i)))
  (and (=> (<= j i) (is_empty int (t2tb (to_fset i j))))
  (forall ((k Int))
  (= (mem int (t2tb1 k) (t2tb (to_fset i j))) (and (<= i k) (< k j))))))))

;; to_fset_unit_ext
  (assert
  (forall ((i Int) (j Int))
  (=> (< i j)
  (= (to_fset i j) (tb2t (add int (t2tb1 i) (t2tb (to_fset (+ i 1) j))))))))

(assert
;; VC_test2
 ;; File "p_set/../p_set.mlw", line 463, characters 17-22
  (not false))
(check-sat)

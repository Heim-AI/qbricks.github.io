(set-logic AUFNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
OB(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

;; bool_inversion
  (assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

(declare-fun tuple01 () ty)

(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
  (assert (forall ((u tuple0)) (= u Tuple0)))

(declare-fun prefix_mnas (Real) Real)

(declare-fun infix_mnas (Real Real) Real)

(declare-fun infix_slas (Real Real) Real)

(declare-fun infix_plas (Real Real) Real)

(declare-fun infix_asas (Real Real) Real)

(declare-fun infix_lseqas (Real Real) Bool)

(declare-fun infix_lsas (Real Real) Bool)

;; infix <*_def
  (assert
  (forall ((x Real) (y Real))
  (= (infix_lsas x y) (and (infix_lseqas x y) (not (= x y))))))

;; Two
  (assert (= (infix_plas 1.0 1.0) 2.0))

;; two
  (assert (= (infix_plas 1.0 1.0) 2.0))

;; Assoc
  (assert
  (forall ((x Real) (y Real) (z Real))
  (= (infix_plas (infix_plas x y) z) (infix_plas x (infix_plas y z)))))

;; Unit_def_l
  (assert (forall ((x Real)) (= (infix_plas 0.0 x) x)))

;; Unit_def_r
  (assert (forall ((x Real)) (= (infix_plas x 0.0) x)))

;; Inv_def_l
  (assert (forall ((x Real)) (= (infix_plas (prefix_mnas x) x) 0.0)))

;; Inv_def_r
  (assert (forall ((x Real)) (= (infix_plas x (prefix_mnas x)) 0.0)))

;; Comm
  (assert (forall ((x Real) (y Real)) (= (infix_plas x y) (infix_plas y x))))

;; Assoc
  (assert
  (forall ((x Real) (y Real) (z Real))
  (= (infix_asas (infix_asas x y) z) (infix_asas x (infix_asas y z)))))

;; Mul_distr_l
  (assert
  (forall ((x Real) (y Real) (z Real))
  (= (infix_asas x (infix_plas y z)) (infix_plas (infix_asas x y)
                                     (infix_asas x z)))))

;; Mul_distr_r
  (assert
  (forall ((x Real) (y Real) (z Real))
  (= (infix_asas (infix_plas y z) x) (infix_plas (infix_asas y x)
                                     (infix_asas z x)))))

;; Comm
  (assert (forall ((x Real) (y Real)) (= (infix_asas x y) (infix_asas y x))))

;; Unitary
  (assert (forall ((x Real)) (= (infix_asas 1.0 x) x)))

;; NonTrivialRing
  (assert (not (= 0.0 1.0)))

(declare-fun inv (Real) Real)

;; Inverse
  (assert
  (forall ((x Real)) (=> (not (= x 0.0)) (= (infix_asas x (inv x)) 1.0))))

;; sub_def
  (assert
  (forall ((x Real) (y Real))
  (= (infix_mnas x y) (infix_plas x (prefix_mnas y)))))

;; div_def
  (assert
  (forall ((x Real) (y Real))
  (=> (not (= y 0.0)) (= (infix_slas x y) (infix_asas x (inv y))))))

;; absorbinf_zero
  (assert (forall ((x Real)) (= (infix_asas x 0.0) 0.0)))

;; add_div
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (not (= z 0.0))
  (= (infix_slas (infix_plas x y) z) (infix_plas (infix_slas x z)
                                     (infix_slas y z))))))

;; sub_div
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (not (= z 0.0))
  (= (infix_slas (infix_mnas x y) z) (infix_mnas (infix_slas x z)
                                     (infix_slas y z))))))

;; neg_div
  (assert
  (forall ((x Real) (y Real))
  (=> (not (= y 0.0))
  (= (infix_slas (prefix_mnas x) y) (prefix_mnas (infix_slas x y))))))

;; assoc_mul_div
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (not (= z 0.0))
  (= (infix_slas (infix_asas x y) z) (infix_asas x (infix_slas y z))))))

;; assoc_div_mul
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (and (not (= y 0.0)) (not (= z 0.0)))
  (= (infix_slas (infix_slas x y) z) (infix_slas x (infix_asas y z))))))

;; assoc_div_div
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (and (not (= y 0.0)) (not (= z 0.0)))
  (= (infix_slas x (infix_slas y z)) (infix_slas (infix_asas x z) y)))))

;; Refl
  (assert (forall ((x Real)) (infix_lseqas x x)))

;; Trans
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (infix_lseqas x y) (=> (infix_lseqas y z) (infix_lseqas x z)))))

;; Antisymm
  (assert
  (forall ((x Real) (y Real))
  (=> (infix_lseqas x y) (=> (infix_lseqas y x) (= x y)))))

;; Total
  (assert
  (forall ((x Real) (y Real)) (or (infix_lseqas x y) (infix_lseqas y x))))

;; ZeroLessOne
  (assert (infix_lseqas 0.0 1.0))

;; CompatOrderAdd
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (infix_lseqas x y) (infix_lseqas (infix_plas x z) (infix_plas y z)))))

;; CompatOrderMult
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (infix_lseqas x y)
  (=> (infix_lseqas 0.0 z) (infix_lseqas (infix_asas x z) (infix_asas y z))))))

;; CompatOrderMult
  (assert
  (forall ((x Int) (y Int) (z Int))
  (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

(declare-fun from_int (Int) Real)

;; Zero
  (assert (= (from_int 0) 0.0))

;; One
  (assert (= (from_int 1) 1.0))

;; Add
  (assert
  (forall ((x Int) (y Int))
  (= (from_int (+ x y)) (infix_plas (from_int x) (from_int y)))))

;; Sub
  (assert
  (forall ((x Int) (y Int))
  (= (from_int (- x y)) (infix_mnas (from_int x) (from_int y)))))

;; Mul
  (assert
  (forall ((x Int) (y Int))
  (= (from_int (* x y)) (infix_asas (from_int x) (from_int y)))))

;; Neg
  (assert (forall ((x Int)) (= (from_int (- x)) (prefix_mnas (from_int x)))))

;; Injective
  (assert
  (forall ((x Int) (y Int)) (=> (= (from_int x) (from_int y)) (= x y))))

;; Monotonic
  (assert
  (forall ((x Int) (y Int))
  (=> (<= x y) (infix_lseqas (from_int x) (from_int y)))))

;; r_zeroLessOne
  (assert (infix_lseqas 0.0 1.0))

;; r_compatOrderAdd
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (infix_lseqas x y) (infix_lseqas (infix_plas x z) (infix_plas y z)))))

;; r_compatOrderMult
  (assert
  (forall ((x Real) (y Real) (z Real))
  (=> (infix_lseqas x y)
  (=> (infix_lseqas 0.0 z) (infix_lseqas (infix_asas x z) (infix_asas y z))))))

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun prefix_mndt (t) t)

(declare-fun infix_mndt (t t) t)

(declare-fun infix_sldt (t t) t)

(declare-fun infix_pldt (t t) t)

(declare-fun infix_asdt (t t) t)

(declare-fun infix_lseqdt (t t) Bool)

(declare-fun infix_lsdt (t t) Bool)

(declare-fun infix_gteqdt (t t) Bool)

(declare-fun infix_gtdt (t t) Bool)

;; inf_st
  (assert
  (forall ((x t) (y t))
  (= (infix_lsdt x y) (and (infix_lseqdt x y) (not (= x y))))))

;; sup_eq
  (assert (forall ((x t) (y t)) (= (infix_gteqdt x y) (infix_lseqdt y x))))

;; sup_st
  (assert
  (forall ((x t) (y t))
  (= (infix_gtdt x y) (and (infix_gteqdt x y) (not (= x y))))))

;; Assoc
  (assert
  (forall ((x t) (y t) (z t))
  (= (infix_pldt (infix_pldt x y) z) (infix_pldt x (infix_pldt y z)))))

;; Unit_def_l
  (assert (forall ((x t)) (= (infix_pldt tzero x) x)))

;; Unit_def_r
  (assert (forall ((x t)) (= (infix_pldt x tzero) x)))

;; Inv_def_l
  (assert (forall ((x t)) (= (infix_pldt (prefix_mndt x) x) tzero)))

;; Inv_def_r
  (assert (forall ((x t)) (= (infix_pldt x (prefix_mndt x)) tzero)))

;; Comm
  (assert (forall ((x t) (y t)) (= (infix_pldt x y) (infix_pldt y x))))

;; Assoc
  (assert
  (forall ((x t) (y t) (z t))
  (= (infix_asdt (infix_asdt x y) z) (infix_asdt x (infix_asdt y z)))))

;; Mul_distr_l
  (assert
  (forall ((x t) (y t) (z t))
  (= (infix_asdt x (infix_pldt y z)) (infix_pldt (infix_asdt x y)
                                     (infix_asdt x z)))))

;; Mul_distr_r
  (assert
  (forall ((x t) (y t) (z t))
  (= (infix_asdt (infix_pldt y z) x) (infix_pldt (infix_asdt y x)
                                     (infix_asdt z x)))))

;; Comm
  (assert (forall ((x t) (y t)) (= (infix_asdt x y) (infix_asdt y x))))

;; Unitary
  (assert (forall ((x t)) (= (infix_asdt tone x) x)))

;; NonTrivialRing
  (assert (not (= tzero tone)))

(declare-fun inv1 (t) t)

;; Inverse
  (assert
  (forall ((x t)) (=> (not (= x tzero)) (= (infix_asdt x (inv1 x)) tone))))

;; sub_def
  (assert
  (forall ((x t) (y t)) (= (infix_mndt x y) (infix_pldt x (prefix_mndt y)))))

;; div_def
  (assert
  (forall ((x t) (y t))
  (=> (not (= y tzero)) (= (infix_sldt x y) (infix_asdt x (inv1 y))))))

;; absorbinf_zero
  (assert (forall ((x t)) (= (infix_asdt x tzero) tzero)))

;; add_div
  (assert
  (forall ((x t) (y t) (z t))
  (=> (not (= z tzero))
  (= (infix_sldt (infix_pldt x y) z) (infix_pldt (infix_sldt x z)
                                     (infix_sldt y z))))))

;; sub_div
  (assert
  (forall ((x t) (y t) (z t))
  (=> (not (= z tzero))
  (= (infix_sldt (infix_mndt x y) z) (infix_mndt (infix_sldt x z)
                                     (infix_sldt y z))))))

;; neg_div
  (assert
  (forall ((x t) (y t))
  (=> (not (= y tzero))
  (= (infix_sldt (prefix_mndt x) y) (prefix_mndt (infix_sldt x y))))))

;; assoc_mul_div
  (assert
  (forall ((x t) (y t) (z t))
  (=> (not (= z tzero))
  (= (infix_sldt (infix_asdt x y) z) (infix_asdt x (infix_sldt y z))))))

;; assoc_div_mul
  (assert
  (forall ((x t) (y t) (z t))
  (=> (and (not (= y tzero)) (not (= z tzero)))
  (= (infix_sldt (infix_sldt x y) z) (infix_sldt x (infix_asdt y z))))))

;; assoc_div_div
  (assert
  (forall ((x t) (y t) (z t))
  (=> (and (not (= y tzero)) (not (= z tzero)))
  (= (infix_sldt x (infix_sldt y z)) (infix_sldt (infix_asdt x z) y)))))

;; Absorbing_zero
  (assert
  (forall ((a t) (b t))
  (= (= (infix_asdt a b) tzero) (=> (not (= a tzero)) (= b tzero)))))

;; absorbing_zero
  (assert
  (forall ((a t) (b t))
  (=> (= (infix_asdt a b) tzero)
  (and (=> (not (= a tzero)) (= b tzero)) (=> (not (= b tzero)) (= a tzero))))))

;; invol_neg
  (assert (forall ((a t)) (= (prefix_mndt (prefix_mndt a)) a)))

;; mult_num
  (assert
  (forall ((a t) (b t) (c t))
  (=> (not (= c tzero))
  (= (infix_sldt (infix_asdt a b) c) (infix_asdt a (infix_sldt b c))))))

;; mult_denom
  (assert
  (forall ((a t) (b t) (c t))
  (=> (not (= c tzero))
  (=> (not (= b tzero))
  (= (infix_sldt a (infix_asdt b c)) (infix_asdt (infix_sldt a b)
                                     (infix_sldt tone c)))))))

;; mult_simpl
  (assert
  (forall ((a t) (b t) (c t))
  (=> (not (= c tzero))
  (=> (not (= b tzero))
  (= (infix_sldt (infix_asdt a b) (infix_asdt c b)) (infix_sldt a c))))))

;; non_zero_prod
  (assert
  (forall ((a t) (b t))
  (=> (not (= a tzero))
  (=> (not (= b tzero)) (not (= (infix_asdt a b) tzero))))))

;; invadd
  (assert
  (forall ((i t)) (= (prefix_mndt i) (infix_asdt (prefix_mndt tone) i))))

;; notZeroAdd
  (assert
  (forall ((x t) (y t)) (=> (not (= x tzero)) (not (= (infix_pldt x y) y)))))

(declare-fun im () t)

;; im_Def
  (assert (= (infix_asdt im im) (prefix_mndt tone)))

(declare-fun r_to_t (Real) t)

;; r_to_t_zero
  (assert (= (r_to_t 0.0) tzero))

;; r_to_t_one
  (assert (= (r_to_t 1.0) tone))

;; r_to_t_add
  (assert
  (forall ((i Real) (j Real))
  (= (infix_pldt (r_to_t i) (r_to_t j)) (r_to_t (infix_plas i j)))))

;; r_to_t_mult
  (assert
  (forall ((i Real) (j Real))
  (= (infix_asdt (r_to_t i) (r_to_t j)) (r_to_t (infix_asas i j)))))

;; r_to_t_sub
  (assert
  (forall ((i Real) (j Real))
  (= (infix_mndt (r_to_t i) (r_to_t j)) (r_to_t (infix_mnas i j)))))

;; r_to_t_div
  (assert
  (forall ((i Real) (j Real))
  (=> (not (= j 0.0))
  (= (infix_sldt (r_to_t i) (r_to_t j)) (r_to_t (infix_slas i j))))))

;; r_to_t_inf
  (assert
  (forall ((i Real) (j Real))
  (= (infix_lseqdt (r_to_t i) (r_to_t j)) (infix_lseqas i j))))

(declare-fun real_part (t) Real)

(declare-fun im_part (t) Real)

;; Real_part_add
  (assert
  (forall ((i t) (j t))
  (= (real_part (infix_pldt i j)) (infix_plas (real_part i) (real_part j)))))

;; Im_part_add
  (assert
  (forall ((i t) (j t))
  (= (im_part (infix_pldt i j)) (infix_plas (im_part i) (im_part j)))))

;; real_part_add
  (assert
  (forall ((i t) (j t))
  (= (real_part (infix_pldt i j)) (infix_plas (real_part i) (real_part j)))))

;; im_part_add
  (assert
  (forall ((i t) (j t))
  (= (im_part (infix_pldt i j)) (infix_plas (im_part i) (im_part j)))))

;; Complex_decomp
  (assert
  (forall ((i t))
  (= i (infix_pldt (r_to_t (real_part i))
       (infix_asdt im (r_to_t (im_part i)))))))

;; Unic_decomp
  (assert
  (forall ((i t))
  (forall ((x Real) (y Real))
  (=> (= i (infix_pldt (r_to_t x) (infix_asdt im (r_to_t y))))
  (and (= x (real_part i)) (= y (im_part i)))))))

;; injective_real_part
  (assert
  (forall ((i t) (j t))
  (=> (not (= (real_part i) (real_part j))) (not (= i j)))))

;; injective_im_part
  (assert
  (forall ((i t) (j t)) (=> (not (= (im_part i) (im_part j))) (not (= i j)))))

;; complex_decomp
  (assert
  (forall ((i t))
  (= i (infix_pldt (r_to_t (real_part i))
       (infix_asdt im (r_to_t (im_part i)))))))

;; unic_decomp
  (assert
  (forall ((i t) (x Real) (y Real))
  (=> (= i (infix_pldt (r_to_t x) (infix_asdt im (r_to_t y))))
  (and (= x (real_part i)) (= y (im_part i))))))

(declare-fun real_ (t) Bool)

;; real__def
  (assert (forall ((x t)) (= (real_ x) (= (im_part x) 0.0))))

(declare-fun pure_im_ (t) Bool)

;; pure_im__def
  (assert (forall ((x t)) (= (pure_im_ x) (= (real_part x) 0.0))))

(declare-fun pi1 () t)

;; pi_def
  (assert (real_ pi1))

;; r_to_t_real
  (assert (forall ((x t)) (=> (real_ x) (= x (r_to_t (real_part x))))))

;; real_r_to_t
  (assert (forall ((x Real)) (real_ (r_to_t x))))

;; r_to_t_pure_im
  (assert
  (forall ((x t))
  (=> (pure_im_ x) (= x (infix_asdt im (r_to_t (im_part x)))))))

;; simpl_frac
  (assert
  (forall ((x t) (y t))
  (=> (not (= y tzero)) (= (infix_sldt (infix_asdt x y) y) x))))

;; simpl_frac_
  (assert
  (forall ((x t) (y t) (z t))
  (=> (not (= y tzero))
  (=> (not (= z tzero))
  (= (infix_sldt (infix_asdt x y) (infix_asdt z y)) (infix_sldt x z))))))

;; fact_frac
  (assert
  (forall ((x t) (y t) (z t))
  (=> (not (= z tzero))
  (= (infix_sldt (infix_asdt x y) z) (infix_asdt x (infix_sldt y z))))))

;; inv_mult
  (assert
  (forall ((x t) (y t))
  (=> (not (= x tzero))
  (=> (not (= y tzero))
  (= (infix_asdt (infix_sldt tone x) (infix_sldt tone y)) (infix_sldt 
                                                          tone
                                                          (infix_asdt x y)))))))

;; Inf_eq_def
  (assert
  (forall ((x t) (y t))
  (= (infix_lseqdt x y)
  (or
  (and (real_ x) (and (real_ y) (infix_lseqas (real_part x) (real_part y))))
  (= x y)))))

;; inf_eq_def
  (assert
  (forall ((x t) (y t))
  (= (infix_lseqdt x y)
  (or
  (and (real_ x) (and (real_ y) (infix_lseqas (real_part x) (real_part y))))
  (= x y)))))

;; inf_def
  (assert
  (forall ((x t) (y t))
  (= (infix_lsdt x y)
  (and (real_ x) (and (real_ y) (infix_lsas (real_part x) (real_part y)))))))

;; sup_eq_def
  (assert
  (forall ((x t) (y t))
  (= (infix_gteqdt x y)
  (or
  (and (real_ x) (and (real_ y) (infix_lseqas (real_part y) (real_part x))))
  (= x y)))))

;; sup_def
  (assert
  (forall ((x t) (y t))
  (= (infix_gtdt x y)
  (and (real_ x) (and (real_ y) (infix_lsas (real_part y) (real_part x)))))))

;; decomp_mult
  (assert
  (forall ((a t) (b t))
  (= (infix_asdt a b) (infix_pldt
                      (infix_mndt
                      (infix_asdt (r_to_t (real_part a))
                      (r_to_t (real_part b)))
                      (infix_asdt (r_to_t (im_part a)) (r_to_t (im_part b))))
                      (infix_asdt im
                      (infix_pldt
                      (infix_asdt (r_to_t (real_part a))
                      (r_to_t (im_part b)))
                      (infix_asdt (r_to_t (real_part b))
                      (r_to_t (im_part a)))))))))

;; decomp_mult_real_part
  (assert
  (forall ((a t) (b t))
  (= (real_part (infix_asdt a b)) (infix_mnas
                                  (infix_asas (real_part a) (real_part b))
                                  (infix_asas (im_part a) (im_part b))))))

;; decomp_mult_im_part
  (assert
  (forall ((a t) (b t))
  (= (im_part (infix_asdt a b)) (infix_plas
                                (infix_asas (real_part a) (im_part b))
                                (infix_asas (real_part b) (im_part a))))))

(declare-fun t_real_part (t) t)

;; t_real_part_def
  (assert (forall ((x t)) (= (t_real_part x) (r_to_t (real_part x)))))

;; t_real_part_spec
  (assert (forall ((x t)) (real_ (t_real_part x))))

(declare-fun t_im_part (t) t)

;; t_im_part_def
  (assert (forall ((x t)) (= (t_im_part x) (r_to_t (im_part x)))))

;; t_im_part_spec
  (assert (forall ((x t)) (real_ (t_im_part x))))

;; t_mult_real
  (assert
  (forall ((a t) (b t))
  (= (t_real_part (infix_asdt a b)) (infix_mndt
                                    (infix_asdt (t_real_part a)
                                    (t_real_part b))
                                    (infix_asdt (t_im_part a) (t_im_part b))))))

;; t_im_real
  (assert
  (forall ((a t) (b t))
  (= (t_im_part (infix_asdt a b)) (infix_pldt
                                  (infix_asdt (t_real_part a) (t_im_part b))
                                  (infix_asdt (t_im_part a) (t_real_part b))))))

;; t_decomp_mult
  (assert
  (forall ((a t) (b t))
  (= (infix_asdt a b) (infix_pldt
                      (infix_mndt
                      (infix_asdt (t_real_part a) (t_real_part b))
                      (infix_asdt (t_im_part a) (t_im_part b)))
                      (infix_asdt im
                      (infix_pldt (infix_asdt (t_real_part a) (t_im_part b))
                      (infix_asdt (t_im_part a) (t_real_part b))))))))

;; t_complex_decomp
  (assert
  (forall ((i t))
  (= i (infix_pldt (t_real_part i) (infix_asdt im (t_im_part i))))))

;; t_unic_decomp
  (assert
  (forall ((i t) (a t) (b t))
  (=> (real_ a)
  (=> (real_ b)
  (=> (= i (infix_pldt a (infix_asdt im b)))
  (and (= a (t_real_part i)) (= b (t_im_part i))))))))

;; real_sum
  (assert
  (forall ((x t) (y t))
  (=> (real_ x) (=> (real_ y) (real_ (infix_pldt x y))))))

;; real_diff
  (assert
  (forall ((x t) (y t))
  (=> (real_ x) (=> (real_ y) (real_ (infix_mndt x y))))))

;; pure_im_sum
  (assert
  (forall ((x t) (y t))
  (=> (pure_im_ x) (=> (pure_im_ y) (pure_im_ (infix_pldt x y))))))

;; pure_im_diff
  (assert
  (forall ((x t) (y t))
  (=> (pure_im_ x) (=> (pure_im_ y) (pure_im_ (infix_mndt x y))))))

;; real_mult
  (assert
  (forall ((x t) (y t))
  (=> (real_ x) (=> (real_ y) (real_ (infix_asdt x y))))))

;; real_inv
  (assert
  (forall ((x t)) (=> (real_ x) (=> (not (= x tzero)) (real_ (inv1 x))))))

;; real_div
  (assert
  (forall ((x t) (y t))
  (=> (real_ x)
  (=> (not (= y tzero)) (=> (real_ y) (real_ (infix_sldt x y)))))))

;; mult_real_real
  (assert
  (forall ((a t) (b t))
  (=> (real_ a)
  (=> (real_ b)
  (and
  (and
  (= (infix_asdt a b) (infix_asdt (r_to_t (real_part a))
                      (r_to_t (real_part b))))
  (= (infix_asdt (r_to_t (real_part a)) (r_to_t (real_part b))) (r_to_t
                                                                (infix_asas
                                                                (real_part a)
                                                                (real_part b)))))
  (and
  (= (real_part (infix_asdt a b)) (infix_asas (real_part a) (real_part b)))
  (= (im_part (infix_asdt a b)) 0.0)))))))

;; mult_im_im
  (assert
  (forall ((a t) (b t))
  (=> (pure_im_ a)
  (=> (pure_im_ b)
  (and
  (= (infix_asdt a b) (infix_asdt (infix_asdt im im)
                      (infix_asdt (r_to_t (im_part a)) (r_to_t (im_part b)))))
  (and
  (= (infix_asdt a b) (prefix_mndt
                      (r_to_t (infix_asas (im_part a) (im_part b)))))
  (and
  (= (real_part (infix_asdt a b)) (prefix_mnas
                                  (infix_asas (im_part a) (im_part b))))
  (= (im_part (infix_asdt a b)) 0.0))))))))

;; mult_real_im
  (assert
  (forall ((a t) (b t))
  (=> (real_ a)
  (=> (pure_im_ b)
  (and
  (= (infix_asdt a b) (infix_asdt im
                      (infix_asdt (r_to_t (real_part a))
                      (r_to_t (im_part b)))))
  (and
  (= (infix_asdt a b) (infix_asdt im
                      (r_to_t (infix_asas (real_part a) (im_part b)))))
  (and (= (real_part (infix_asdt a b)) 0.0)
  (= (im_part (infix_asdt a b)) (infix_asas (real_part a) (im_part b))))))))))

;; mult_im_real
  (assert
  (forall ((a t) (b t))
  (=> (pure_im_ a)
  (=> (real_ b)
  (and
  (= (infix_asdt a b) (infix_asdt im
                      (infix_asdt (r_to_t (im_part a))
                      (r_to_t (real_part b)))))
  (and
  (= (infix_asdt a b) (infix_asdt im
                      (r_to_t (infix_asas (im_part a) (real_part b)))))
  (and (= (real_part (infix_asdt a b)) 0.0)
  (= (im_part (infix_asdt a b)) (infix_asas (im_part a) (real_part b))))))))))

;; decomp_mult_gen
  (assert
  (forall ((a t) (b t))
  (and
  (= (real_part (infix_asdt a b)) (infix_mnas
                                  (infix_asas (real_part a) (real_part b))
                                  (infix_asas (im_part a) (im_part b))))
  (= (im_part (infix_asdt a b)) (infix_plas
                                (infix_asas (real_part a) (im_part b))
                                (infix_asas (im_part a) (real_part b)))))))

;; inv_real
  (assert
  (forall ((a t))
  (=> (not (= a tzero))
  (=> (real_ a)
  (and (= (real_part (inv1 a)) (infix_slas 1.0 (real_part a))) (real_
  (inv1 a)))))))

;; zeroLessOne
  (assert (infix_lseqdt tzero tone))

;; compatOrderAdd
  (assert
  (forall ((x t) (y t) (z t))
  (=> (infix_lseqdt x y)
  (=> (real_ x)
  (=> (real_ y)
  (=> (real_ z) (infix_lseqdt (infix_pldt x z) (infix_pldt y z))))))))

;; compat_order_mult
  (assert
  (forall ((x t) (y t) (z t))
  (=> (infix_lseqdt x y)
  (=> (real_ x)
  (=> (real_ y)
  (=> (real_ z)
  (=> (infix_lseqdt tzero z) (infix_lseqdt (infix_asdt x z)
  (infix_asdt y z)))))))))

;; strict_compat_order_mult
  (assert
  (forall ((x t) (y t) (z t))
  (=> (infix_lsdt x y)
  (=> (real_ x)
  (=> (real_ y)
  (=> (real_ z)
  (=> (infix_lsdt tzero z) (infix_lsdt (infix_asdt x z) (infix_asdt y z)))))))))

;; inv_eqinf
  (assert
  (forall ((x t) (y t))
  (=> (and (infix_lsdt tzero x) (infix_lseqdt x y)) (infix_gteqdt (inv1 x)
  (inv1 y)))))

;; inv_inf
  (assert
  (forall ((x t) (y t))
  (=> (and (infix_lsdt tzero x) (infix_lsdt x y)) (infix_gtdt (inv1 x)
  (inv1 y)))))

;; inv_eqsup
  (assert
  (forall ((x t) (y t))
  (=> (and (infix_gteqdt x y) (infix_gtdt y tzero)) (infix_lseqdt (inv1 x)
  (inv1 y)))))

;; inv_sup
  (assert
  (forall ((x t) (y t))
  (=> (and (infix_gtdt x y) (infix_gtdt y tzero)) (infix_lsdt (inv1 x)
  (inv1 y)))))

;; inv_pos
  (assert
  (forall ((x t)) (=> (infix_lsdt tzero x) (infix_gtdt (inv1 x) tzero))))

;; inv_neg
  (assert
  (forall ((x t)) (=> (infix_gtdt tzero x) (infix_lsdt (inv1 x) tzero))))

;; zero_add_t
  (assert
  (forall ((a1 t) (a2 t)) (=> (= a1 tzero) (= (infix_pldt a1 a2) a2))))

;; add_zero_t
  (assert
  (forall ((a1 t) (a2 t)) (=> (= a2 tzero) (= (infix_pldt a1 a2) a1))))

;; one_mult_t
  (assert
  (forall ((a1 t) (a2 t)) (=> (= a1 tone) (= (infix_asdt a1 a2) a2))))

;; one_mult_t_const
  (assert (forall ((a t)) (= (infix_asdt tone a) a)))

;; zero_mult_t_const
  (assert (forall ((a t)) (= (infix_asdt tzero a) tzero)))

;; mult_zero_t_const
  (assert (forall ((a t)) (= (infix_asdt a tzero) tzero)))

;; zero_mult_t
  (assert
  (forall ((a1 t) (a2 t)) (=> (= a1 tzero) (= (infix_asdt a1 a2) tzero))))

;; mult_zero_t
  (assert
  (forall ((a1 t) (a2 t)) (=> (= a1 tzero) (= (infix_asdt a2 a1) tzero))))

;; mult_one_t
  (assert
  (forall ((a1 t) (a2 t)) (=> (= a2 tone) (= (infix_asdt a1 a2) a1))))

;; add_eq_t
  (assert
  (forall ((a1 t) (a2 t) (b1 t) (b2 t))
  (=> (= a1 a2) (=> (= b1 b2) (= (infix_pldt a1 b1) (infix_pldt a2 b2))))))

;; add_eq_t_rev
  (assert
  (forall ((a1 t) (a2 t) (b1 t) (b2 t))
  (=> (= a1 a2) (=> (= b1 b2) (= (infix_pldt a1 b1) (infix_pldt b2 a2))))))

;; mult_eq_t
  (assert
  (forall ((a1 t) (a2 t) (b1 t) (b2 t))
  (=> (= a1 a2) (=> (= b1 b2) (= (infix_asdt a1 b1) (infix_asdt a2 b2))))))

;; mult_eq_t_rev
  (assert
  (forall ((a1 t) (a2 t) (b1 t) (b2 t))
  (=> (= a1 a2) (=> (= b1 b2) (= (infix_asdt a1 b1) (infix_asdt b2 a2))))))

;; mult_comm
  (assert (forall ((a t) (b t)) (= (infix_asdt a b) (infix_asdt b a))))

;; mult_assoc
  (assert
  (forall ((a t) (b t) (c t))
  (= (infix_asdt (infix_asdt a b) c) (infix_asdt a (infix_asdt b c)))))

;; mult_assoc_rev
  (assert
  (forall ((a t) (b t) (c t))
  (= (infix_asdt a (infix_asdt b c)) (infix_asdt (infix_asdt a b) c))))

;; div_mult
  (assert
  (forall ((a t) (b t) (c t))
  (=> (not (= c tzero))
  (= (infix_asdt a (infix_sldt b c)) (infix_sldt (infix_asdt a b) c)))))

;; div_mult_rev
  (assert
  (forall ((a t) (b t) (c t))
  (=> (not (= c tzero))
  (= (infix_sldt (infix_asdt a b) c) (infix_asdt a (infix_sldt b c))))))

;; div_eq
  (assert
  (forall ((a1 t) (a2 t) (b1 t) (b2 t))
  (=> (= a1 a2)
  (=> (= b1 b2)
  (=> (not (= b1 tzero)) (= (infix_sldt a1 b1) (infix_sldt a2 b2)))))))

;; add_eq_inv_t
  (assert
  (forall ((a1 t) (a2 t) (b1 t) (b2 t))
  (=> (= a1 a2) (=> (= b1 b2) (= (infix_pldt a1 b1) (infix_pldt b2 a2))))))

;; mult_eq_inv_t
  (assert
  (forall ((a1 t) (a2 t) (b1 t) (b2 t))
  (=> (= a1 a2) (=> (= b1 b2) (= (infix_asdt a1 b1) (infix_asdt b2 a2))))))

;; sum_frac
  (assert
  (forall ((a1 t) (a2 t) (b t))
  (=> (not (= b tzero))
  (= (infix_pldt (infix_sldt a1 b) (infix_sldt a2 b)) (infix_sldt
                                                      (infix_pldt a1 a2) b)))))

;; sum_frac_rev
  (assert
  (forall ((a1 t) (a2 t) (b t))
  (=> (not (= b tzero))
  (= (infix_sldt (infix_pldt a1 a2) b) (infix_pldt (infix_sldt a1 b)
                                       (infix_sldt a2 b))))))

;; real
  (assert (forall ((x t)) (=> (real_ x) (= x (r_to_t (real_part x))))))

;; pure_im
  (assert
  (forall ((x t))
  (=> (pure_im_ x) (= x (infix_asdt im (r_to_t (im_part x)))))))

;; im_dec
  (assert (and (= (real_part im) 0.0) (= (im_part im) 1.0)))

;; tone_dec
  (assert (and (= (real_part tone) 1.0) (= (im_part tone) 0.0)))

;; tzero_dec
  (assert (and (= (real_part tzero) 0.0) (= (im_part tzero) 0.0)))

;; ttwo_dec
  (assert
  (and (= (real_part (infix_pldt tone tone)) 2.0)
  (= (im_part (infix_pldt tone tone)) 0.0)))

(declare-fun i_to_t (Int) t)

;; i_to_t_def
  (assert (forall ((i Int)) (= (i_to_t i) (r_to_t (from_int i)))))

;; i_to_t_spec
  (assert (forall ((i Int)) (real_ (i_to_t i))))

;; i_to_t_zero
  (assert (= (i_to_t 0) tzero))

;; i_to_t_eq
  (assert (forall ((i Int) (j Int)) (=> (= i j) (= (i_to_t i) (i_to_t j)))))

;; i_to_t_nzero
  (assert (forall ((i Int)) (=> (not (= i 0)) (not (= (i_to_t i) tzero)))))

;; i_to_t_one
  (assert (= (i_to_t 1) tone))

;; i_to_t_add
  (assert
  (forall ((i Int) (j Int))
  (= (infix_pldt (i_to_t i) (i_to_t j)) (i_to_t (+ i j)))))

;; i_to_t_add_rev
  (assert
  (forall ((i Int) (j Int))
  (= (i_to_t (+ i j)) (infix_pldt (i_to_t i) (i_to_t j)))))

;; i_to_t_ttwo
  (assert (= (i_to_t 2) (infix_pldt tone tone)))

;; i_to_t_mult
  (assert
  (forall ((i Int) (j Int))
  (= (infix_asdt (i_to_t i) (i_to_t j)) (i_to_t (* i j)))))

;; i_to_t_mult_rev
  (assert
  (forall ((i Int) (j Int))
  (= (i_to_t (* i j)) (infix_asdt (i_to_t i) (i_to_t j)))))

;; i_to_t_sub
  (assert
  (forall ((i Int) (j Int))
  (= (infix_mndt (i_to_t i) (i_to_t j)) (i_to_t (- i j)))))

;; i_to_t_div
  (assert
  (forall ((i Int) (j Int))
  (=> (not (= j 0)) (= (infix_sldt (i_to_t (* i j)) (i_to_t j)) (i_to_t i)))))

(declare-sort set 1)

(declare-fun set1 (ty) ty)

(declare-fun mem (ty uni uni) Bool)

(declare-fun infix_eqeq (ty uni uni) Bool)

;; infix ==_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (and
  (=> (infix_eqeq a s1 s2) (forall ((x uni)) (= (mem a x s1) (mem a x s2))))
  (=> (forall ((x uni)) (=> (sort a x) (= (mem a x s1) (mem a x s2))))
  (infix_eqeq a s1 s2))))))

;; extensionality
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (=> (sort (set1 a) s1)
  (=> (sort (set1 a) s2) (=> (infix_eqeq a s1 s2) (= s1 s2)))))))

(declare-fun subset1 (ty uni uni) Bool)

;; subset_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (and
  (=> (subset1 a s1 s2) (forall ((x uni)) (=> (mem a x s1) (mem a x s2))))
  (=> (forall ((x uni)) (=> (sort a x) (=> (mem a x s1) (mem a x s2))))
  (subset1 a s1 s2))))))

;; subset_refl
  (assert (forall ((a ty)) (forall ((s uni)) (subset1 a s s))))

;; subset_trans
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni) (s3 uni))
  (=> (subset1 a s1 s2) (=> (subset1 a s2 s3) (subset1 a s1 s3))))))

(declare-fun is_empty (ty uni) Bool)

;; is_empty_spec
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (and (=> (is_empty a s) (forall ((x uni)) (not (mem a x s))))
  (=> (forall ((x uni)) (=> (sort a x) (not (mem a x s)))) (is_empty a s))))))

(declare-fun empty (ty) uni)

;; empty_sort
  (assert (forall ((a ty)) (sort (set1 a) (empty a))))

;; empty_def
  (assert (forall ((a ty)) (is_empty a (empty a))))

(declare-fun add (ty uni uni) uni)

;; add_sort
  (assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (set1 a) (add a x x1)))))

;; add_spec
  (assert
  (forall ((a ty))
  (forall ((x uni) (s uni))
  (=> (sort a x)
  (forall ((y uni))
  (=> (sort a y) (= (mem a y (add a x s)) (or (= y x) (mem a y s)))))))))

(declare-fun remove (ty uni uni) uni)

;; remove_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (remove a x x1)))))

;; remove_spec
  (assert
  (forall ((a ty))
  (forall ((x uni) (s uni))
  (=> (sort a x)
  (forall ((y uni))
  (=> (sort a y)
  (= (mem a y (remove a x s)) (and (not (= y x)) (mem a y s)))))))))

;; add_remove
  (assert
  (forall ((a ty))
  (forall ((x uni) (s uni))
  (=> (sort (set1 a) s) (=> (mem a x s) (= (add a x (remove a x s)) s))))))

;; remove_add
  (assert
  (forall ((a ty))
  (forall ((x uni) (s uni)) (= (remove a x (add a x s)) (remove a x s)))))

;; subset_remove
  (assert
  (forall ((a ty)) (forall ((x uni) (s uni)) (subset1 a (remove a x s) s))))

(declare-fun union1 (ty uni uni) uni)

;; union_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (union1 a x x1)))))

;; union_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (forall ((x uni))
  (= (mem a x (union1 a s1 s2)) (or (mem a x s1) (mem a x s2)))))))

(declare-fun inter (ty uni uni) uni)

;; inter_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (inter a x x1)))))

;; inter_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (forall ((x uni))
  (= (mem a x (inter a s1 s2)) (and (mem a x s1) (mem a x s2)))))))

(declare-fun diff (ty uni uni) uni)

;; diff_sort
  (assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (set1 a) (diff a x x1)))))

;; diff_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (forall ((x uni))
  (= (mem a x (diff a s1 s2)) (and (mem a x s1) (not (mem a x s2))))))))

;; subset_diff
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni)) (subset1 a (diff a s1 s2) s1))))

(declare-fun choose (ty uni) uni)

;; choose_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (choose a x)))))

;; choose_spec
  (assert
  (forall ((a ty))
  (forall ((s uni)) (=> (not (is_empty a s)) (mem a (choose a s) s)))))

(declare-fun cardinal (ty uni) Int)

;; cardinal_nonneg
  (assert (forall ((a ty)) (forall ((s uni)) (<= 0 (cardinal a s)))))

;; cardinal_empty
  (assert
  (forall ((a ty))
  (forall ((s uni)) (= (= (cardinal a s) 0) (is_empty a s)))))

;; cardinal_add
  (assert
  (forall ((a ty))
  (forall ((x uni))
  (forall ((s uni))
  (=> (not (mem a x s)) (= (cardinal a (add a x s)) (+ 1 (cardinal a s))))))))

;; cardinal_remove
  (assert
  (forall ((a ty))
  (forall ((x uni))
  (forall ((s uni))
  (=> (mem a x s) (= (cardinal a s) (+ 1 (cardinal a (remove a x s)))))))))

;; cardinal_subset
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (=> (subset1 a s1 s2) (<= (cardinal a s1) (cardinal a s2))))))

;; subset_eq
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (=> (subset1 a s1 s2)
  (=> (= (cardinal a s1) (cardinal a s2)) (infix_eqeq a s1 s2))))))

;; cardinal1
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (= (cardinal a s) 1)
  (forall ((x uni)) (=> (sort a x) (=> (mem a x s) (= x (choose a s)))))))))

(declare-fun op (ty uni uni) uni)

;; op_sort
  (assert
  (forall ((im1 ty)) (forall ((x uni) (x1 uni)) (sort im1 (op im1 x x1)))))

(declare-fun po (ty uni uni) uni)

;; po_sort
  (assert
  (forall ((im1 ty)) (forall ((x uni) (x1 uni)) (sort im1 (po im1 x x1)))))

(declare-fun inver (ty uni) uni)

;; inver_sort
  (assert (forall ((im1 ty)) (forall ((x uni)) (sort im1 (inver im1 x)))))

(declare-fun infix_mngt (ty ty) ty)

(declare-fun infix_at (ty ty uni uni) uni)

;; infix @_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

(declare-fun filter (ty uni uni) uni)

;; filter_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (filter a x x1)))))

(declare-fun t2tb (Bool) uni)

;; t2tb_sort
  (assert (forall ((x Bool)) (sort bool (t2tb x))))

(declare-fun tb2t (uni) Bool)

;; BridgeL
  (assert (forall ((i Bool)) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort bool j) (= (t2tb (tb2t j)) j)) :pattern ((t2tb (tb2t j))) )))

;; filter_def
  (assert
  (forall ((a ty))
  (forall ((p uni) (u uni))
  (forall ((x uni))
  (= (mem a x (filter a p u))
  (and (= (tb2t (infix_at bool a p x)) true) (mem a x u)))))))

;; filter_cardinal
  (assert
  (forall ((a ty))
  (forall ((p uni) (u uni)) (<= (cardinal a (filter a p u)) (cardinal a u)))))

(declare-fun map1 (ty ty uni uni) uni)

;; map_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (set1 b) (map1 b a x x1)))))

;; map_def1
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (u uni))
  (forall ((y uni))
  (=> (sort b y)
  (and
  (=> (mem b y (map1 b a f u))
  (exists ((x uni))
  (and (sort a x) (and (mem a x u) (= y (infix_at b a f x))))))
  (=> (exists ((x uni)) (and (mem a x u) (= y (infix_at b a f x)))) (mem b y
  (map1 b a f u)))))))))

;; map_def2
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (u uni))
  (forall ((x uni))
  (=> (mem a x u) (mem b (infix_at b a f x) (map1 b a f u)))))))

;; map_cardinal
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (u uni)) (<= (cardinal b (map1 b a f u)) (cardinal a u)))))

;; assert_equal
  (assert true)

;; goal_comm
  (assert
  (forall ((a ty))
  (forall ((a1 uni) (b uni))
  (=> (sort a a1) (=> (sort a b) (=> (= a1 b) (= b a1)))))))

(declare-sort tuple2 2)

(declare-fun tuple21 (ty ty) ty)

(declare-fun Tuple2 (ty ty uni uni) uni)

;; Tuple2_sort
  (assert
  (forall ((a ty) (a1 ty))
  (forall ((x uni) (x1 uni)) (sort (tuple21 a1 a) (Tuple2 a1 a x x1)))))

(declare-fun Tuple2_proj_1 (ty ty uni) uni)

;; Tuple2_proj_1_sort
  (assert
  (forall ((a ty) (a1 ty))
  (forall ((x uni)) (sort a1 (Tuple2_proj_1 a1 a x)))))

;; Tuple2_proj_1_def
  (assert
  (forall ((a ty) (a1 ty))
  (forall ((u uni) (u1 uni))
  (=> (sort a1 u) (= (Tuple2_proj_1 a1 a (Tuple2 a1 a u u1)) u)))))

(declare-fun Tuple2_proj_2 (ty ty uni) uni)

;; Tuple2_proj_2_sort
  (assert
  (forall ((a ty) (a1 ty))
  (forall ((x uni)) (sort a (Tuple2_proj_2 a1 a x)))))

;; Tuple2_proj_2_def
  (assert
  (forall ((a ty) (a1 ty))
  (forall ((u uni) (u1 uni))
  (=> (sort a u1) (= (Tuple2_proj_2 a1 a (Tuple2 a1 a u u1)) u1)))))

;; tuple2_inversion
  (assert
  (forall ((a ty) (a1 ty))
  (forall ((u uni))
  (=> (sort (tuple21 a1 a) u)
  (= u (Tuple2 a1 a (Tuple2_proj_1 a1 a u) (Tuple2_proj_2 a1 a u)))))))

(declare-fun fir (ty ty uni) uni)

;; fir_sort
  (assert (forall ((a ty) (b ty)) (forall ((x uni)) (sort a (fir b a x)))))

(declare-fun sec (ty ty uni) uni)

;; sec_sort
  (assert (forall ((a ty) (b ty)) (forall ((x uni)) (sort b (sec b a x)))))

;; projections
  (assert
  (forall ((a ty) (b ty))
  (forall ((o uni))
  (=> (sort (tuple21 a b) o) (= o (Tuple2 a b (fir b a o) (sec b a o)))))))

;; get_fir
  (assert
  (forall ((a ty) (b ty))
  (forall ((a1 uni) (b1 uni))
  (=> (sort a a1) (= (fir b a (Tuple2 a b a1 b1)) a1)))))

;; get_sec
  (assert
  (forall ((a ty) (b ty))
  (forall ((a1 uni) (b1 uni))
  (=> (sort b b1) (= (sec b a (Tuple2 a b a1 b1)) b1)))))

(declare-fun ref (ty) ty)

(declare-fun mk_ref (ty uni) uni)

;; mk ref_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (mk_ref a x)))))

(declare-fun contents (ty uni) uni)

;; contents_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; contents_def
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort a u) (= (contents a (mk_ref a u)) u)))))

;; ref_inversion
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort (ref a) u) (= u (mk_ref a (contents a u)))))))

;; union_exchange
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (not (is_empty a sqt))
  (= (union1 a (add a (choose a sqt) s) (remove a (choose a sqt) sqt)) 
  (union1 a s sqt))))))

;; get_filter
  (assert
  (forall ((a ty))
  (forall ((p uni) (s uni) (x uni))
  (=> (mem a x (filter a p s))
  (and (= (tb2t (infix_at bool a p x)) true) (mem a x s))))))

;; set_filter
  (assert
  (forall ((a ty))
  (forall ((p uni) (s uni) (x uni))
  (=> (= (tb2t (infix_at bool a p x)) true)
  (=> (mem a x s) (mem a x (filter a p s)))))))

;; inter_empty
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (is_empty a s) (is_empty a (inter a s sqt))))))

;; inter_empty_comm
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (is_empty a sqt) (is_empty a (inter a s sqt))))))

;; union_empty
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (sort (set1 a) sqt) (=> (is_empty a s) (= (union1 a s sqt) sqt))))))

;; union_comm
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (sort (set1 a) s) (=> (is_empty a sqt) (= (union1 a s sqt) s))))))

;; union_alt
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni) (e uni))
  (=> (mem a e (union1 a s sqt)) (=> (not (mem a e s)) (mem a e sqt))))))

;; union_empty_comm
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (sort (set1 a) s) (=> (is_empty a sqt) (= (union1 a s sqt) s))))))

;; set_subset
  (assert
  (forall ((a ty))
  (forall ((sqt uni) (s uni))
  (=> (forall ((e uni)) (=> (sort a e) (=> (mem a e sqt) (mem a e s))))
  (subset1 a sqt s)))))

;; set_empty
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (sort (set1 a) s)
  (=> (forall ((e uni)) (=> (sort a e) (not (mem a e s))))
  (and (= s (empty a)) (is_empty a s)))))))

;; set_equal
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (sort (set1 a) s)
  (=> (sort (set1 a) sqt)
  (=> (forall ((e uni)) (=> (sort a e) (=> (mem a e s) (mem a e sqt))))
  (=> (forall ((e uni)) (=> (sort a e) (=> (mem a e sqt) (mem a e s))))
  (= s sqt))))))))

;; get_empty
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (= s (empty a))
  (and (forall ((e uni)) (not (mem a e s))) (is_empty a s))))))

;; get_non_empty
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (not (is_empty a s)) (exists ((e uni)) (and (sort a e) (mem a e s)))))))

;; set_non_empty
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (exists ((e uni)) (mem a e s))
  (and (not (is_empty a s)) (< 0 (cardinal a s)))))))

;; set_pos_card_elt
  (assert
  (forall ((a ty))
  (forall ((s uni) (a1 uni)) (=> (mem a a1 s) (< 0 (cardinal a s))))))

;; union_add
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni) (x uni))
  (=> (not (mem a x sqt))
  (= (union1 a s (add a x sqt)) (add a x (union1 a s sqt)))))))

;; union_add_mem
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni) (x uni) (y uni))
  (=> (sort a x)
  (=> (sort a y)
  (=> (mem a x (add a y (union1 a s sqt)))
  (=> (not (mem a x sqt)) (=> (not (mem a x s)) (= x y)))))))))

;; union_add_comm
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni) (x uni))
  (=> (not (mem a x sqt))
  (= (add a x (union1 a s sqt)) (union1 a s (add a x sqt)))))))

;; remove_add
  (assert
  (forall ((a ty))
  (forall ((s uni) (x uni))
  (=> (sort (set1 a) s)
  (=> (not (mem a x s)) (= (remove a x (add a x s)) s))))))

;; add_remove
  (assert
  (forall ((a ty))
  (forall ((s uni) (x uni))
  (=> (sort (set1 a) s) (=> (mem a x s) (= (add a x (remove a x s)) s))))))

(declare-fun p_injective (ty ty uni uni) Bool)

;; p_injective_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (= (p_injective b a f s)
  (forall ((e uni) (eqt uni))
  (=> (sort a e)
  (=> (sort a eqt)
  (=> (mem a e s)
  (=> (mem a eqt s)
  (=> (not (= e eqt)) (not (= (infix_at b a f e) (infix_at b a f eqt)))))))))))))

;; set_map_mem
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (b1 uni))
  (=> (exists ((a1 uni)) (and (mem a a1 s) (= b1 (infix_at b a f a1)))) (mem
  b b1 (map1 b a f s))))))

;; map_add
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (x uni))
  (=> (not (mem a x s))
  (= (map1 b a f (add a x s)) (add b (infix_at b a f x) (map1 b a f s)))))))

;; map_eq
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (g uni) (s uni))
  (=>
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (= (infix_at b a f e) (infix_at b a g e)))))
  (= (map1 b a f s) (map1 b a g s))))))

;; injective_map_cardinal
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (=> (p_injective b a f s) (= (cardinal b (map1 b a f s)) (cardinal a s))))))

;; set_map_mem_el
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (b1 uni) (a1 uni))
  (=> (mem a a1 s) (=> (= b1 (infix_at b a f a1)) (mem b b1 (map1 b a f s)))))))

;; set_map_mem_el_gen
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (b1 uni))
  (=> (exists ((a1 uni)) (and (mem a a1 s) (= b1 (infix_at b a f a1)))) (mem
  b b1 (map1 b a f s))))))

;; map_antec
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (b1 uni))
  (=> (sort b b1)
  (=> (mem b b1 (map1 b a f s))
  (exists ((a1 uni))
  (and (sort a a1) (and (mem a a1 s) (= b1 (infix_at b a f a1))))))))))

;; map_antec_gen
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (forall ((b1 uni))
  (=> (sort b b1)
  (=> (mem b b1 (map1 b a f s))
  (exists ((a1 uni))
  (and (sort a a1) (and (mem a a1 s) (= b1 (infix_at b a f a1)))))))))))

;; map_remove_choose
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (f uni))
  (=> (p_injective b a f s)
  (= (map1 b a f (remove a (choose a s) s)) (remove b
                                            (infix_at b a f (choose a s))
                                            (map1 b a f s)))))))

(declare-fun antec_set (ty ty uni uni uni) uni)

;; antec_set_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (set1 a)
  (antec_set b a x x1 x2)))))

(declare-fun result (ty ty uni uni) uni)

;; result_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a bool) (result b a x x1)))))

;; result_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (b1 uni) (e uni))
  (=> (sort b b1)
  (= (= (tb2t (infix_at bool a (result b a f b1) e)) true)
  (= (infix_at b a f e) b1))))))

;; antec_set_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (f uni) (b1 uni))
  (=> (mem b b1 (map1 b a f s))
  (= (antec_set b a s f b1) (filter a (result b a f b1) s))))))

(declare-fun remove_s (ty uni uni) uni)

;; remove_s_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (remove_s a x x1)))))

(declare-fun result1 (ty uni) uni)

;; result_sort
  (assert
  (forall ((a ty))
  (forall ((x uni)) (sort (infix_mngt a bool) (result1 a x)))))

;; result_def
  (assert
  (forall ((a ty))
  (forall ((sqt uni) (e uni))
  (= (= (tb2t (infix_at bool a (result1 a sqt) e)) true) (not (mem a e sqt))))))

;; remove_s_def
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (subset1 a sqt s) (= (remove_s a s sqt) (filter a (result1 a sqt) s))))))

;; remove_s_spec
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (subset1 a sqt s)
  (forall ((e uni))
  (= (mem a e (remove_s a s sqt)) (and (mem a e s) (not (mem a e sqt)))))))))

(declare-fun remove_antecs (ty ty uni uni uni) uni)

;; remove_antecs_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (set1 a)
  (remove_antecs b a x x1 x2)))))

;; remove_antecs_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (f uni) (b1 uni))
  (=> (mem b b1 (map1 b a f s))
  (= (remove_antecs b a s f b1) (remove_s a s (antec_set b a s f b1)))))))

;; remove_antecs_spec
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (f uni) (b1 uni))
  (=> (sort b b1)
  (=> (mem b b1 (map1 b a f s))
  (and
  (forall ((e uni))
  (= (mem a e (remove_antecs b a s f b1))
  (and (mem a e s) (not (= (infix_at b a f e) b1)))))
  (< (cardinal a (remove_antecs b a s f b1)) (cardinal a s))))))))

;; map_remove_antec
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (f uni) (b1 uni))
  (=> (mem b b1 (map1 b a f s))
  (= (map1 b a f (remove_antecs b a s f b1)) (remove b b1 (map1 b a f s)))))))

;; map_non_empty
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (=> (< 0 (cardinal a s)) (< 0 (cardinal b (map1 b a f s)))))))

;; non_empty_map
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (=> (< 0 (cardinal b (map1 b a f s))) (< 0 (cardinal a s))))))

(declare-fun right_injections (ty ty uni uni) uni)

;; right_injections_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (set1 (tuple21 a b))
  (right_injections b a x x1)))))

;; right_injections_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((a1 uni) (s uni))
  (ite (is_empty b s) (= (right_injections b a a1 s) (empty (tuple21 a b)))
  (= (right_injections b a a1 s) (add (tuple21 a b)
                                 (Tuple2 a b a1 (choose b s))
                                 (right_injections b a a1
                                 (remove b (choose b s) s))))))))

(declare-fun Tuple2_closure (ty ty) uni)

;; Tuple2_closure_sort
  (assert
  (forall ((a ty) (a1 ty)) (sort
  (infix_mngt a1 (infix_mngt a (tuple21 a1 a))) (Tuple2_closure a1 a))))

;; Tuple2_closure_def
  (assert
  (forall ((a ty) (a1 ty))
  (forall ((y uni) (y1 uni))
  (= (infix_at (tuple21 a1 a) a
     (infix_at (infix_mngt a (tuple21 a1 a)) a1 (Tuple2_closure a1 a) y) y1) 
  (Tuple2 a1 a y y1)))))

;; right_injections_spec
  (assert
  (forall ((a ty) (b ty))
  (forall ((a1 uni) (s uni))
  (=> (sort a a1)
  (and
  (= (cardinal (tuple21 a b) (right_injections b a a1 s)) (cardinal b s))
  (and
  (forall ((aqt uni))
  (=> (sort a aqt)
  (forall ((b1 uni))
  (= (mem (tuple21 a b) (Tuple2 a b aqt b1) (right_injections b a a1 s))
  (and (= aqt a1) (mem b b1 s))))))
  (= (right_injections b a a1 s) (map1 (tuple21 a b) b
                                 (infix_at (infix_mngt b (tuple21 a b)) a
                                 (Tuple2_closure a b) a1) s))))))))

(declare-fun left_injections (ty ty uni uni) uni)

;; left_injections_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (set1 (tuple21 a b))
  (left_injections b a x x1)))))

;; left_injections_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (b1 uni))
  (ite (is_empty a s) (= (left_injections b a s b1) (empty (tuple21 a b)))
  (= (left_injections b a s b1) (add (tuple21 a b)
                                (Tuple2 a b (choose a s) b1)
                                (left_injections b a
                                (remove a (choose a s) s) b1)))))))

(declare-fun fc (ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni)) (sort (infix_mngt a (tuple21 a b)) (fc b a x)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((b1 uni) (a1 uni))
  (= (infix_at (tuple21 a b) a (fc b a b1) a1) (Tuple2 a b a1 b1)))))

;; left_injections_spec
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (b1 uni))
  (=> (sort b b1)
  (and
  (forall ((a1 uni))
  (forall ((bqt uni))
  (=> (sort b bqt)
  (= (mem (tuple21 a b) (Tuple2 a b a1 bqt) (left_injections b a s b1))
  (and (mem a a1 s) (= bqt b1))))))
  (and (= (cardinal (tuple21 a b) (left_injections b a s b1)) (cardinal a s))
  (= (left_injections b a s b1) (map1 (tuple21 a b) a (fc b a b1) s))))))))

;; right_injections_l
  (assert
  (forall ((a ty) (b ty))
  (forall ((a1 uni) (s uni))
  (=> (sort a a1)
  (and
  (= (cardinal (tuple21 a b) (right_injections b a a1 s)) (cardinal b s))
  (and
  (forall ((aqt uni))
  (=> (sort a aqt)
  (forall ((b1 uni))
  (= (mem (tuple21 a b) (Tuple2 a b aqt b1) (right_injections b a a1 s))
  (and (= aqt a1) (mem b b1 s))))))
  (= (right_injections b a a1 s) (map1 (tuple21 a b) b
                                 (infix_at (infix_mngt b (tuple21 a b)) a
                                 (Tuple2_closure a b) a1) s))))))))

(declare-fun fc1 (ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni)) (sort (infix_mngt a (tuple21 a b)) (fc1 b a x)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((b1 uni) (a1 uni))
  (= (infix_at (tuple21 a b) a (fc1 b a b1) a1) (Tuple2 a b a1 b1)))))

;; left_injections_l
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (b1 uni))
  (=> (sort b b1)
  (and
  (forall ((a1 uni))
  (forall ((bqt uni))
  (=> (sort b bqt)
  (= (mem (tuple21 a b) (Tuple2 a b a1 bqt) (left_injections b a s b1))
  (and (mem a a1 s) (= bqt b1))))))
  (and (= (cardinal (tuple21 a b) (left_injections b a s b1)) (cardinal a s))
  (= (left_injections b a s b1) (map1 (tuple21 a b) a (fc1 b a b1) s))))))))

;; disjoint_injections
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (b1 uni) (c uni))
  (=> (sort b b1)
  (=> (sort b c)
  (=> (not (= b1 c))
  (and (is_empty (tuple21 b a)
  (inter (tuple21 b a) (right_injections a b b1 s)
  (right_injections a b c s))) (is_empty (tuple21 a b)
  (inter (tuple21 a b) (left_injections b a s b1) (left_injections b a s c))))))))))

;; induction
  (assert
  (forall ((a ty))
  (forall ((p uni) (t2 uni))
  (=>
  (forall ((s uni))
  (=> (sort (set1 a) s)
  (=> (is_empty a s) (= (tb2t (infix_at bool (set1 a) p s)) true))))
  (=>
  (forall ((s uni))
  (=> (sort (set1 a) s)
  (=> (= (tb2t (infix_at bool (set1 a) p s)) true)
  (forall ((t3 uni))
  (=> (sort a t3)
  (=> (not (mem a t3 s))
  (= (tb2t (infix_at bool (set1 a) p (add a t3 s))) true)))))))
  (= (tb2t (infix_at bool (set1 a) p t2)) true))))))

;; cardinal_sum
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (= (cardinal a (union1 a s sqt)) (- (+ (cardinal a s) (cardinal a sqt)) 
  (cardinal a (inter a s sqt)))))))

;; cardinal_sum_empty_inter
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni))
  (=> (= (inter a s sqt) (empty a))
  (= (cardinal a (union1 a s sqt)) (+ (cardinal a s) (cardinal a sqt)))))))

(declare-fun cartesian_product (ty ty uni uni) uni)

;; cartesian_product_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (set1 (tuple21 a b))
  (cartesian_product b a x x1)))))

;; cartesian_product_spec
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni))
  (and
  (= (cardinal (tuple21 a b) (cartesian_product b a s1 s2)) (* (cardinal a
                                                               s1) (cardinal
                                                                   b s2)))
  (and
  (forall ((a1 uni))
  (forall ((b1 uni))
  (= (mem (tuple21 a b) (Tuple2 a b a1 b1) (cartesian_product b a s1 s2))
  (and (mem a a1 s1) (mem b b1 s2)))))
  (forall ((o uni))
  (= (mem (tuple21 a b) o (cartesian_product b a s1 s2))
  (and (mem a (fir b a o) s1) (mem b (sec b a o) s2)))))))))

(declare-fun commute (ty ty uni) uni)

;; commute_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni)) (sort (tuple21 b a) (commute b a x)))))

;; commute_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((a1 uni) (b1 uni))
  (= (commute b a (Tuple2 a b a1 b1)) (Tuple2 b a b1 a1)))))

;; commute_inj
  (assert
  (forall ((a ty) (b ty))
  (forall ((a1 uni) (aqt uni) (b1 uni) (bqt uni))
  (=> (sort a a1)
  (=> (sort a aqt)
  (=> (sort b b1)
  (=> (sort b bqt)
  (=> (=> (= a1 aqt) (not (= b1 bqt)))
  (not
  (= (commute b a (Tuple2 a b a1 b1)) (commute b a (Tuple2 a b aqt bqt))))))))))))

;; mem_cartesian_product
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni) (a1 uni) (b1 uni))
  (=> (mem a a1 s1)
  (=> (mem b b1 s2) (mem (tuple21 a b) (Tuple2 a b a1 b1)
  (cartesian_product b a s1 s2)))))))

(declare-fun commute_closure (ty ty) uni)

;; commute_closure_sort
  (assert
  (forall ((a ty) (b ty)) (sort (infix_mngt (tuple21 a b) (tuple21 b a))
  (commute_closure b a))))

;; commute_closure_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((y uni))
  (= (infix_at (tuple21 b a) (tuple21 a b) (commute_closure b a) y) (commute
                                                                    b a y)))))

;; commute_inj_gen
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni)) (p_injective (tuple21 b a) (tuple21 a b)
  (commute_closure b a) (cartesian_product b a s1 s2)))))

(declare-fun commute_product (ty ty uni uni) uni)

;; commute_product_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (set1 (tuple21 b a))
  (commute_product b a x x1)))))

;; commute_product_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni))
  (= (commute_product b a s1 s2) (map1 (tuple21 b a) (tuple21 a b)
                                 (commute_closure b a)
                                 (cartesian_product b a s1 s2))))))

;; commute_product_spec
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni))
  (= (commute_product b a s1 s2) (cartesian_product a b s2 s1)))))

(declare-fun commute_product_el (ty ty uni uni) uni)

;; commute_product_el_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (set1 (tuple21 b a))
  (commute_product_el b a x x1)))))

;; commute_product_el_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni))
  (= (commute_product_el b a s1 s2) (map1 (tuple21 b a) (tuple21 a b)
                                    (commute_closure b a)
                                    (cartesian_product b a s1 s2))))))

;; commute_product_el_spec
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni))
  (forall ((a1 uni) (b1 uni))
  (and
  (= (mem (tuple21 a b) (Tuple2 a b a1 b1) (cartesian_product b a s1 s2))
  (and (mem a a1 s1) (mem b b1 s2)))
  (= (and (mem a a1 s1) (mem b b1 s2)) (mem (tuple21 b a) (Tuple2 b a b1 a1)
  (commute_product_el b a s1 s2))))))))

;; cartesian_product_union
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni) (s3 uni))
  (= (cartesian_product b a s1 (union1 b s2 s3)) (union1 (tuple21 a b)
                                                 (cartesian_product b a s1
                                                 s2)
                                                 (cartesian_product b a s1
                                                 s3))))))

;; cartesian_union_product
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni) (s3 uni))
  (= (cartesian_product b a (union1 a s1 s2) s3) (union1 (tuple21 a b)
                                                 (cartesian_product b a s1
                                                 s3)
                                                 (cartesian_product b a s2
                                                 s3))))))

;; cartesian_product_cardone_r
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni))
  (=> (= (cardinal a s1) 1)
  (and (infix_eqeq (tuple21 a b) (cartesian_product b a s1 s2)
  (right_injections b a (choose a s1) s2)) (infix_eqeq (tuple21 a b)
  (cartesian_product b a s1 s2)
  (map1 (tuple21 a b) b
  (infix_at (infix_mngt b (tuple21 a b)) a (Tuple2_closure a b)
  (choose a s1)) s2)))))))

(declare-fun fc2 (ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni)) (sort (infix_mngt a (tuple21 a b)) (fc2 b a x)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s2 uni) (e1 uni))
  (= (infix_at (tuple21 a b) a (fc2 b a s2) e1) (Tuple2 a b e1 (choose b s2))))))

;; cartesian_product_cardone_l
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni))
  (=> (= (cardinal b s2) 1)
  (and (infix_eqeq (tuple21 a b) (cartesian_product b a s1 s2)
  (left_injections b a s1 (choose b s2))) (infix_eqeq (tuple21 a b)
  (cartesian_product b a s1 s2) (map1 (tuple21 a b) a (fc2 b a s2) s1)))))))

;; disjoint_cartesian_product_l
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni) (s3 uni))
  (=> (= (inter a s1 s2) (empty a))
  (= (inter (tuple21 a b) (cartesian_product b a s1 s3)
     (cartesian_product b a s2 s3)) (empty (tuple21 a b)))))))

;; disjoint_cartesian_product_r
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni) (s3 uni))
  (=> (= (inter b s2 s3) (empty b))
  (= (inter (tuple21 a b) (cartesian_product b a s1 s2)
     (cartesian_product b a s1 s3)) (empty (tuple21 a b)))))))

(declare-fun op_neutral_left (ty uni uni) Bool)

;; op_neutral_left_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (neutral uni))
  (= (op_neutral_left im1 op1 neutral)
  (forall ((e uni))
  (=> (sort im1 e)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 neutral) e) e)))))))

(declare-fun op_neutral_right (ty uni uni) Bool)

;; op_neutral_right_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (neutral uni))
  (= (op_neutral_right im1 op1 neutral)
  (forall ((e uni))
  (=> (sort im1 e)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 e) neutral) e)))))))

(declare-fun op_assoc (ty uni) Bool)

;; op_assoc_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni))
  (and
  (=> (op_assoc im1 op1)
  (forall ((a uni) (b uni) (c uni))
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) c) 
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a)
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 b) c)))))
  (=>
  (forall ((a uni) (b uni) (c uni))
  (=> (sort im1 a)
  (=> (sort im1 b)
  (=> (sort im1 c)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) c) 
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a)
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 b) c)))))))
  (op_assoc im1 op1))))))

(declare-fun op_neutral_left_comm (ty uni uni) Bool)

;; op_neutral_left_comm_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (neutral uni))
  (=> (sort im1 neutral)
  (= (op_neutral_left_comm im1 op1 neutral)
  (forall ((a uni))
  (=> (sort im1 a)
  (=>
  (forall ((b uni))
  (=> (sort im1 b)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b) b)))
  (= a neutral)))))))))

(declare-fun commut (ty uni) Bool)

;; commut_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni))
  (and
  (=> (commut im1 op1)
  (forall ((a uni) (b uni))
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b) (infix_at
                                                                    im1 im1
                                                                    (infix_at
                                                                    (infix_mngt
                                                                    im1 im1)
                                                                    im1 op1
                                                                    b) a))))
  (=>
  (forall ((a uni) (b uni))
  (=> (sort im1 a)
  (=> (sort im1 b)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b) (infix_at
                                                                    im1 im1
                                                                    (infix_at
                                                                    (infix_mngt
                                                                    im1 im1)
                                                                    im1 op1
                                                                    b) a)))))
  (commut im1 op1))))))

(declare-fun assoc (ty uni) Bool)

;; assoc_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni))
  (and
  (=> (assoc im1 op1)
  (forall ((a uni) (b uni) (c uni))
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) c) 
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a)
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 b) c)))))
  (=>
  (forall ((a uni) (b uni) (c uni))
  (=> (sort im1 a)
  (=> (sort im1 b)
  (=> (sort im1 c)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) c) 
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a)
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 b) c))))))) (assoc
  im1 op1))))))

(declare-fun opposite_n (ty uni uni uni) Bool)

;; opposite_n_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni) (neutral uni))
  (=> (sort im1 neutral)
  (and
  (=> (opposite_n im1 op1 po1 neutral)
  (forall ((a uni))
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a) a) neutral)))
  (=>
  (forall ((a uni))
  (=> (sort im1 a)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a) a) neutral)))
  (opposite_n im1 op1 po1 neutral)))))))

(declare-fun inverse (ty uni uni uni) Bool)

;; inverse_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni) (inver1 uni))
  (and
  (=> (inverse im1 op1 po1 inver1)
  (forall ((a uni) (b uni))
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a) b) (infix_at
                                                                    im1 im1
                                                                    (infix_at
                                                                    (infix_mngt
                                                                    im1 im1)
                                                                    im1 op1
                                                                    a)
                                                                    (infix_at
                                                                    im1 im1
                                                                    inver1 b)))))
  (=>
  (forall ((a uni) (b uni))
  (=> (sort im1 a)
  (=> (sort im1 b)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a) b) (infix_at
                                                                    im1 im1
                                                                    (infix_at
                                                                    (infix_mngt
                                                                    im1 im1)
                                                                    im1 op1
                                                                    a)
                                                                    (infix_at
                                                                    im1 im1
                                                                    inver1 b))))))
  (inverse im1 op1 po1 inver1))))))

(declare-fun opposite (ty uni uni) Bool)

;; opposite_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni))
  (and
  (=> (opposite im1 op1 po1)
  (forall ((a uni) (b uni))
  (=> (sort im1 a)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a) b)) b) a))))
  (=>
  (forall ((a uni) (b uni))
  (=> (sort im1 a)
  (=> (sort im1 b)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a) b)) b) a))))
  (opposite im1 op1 po1))))))

(declare-fun opposite_com (ty uni uni) Bool)

;; opposite_com_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni))
  (and
  (=> (opposite_com im1 op1 po1)
  (forall ((a uni) (b uni))
  (=> (sort im1 a)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 po1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) b) a))))
  (=>
  (forall ((a uni) (b uni))
  (=> (sort im1 a)
  (=> (sort im1 b)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 po1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) b) a))))
  (opposite_com im1 op1 po1))))))

;; refl
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (a uni) (b uni))
  (=> (commut im1 op1)
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b) (infix_at
                                                                    im1 im1
                                                                    (infix_at
                                                                    (infix_mngt
                                                                    im1 im1)
                                                                    im1 op1
                                                                    b) a))))))

(declare-fun neutral (ty uni uni) Bool)

;; neutral_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (neut uni))
  (= (neutral im1 op1 neut)
  (and (op_neutral_left im1 op1 neut)
  (and (op_neutral_right im1 op1 neut) (op_assoc im1 op1)))))))

;; set_neutral
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (neut uni))
  (=> (op_neutral_left im1 op1 neut)
  (=> (op_neutral_right im1 op1 neut)
  (=> (op_assoc im1 op1) (neutral im1 op1 neut)))))))

(declare-fun has_neutral (ty uni) Bool)

;; has_neutral_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni))
  (and
  (=> (has_neutral im1 op1)
  (exists ((e uni)) (and (sort im1 e) (neutral im1 op1 e))))
  (=> (exists ((e uni)) (neutral im1 op1 e)) (has_neutral im1 op1))))))

(declare-fun iterates (ty uni uni) Bool)

;; iterates_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (neutral1 uni))
  (= (iterates im1 op1 neutral1)
  (and (op_neutral_left im1 op1 neutral1)
  (and (op_neutral_right im1 op1 neutral1) (op_assoc im1 op1)))))))

(declare-fun iterable (ty uni) Bool)

;; iterable_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni))
  (and
  (=> (iterable im1 op1)
  (exists ((e uni)) (and (sort im1 e) (iterates im1 op1 e))))
  (=> (exists ((e uni)) (iterates im1 op1 e)) (iterable im1 op1))))))

;; iterates_
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (neutral1 uni))
  (=> (op_neutral_left im1 op1 neutral1)
  (=> (op_neutral_right im1 op1 neutral1)
  (=> (op_assoc im1 op1)
  (and (iterates im1 op1 neutral1) (iterable im1 op1))))))))

(declare-fun neutral_elt (ty uni) uni)

;; neutral_elt_sort
  (assert
  (forall ((im1 ty)) (forall ((x uni)) (sort im1 (neutral_elt im1 x)))))

;; neutral_elt_spec
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni))
  (forall ((e uni))
  (=> (sort im1 e) (= (neutral im1 op1 e) (= (neutral_elt im1 op1) e)))))))

(declare-fun inverse_tuple (ty uni uni uni) Bool)

;; inverse_tuple_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni) (neutral1 uni))
  (= (inverse_tuple im1 op1 po1 neutral1)
  (and (opposite_n im1 op1 po1 neutral1)
  (and (opposite im1 op1 po1) (opposite_com im1 op1 po1)))))))

(declare-fun iterate (ty ty uni uni uni) uni)

;; iterate_sort
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort im1 (iterate im1 a x x1 x2)))))

;; Iterate_def_empty
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni))
  (forall ((s uni))
  (forall ((f uni))
  (=> (commut im1 op1)
  (=> (iterable im1 op1)
  (=> (is_empty a s)
  (= (iterate im1 a op1 (empty a) f) (neutral_elt im1 op1))))))))))

;; Iterate_add
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni))
  (forall ((s uni))
  (forall ((f uni))
  (forall ((x uni))
  (=> (commut im1 op1)
  (=> (iterable im1 op1)
  (=> (not (mem a x s))
  (= (iterate im1 a op1 (add a x s) f) (infix_at im1 im1
                                       (infix_at (infix_mngt im1 im1) im1 op1
                                       (infix_at im1 a f x))
                                       (iterate im1 a op1 s f))))))))))))

;; minus_zero
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni) (a uni))
  (=> (sort im1 a)
  (=> (iterable im1 op1)
  (=> (inverse_tuple im1 op1 po1 (neutral_elt im1 op1))
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a)
     (neutral_elt im1 op1)) a)))))))

;; unic
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni) (a uni) (b uni) (c uni))
  (=> (sort im1 b)
  (=> (sort im1 c)
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=>
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b) (infix_at
                                                                    im1 im1
                                                                    (infix_at
                                                                    (infix_mngt
                                                                    im1 im1)
                                                                    im1 op1
                                                                    a) c))
  (=> (inverse_tuple im1 op1 po1 (neutral_elt im1 op1)) (= b c))))))))))

;; substract_comm
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (po1 uni) (a uni) (b uni) (c uni))
  (=> (sort im1 b)
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (inverse_tuple im1 op1 po1 (neutral_elt im1 op1))
  (and
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 po1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) a) b)
  (and
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 po1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 b) a)) a) b)
  (and
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a)
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 b) c)) 
  (infix_at im1 im1
  (infix_at (infix_mngt im1 im1) im1 op1
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 a) b)) c))
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 po1
     (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a) b)) c) 
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 op1 a)
  (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 po1 b) c)))))))))))))

(declare-fun int_iterate (ty uni uni Int Int) uni)

;; int_iterate_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 uni) (x2 Int) (x3 Int)) (sort im1
  (int_iterate im1 x x1 x2 x3)))))

(declare-fun t2tb1 (Int) uni)

;; t2tb_sort
  (assert (forall ((x Int)) (sort int (t2tb1 x))))

(declare-fun tb2t1 (uni) Int)

;; BridgeL
  (assert
  (forall ((i Int)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb1 (tb2t1 j)) j) :pattern ((t2tb1 (tb2t1 j))) )))

;; int_iterate_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (iterable im1 op1)
  (ite (<= j i) (= (int_iterate im1 op1 f i j) (neutral_elt im1 op1))
  (= (int_iterate im1 op1 f i j) (infix_at im1 im1
                                 (infix_at (infix_mngt im1 im1) im1 op1
                                 (infix_at im1 int f (t2tb1 i)))
                                 (int_iterate im1 op1 f (+ i 1) j))))))))

;; int_iterate_spec
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (iterable im1 op1)
  (=> (<= j i) (= (int_iterate im1 op1 f i j) (neutral_elt im1 op1)))))))

(declare-fun int_int_iterate (ty uni uni Int Int Int Int) uni)

;; int_int_iterate_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 uni) (x2 Int) (x3 Int) (x4 Int) (x5 Int)) (sort im1
  (int_int_iterate im1 x x1 x2 x3 x4 x5)))))

;; int_int_iterate_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (iterable im1 op1)
  (ite (<= j i) (= (int_int_iterate im1 op1 f i j k l) (neutral_elt im1 op1))
  (= (int_int_iterate im1 op1 f i j k l) (infix_at im1 im1
                                         (infix_at (infix_mngt im1 im1) im1
                                         op1
                                         (int_iterate im1 op1
                                         (infix_at (infix_mngt int im1) 
                                         int f (t2tb1 i)) k l))
                                         (int_int_iterate im1 op1 f (+ i 1) j
                                         k l))))))))

(declare-fun element (ty uni) uni)

;; element_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (element a x)))))

;; element_def
  (assert
  (forall ((a ty))
  (forall ((s uni)) (=> (= (cardinal a s) 1) (= (element a s) (choose a s))))))

;; cardone
  (assert
  (forall ((a ty))
  (forall ((s uni) (a1 uni))
  (=> (sort a a1)
  (=> (forall ((b uni)) (=> (sort a b) (= (mem a b s) (= b a1))))
  (=> (< 0 (cardinal a s)) (and (= (cardinal a s) 1) (= (element a s) a1))))))))

;; set_cardone
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (< 0 (cardinal a s))
  (=>
  (exists ((a1 uni))
  (and (sort a a1)
  (forall ((b uni)) (=> (sort a b) (= (mem a b s) (= b a1))))))
  (= (cardinal a s) 1))))))

;; get_cardone
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (= (cardinal a s) 1)
  (exists ((a1 uni))
  (and (sort a a1)
  (forall ((b uni)) (=> (sort a b) (= (mem a b s) (= b a1))))))))))

;; set_cardone_elt
  (assert
  (forall ((a ty))
  (forall ((s uni) (a1 uni))
  (=> (sort a a1)
  (=> (< 0 (cardinal a s))
  (=> (forall ((b uni)) (=> (sort a b) (= (mem a b s) (= b a1))))
  (and (= (cardinal a s) 1) (= (element a s) a1))))))))

;; cardzero
  (assert
  (forall ((a ty))
  (forall ((s uni))
  (=> (forall ((b uni)) (=> (sort a b) (not (mem a b s))))
  (= (cardinal a s) 0)))))

;; to_set_spec
  (assert
  (forall ((a ty))
  (forall ((e uni))
  (=> (sort a e)
  (and (= (cardinal a (add a e (empty a))) 1)
  (forall ((b uni))
  (=> (sort a b) (=> (mem a b (add a e (empty a))) (= b e)))))))))

(declare-fun to_fset (Int Int) (set Int))

(declare-fun t2tb2 ((set Int)) uni)

;; t2tb_sort
  (assert (forall ((x (set Int))) (sort (set1 int) (t2tb2 x))))

(declare-fun tb2t2 (uni) (set Int))

;; BridgeL
  (assert
  (forall ((i (set Int))) (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb2 (tb2t2 j)) j) :pattern ((t2tb2 (tb2t2 j))) )))

;; to_fset_spec
  (assert
  (forall ((i Int) (j Int))
  (and (=> (< i j) (= (cardinal int (t2tb2 (to_fset i j))) (- j i)))
  (and (=> (<= j i) (is_empty int (t2tb2 (to_fset i j))))
  (forall ((k Int))
  (= (mem int (t2tb1 k) (t2tb2 (to_fset i j))) (and (<= i k) (< k j))))))))

;; to_fset_unit_ext
  (assert
  (forall ((i Int) (j Int))
  (=> (< i j)
  (= (to_fset i j) (tb2t2 (add int (t2tb1 i) (t2tb2 (to_fset (+ i 1) j))))))))

;; to_fset_ext
  (assert
  (forall ((i Int) (iqt Int) (j Int))
  (=> (and (<= i iqt) (<= iqt j))
  (= (to_fset i j) (tb2t2
                   (union1 int (t2tb2 (to_fset i iqt))
                   (t2tb2 (to_fset iqt j))))))))

(declare-fun p_injective_in (ty ty uni uni uni) Bool)

;; p_injective_in_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (and
  (=> (p_injective_in b a f s sqt)
  (forall ((e uni))
  (=> (mem a e s)
  (and (mem b (infix_at b a f e) sqt)
  (forall ((e1 uni) (eqt uni))
  (=> (sort a e1)
  (=> (sort a eqt)
  (=> (mem a e1 s)
  (=> (mem a eqt s)
  (=> (not (= e1 eqt)) (not (= (infix_at b a f e1) (infix_at b a f eqt)))))))))))))
  (=>
  (forall ((e uni))
  (=> (sort a e)
  (=> (mem a e s)
  (and (mem b (infix_at b a f e) sqt)
  (forall ((e1 uni) (eqt uni))
  (=> (sort a e1)
  (=> (sort a eqt)
  (=> (mem a e1 s)
  (=> (mem a eqt s)
  (=> (not (= e1 eqt)) (not (= (infix_at b a f e1) (infix_at b a f eqt)))))))))))))
  (p_injective_in b a f s sqt))))))

(declare-fun equal_func (ty ty uni uni) Bool)

;; equal_func_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (g uni))
  (and
  (=> (equal_func b a f g)
  (forall ((e uni)) (= (infix_at b a f e) (infix_at b a g e))))
  (=>
  (forall ((e uni))
  (=> (sort a e) (= (infix_at b a f e) (infix_at b a g e)))) (equal_func b a
  f g))))))

;; set_equal_func
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (g uni))
  (=> (sort (infix_mngt a b) f)
  (=> (sort (infix_mngt a b) g)
  (=>
  (forall ((e uni))
  (=> (sort a e) (= (infix_at b a f e) (infix_at b a g e)))) (= f g)))))))

;; get_equal_func
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (g uni))
  (=> (equal_func b a f g)
  (forall ((e uni)) (= (infix_at b a f e) (infix_at b a g e)))))))

;; set_injective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (=>
  (forall ((e uni) (eqt uni))
  (=> (sort a e)
  (=> (sort a eqt)
  (=> (mem a e s)
  (=> (mem a eqt s)
  (=> (not (= e eqt)) (not (= (infix_at b a f e) (infix_at b a f eqt)))))))))
  (p_injective b a f s)))))

;; image_spec
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (forall ((a1 uni))
  (=> (sort b a1)
  (and
  (=> (mem b a1 (map1 b a f s))
  (exists ((antec_a uni))
  (and (sort a antec_a)
  (and (mem a antec_a s) (= a1 (infix_at b a f antec_a))))))
  (=>
  (exists ((antec_a uni))
  (and (mem a antec_a s) (= a1 (infix_at b a f antec_a)))) (mem b a1
  (map1 b a f s)))))))))

;; card_image
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni)) (<= (cardinal b (map1 b a f s)) (cardinal a s)))))

;; card_image_injective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (=> (p_injective b a f s) (= (cardinal b (map1 b a f s)) (cardinal a s))))))

;; get_injective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (=> (p_injective b a f s)
  (forall ((e uni) (eqt uni))
  (=> (sort a e)
  (=> (sort a eqt)
  (=> (mem a e s)
  (=> (mem a eqt s)
  (=> (not (= e eqt)) (not (= (infix_at b a f e) (infix_at b a f eqt)))))))))))))

;; set_injective_in
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=>
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (mem b (infix_at b a f e) sqt))))
  (=>
  (forall ((e uni) (eqt uni))
  (=> (sort a e)
  (=> (sort a eqt)
  (=> (mem a e s)
  (=> (mem a eqt s)
  (=> (not (= e eqt)) (not (= (infix_at b a f e) (infix_at b a f eqt)))))))))
  (p_injective b a f s))))))

;; get_injective_in
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (p_injective_in b a f s sqt)
  (and (forall ((e uni)) (=> (mem a e s) (mem b (infix_at b a f e) sqt)))
  (forall ((e uni) (eqt uni))
  (=> (sort a e)
  (=> (sort a eqt)
  (=> (mem a e s)
  (=> (mem a eqt s)
  (=> (not (= e eqt)) (not (= (infix_at b a f e) (infix_at b a f eqt))))))))))))))

(declare-fun p_surjective (ty ty uni uni uni) Bool)

;; p_surjective_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (and
  (=> (p_surjective b a f s sqt)
  (and (forall ((e uni)) (=> (mem a e s) (mem b (infix_at b a f e) sqt)))
  (forall ((eqt uni))
  (=> (sort b eqt)
  (=> (mem b eqt sqt)
  (exists ((e uni))
  (and (sort a e) (and (mem a e s) (= (infix_at b a f e) eqt)))))))))
  (=>
  (and
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (mem b (infix_at b a f e) sqt))))
  (forall ((eqt uni))
  (=> (sort b eqt)
  (=> (mem b eqt sqt)
  (exists ((e uni)) (and (mem a e s) (= (infix_at b a f e) eqt)))))))
  (p_surjective b a f s sqt))))))

;; set_surjective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=>
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (mem b (infix_at b a f e) sqt))))
  (=>
  (forall ((eqt uni))
  (=> (sort b eqt)
  (=> (mem b eqt sqt)
  (exists ((e uni)) (and (mem a e s) (= (infix_at b a f e) eqt))))))
  (p_surjective b a f s sqt))))))

;; get_surjective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (p_surjective b a f s sqt)
  (and (forall ((e uni)) (=> (mem a e s) (mem b (infix_at b a f e) sqt)))
  (forall ((eqt uni))
  (=> (sort b eqt)
  (=> (mem b eqt sqt)
  (exists ((e uni))
  (and (sort a e) (and (mem a e s) (= (infix_at b a f e) eqt))))))))))))

;; image_surjective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (sort (set1 b) sqt)
  (=> (p_surjective b a f s sqt) (= (map1 b a f s) sqt))))))

(declare-fun p_bijective (ty ty uni uni uni) Bool)

;; p_bijective_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (= (p_bijective b a f s sqt)
  (and (p_injective_in b a f s sqt) (p_surjective b a f s sqt))))))

;; bijective_is_injective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (p_bijective b a f s sqt) (p_injective b a f s)))))

;; bijective_is_surjective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (p_bijective b a f s sqt) (p_surjective b a f s sqt)))))

;; set_bijective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (sort (set1 b) sqt)
  (=>
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (mem b (infix_at b a f e) sqt))))
  (=>
  (forall ((e uni) (eqt uni))
  (=> (sort a e)
  (=> (sort a eqt)
  (=> (mem a e s)
  (=> (mem a eqt s)
  (=> (not (= e eqt)) (not (= (infix_at b a f e) (infix_at b a f eqt)))))))))
  (=>
  (forall ((eqt uni))
  (=> (sort b eqt)
  (=> (mem b eqt sqt)
  (exists ((e uni)) (and (mem a e s) (= (infix_at b a f e) eqt))))))
  (and (p_bijective b a f s sqt) (= (map1 b a f s) sqt)))))))))

(declare-fun fc3 (ty ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty) (c ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a c) (fc3 c b a x x1)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty) (c ty))
  (forall ((f uni) (g uni) (k uni))
  (= (infix_at c a (fc3 c b a f g) k) (infix_at c b g (infix_at b a f k))))))

;; bijectivity_is_transitive
  (assert
  (forall ((a ty) (b ty) (c ty))
  (forall ((f uni) (g uni) (s uni) (sqt uni) (sqtqt uni))
  (=> (p_bijective b a f s sqt)
  (=> (p_bijective c b g sqt sqtqt) (p_bijective c a (fc3 c b a f g) s
  sqtqt))))))

;; bijective_image
  (assert
  (forall ((a ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (sort (set1 a) sqt)
  (=> (p_bijective a a f s sqt)
  (and (= (cardinal a s) (cardinal a sqt)) (= sqt (map1 a a f s))))))))

;; get_bijective
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (p_bijective b a f s sqt)
  (and (forall ((e uni)) (=> (mem a e s) (mem b (infix_at b a f e) sqt)))
  (and
  (forall ((e uni) (eqt uni))
  (=> (sort a e)
  (=> (sort a eqt)
  (=> (mem a e s)
  (=> (mem a eqt s)
  (=> (not (= e eqt)) (not (= (infix_at b a f e) (infix_at b a f eqt)))))))))
  (and
  (forall ((eqt uni))
  (=> (sort b eqt)
  (=> (mem b eqt sqt)
  (exists ((e uni))
  (and (sort a e) (and (mem a e s) (= (infix_at b a f e) eqt)))))))
  (= (cardinal a s) (cardinal b sqt)))))))))

;; bijective_eq
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (g uni) (s uni) (sqt uni))
  (=> (p_bijective b a f s sqt)
  (=>
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (= (infix_at b a f e) (infix_at b a g e)))))
  (p_bijective b a g s sqt))))))

;; bijective_eq_gen
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni) (sqt uni))
  (=> (p_bijective b a f s sqt)
  (forall ((g uni))
  (=>
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (= (infix_at b a f e) (infix_at b a g e)))))
  (p_bijective b a g s sqt)))))))

;; bij_equal_card
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (s uni))
  (=> (= (cardinal a s) (cardinal b (map1 b a f s))) (p_bijective b a f s
  (map1 b a f s))))))

;; set_bijective_auto
  (assert
  (forall ((a ty))
  (forall ((f uni) (s uni))
  (=>
  (forall ((e uni))
  (=> (sort a e) (=> (mem a e s) (mem a (infix_at a a f e) s))))
  (=>
  (forall ((eqt uni))
  (=> (sort a eqt)
  (=> (mem a eqt s)
  (exists ((e uni)) (and (mem a e s) (= (infix_at a a f e) eqt))))))
  (p_bijective a a f s s))))))

;; iterate_empty
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (=> (is_empty a s)
  (=> (commut im1 op1)
  (=> (iterable im1 op1) (= (iterate im1 a op1 s t2) (neutral_elt im1 op1))))))))

;; iterate_add
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (f uni) (x uni))
  (=> (commut im1 op1)
  (=> (iterable im1 op1)
  (=> (not (mem a x s))
  (= (iterate im1 a op1 (add a x s) f) (infix_at im1 im1
                                       (infix_at (infix_mngt im1 im1) im1 op1
                                       (infix_at im1 a f x))
                                       (iterate im1 a op1 s f)))))))))

(declare-fun po_closure (ty) uni)

;; po_closure_sort
  (assert
  (forall ((im1 ty)) (sort (infix_mngt im1 (infix_mngt im1 im1))
  (po_closure im1))))

;; po_closure_def
  (assert
  (forall ((im1 ty))
  (forall ((y uni) (y1 uni))
  (= (infix_at im1 im1 (infix_at (infix_mngt im1 im1) im1 (po_closure im1) y)
     y1) (po im1 y y1)))))

;; iterate_remove
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (f uni) (x uni))
  (=> (commut im1 op1)
  (=> (iterable im1 op1)
  (=> (inverse_tuple im1 op1 (po_closure im1) (neutral_elt im1 op1))
  (=> (mem a x s)
  (= (iterate im1 a op1 (remove a x s) f) (po im1 (iterate im1 a op1 s f)
                                          (infix_at im1 a f x))))))))))

;; iterate_def_choose
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (f uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (not (is_empty a s))
  (= (iterate im1 a op1 s f) (infix_at im1 im1
                             (infix_at (infix_mngt im1 im1) im1 op1
                             (infix_at im1 a f (choose a s)))
                             (iterate im1 a op1 (remove a (choose a s) s) f)))))))))

;; choose_any
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (f uni) (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (mem a t2 s)
  (= (iterate im1 a op1 s f) (infix_at im1 im1
                             (infix_at (infix_mngt im1 im1) im1 op1
                             (infix_at im1 a f t2))
                             (iterate im1 a op1 (remove a t2 s) f)))))))))

(declare-fun fc4 (ty ty uni uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (infix_mngt a im1)
  (fc4 im1 a x x1 x2)))))

;; fc_def
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (f uni) (g uni) (k uni))
  (= (infix_at im1 a (fc4 im1 a op1 f g) k) (infix_at im1 im1
                                            (infix_at (infix_mngt im1 im1)
                                            im1 op1 (infix_at im1 a f k))
                                            (infix_at im1 a g k))))))

;; iterate_comp_iterate
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s1 uni) (f uni) (g uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (assoc im1 op1)
  (= (iterate im1 a op1 s1 (fc4 im1 a op1 f g)) (infix_at im1 im1
                                                (infix_at
                                                (infix_mngt im1 im1) im1 op1
                                                (iterate im1 a op1 s1 f))
                                                (iterate im1 a op1 s1 g)))))))))

(declare-fun fc5 (ty ty uni uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (infix_mngt a im1)
  (fc5 im1 a x x1 x2)))))

;; fc_def
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (f uni) (g uni) (k uni))
  (= (infix_at im1 a (fc5 im1 a op1 f g) k) (infix_at im1 im1
                                            (infix_at (infix_mngt im1 im1)
                                            im1 op1 (infix_at im1 a f k))
                                            (infix_at im1 a g k))))))

;; iterate_comp_iterate_com
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s1 uni) (f uni) (g uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1 (iterate im1 a op1 s1 f))
     (iterate im1 a op1 s1 g)) (iterate im1 a op1 s1 (fc5 im1 a op1 f g))))))))

;; iterate_transitivity
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (po1 uni) (s1 uni) (s2 uni) (f uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (inverse_tuple im1 op1 po1 (neutral_elt im1 op1))
  (= (iterate im1 a op1 (union1 a s1 s2) f) (infix_at im1 im1
                                            (infix_at (infix_mngt im1 im1)
                                            im1 po1
                                            (infix_at im1 im1
                                            (infix_at (infix_mngt im1 im1)
                                            im1 op1 (iterate im1 a op1 s1 f))
                                            (iterate im1 a op1 s2 f)))
                                            (iterate im1 a op1
                                            (inter a s1 s2) f)))))))))

;; iterate_disjoint_transitivity
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s1 uni) (s2 uni) (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (= (inter a s1 s2) (empty a))
  (= (iterate im1 a op1 (union1 a s1 s2) t2) (infix_at im1 im1
                                             (infix_at (infix_mngt im1 im1)
                                             im1 op1
                                             (iterate im1 a op1 s1 t2))
                                             (iterate im1 a op1 s2 t2)))))))))

;; iterate_eq
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (f uni) (g uni))
  (=>
  (forall ((x uni))
  (=> (sort a x)
  (=> (mem a x s) (= (infix_at im1 a f x) (infix_at im1 a g x)))))
  (=> (commut im1 op1)
  (=> (iterable im1 op1) (= (iterate im1 a op1 s f) (iterate im1 a op1 s g))))))))

(declare-fun fc6 (ty ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt b im1) (fc6 im1 b a x x1)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((f uni) (t2 uni) (b1 uni))
  (= (infix_at im1 b (fc6 im1 b a f t2) b1) (infix_at im1 a t2
                                            (infix_at a b f b1))))))

;; iterate_map
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((op1 uni) (s uni) (f uni) (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (p_injective a b f s)
  (= (iterate im1 a op1 (map1 a b f s) t2) (iterate im1 b op1 s
                                           (fc6 im1 b a f t2)))))))))

;; iterate_cardone
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (= (cardinal a s) 1)
  (= (iterate im1 a op1 s t2) (infix_at im1 a t2 (element a s)))))))))

;; iterate_cardzero
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (=> (commut im1 op1)
  (=> (iterable im1 op1)
  (=> (= (cardinal a s) 0)
  (= (iterate im1 a op1 s t2) (neutral_elt im1 op1))))))))

(declare-fun fc7 (ty ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((x uni)) (sort (infix_mngt (tuple21 a b) im1) (fc7 im1 b a x)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((f uni) (o uni))
  (= (infix_at im1 (tuple21 a b) (fc7 im1 b a f) o) (infix_at im1 b
                                                    (infix_at
                                                    (infix_mngt b im1) a f
                                                    (fir b a o)) (sec b a o))))))

;; injec_iterate
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((op1 uni) (a1 uni) (s uni) (f uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (= (iterate im1 b op1 s (infix_at (infix_mngt b im1) a f a1)) (iterate im1
                                                                (tuple21 a b)
                                                                op1
                                                                (cartesian_product
                                                                b a
                                                                (add a a1
                                                                (empty a)) s)
                                                                (fc7 im1 b a
                                                                f))))))))

(declare-fun fc8 (ty ty ty uni uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (infix_mngt a im1)
  (fc8 im1 b a x x1 x2)))))

(declare-fun fc9 (ty ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((x uni)) (sort (infix_mngt (tuple21 a b) im1) (fc9 im1 b a x)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((op1 uni) (s2 uni) (f uni) (a1 uni))
  (= (infix_at im1 a (fc8 im1 b a op1 s2 f) a1) (iterate im1 b op1 s2
                                                (infix_at (infix_mngt b im1)
                                                a f a1))))))

;; fc_def
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((f uni) (o uni))
  (= (infix_at im1 (tuple21 a b) (fc9 im1 b a f) o) (infix_at im1 b
                                                    (infix_at
                                                    (infix_mngt b im1) a f
                                                    (fir b a o)) (sec b a o))))))

;; iterate_cartesian_product
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((op1 uni) (s1 uni) (s2 uni) (f uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (= (iterate im1 a op1 s1 (fc8 im1 b a op1 s2 f)) (iterate im1 (tuple21 a b)
                                                   op1
                                                   (cartesian_product b a s1
                                                   s2) (fc9 im1 b a f))))))))

;; iterate_eq_func
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (f1 uni) (f2 uni))
  (=> (commut im1 op1)
  (=> (iterable im1 op1)
  (=> (p_injective im1 a f1 s)
  (=> (p_injective im1 a f2 s)
  (=> (= (map1 im1 a f1 s) (map1 im1 a f2 s))
  (= (iterate im1 a op1 s f1) (iterate im1 a op1 s f2))))))))))

;; int_iterate_def_empty
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (<= j i)
  (=> (iterable im1 op1)
  (= (int_iterate im1 op1 f i j) (neutral_elt im1 op1)))))))

;; int_iterate_def_plus_one
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (< i j)
  (=> (iterable im1 op1)
  (= (int_iterate im1 op1 f i j) (infix_at im1 im1
                                 (infix_at (infix_mngt im1 im1) im1 op1
                                 (infix_at im1 int f (t2tb1 i)))
                                 (int_iterate im1 op1 f (+ i 1) j))))))))

;; int_iterate_cardone
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (= j (+ i 1))
  (=> (iterable im1 op1)
  (= (int_iterate im1 op1 f i j) (infix_at im1 int f (t2tb1 i))))))))

;; int_iterate_def_plus_one_com
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (< i j)
  (=> (iterable im1 op1)
  (= (infix_at im1 im1
     (infix_at (infix_mngt im1 im1) im1 op1 (infix_at im1 int f (t2tb1 i)))
     (int_iterate im1 op1 f (+ i 1) j)) (int_iterate im1 op1 f i j)))))))

;; int_iterate_to_iterate
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (= (int_iterate im1 op1 f i j) (iterate im1 int op1 (t2tb2 (to_fset i j))
                                 f)))))))

;; int_iterate_right_extension
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int))
  (=> (iterable im1 op1)
  (=> (< i j)
  (= (int_iterate im1 op1 f i j) (infix_at im1 im1
                                 (infix_at (infix_mngt im1 im1) im1 op1
                                 (int_iterate im1 op1 f i (- j 1)))
                                 (infix_at im1 int f (t2tb1 (- j 1))))))))))

;; int_iterate_transitivity
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (k Int) (j Int))
  (=> (iterable im1 op1)
  (=> (op_neutral_left im1 op1 (neutral_elt im1 op1))
  (=> (and (<= i k) (<= k j))
  (= (int_iterate im1 op1 f i j) (infix_at im1 im1
                                 (infix_at (infix_mngt im1 im1) im1 op1
                                 (int_iterate im1 op1 f i k))
                                 (int_iterate im1 op1 f k j)))))))))

(declare-fun fc10 (ty uni uni uni) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (infix_mngt int im1)
  (fc10 im1 x x1 x2)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (g uni) (k Int))
  (= (infix_at im1 int (fc10 im1 op1 f g) (t2tb1 k)) (infix_at im1 im1
                                                     (infix_at
                                                     (infix_mngt im1 im1) im1
                                                     op1
                                                     (infix_at im1 int f
                                                     (t2tb1 k)))
                                                     (infix_at im1 int g
                                                     (t2tb1 k)))))))

;; int_iterate_comp_iterate
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (g uni) (i Int) (j Int))
  (=> (iterable im1 op1)
  (=> (op_neutral_right im1 op1 (neutral_elt im1 op1))
  (=> (commut im1 op1)
  (= (int_iterate im1 op1 (fc10 im1 op1 f g) i j) (infix_at im1 im1
                                                  (infix_at
                                                  (infix_mngt im1 im1) im1
                                                  op1
                                                  (int_iterate im1 op1 f i j))
                                                  (int_iterate im1 op1 g i j)))))))))

;; int_iterate_attr_no_f
  (assert
  (forall ((im1 ty) (im2 ty))
  (forall ((op1 uni) (op2 uni) (t11 uni) (t2 uni) (f uni) (i Int) (j Int))
  (=>
  (forall ((x Int))
  (forall ((y uni))
  (=> (sort im1 y)
  (= (infix_at im2 im2
     (infix_at (infix_mngt im2 im2) im2 op2 (infix_at im2 int t2 (t2tb1 x)))
     (infix_at im2 im1 f y)) (infix_at im2 im1 f
                             (infix_at im1 im1
                             (infix_at (infix_mngt im1 im1) im1 op1
                             (infix_at im1 int t11 (t2tb1 x))) y))))))
  (=> (= (infix_at im2 im1 f (neutral_elt im1 op1)) (neutral_elt im2 op2))
  (=> (iterable im1 op1)
  (=> (iterable im2 op2)
  (=>
  (forall ((i1 Int))
  (= (infix_at im2 im1 f (infix_at im1 int t11 (t2tb1 i1))) (infix_at im2 
                                                            int t2
                                                            (t2tb1 i1))))
  (= (int_iterate im2 op2 t2 i j) (infix_at im2 im1 f
                                  (int_iterate im1 op1 t11 i j)))))))))))

(declare-fun fc11 (ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((im1 ty) (im2 ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt int im2) (fc11 im2 im1 x x1)))))

;; fc_def
  (assert
  (forall ((im1 ty) (im2 ty))
  (forall ((t2 uni) (f uni) (e Int))
  (= (infix_at im2 int (fc11 im2 im1 t2 f) (t2tb1 e)) (infix_at im2 im1 f
                                                      (infix_at im1 int t2
                                                      (t2tb1 e)))))))

;; int_iterate_attr
  (assert
  (forall ((im1 ty) (im2 ty))
  (forall ((op1 uni) (op2 uni) (t2 uni) (f uni) (i Int) (j Int))
  (=>
  (forall ((x Int))
  (forall ((y uni))
  (=> (sort im1 y)
  (= (infix_at im2 im2
     (infix_at (infix_mngt im2 im2) im2 op2
     (infix_at im2 im1 f (infix_at im1 int t2 (t2tb1 x))))
     (infix_at im2 im1 f y)) (infix_at im2 im1 f
                             (infix_at im1 im1
                             (infix_at (infix_mngt im1 im1) im1 op1
                             (infix_at im1 int t2 (t2tb1 x))) y))))))
  (=> (= (infix_at im2 im1 f (neutral_elt im1 op1)) (neutral_elt im2 op2))
  (=> (iterable im1 op1)
  (=> (iterable im2 op2)
  (= (int_iterate im2 op2 (fc11 im2 im1 t2 f) i j) (infix_at im2 im1 f
                                                   (int_iterate im1 op1 t2 i
                                                   j))))))))))

(declare-fun fc12 (ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((im1 ty) (im2 ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt int im2) (fc12 im2 im1 x x1)))))

;; fc_def
  (assert
  (forall ((im1 ty) (im2 ty))
  (forall ((t2 uni) (f uni) (e Int))
  (= (infix_at im2 int (fc12 im2 im1 t2 f) (t2tb1 e)) (infix_at im2 im1 f
                                                      (infix_at im1 int t2
                                                      (t2tb1 e)))))))

;; int_iterate_attr_comm
  (assert
  (forall ((im1 ty) (im2 ty))
  (forall ((op1 uni) (op2 uni) (t2 uni) (f uni) (i Int) (j Int))
  (=>
  (forall ((x Int))
  (forall ((y uni))
  (=> (sort im1 y)
  (= (infix_at im2 im2
     (infix_at (infix_mngt im2 im2) im2 op2
     (infix_at im2 im1 f (infix_at im1 int t2 (t2tb1 x))))
     (infix_at im2 im1 f y)) (infix_at im2 im1 f
                             (infix_at im1 im1
                             (infix_at (infix_mngt im1 im1) im1 op1
                             (infix_at im1 int t2 (t2tb1 x))) y))))))
  (=> (= (infix_at im2 im1 f (neutral_elt im1 op1)) (neutral_elt im2 op2))
  (=> (iterable im1 op1)
  (=> (iterable im2 op2)
  (= (infix_at im2 im1 f (int_iterate im1 op1 t2 i j)) (int_iterate im2 op2
                                                       (fc12 im2 im1 t2 f) i
                                                       j)))))))))

;; int_iterate_eq
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (g uni) (i Int) (j Int))
  (=>
  (forall ((k Int))
  (=> (and (<= i k) (< k j))
  (= (infix_at im1 int f (t2tb1 k)) (infix_at im1 int g (t2tb1 k)))))
  (=> (iterable im1 op1)
  (= (int_iterate im1 op1 f i j) (int_iterate im1 op1 g i j)))))))

(declare-fun fc13 (ty uni Int Int) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 Int) (x2 Int)) (sort (infix_mngt int im1)
  (fc13 im1 x x1 x2)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((f uni) (l Int) (h Int) (a Int))
  (= (infix_at im1 int (fc13 im1 f l h) (t2tb1 a)) (infix_at im1 int f
                                                   (t2tb1
                                                   (+ (- h (+ a 1)) l)))))))

;; int_iterate_left_right
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (l Int) (k Int) (h Int))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (and (<= l k) (<= k h))
  (= (int_iterate im1 op1 f l k) (int_iterate im1 op1 (fc13 im1 f l h)
                                 (+ (- h k) l) h))))))))

;; int_iterate_eq_func
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (i Int) (j Int) (f uni) (g uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (p_injective im1 int f (t2tb2 (to_fset i j)))
  (=> (p_injective im1 int g (t2tb2 (to_fset i j)))
  (=>
  (= (map1 im1 int f (t2tb2 (to_fset i j))) (map1 im1 int g
                                            (t2tb2 (to_fset i j))))
  (= (int_iterate im1 op1 f i j) (int_iterate im1 op1 g i j))))))))))

(declare-fun fc14 (ty (Array Int Int) uni) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x (Array Int Int)) (x1 uni)) (sort (infix_mngt int im1)
  (fc14 im1 x x1)))))

(declare-fun t2tb3 ((Array Int Int)) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array Int Int))) (sort (infix_mngt int int) (t2tb3 x))))

(declare-fun tb2t3 (uni) (Array Int Int))

;; BridgeL
  (assert
  (forall ((i (Array Int Int)))
  (! (= (tb2t3 (t2tb3 i)) i) :pattern ((t2tb3 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb3 (tb2t3 j)) j) :pattern ((t2tb3 (tb2t3 j))) )))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((f (Array Int Int)) (t2 uni) (b Int))
  (= (infix_at im1 int (fc14 im1 f t2) (t2tb1 b)) (infix_at im1 int t2
                                                  (infix_at int int (t2tb3 f)
                                                  (t2tb1 b)))))))

;; int_iterate_map
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (i Int) (j Int) (k Int) (l Int) (f (Array Int Int))
  (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (p_bijective int int (t2tb3 f) (t2tb2 (to_fset i j))
  (t2tb2 (to_fset k l)))
  (= (int_iterate im1 op1 t2 k l) (int_iterate im1 op1 (fc14 im1 f t2) i j))))))))

(declare-fun fc15 (ty uni Int) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 Int)) (sort (infix_mngt int im1) (fc15 im1 x x1)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((f uni) (k Int) (b Int))
  (= (infix_at im1 int (fc15 im1 f k) (t2tb1 b)) (infix_at im1 int f
                                                 (t2tb1 (+ b k)))))))

;; int_iterate_transl
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int))
  (=> (iterable im1 op1)
  (= (int_iterate im1 op1 f i j) (int_iterate im1 op1 (fc15 im1 f k) (- i k)
                                 (- j k)))))))

(declare-fun fc16 (ty (Array Int Int) uni) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x (Array Int Int)) (x1 uni)) (sort (infix_mngt int im1)
  (fc16 im1 x x1)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((f (Array Int Int)) (t2 uni) (b Int))
  (= (infix_at im1 int (fc16 im1 f t2) (t2tb1 b)) (infix_at im1 int t2
                                                  (infix_at int int (t2tb3 f)
                                                  (t2tb1 b)))))))

;; int_iterate_map_auto
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (i Int) (j Int) (f (Array Int Int)) (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (p_bijective int int (t2tb3 f) (t2tb2 (to_fset i j))
  (t2tb2 (to_fset i j)))
  (= (int_iterate im1 op1 t2 i j) (int_iterate im1 op1 (fc16 im1 f t2) i j))))))))

(declare-fun nonn_part (ty ty uni uni uni) uni)

;; nonn_part_sort
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (set1 a)
  (nonn_part im1 a x x1 x2)))))

(declare-fun result2 (ty ty uni uni) uni)

;; result_sort
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a bool) (result2 im1 a x x1)))))

;; result_def
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (t2 uni) (e uni))
  (= (= (tb2t (infix_at bool a (result2 im1 a op1 t2) e)) true)
  (not (neutral im1 op1 (infix_at im1 a t2 e)))))))

;; nonn_part_def
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (= (nonn_part im1 a op1 s t2) (filter a (result2 im1 a op1 t2) s)))))

;; nonn_part_spec
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (forall ((e uni))
  (= (mem a e (nonn_part im1 a op1 s t2))
  (and (mem a e s) (not (neutral im1 op1 (infix_at im1 a t2 e)))))))))

(declare-fun n_part (ty ty uni uni uni) uni)

;; n_part_sort
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (set1 a) (n_part im1 a x x1 x2)))))

(declare-fun result3 (ty ty uni uni) uni)

;; result_sort
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a bool) (result3 im1 a x x1)))))

;; result_def
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (t2 uni) (e uni))
  (= (= (tb2t (infix_at bool a (result3 im1 a op1 t2) e)) true) (neutral im1
  op1 (infix_at im1 a t2 e))))))

;; n_part_def
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (= (n_part im1 a op1 s t2) (filter a (result3 im1 a op1 t2) s)))))

;; n_part_spec
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (forall ((e uni))
  (= (mem a e (n_part im1 a op1 s t2))
  (and (mem a e s) (neutral im1 op1 (infix_at im1 a t2 e))))))))

;; nullity_partition
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (=> (sort (set1 a) s)
  (=> (commut im1 op1)
  (and (= s (union1 a (nonn_part im1 a op1 s t2) (n_part im1 a op1 s t2)))
  (= (inter a (nonn_part im1 a op1 s t2) (n_part im1 a op1 s t2)) (empty a))))))))

;; iterate_neutral
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=>
  (forall ((a1 uni))
  (=> (sort a a1)
  (=> (mem a a1 s) (= (infix_at im1 a t2 a1) (neutral_elt im1 op1)))))
  (= (iterate im1 a op1 s t2) (neutral_elt im1 op1))))))))

;; iterate_nullity_partition
  (assert
  (forall ((a ty) (im1 ty))
  (forall ((op1 uni) (s uni) (t2 uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (= (iterate im1 a op1 s t2) (iterate im1 a op1 (nonn_part im1 a op1 s t2)
                              t2)))))))

(declare-fun couple (ty ty ty uni uni) uni)

;; couple_sort
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((x uni) (x1 uni)) (sort im1 (couple im1 b a x x1)))))

;; couple_def
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((f uni))
  (forall ((a1 uni) (b1 uni))
  (= (couple im1 b a f (Tuple2 a b a1 b1)) (infix_at im1 b
                                           (infix_at (infix_mngt b im1) a f
                                           a1) b1))))))

;; null_product
  (assert
  (forall ((a t) (b t))
  (=> (= (infix_asdt a b) tzero) (or (= a tzero) (= b tzero)))))

(declare-fun infix_pldt_closure () (Array t (Array t t)))

(declare-fun t2tb4 ((Array t t)) uni)

;; t2tb_sort
  (assert (forall ((x (Array t t))) (sort (infix_mngt t1 t1) (t2tb4 x))))

(declare-fun tb2t4 (uni) (Array t t))

;; BridgeL
  (assert
  (forall ((i (Array t t)))
  (! (= (tb2t4 (t2tb4 i)) i) :pattern ((t2tb4 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt t1 t1) j) (= (t2tb4 (tb2t4 j)) j)) :pattern (
  (t2tb4 (tb2t4 j))) )))

(declare-fun t2tb5 (t) uni)

;; t2tb_sort
  (assert (forall ((x t)) (sort t1 (t2tb5 x))))

(declare-fun tb2t5 (uni) t)

;; BridgeL
  (assert (forall ((i t)) (! (= (tb2t5 (t2tb5 i)) i) :pattern ((t2tb5 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort t1 j) (= (t2tb5 (tb2t5 j)) j)) :pattern ((t2tb5 (tb2t5 j))) )))

(declare-fun t2tb6 ((Array t (Array t t))) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array t (Array t t)))) (sort
  (infix_mngt t1 (infix_mngt t1 t1)) (t2tb6 x))))

(declare-fun tb2t6 (uni) (Array t (Array t t)))

;; BridgeL
  (assert
  (forall ((i (Array t (Array t t))))
  (! (= (tb2t6 (t2tb6 i)) i) :pattern ((t2tb6 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt t1 (infix_mngt t1 t1)) j) (= (t2tb6 (tb2t6 j)) j)) :pattern (
  (t2tb6 (tb2t6 j))) )))

;; infix +._closure_def
  (assert
  (forall ((y t) (y1 t))
  (= (tb2t5
     (infix_at t1 t1
     (infix_at (infix_mngt t1 t1) t1 (t2tb6 infix_pldt_closure) (t2tb5 y))
     (t2tb5 y1))) (infix_pldt y y1))))

;; neutral_tzero
  (assert
  (and (neutral t1 (t2tb6 infix_pldt_closure) (t2tb5 tzero)) (iterable 
  t1 (t2tb6 infix_pldt_closure))))

(declare-fun sum (ty uni uni) t)

;; sum_def
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (= (sum a s t2) (tb2t5 (iterate t1 a (t2tb6 infix_pldt_closure) s t2))))))

;; sum_empty
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni)) (=> (is_empty a s) (= (sum a s t2) tzero)))))

;; sum_add
  (assert
  (forall ((b ty))
  (forall ((s uni) (f uni) (x uni))
  (=> (not (mem b x s))
  (= (sum b (add b x s) f) (infix_pldt (tb2t5 (infix_at t1 b f x))
                           (sum b s f)))))))

(declare-fun fc17 (ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt b t1) (fc17 b a x x1)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (t2 uni) (b1 uni))
  (= (tb2t5 (infix_at t1 b (fc17 b a f t2) b1)) (tb2t5
                                                (infix_at t1 a t2
                                                (infix_at a b f b1)))))))

;; map_sum_eq
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (f uni) (t2 uni))
  (=> (p_injective a b f s)
  (= (sum a (map1 a b f s) t2) (sum b s (fc17 b a f t2)))))))

(declare-fun fc18 (ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((b ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt b t1) (fc18 b x x1)))))

;; fc_def
  (assert
  (forall ((b ty))
  (forall ((f uni) (g uni) (k uni))
  (= (tb2t5 (infix_at t1 b (fc18 b f g) k)) (infix_pldt
                                            (tb2t5 (infix_at t1 b f k))
                                            (tb2t5 (infix_at t1 b g k)))))))

;; sum_comp
  (assert
  (forall ((b ty))
  (forall ((s uni) (f uni) (g uni))
  (= (sum b s (fc18 b f g)) (infix_pldt (sum b s f) (sum b s g))))))

(declare-fun infix_mndt_closure () (Array t (Array t t)))

;; infix -._closure_def
  (assert
  (forall ((y t) (y1 t))
  (= (tb2t5
     (infix_at t1 t1
     (infix_at (infix_mngt t1 t1) t1 (t2tb6 infix_mndt_closure) (t2tb5 y))
     (t2tb5 y1))) (infix_mndt y y1))))

;; sum_iter_
  (assert
  (and (opposite_n t1 (t2tb6 infix_pldt_closure) (t2tb6 infix_mndt_closure)
  (t2tb5 tzero))
  (and (opposite t1 (t2tb6 infix_pldt_closure) (t2tb6 infix_mndt_closure))
  (and (opposite_com t1 (t2tb6 infix_pldt_closure)
  (t2tb6 infix_mndt_closure)) (inverse_tuple t1 (t2tb6 infix_pldt_closure)
  (t2tb6 infix_mndt_closure) (t2tb5 tzero))))))

;; neutral_zero
  (assert (= (tb2t5 (neutral_elt t1 (t2tb6 infix_pldt_closure))) tzero))

;; sum_eq
  (assert
  (forall ((a ty))
  (forall ((s uni) (f uni) (g uni))
  (=>
  (forall ((x uni))
  (=> (sort a x)
  (=> (mem a x s)
  (= (tb2t5 (infix_at t1 a f x)) (tb2t5 (infix_at t1 a g x))))))
  (= (sum a s f) (sum a s g))))))

;; sum_eq_gen
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni) (f uni) (g uni))
  (=> (= s sqt)
  (=>
  (forall ((x uni))
  (=> (sort a x)
  (=> (mem a x s)
  (= (tb2t5 (infix_at t1 a f x)) (tb2t5 (infix_at t1 a g x))))))
  (= (sum a s f) (sum a sqt g)))))))

;; sum_disjoint_transitivity
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni) (t2 uni))
  (=> (= (inter a s1 s2) (empty a))
  (= (sum a (union1 a s1 s2) t2) (infix_pldt (sum a s1 t2) (sum a s2 t2)))))))

(declare-fun fc19 (ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a t1) (fc19 b a x x1)))))

(declare-fun fc20 (ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni)) (sort (infix_mngt (tuple21 a b) t1) (fc20 b a x)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s2 uni) (f uni) (a1 uni))
  (= (tb2t5 (infix_at t1 a (fc19 b a s2 f) a1)) (sum b s2
                                                (infix_at (infix_mngt b t1) a
                                                f a1))))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (o uni))
  (= (tb2t5 (infix_at t1 (tuple21 a b) (fc20 b a f) o)) (tb2t5
                                                        (infix_at t1 b
                                                        (infix_at
                                                        (infix_mngt b t1) a f
                                                        (fir b a o))
                                                        (sec b a o)))))))

;; sum_to_cartesian_product
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni) (f uni))
  (= (sum a s1 (fc19 b a s2 f)) (sum (tuple21 a b)
                                (cartesian_product b a s1 s2) (fc20 b a f))))))

(declare-fun fc21 (ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni)) (sort (infix_mngt (tuple21 a b) t1) (fc21 b a x)))))

(declare-fun fc22 (ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a t1) (fc22 b a x x1)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (o uni))
  (= (tb2t5 (infix_at t1 (tuple21 a b) (fc21 b a f) o)) (tb2t5
                                                        (infix_at t1 b
                                                        (infix_at
                                                        (infix_mngt b t1) a f
                                                        (fir b a o))
                                                        (sec b a o)))))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((s2 uni) (f uni) (a1 uni))
  (= (tb2t5 (infix_at t1 a (fc22 b a s2 f) a1)) (sum b s2
                                                (infix_at (infix_mngt b t1) a
                                                f a1))))))

;; sum_from_cartesian_product
  (assert
  (forall ((a ty) (b ty))
  (forall ((s1 uni) (s2 uni) (f uni))
  (= (sum (tuple21 a b) (cartesian_product b a s1 s2) (fc21 b a f)) (sum a s1
                                                                    (fc22 b a
                                                                    s2 f))))))

(declare-fun ind_sum ((Array Int t) Int Int) t)

(declare-fun t2tb7 ((Array Int t)) uni)

;; t2tb_sort
  (assert (forall ((x (Array Int t))) (sort (infix_mngt int t1) (t2tb7 x))))

(declare-fun tb2t7 (uni) (Array Int t))

;; BridgeL
  (assert
  (forall ((i (Array Int t)))
  (! (= (tb2t7 (t2tb7 i)) i) :pattern ((t2tb7 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt int t1) j) (= (t2tb7 (tb2t7 j)) j)) :pattern (
  (t2tb7 (tb2t7 j))) )))

;; ind_sum_def
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (= (ind_sum f i j) (tb2t5
                     (int_iterate t1 (t2tb6 infix_pldt_closure) (t2tb7 f) i
                     j)))))

;; ind_sum_to_int_iterate
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (= (ind_sum f i j) (tb2t5
                     (int_iterate t1 (t2tb6 infix_pldt_closure) (t2tb7 f) i
                     j)))))

;; ind_sum_cardone
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (= j (+ i 1))
  (= (ind_sum f i j) (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 i)))))))

;; ind_sum_right_extension
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (< i j)
  (= (ind_sum f i j) (infix_pldt (ind_sum f i (- j 1))
                     (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 (- j 1)))))))))

;; ind_sum_plus_one
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (< i j)
  (= (ind_sum f i j) (infix_pldt
                     (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 i)))
                     (ind_sum f (+ i 1) j))))))

;; ind_sum_eq
  (assert
  (forall ((f (Array Int t)) (g (Array Int t)) (i Int) (j Int))
  (=>
  (forall ((k Int))
  (=> (and (<= i k) (< k j))
  (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 k))) (tb2t5
                                                   (infix_at t1 int (t2tb7 g)
                                                   (t2tb1 k))))))
  (= (ind_sum f i j) (ind_sum g i j)))))

(declare-fun fc23 ((Array Int t) t Int Int) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int t)) (g t) (i Int) (j Int) (k Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc23 f g i j)) (t2tb1 k))) (ite 
                                                                (and (<= i k)
                                                                (< k j))
                                                                (tb2t5
                                                                (infix_at 
                                                                t1 int
                                                                (t2tb7 f)
                                                                (t2tb1 k)))
                                                                g))))

;; ind_sum_eq_del_bound
  (assert
  (forall ((f (Array Int t)) (g t) (i Int) (j Int))
  (= (ind_sum (fc23 f g i j) i j) (ind_sum f i j))))

(declare-fun fc24 ((Array Int t) t Int Int) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int t)) (g t) (i Int) (j Int) (k Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc24 f g i j)) (t2tb1 k))) (ite 
                                                                (and (<= i k)
                                                                (< k j))
                                                                (tb2t5
                                                                (infix_at 
                                                                t1 int
                                                                (t2tb7 f)
                                                                (t2tb1 k)))
                                                                g))))

;; ind_sum_eq_del_bound_rev
  (assert
  (forall ((f (Array Int t)) (g t) (i Int) (j Int))
  (= (ind_sum f i j) (ind_sum (fc24 f g i j) i j))))

;; ind_sum_eq_gen
  (assert
  (forall ((f (Array Int t)) (g (Array Int t)) (i1 Int) (j1 Int) (i2 Int)
  (j2 Int))
  (=> (= i1 i2)
  (=> (= j1 j2)
  (=>
  (forall ((k Int))
  (=> (and (<= i1 k) (< k j1))
  (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 k))) (tb2t5
                                                   (infix_at t1 int (t2tb7 g)
                                                   (t2tb1 k))))))
  (= (ind_sum f i1 j1) (ind_sum g i2 j2)))))))

;; ind_sum_eq_bound
  (assert
  (forall ((f (Array Int t)) (g (Array Int t)) (i Int) (j Int))
  (=> (= i j)
  (=>
  (forall ((k Int))
  (=> (and (<= 0 k) (< k j))
  (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 k))) (tb2t5
                                                   (infix_at t1 int (t2tb7 g)
                                                   (t2tb1 k))))))
  (= (ind_sum f 0 i) (ind_sum g 0 j))))))

(declare-fun fc25 ((Array Int t) (Array Int t)) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int t)) (g (Array Int t)) (k Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc25 f g)) (t2tb1 k))) (infix_pldt
                                                            (tb2t5
                                                            (infix_at 
                                                            t1 int (t2tb7 f)
                                                            (t2tb1 k)))
                                                            (tb2t5
                                                            (infix_at 
                                                            t1 int (t2tb7 g)
                                                            (t2tb1 k)))))))

;; ind_sum_comp
  (assert
  (forall ((f (Array Int t)) (g (Array Int t)) (i Int) (j Int))
  (= (ind_sum (fc25 f g) i j) (infix_pldt (ind_sum f i j) (ind_sum g i j)))))

;; ind_sum_to_iterate
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (= (ind_sum f i j) (tb2t5
                     (iterate t1 int (t2tb6 infix_pldt_closure)
                     (t2tb2 (to_fset i j)) (t2tb7 f))))))

;; ind_sum_to_sum
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (= (ind_sum f i j) (sum int (t2tb2 (to_fset i j)) (t2tb7 f)))))

(declare-fun fc26 ((Array Int Int) (Array Int t)) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int Int)) (t2 (Array Int t)) (b Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc26 f t2)) (t2tb1 b))) (tb2t5
                                                             (infix_at 
                                                             t1 int
                                                             (t2tb7 t2)
                                                             (infix_at 
                                                             int int
                                                             (t2tb3 f)
                                                             (t2tb1 b)))))))

;; map_ind_sum_eq
  (assert
  (forall ((i Int) (j Int) (k Int) (l Int) (f (Array Int Int))
  (t2 (Array Int t)))
  (=> (p_bijective int int (t2tb3 f) (t2tb2 (to_fset i j))
  (t2tb2 (to_fset k l))) (= (ind_sum t2 k l) (ind_sum (fc26 f t2) i j)))))

(declare-fun fc27 (ty uni t) uni)

;; fc_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 t)) (sort (infix_mngt a t1) (fc27 a x x1)))))

;; fc_def
  (assert
  (forall ((a ty))
  (forall ((f uni) (c t) (x uni))
  (= (tb2t5 (infix_at t1 a (fc27 a f c) x)) (infix_asdt c
                                            (tb2t5 (infix_at t1 a f x)))))))

;; sum_scal
  (assert
  (forall ((a ty))
  (forall ((f uni) (s uni) (c t))
  (= (sum a s (fc27 a f c)) (infix_asdt c (sum a s f))))))

(declare-fun fc28 ((Array Int t) t) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int t)) (a t) (i Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc28 f a)) (t2tb1 i))) (infix_asdt a
                                                            (tb2t5
                                                            (infix_at 
                                                            t1 int (t2tb7 f)
                                                            (t2tb1 i)))))))

;; ind_sum_scal
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int) (a t))
  (= (ind_sum (fc28 f a) i j) (infix_asdt a (ind_sum f i j)))))

(declare-fun fc29 ((Array Int t) t) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int t)) (a t) (i Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc29 f a)) (t2tb1 i))) (infix_asdt a
                                                            (tb2t5
                                                            (infix_at 
                                                            t1 int (t2tb7 f)
                                                            (t2tb1 i)))))))

;; ind_sum_scal_rev
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int) (a t))
  (= (infix_asdt a (ind_sum f i j)) (ind_sum (fc29 f a) i j))))

(declare-fun fc30 ((Array Int t) t) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int t)) (a t) (i Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc30 f a)) (t2tb1 i))) (infix_asdt a
                                                            (tb2t5
                                                            (infix_at 
                                                            t1 int (t2tb7 f)
                                                            (t2tb1 i)))))))

;; sum_scal_gen
  (assert
  (forall ((f (Array Int t)) (s (set Int)))
  (forall ((a t))
  (= (sum int (t2tb2 s) (t2tb7 (fc30 f a))) (infix_asdt a
                                            (sum int (t2tb2 s) (t2tb7 f)))))))

(declare-fun fc31 ((Array Int t) t) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int t)) (a t) (i Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc31 f a)) (t2tb1 i))) (infix_asdt a
                                                            (tb2t5
                                                            (infix_at 
                                                            t1 int (t2tb7 f)
                                                            (t2tb1 i)))))))

;; ind_sum_scal_gen
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (forall ((a t))
  (= (ind_sum (fc31 f a) i j) (infix_asdt a (ind_sum f i j))))))

;; int_int_iterate_def_empty
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (<= j i)
  (=> (iterable im1 op1)
  (= (int_int_iterate im1 op1 f i j k l) (neutral_elt im1 op1)))))))

;; int_int_iterate_def_plus_one
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (< i j)
  (=> (iterable im1 op1)
  (= (int_int_iterate im1 op1 f i j k l) (infix_at im1 im1
                                         (infix_at (infix_mngt im1 im1) im1
                                         op1
                                         (int_iterate im1 op1
                                         (infix_at (infix_mngt int im1) 
                                         int f (t2tb1 i)) k l))
                                         (int_int_iterate im1 op1 f (+ i 1) j
                                         k l))))))))

(declare-fun fc32 (ty uni uni Int Int) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 uni) (x2 Int) (x3 Int)) (sort (infix_mngt int im1)
  (fc32 im1 x x1 x2 x3)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (k Int) (l Int) (a Int))
  (= (infix_at im1 int (fc32 im1 op1 f k l) (t2tb1 a)) (int_iterate im1 op1
                                                       (infix_at
                                                       (infix_mngt int im1)
                                                       int f (t2tb1 a)) k l)))))

;; int_int_iterate_to_int_iterate
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (<= i j)
  (=> (iterable im1 op1)
  (= (int_int_iterate im1 op1 f i j k l) (int_iterate im1 op1
                                         (fc32 im1 op1 f k l) i j)))))))

(declare-fun fc33 (ty uni uni Int Int) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 uni) (x2 Int) (x3 Int)) (sort (infix_mngt int im1)
  (fc33 im1 x x1 x2 x3)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (k Int) (l Int) (a Int))
  (= (infix_at im1 int (fc33 im1 op1 f k l) (t2tb1 a)) (int_iterate im1 op1
                                                       (infix_at
                                                       (infix_mngt int im1)
                                                       int f (t2tb1 a)) k l)))))

;; int_iterate_to_int_int_iterate
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (<= i j)
  (=> (iterable im1 op1)
  (= (int_iterate im1 op1 (fc33 im1 op1 f k l) i j) (int_int_iterate im1 op1
                                                    f i j k l)))))))

(declare-fun fc34 (ty uni) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni)) (sort (infix_mngt (tuple21 int int) im1) (fc34 im1 x)))))

(declare-fun t2tb8 ((tuple2 Int Int)) uni)

;; t2tb_sort
  (assert (forall ((x (tuple2 Int Int))) (sort (tuple21 int int) (t2tb8 x))))

(declare-fun tb2t8 (uni) (tuple2 Int Int))

;; BridgeL
  (assert
  (forall ((i (tuple2 Int Int)))
  (! (= (tb2t8 (t2tb8 i)) i) :pattern ((t2tb8 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb8 (tb2t8 j)) j) :pattern ((t2tb8 (tb2t8 j))) )))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((f uni) (o (tuple2 Int Int)))
  (= (infix_at im1 (tuple21 int int) (fc34 im1 f) (t2tb8 o)) (infix_at im1
                                                             int
                                                             (infix_at
                                                             (infix_mngt 
                                                             int im1) 
                                                             int f
                                                             (fir int 
                                                             int (t2tb8 o)))
                                                             (sec int 
                                                             int (t2tb8 o)))))))

(declare-fun t2tb9 ((set (tuple2 Int Int))) uni)

;; t2tb_sort
  (assert
  (forall ((x (set (tuple2 Int Int)))) (sort (set1 (tuple21 int int))
  (t2tb9 x))))

(declare-fun tb2t9 (uni) (set (tuple2 Int Int)))

;; BridgeL
  (assert
  (forall ((i (set (tuple2 Int Int))))
  (! (= (tb2t9 (t2tb9 i)) i) :pattern ((t2tb9 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb9 (tb2t9 j)) j) :pattern ((t2tb9 (tb2t9 j))) )))

;; int_int_iterate_to_iterate
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (<= i j)
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (= (int_int_iterate im1 op1 f i j k l) (iterate im1 (tuple21 int int) op1
                                         (cartesian_product int int
                                         (t2tb2 (to_fset i j))
                                         (t2tb2 (to_fset k l))) (fc34 im1 f)))))))))

(declare-fun fc35 (ty ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((x uni)) (sort (infix_mngt (tuple21 a b) im1) (fc35 im1 b a x)))))

(declare-fun fc36 (ty ty ty uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((x uni)) (sort (infix_mngt (tuple21 b a) im1) (fc36 im1 b a x)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((f uni) (o uni))
  (= (infix_at im1 (tuple21 a b) (fc35 im1 b a f) o) (infix_at im1 b
                                                     (infix_at
                                                     (infix_mngt b im1) a f
                                                     (fir b a o))
                                                     (sec b a o))))))

;; fc_def
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((f uni) (o uni))
  (= (infix_at im1 (tuple21 b a) (fc36 im1 b a f) o) (infix_at im1 b
                                                     (infix_at
                                                     (infix_mngt b im1) a f
                                                     (sec a b o))
                                                     (fir a b o))))))

;; iterate_commute
  (assert
  (forall ((a ty) (b ty) (im1 ty))
  (forall ((op1 uni) (s1 uni) (s2 uni) (f uni))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (= (iterate im1 (tuple21 a b) op1 (cartesian_product b a s1 s2)
     (fc35 im1 b a f)) (iterate im1 (tuple21 b a) op1
                       (cartesian_product a b s2 s1) (fc36 im1 b a f))))))))

(declare-fun fc37 (ty uni) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni)) (sort (infix_mngt int (infix_mngt int im1))
  (fc37 im1 x)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((f uni) (a Int) (b Int))
  (= (infix_at im1 int
     (infix_at (infix_mngt int im1) int (fc37 im1 f) (t2tb1 a)) (t2tb1 b)) 
  (infix_at im1 int (infix_at (infix_mngt int im1) int f (t2tb1 b))
  (t2tb1 a))))))

;; int_int_iterate_commute
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (<= i j)
  (=> (<= k l)
  (= (int_int_iterate im1 op1 f i j k l) (int_int_iterate im1 op1
                                         (fc37 im1 f) k l i j)))))))))

(declare-fun fc38 (ty uni uni Int Int) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 uni) (x2 Int) (x3 Int)) (sort (infix_mngt int im1)
  (fc38 im1 x x1 x2 x3)))))

(declare-fun fc39 (ty uni Int) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 Int)) (sort (infix_mngt int im1) (fc39 im1 x x1)))))

(declare-fun fc40 (ty uni uni Int Int) uni)

;; fc_sort
  (assert
  (forall ((im1 ty))
  (forall ((x uni) (x1 uni) (x2 Int) (x3 Int)) (sort (infix_mngt int im1)
  (fc40 im1 x x1 x2 x3)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (k Int) (l Int) (a Int))
  (= (infix_at im1 int (fc38 im1 op1 f k l) (t2tb1 a)) (int_iterate im1 op1
                                                       (infix_at
                                                       (infix_mngt int im1)
                                                       int f (t2tb1 a)) k l)))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((f uni) (a Int) (b Int))
  (= (infix_at im1 int (fc39 im1 f a) (t2tb1 b)) (infix_at im1 int
                                                 (infix_at
                                                 (infix_mngt int im1) 
                                                 int f (t2tb1 b)) (t2tb1 a))))))

;; fc_def
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (a Int))
  (= (infix_at im1 int (fc40 im1 op1 f i j) (t2tb1 a)) (int_iterate im1 op1
                                                       (fc39 im1 f a) i j)))))

;; int_iterate_commute
  (assert
  (forall ((im1 ty))
  (forall ((op1 uni) (f uni) (i Int) (j Int) (k Int) (l Int))
  (=> (iterable im1 op1)
  (=> (commut im1 op1)
  (=> (<= i j)
  (=> (<= k l)
  (= (int_iterate im1 op1 (fc38 im1 op1 f k l) i j) (int_iterate im1 op1
                                                    (fc40 im1 op1 f i j) k l)))))))))

(declare-fun fc41 ((Array Int (Array Int t)) Int Int) (Array Int t))

(declare-fun fc42 ((Array Int (Array Int t)) Int) (Array Int t))

(declare-fun fc43 ((Array Int (Array Int t)) Int Int) (Array Int t))

(declare-fun t2tb10 ((Array Int (Array Int t))) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array Int (Array Int t)))) (sort
  (infix_mngt int (infix_mngt int t1)) (t2tb10 x))))

(declare-fun tb2t10 (uni) (Array Int (Array Int t)))

;; BridgeL
  (assert
  (forall ((i (Array Int (Array Int t))))
  (! (= (tb2t10 (t2tb10 i)) i) :pattern ((t2tb10 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt int (infix_mngt int t1)) j)
     (= (t2tb10 (tb2t10 j)) j)) :pattern ((t2tb10 (tb2t10 j))) )))

;; fc_def
  (assert
  (forall ((f (Array Int (Array Int t))) (k Int) (l Int) (k1 Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc41 f k l)) (t2tb1 k1))) (ind_sum
                                                               (tb2t7
                                                               (infix_at
                                                               (infix_mngt
                                                               int t1) 
                                                               int (t2tb10 f)
                                                               (t2tb1 k1))) k
                                                               l))))

;; fc_def
  (assert
  (forall ((f (Array Int (Array Int t))) (k1 Int) (k2 Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc42 f k1)) (t2tb1 k2))) (tb2t5
                                                              (infix_at 
                                                              t1 int
                                                              (infix_at
                                                              (infix_mngt 
                                                              int t1) 
                                                              int (t2tb10 f)
                                                              (t2tb1 k2))
                                                              (t2tb1 k1))))))

;; fc_def
  (assert
  (forall ((f (Array Int (Array Int t))) (i Int) (j Int) (k1 Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc43 f i j)) (t2tb1 k1))) (ind_sum
                                                               (fc42 f k1) i
                                                               j))))

;; ind_sum_commute
  (assert
  (forall ((f (Array Int (Array Int t))) (i Int) (j Int) (k Int) (l Int))
  (=> (<= i j)
  (=> (<= k l) (= (ind_sum (fc41 f k l) i j) (ind_sum (fc43 f i j) k l))))))

(declare-fun non_tzero (ty uni uni) uni)

;; non_tzero_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (set1 a) (non_tzero a x x1)))))

;; non_tzero_def
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (= (non_tzero a s t2) (nonn_part t1 a (t2tb6 infix_pldt_closure) s t2)))))

;; non_tzero_spec
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (forall ((e uni))
  (= (mem a e (non_tzero a s t2))
  (and (mem a e s) (not (= (tb2t5 (infix_at t1 a t2 e)) tzero))))))))

;; get_non_tzero_member
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni) (e uni))
  (=> (mem a e (non_tzero a s t2))
  (and (mem a e s) (not (= (tb2t5 (infix_at t1 a t2 e)) tzero)))))))

;; set_non_tzero_member
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni) (e uni))
  (=> (mem a e s)
  (=> (not (= (tb2t5 (infix_at t1 a t2 e)) tzero)) (mem a e
  (non_tzero a s t2)))))))

;; set_non_tzero_member_gen
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (forall ((e uni))
  (=> (and (mem a e s) (not (= (tb2t5 (infix_at t1 a t2 e)) tzero))) (mem a e
  (non_tzero a s t2)))))))

;; set_non_tzero_member_gen_
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (forall ((e uni))
  (=> (and (mem a e s) (not (= (tb2t5 (infix_at t1 a t2 e)) tzero))) (mem a e
  (non_tzero a s t2)))))))

;; sum_nullity_partition
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni)) (= (sum a s t2) (sum a (non_tzero a s t2) t2)))))

(declare-fun fc44 (ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a t1) (fc44 a x x1)))))

;; fc_def
  (assert
  (forall ((a ty))
  (forall ((f uni) (t2 uni) (b uni))
  (= (tb2t5 (infix_at t1 a (fc44 a f t2) b)) (tb2t5
                                             (infix_at t1 a t2
                                             (infix_at a a f b)))))))

;; non_null_map
  (assert
  (forall ((a ty))
  (forall ((s uni) (f uni) (t2 uni))
  (= (non_tzero a (map1 a a f s) t2) (map1 a a f
                                     (non_tzero a s (fc44 a f t2)))))))

(declare-fun fc45 (ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a t1) (fc45 a x x1)))))

(declare-fun fc46 (ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a t1) (fc46 a x x1)))))

(declare-fun fc47 (ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt a t1) (fc47 a x x1)))))

;; fc_def
  (assert
  (forall ((a ty))
  (forall ((f uni) (t2 uni) (b uni))
  (= (tb2t5 (infix_at t1 a (fc45 a f t2) b)) (tb2t5
                                             (infix_at t1 a t2
                                             (infix_at a a f b)))))))

;; fc_def
  (assert
  (forall ((a ty))
  (forall ((f uni) (t2 uni) (b uni))
  (= (tb2t5 (infix_at t1 a (fc46 a f t2) b)) (tb2t5
                                             (infix_at t1 a t2
                                             (infix_at a a f b)))))))

;; fc_def
  (assert
  (forall ((a ty))
  (forall ((f uni) (t2 uni) (b uni))
  (= (tb2t5 (infix_at t1 a (fc47 a f t2) b)) (tb2t5
                                             (infix_at t1 a t2
                                             (infix_at a a f b)))))))

;; map_sum_eq_nonnull
  (assert
  (forall ((a ty))
  (forall ((s uni) (f uni) (t2 uni))
  (=> (p_bijective a a f (non_tzero a s (fc45 a f t2))
  (non_tzero a (map1 a a f s) t2))
  (= (sum a (non_tzero a (map1 a a f s) t2) t2) (sum a
                                                (non_tzero a s (fc46 a f t2))
                                                (fc47 a f t2)))))))

;; sum_null_but_one
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (=> (= (cardinal a (non_tzero a s t2)) 1)
  (= (sum a s t2) (tb2t5 (infix_at t1 a t2 (element a (non_tzero a s t2)))))))))

;; sum_null
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (=> (= (cardinal a (non_tzero a s t2)) 0) (= (sum a s t2) tzero)))))

;; ind_sum_null
  (assert
  (forall ((t2 (Array Int t)) (i Int) (j Int))
  (=>
  (forall ((k Int))
  (=> (and (<= i k) (< k j))
  (= (tb2t5 (infix_at t1 int (t2tb7 t2) (t2tb1 k))) tzero)))
  (= (ind_sum t2 i j) tzero))))

;; sum_null_but_one_elt
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni) (elt uni))
  (=> (and (mem a elt s) (not (= (tb2t5 (infix_at t1 a t2 elt)) tzero)))
  (=>
  (forall ((a1 uni))
  (=> (sort a a1)
  (=> (mem a a1 s)
  (=> (not (= a1 elt)) (= (tb2t5 (infix_at t1 a t2 a1)) tzero)))))
  (= (sum a s t2) (tb2t5 (infix_at t1 a t2 elt))))))))

;; sum_null_but_maybe_one_elt
  (assert
  (forall ((a ty))
  (forall ((t2 uni) (s uni) (elt uni))
  (=> (mem a elt s)
  (=>
  (forall ((k uni))
  (=> (sort a k)
  (=> (mem a k s)
  (=> (not (= k elt)) (= (tb2t5 (infix_at t1 a t2 k)) tzero)))))
  (= (sum a s t2) (tb2t5 (infix_at t1 a t2 elt))))))))

;; ind_sum_null_but_maybe_one_elt
  (assert
  (forall ((t2 (Array Int t)) (i Int) (j Int) (ind Int))
  (=> (and (<= i ind) (< ind j))
  (=>
  (forall ((k Int))
  (=> (and (<= i k) (< k j))
  (=> (not (= k ind))
  (= (tb2t5 (infix_at t1 int (t2tb7 t2) (t2tb1 k))) tzero))))
  (= (ind_sum t2 i j) (tb2t5 (infix_at t1 int (t2tb7 t2) (t2tb1 ind))))))))

(declare-fun infix_asdt_closure () (Array t (Array t t)))

;; infix *._closure_def
  (assert
  (forall ((y t) (y1 t))
  (= (tb2t5
     (infix_at t1 t1
     (infix_at (infix_mngt t1 t1) t1 (t2tb6 infix_asdt_closure) (t2tb5 y))
     (t2tb5 y1))) (infix_asdt y y1))))

;; neutral_tone
  (assert
  (and (neutral t1 (t2tb6 infix_asdt_closure) (t2tb5 tone)) (iterable 
  t1 (t2tb6 infix_asdt_closure))))

;; product_iter
  (assert
  (and (op_neutral_left t1 (t2tb6 infix_asdt_closure) (t2tb5 tone))
  (and
  (and (op_neutral_right t1 (t2tb6 infix_asdt_closure) (t2tb5 tone))
  (op_assoc t1 (t2tb6 infix_asdt_closure)))
  (and (commut t1 (t2tb6 infix_asdt_closure)) (iterates t1
  (t2tb6 infix_asdt_closure) (t2tb5 tone))))))

(declare-fun product (ty uni uni) t)

;; product_def
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni))
  (= (product a s t2) (tb2t5 (iterate t1 a (t2tb6 infix_asdt_closure) s t2))))))

;; product_eq
  (assert
  (forall ((a ty))
  (forall ((s uni) (t2 uni) (tqt uni))
  (=>
  (forall ((e uni))
  (=> (sort a e)
  (=> (mem a e s)
  (= (tb2t5 (infix_at t1 a t2 e)) (tb2t5 (infix_at t1 a tqt e))))))
  (= (product a s t2) (product a s tqt))))))

;; product_eq_gen
  (assert
  (forall ((a ty))
  (forall ((s uni) (sqt uni) (t2 uni) (tqt uni))
  (=> (= s sqt)
  (=>
  (forall ((e uni))
  (=> (sort a e)
  (=> (mem a e s)
  (= (tb2t5 (infix_at t1 a t2 e)) (tb2t5 (infix_at t1 a tqt e))))))
  (= (product a s t2) (product a sqt tqt)))))))

;; product_empty
  (assert
  (forall ((a ty))
  (forall ((s uni) (f uni)) (=> (is_empty a s) (= (product a s f) tone)))))

;; product_iter_
  (assert (iterable t1 (t2tb6 infix_asdt_closure)))

;; add_product
  (assert
  (forall ((a ty))
  (forall ((s uni) (f uni) (x uni))
  (=> (not (mem a x s))
  (= (product a (add a x s) f) (infix_asdt (tb2t5 (infix_at t1 a f x))
                               (product a s f)))))))

;; product_add
  (assert
  (forall ((a ty))
  (forall ((s uni) (f uni) (x uni))
  (=> (not (mem a x s))
  (= (product a (add a x s) f) (infix_asdt (product a s f)
                               (tb2t5 (infix_at t1 a f x))))))))

;; neutral_one
  (assert (= (tb2t5 (neutral_elt t1 (t2tb6 infix_asdt_closure))) tone))

(declare-fun ind_product ((Array Int t) Int Int) t)

;; ind_product_def
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (= (ind_product f i j) (tb2t5
                         (int_iterate t1 (t2tb6 infix_asdt_closure) (t2tb7 f)
                         i j)))))

;; ind_product_eq
  (assert
  (forall ((f (Array Int t)) (g (Array Int t)) (i Int) (j Int))
  (=>
  (forall ((k Int))
  (=> (and (<= i k) (< k j))
  (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 k))) (tb2t5
                                                   (infix_at t1 int (t2tb7 g)
                                                   (t2tb1 k))))))
  (= (ind_product f i j) (ind_product g i j)))))

;; ind_product_eq_gen
  (assert
  (forall ((f (Array Int t)) (g (Array Int t)) (i1 Int) (j1 Int) (i2 Int)
  (j2 Int))
  (=>
  (forall ((k Int))
  (=> (and (<= i1 k) (< k j1))
  (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 k))) (tb2t5
                                                   (infix_at t1 int (t2tb7 g)
                                                   (t2tb1 k))))))
  (=> (= i1 i2)
  (=> (= j1 j2) (= (ind_product f i1 j1) (ind_product g i2 j2)))))))

;; ind_product_right_extension
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (< i j)
  (= (ind_product f i j) (infix_asdt (ind_product f i (- j 1))
                         (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 (- j 1)))))))))

;; ind_product_left_extension
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (< i j)
  (= (ind_product f i j) (infix_asdt
                         (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 i)))
                         (ind_product f (+ i 1) j))))))

;; ind_product_to_product
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (= (ind_product f i j) (product int (t2tb2 (to_fset i j)) (t2tb7 f)))))

(declare-fun fc48 (ty ty uni uni) uni)

;; fc_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort (infix_mngt b t1) (fc48 b a x x1)))))

;; fc_def
  (assert
  (forall ((a ty) (b ty))
  (forall ((f uni) (t2 uni) (b1 uni))
  (= (tb2t5 (infix_at t1 b (fc48 b a f t2) b1)) (tb2t5
                                                (infix_at t1 a t2
                                                (infix_at a b f b1)))))))

;; map_product_eq
  (assert
  (forall ((a ty) (b ty))
  (forall ((s uni) (f uni) (t2 uni))
  (=> (p_injective a b f s)
  (= (product a (map1 a b f s) t2) (product b s (fc48 b a f t2)))))))

(declare-fun fc49 ((Array Int Int) (Array Int t)) (Array Int t))

;; fc_def
  (assert
  (forall ((f (Array Int Int)) (t2 (Array Int t)) (b Int))
  (= (tb2t5 (infix_at t1 int (t2tb7 (fc49 f t2)) (t2tb1 b))) (tb2t5
                                                             (infix_at 
                                                             t1 int
                                                             (t2tb7 t2)
                                                             (infix_at 
                                                             int int
                                                             (t2tb3 f)
                                                             (t2tb1 b)))))))

;; map_ind_product_eq
  (assert
  (forall ((i Int) (j Int) (k Int) (l Int) (f (Array Int Int))
  (t2 (Array Int t)))
  (=> (p_bijective int int (t2tb3 f) (t2tb2 (to_fset i j))
  (t2tb2 (to_fset k l)))
  (= (ind_product t2 k l) (ind_product (fc49 f t2) i j)))))

;; ind_product_right_extension_comm
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (< i j)
  (= (infix_asdt (ind_product f i (- j 1))
     (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 (- j 1))))) (ind_product f i j)))))

(declare-fun t2tb11 ((set t)) uni)

;; t2tb_sort
  (assert (forall ((x (set t))) (sort (set1 t1) (t2tb11 x))))

(declare-fun tb2t11 (uni) (set t))

;; BridgeL
  (assert
  (forall ((i (set t))) (! (= (tb2t11 (t2tb11 i)) i) :pattern ((t2tb11 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (set1 t1) j) (= (t2tb11 (tb2t11 j)) j)) :pattern ((t2tb11
                                                                 (tb2t11 j))) )))

;; ind_product_eq_func
  (assert
  (forall ((i Int) (j Int) (f1 (Array Int t)) (f2 (Array Int t)))
  (=> (p_injective t1 int (t2tb7 f1) (t2tb2 (to_fset i j)))
  (=> (p_injective t1 int (t2tb7 f2) (t2tb2 (to_fset i j)))
  (=>
  (= (tb2t11 (map1 t1 int (t2tb7 f1) (t2tb2 (to_fset i j)))) (tb2t11
                                                             (map1 t1 
                                                             int (t2tb7 f2)
                                                             (t2tb2
                                                             (to_fset i j)))))
  (= (ind_product f1 i j) (ind_product f2 i j)))))))

;; ind_product_trans
  (assert
  (forall ((f (Array Int t)) (i Int) (k Int) (j Int))
  (=> (and (<= i k) (<= k j))
  (= (ind_product f i j) (infix_asdt (ind_product f i k) (ind_product f k j))))))

;; ind_product_zero_pre
  (assert
  (forall ((f (Array Int t)) (i Int) (t2 Int) (j Int))
  (=> (and (<= i t2) (< t2 j))
  (=> (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 t2))) tzero)
  (= (ind_product f i j) tzero)))))

;; ind_product_zero
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (<= i j)
  (=>
  (exists ((t2 Int))
  (and (and (<= i t2) (< t2 j))
  (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 t2))) tzero)))
  (= (ind_product f i j) tzero)))))

;; ind_product_zero_elt
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int) (t2 Int))
  (=> (<= i j)
  (=> (and (<= i t2) (< t2 j))
  (=> (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 t2))) tzero)
  (= (ind_product f i j) tzero))))))

;; ind_product_const_tone
  (assert
  (forall ((f (Array Int t)) (i Int) (j Int))
  (=> (<= i j)
  (=>
  (forall ((t2 Int))
  (=> (and (<= i t2) (< t2 j))
  (= (tb2t5 (infix_at t1 int (t2tb7 f) (t2tb1 t2))) tone)))
  (= (ind_product f i j) tone)))))

(declare-fun antisym (ty uni) Bool)

;; antisym_def
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (= (antisym a rel)
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) a1)) true)
  (= a1 b))))))))))

(declare-fun transitive (ty uni) Bool)

;; transitive_def
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (and
  (=> (transitive a rel)
  (forall ((a1 uni) (b uni) (c uni))
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) c)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) c)) true)))))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=> (sort a c)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) c)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) c)) true)))))))
  (transitive a rel))))))

(declare-fun reflexive (ty uni) Bool)

;; reflexive_def
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (and
  (=> (reflexive a rel)
  (forall ((a1 uni))
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) a1)) true)))
  (=>
  (forall ((a1 uni))
  (=> (sort a a1)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) a1)) true)))
  (reflexive a rel))))))

(declare-fun pre_order (ty uni) Bool)

;; pre_order_def
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (= (pre_order a rel) (and (transitive a rel) (reflexive a rel))))))

(declare-fun partial_order (ty uni) Bool)

;; partial_order_def
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (= (partial_order a rel) (and (antisym a rel) (pre_order a rel))))))

(declare-fun recip (ty uni uni) Bool)

;; recip_def
  (assert
  (forall ((a ty))
  (forall ((rrel uni) (rel uni))
  (and
  (=> (recip a rrel rel)
  (forall ((a1 uni) (b uni))
  (=
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rrel a1) b)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) a1)) true))))
  (=>
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rrel a1) b)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) a1)) true)))))
  (recip a rrel rel))))))

(declare-fun strict (ty uni uni) Bool)

;; strict_def
  (assert
  (forall ((a ty))
  (forall ((srel uni) (rel uni))
  (= (strict a srel rel)
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a srel a1) b)) true)
  (and
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (not (= a1 b)))))))))))

(declare-fun compat_order_mult (ty uni uni uni) Bool)

;; compat_order_mult_def
  (assert
  (forall ((a ty))
  (forall ((rel uni) (mul uni) (tzero1 uni))
  (and
  (=> (compat_order_mult a rel mul tzero1)
  (forall ((a1 uni) (b uni) (c uni))
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel tzero1) c)) true)
  (= (tb2t
     (infix_at bool a
     (infix_at (infix_mngt a bool) a rel
     (infix_at a a (infix_at (infix_mngt a a) a mul a1) c))
     (infix_at a a (infix_at (infix_mngt a a) a mul b) c))) true)))))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=> (sort a c)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel tzero1) c)) true)
  (= (tb2t
     (infix_at bool a
     (infix_at (infix_mngt a bool) a rel
     (infix_at a a (infix_at (infix_mngt a a) a mul a1) c))
     (infix_at a a (infix_at (infix_mngt a a) a mul b) c))) true)))))))
  (compat_order_mult a rel mul tzero1))))))

;; set_antisym
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) a1)) true)
  (= a1 b)))))) (antisym a rel)))))

;; set_transitive
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=> (sort a c)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) c)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) c)) true)))))))
  (transitive a rel)))))

;; set_reflexive
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni))
  (=> (sort a a1)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) a1)) true)))
  (reflexive a rel)))))

;; set_strict
  (assert
  (forall ((a ty))
  (forall ((srel uni) (rel uni))
  (=>
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a srel a1) b)) true)
  (and
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (not (= a1 b))))))) (strict a srel rel)))))

;; set_partial_order
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) a1)) true)
  (= a1 b))))))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=> (sort a c)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) c)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) c)) true)))))))
  (=>
  (forall ((a1 uni))
  (=> (sort a a1)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) a1)) true)))
  (partial_order a rel)))))))

;; compat_order_mul
  (assert
  (forall ((a ty))
  (forall ((rel uni) (mul uni) (tzero1 uni))
  (=> (compat_order_mult a rel mul tzero1)
  (forall ((a1 uni) (b uni) (c uni))
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel tzero1) c)) true)
  (= (tb2t
     (infix_at bool a
     (infix_at (infix_mngt a bool) a rel
     (infix_at a a (infix_at (infix_mngt a a) a mul a1) c))
     (infix_at a a (infix_at (infix_mngt a a) a mul b) c))) true))))))))

;; set_compat_order_mul
  (assert
  (forall ((a ty))
  (forall ((rel uni) (mul uni) (tzero1 uni))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sor rel a1) b)) true)
  (not (= a1 b)))))))))))

(declare-fun compat_order_mult (ty uni uni uni) Bool)

;; compat_order_mult_def
  (assert
  (forall ((a ty))
  (forall ((rel uni) (mul uni) (tzero1 uni))
  (and
  (=> (compat_order_mult a rel mul tzero1)
  (forall ((a1 uni) (b uni) (c uni))
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel tzero1) c)) true)
  (= (tb2t
     (infix_at bool a
     (infix_at (infix_mngt a bool) a rel
     (infix_at a a (infix_at (infix_mngt a a) a mul a1) c))
     (infix_at a a (infix_at (infix_mngt a a) a mul b) c))) true)))))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=> (sort a c)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel tzero1) c)) true)
  (= (tb2t
     (infix_at bool a
     (infix_at (infix_mngt a bool) a rel
     (infix_at a a (infix_at (infix_mngt a a) a mul a1) c))
     (infix_at a a (infix_at (infix_mngt a a) a mul b) c))) true)))))))
  (compat_order_mult a rel mul tzero1))))))

;; set_antisym
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) a1)) true)
  (= a1 b)))))) (antisym a rel)))))

;; set_transitive
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=> (sort a c)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) c)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) c)) true)))))))
  (transitive a rel)))))

;; set_reflexive
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni))
  (=> (sort a a1)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) a1)) true)))
  (reflexive a rel)))))

;; set_strict
  (assert
  (forall ((a ty))
  (forall ((srel uni) (rel uni))
  (=>
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a srel a1) b)) true)
  (and
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (not (= a1 b))))))) (strict a srel rel)))))

;; set_partial_order
  (assert
  (forall ((a ty))
  (forall ((rel uni))
  (=>
  (forall ((a1 uni) (b uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) a1)) true)
  (= a1 b))))))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sort a b)
  (=> (sort a c)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel b) c)) true)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) c)) true)))))))
  (=>
  (forall ((a1 uni))
  (=> (sort a a1)
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) a1)) true)))
  (partial_order a rel)))))))

;; compat_order_mul
  (assert
  (forall ((a ty))
  (forall ((rel uni) (mul uni) (tzero1 uni))
  (=> (compat_order_mult a rel mul tzero1)
  (forall ((a1 uni) (b uni) (c uni))
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel a1) b)) true)
  (=>
  (= (tb2t (infix_at bool a (infix_at (infix_mngt a bool) a rel tzero1) c)) true)
  (= (tb2t
     (infix_at bool a
     (infix_at (infix_mngt a bool) a rel
     (infix_at a a (infix_at (infix_mngt a a) a mul a1) c))
     (infix_at a a (infix_at (infix_mngt a a) a mul b) c))) true))))))))

;; set_compat_order_mul
  (assert
  (forall ((a ty))
  (forall ((rel uni) (mul uni) (tzero1 uni))
  (=>
  (forall ((a1 uni) (b uni) (c uni))
  (=> (sort a a1)
  (=> (sor
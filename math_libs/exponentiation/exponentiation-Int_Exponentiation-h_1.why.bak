(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(* this is a prelude for Alt-Ergo integer arithmetic *)
logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

axiom CompatOrderMult :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

type 'a set

logic mem : 'a, 'a set -> prop

logic infix_eqeq : 'a set, 'a set -> prop

axiom infix_eqeq_spec :
  (forall s1:'a set. forall s2:'a set. (infix_eqeq(s1, s2) ->
  (forall x:'a. (mem(x, s1) -> mem(x, s2)))))

axiom infix_eqeq_spec1 :
  (forall s1:'a set. forall s2:'a set. (infix_eqeq(s1, s2) ->
  (forall x:'a. (mem(x, s2) -> mem(x, s1)))))

axiom infix_eqeq_spec2 :
  (forall s1:'a set. forall s2:'a set.
  ((forall x:'a. (mem(x, s1) <-> mem(x, s2))) -> infix_eqeq(s1, s2)))

axiom extensionality :
  (forall s1:'a set. forall s2:'a set. (infix_eqeq(s1, s2) -> (s1 = s2)))

logic subset : 'a set, 'a set -> prop

axiom subset_spec :
  (forall s1:'a set. forall s2:'a set. (subset(s1, s2) ->
  (forall x:'a. (mem(x, s1) -> mem(x, s2)))))

axiom subset_spec1 :
  (forall s1:'a set. forall s2:'a set.
  ((forall x:'a. (mem(x, s1) -> mem(x, s2))) -> subset(s1, s2)))

axiom subset_refl : (forall s:'a set. subset(s, s))

axiom subset_trans :
  (forall s1:'a set. forall s2:'a set. forall s3:'a set. (subset(s1, s2) ->
  (subset(s2, s3) -> subset(s1, s3))))

logic is_empty : 'a set -> prop

axiom is_empty_spec :
  (forall s:'a set. (is_empty(s) -> (forall x:'a. (not mem(x, s)))))

axiom is_empty_spec1 :
  (forall s:'a set. ((forall x:'a. (not mem(x, s))) -> is_empty(s)))

logic empty : 'a set

axiom empty_def : is_empty((empty : 'a set))

logic add : 'a, 'a set -> 'a set

axiom add_spec :
  (forall x:'a. forall s:'a set.
  (forall y:'a. (mem(y, add(x, s)) -> ((y = x) or mem(y, s)))))

axiom add_spec1 :
  (forall x:'a. forall s:'a set.
  (forall y:'a. (((y = x) or mem(y, s)) -> mem(y, add(x, s)))))

logic remove : 'a, 'a set -> 'a set

axiom remove_spec :
  (forall x:'a. forall s:'a set.
  (forall y:'a. (mem(y, remove(x, s)) -> (not (y = x)))))

axiom remove_spec1 :
  (forall x:'a. forall s:'a set.
  (forall y:'a. (mem(y, remove(x, s)) -> mem(y, s))))

axiom remove_spec2 :
  (forall x:'a. forall s:'a set.
  (forall y:'a. (((not (y = x)) and mem(y, s)) -> mem(y, remove(x, s)))))

axiom add_remove :
  (forall x:'a. forall s:'a set. (mem(x, s) -> (add(x, remove(x, s)) = s)))

axiom remove_add :
  (forall x:'a. forall s:'a set. (remove(x, add(x, s)) = remove(x, s)))

axiom subset_remove : (forall x:'a. forall s:'a set. subset(remove(x, s), s))

logic union : 'a set, 'a set -> 'a set

axiom union_spec :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. (mem(x, union(s1, s2)) -> (mem(x, s1) or mem(x, s2)))))

axiom union_spec1 :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. ((mem(x, s1) or mem(x, s2)) -> mem(x, union(s1, s2)))))

logic inter : 'a set, 'a set -> 'a set

axiom inter_spec :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. (mem(x, inter(s1, s2)) -> mem(x, s1))))

axiom inter_spec1 :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. (mem(x, inter(s1, s2)) -> mem(x, s2))))

axiom inter_spec2 :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. ((mem(x, s1) and mem(x, s2)) -> mem(x, inter(s1, s2)))))

logic diff : 'a set, 'a set -> 'a set

axiom diff_spec :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. (mem(x, diff(s1, s2)) -> mem(x, s1))))

axiom diff_spec1 :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. (mem(x, diff(s1, s2)) -> (not mem(x, s2)))))

axiom diff_spec2 :
  (forall s1:'a set. forall s2:'a set.
  (forall x:'a. ((mem(x, s1) and (not mem(x, s2))) -> mem(x, diff(s1, s2)))))

axiom subset_diff :
  (forall s1:'a set. forall s2:'a set. subset(diff(s1, s2), s1))

logic choose : 'a set -> 'a

axiom choose_spec :
  (forall s:'a set. ((not is_empty(s)) -> mem(choose(s), s)))

logic cardinal : 'a set -> int

axiom cardinal_nonneg : (forall s:'a set. (0 <= cardinal(s)))

axiom cardinal_empty : (forall s:'a set. ((cardinal(s) = 0) -> is_empty(s)))

axiom cardinal_empty1 : (forall s:'a set. (is_empty(s) -> (cardinal(s) = 0)))

axiom cardinal_add :
  (forall x:'a.
  (forall s:'a set. ((not mem(x, s)) -> (cardinal(add(x,
  s)) = (1 + cardinal(s))))))

axiom cardinal_remove :
  (forall x:'a.
  (forall s:'a set. (mem(x, s) -> (cardinal(s) = (1 + cardinal(remove(x,
  s)))))))

axiom cardinal_subset :
  (forall s1:'a set. forall s2:'a set. (subset(s1, s2) ->
  (cardinal(s1) <= cardinal(s2))))

axiom subset_eq :
  (forall s1:'a set. forall s2:'a set. (subset(s1, s2) ->
  ((cardinal(s1) = cardinal(s2)) -> infix_eqeq(s1, s2))))

axiom cardinal1 :
  (forall s:'a set. ((cardinal(s) = 1) ->
  (forall x:'a. (mem(x, s) -> (x = choose(s))))))

logic filter : ('a,bool) farray, 'a set -> 'a set

axiom filter_def :
  (forall p:('a,bool) farray. forall u:'a set.
  (forall x:'a. (mem(x, filter(p, u)) -> ((p[x]) = true))))

axiom filter_def1 :
  (forall p:('a,bool) farray. forall u:'a set.
  (forall x:'a. (mem(x, filter(p, u)) -> mem(x, u))))

axiom filter_def2 :
  (forall p:('a,bool) farray. forall u:'a set.
  (forall x:'a. ((((p[x]) = true) and mem(x, u)) -> mem(x, filter(p, u)))))

axiom filter_cardinal :
  (forall p:('a,bool) farray. forall u:'a set. (cardinal(filter(p,
  u)) <= cardinal(u)))

logic map : ('a,'b) farray, 'a set -> 'b set

axiom map_def1 :
  (forall f:('a,'b) farray. forall u:'a set.
  (forall y:'b. (mem(y, map(f, u)) ->
  (exists x:'a. (mem(x, u) and (y = (f[x])))))))

axiom map_def11 :
  (forall f:('a,'b) farray. forall u:'a set.
  (forall y:'b. ((exists x:'a. (mem(x, u) and (y = (f[x])))) -> mem(y, map(f,
  u)))))

axiom map_def2 :
  (forall f:('a,'b) farray. forall u:'a set.
  (forall x:'a. (mem(x, u) -> mem((f[x]), map(f, u)))))

axiom map_cardinal :
  (forall f:('a,'b) farray. forall u:'a set. (cardinal(map(f,
  u)) <= cardinal(u)))

axiom assert_equal : (forall a:'a1. forall b:'a1. ((a = b) -> (a = b)))

type ('a, 'a1) tuple2 = { Tuple2_proj_1 : 'a; Tuple2_proj_2 : 'a1
}

logic fir : ('a2, 'b) tuple2 -> 'a2

logic sec : ('a, 'b) tuple2 -> 'b

axiom projections :
  (forall o:('a, 'b) tuple2. (o = { Tuple2_proj_1 = fir(o); Tuple2_proj_2 =
  sec(o) }))

type 'a ref = { contents : 'a
}

axiom union_exchange :
  (forall s:'a set. forall sqt:'a set. ((not is_empty(sqt)) ->
  (union(add(choose(sqt), s), remove(choose(sqt), sqt)) = union(s, sqt))))

axiom get_filter :
  (forall p:('a,bool) farray. forall s:'a set. forall x:'a. (mem(x, filter(p,
  s)) -> ((p[x]) = true)))

axiom get_filter1 :
  (forall p:('a,bool) farray. forall s:'a set. forall x:'a. (mem(x, filter(p,
  s)) -> mem(x, s)))

axiom set_filter :
  (forall p:('a,bool) farray. forall s:'a set. forall x:'a.
  (((p[x]) = true) -> (mem(x, s) -> mem(x, filter(p, s)))))

axiom inter_empty :
  (forall s:'a set. forall sqt:'a set. (is_empty(s) -> is_empty(inter(s,
  sqt))))

axiom inter_empty_comm :
  (forall s:'a set. forall sqt:'a set. (is_empty(sqt) -> is_empty(inter(s,
  sqt))))

axiom union_empty :
  (forall s:'a set. forall sqt:'a set. (is_empty(s) -> (union(s,
  sqt) = sqt)))

axiom union_comm :
  (forall s:'a set. forall sqt:'a set. (is_empty(sqt) -> (union(s,
  sqt) = s)))

axiom union_alt :
  (forall s:'a set. forall sqt:'a set. forall e:'a. (mem(e, union(s, sqt)) ->
  ((not mem(e, s)) -> mem(e, sqt))))

axiom union_empty_comm :
  (forall s:'a set. forall sqt:'a set. (is_empty(sqt) -> (union(s,
  sqt) = s)))

axiom set_subset :
  (forall sqt:'a set. forall s:'a set.
  ((forall e:'a. (mem(e, sqt) -> mem(e, s))) -> subset(sqt, s)))

axiom set_empty :
  (forall s:'a set. ((forall e:'a. (not mem(e, s))) ->
  (s = (empty : 'a set))))

axiom set_empty1 :
  (forall s:'a set. ((forall e:'a. (not mem(e, s))) -> is_empty(s)))

axiom set_equal :
  (forall s:'a set. forall sqt:'a set.
  ((forall e:'a. (mem(e, s) -> mem(e, sqt))) ->
  ((forall e:'a. (mem(e, sqt) -> mem(e, s))) -> (s = sqt))))

axiom get_empty :
  (forall s:'a set. ((s = (empty : 'a set)) ->
  (forall e:'a. (not mem(e, s)))))

axiom get_empty1 : (forall s:'a set. ((s = (empty : 'a set)) -> is_empty(s)))

axiom get_non_empty :
  (forall s:'a set. ((not is_empty(s)) -> (exists e:'a. mem(e, s))))

axiom set_non_empty :
  (forall s:'a set. ((exists e:'a. mem(e, s)) -> (not is_empty(s))))

axiom set_non_empty1 :
  (forall s:'a set. ((exists e:'a. mem(e, s)) -> (0 <  cardinal(s))))

axiom union_add :
  (forall s:'a set. forall sqt:'a set. forall x:'a. ((not mem(x, sqt)) ->
  (union(s, add(x, sqt)) = add(x, union(s, sqt)))))

axiom union_add_comm :
  (forall s:'a set. forall sqt:'a set. forall x:'a. ((not mem(x, sqt)) ->
  (add(x, union(s, sqt)) = union(s, add(x, sqt)))))

axiom remove_add1 :
  (forall s:'a set. forall x:'a. ((not mem(x, s)) -> (remove(x, add(x,
  s)) = s)))

axiom add_remove1 :
  (forall s:'a set. forall x:'a. (mem(x, s) -> (add(x, remove(x, s)) = s)))

predicate p_injective(f: ('a,'b) farray, s: 'a set) =
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))

axiom map_choose :
  (forall s:'a set.
  (forall f:('a,'b) farray. (choose(map(f, s)) = (f[choose(s)]))))

axiom set_map_mem :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b.
  ((exists a1:'a. (mem(a1, s) and (b1 = (f[a1])))) -> mem(b1, map(f, s))))

axiom map_add :
  (forall f:('a,'b) farray. forall s:'a set. forall x:'a. ((not mem(x, s)) ->
  (map(f, add(x, s)) = add((f[x]), map(f, s)))))

axiom map_eq :
  (forall f:('a,'b) farray. forall g:('a,'b) farray. forall s:'a set.
  ((forall e:'a. (mem(e, s) -> ((f[e]) = (g[e])))) -> (map(f, s) = map(g,
  s))))

axiom set_map_mem_el :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b. forall a1:'a.
  (mem(a1, s) -> ((b1 = (f[a1])) -> mem(b1, map(f, s)))))

axiom set_map_mem_el_gen :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b.
  ((exists a1:'a. (mem(a1, s) and (b1 = (f[a1])))) -> mem(b1, map(f, s))))

axiom map_antec :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b. (mem(b1, map(f,
  s)) -> (exists a1:'a. (mem(a1, s) and (b1 = (f[a1]))))))

axiom map_antec_gen :
  (forall f:('a,'b) farray. forall s:'a set.
  (forall b1:'b. (mem(b1, map(f, s)) ->
  (exists a1:'a. (mem(a1, s) and (b1 = (f[a1])))))))

axiom map_remove_choose :
  (forall s:'a set. forall f:('a,'b) farray. (p_injective(f, s) -> (map(f,
  remove(choose(s), s)) = remove(choose(map(f, s)), map(f, s)))))

logic right_injections : 'a, 'b set -> ('a, 'b) tuple2 set

axiom right_injections_def :
  (forall a:'a1. forall s:'b set. (is_empty(s) -> (right_injections(a,
  s) = (empty : ('a1, 'b) tuple2 set))))

axiom right_injections_def1 :
  (forall a:'a1. forall s:'b set. ((not is_empty(s)) -> (right_injections(a,
  s) = add({ Tuple2_proj_1 = a; Tuple2_proj_2 = choose(s) },
  right_injections(a, remove(choose(s), s))))))

logic Tuple2_closure : ('a,('a1,('a, 'a1) tuple2) farray) farray

axiom Tuple2_closure_def :
  (forall y:'a. forall y1:'a1. ((((Tuple2_closure : ('a,('a1,('a,
  'a1) tuple2) farray) farray)[y])[y1]) = { Tuple2_proj_1 = y;
  Tuple2_proj_2 = y1 }))

axiom right_injections_spec :
  (forall a:'a1. forall s:'b set. (cardinal(right_injections(a,
  s)) = cardinal(s)))

axiom right_injections_spec1 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> (aqt = a)))))

axiom right_injections_spec2 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> mem(b1, s)))))

axiom right_injections_spec3 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (((aqt = a) and mem(b1, s)) -> mem({ Tuple2_proj_1 = aqt;
  Tuple2_proj_2 = b1 }, right_injections(a, s))))))

axiom right_injections_spec4 :
  (forall a:'a1. forall s:'b set. (right_injections(a,
  s) = map(((Tuple2_closure : ('a1,('b,('a1, 'b) tuple2) farray) farray)[a]),
  s)))

logic left_injections : 'a set, 'b -> ('a, 'b) tuple2 set

axiom left_injections_def :
  (forall s:'a set. forall b:'b1. (is_empty(s) -> (left_injections(s,
  b) = (empty : ('a, 'b1) tuple2 set))))

axiom left_injections_def1 :
  (forall s:'a set. forall b:'b1. ((not is_empty(s)) -> (left_injections(s,
  b) = add({ Tuple2_proj_1 = choose(s); Tuple2_proj_2 = b },
  left_injections(remove(choose(s), s), b)))))

logic fc : 'b -> ('a,('a, 'b) tuple2) farray

axiom fc_def :
  (forall b:'b1. forall a:'a1. (((fc(b) : ('a1,('a1,
  'b1) tuple2) farray)[a]) = { Tuple2_proj_1 = a; Tuple2_proj_2 = b }))

axiom left_injections_spec :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> mem(a1, s)))))

axiom left_injections_spec1 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> (bqt = b)))))

axiom left_injections_spec2 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. ((mem(a1, s) and (bqt = b)) -> mem({ Tuple2_proj_1 = a1;
  Tuple2_proj_2 = bqt }, left_injections(s, b))))))

axiom left_injections_spec3 :
  (forall s:'a set. forall b:'b1. (cardinal(left_injections(s,
  b)) = cardinal(s)))

axiom left_injections_spec4 :
  (forall s:'a set. forall b:'b1. (left_injections(s,
  b) = map((fc(b) : ('a,('a, 'b1) tuple2) farray), s)))

axiom right_injections_l :
  (forall a:'a1. forall s:'b set. (cardinal(right_injections(a,
  s)) = cardinal(s)))

axiom right_injections_l1 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> (aqt = a)))))

axiom right_injections_l2 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> mem(b1, s)))))

axiom right_injections_l3 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (((aqt = a) and mem(b1, s)) -> mem({ Tuple2_proj_1 = aqt;
  Tuple2_proj_2 = b1 }, right_injections(a, s))))))

axiom right_injections_l4 :
  (forall a:'a1. forall s:'b set. (right_injections(a,
  s) = map(((Tuple2_closure : ('a1,('b,('a1, 'b) tuple2) farray) farray)[a]),
  s)))

logic fc1 : 'b -> ('a,('a, 'b) tuple2) farray

axiom fc_def1 :
  (forall b:'b1. forall a:'a1. (((fc1(b) : ('a1,('a1,
  'b1) tuple2) farray)[a]) = { Tuple2_proj_1 = a; Tuple2_proj_2 = b }))

axiom left_injections_l :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> mem(a1, s)))))

axiom left_injections_l1 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> (bqt = b)))))

axiom left_injections_l2 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. ((mem(a1, s) and (bqt = b)) -> mem({ Tuple2_proj_1 = a1;
  Tuple2_proj_2 = bqt }, left_injections(s, b))))))

axiom left_injections_l3 :
  (forall s:'a set. forall b:'b1. (cardinal(left_injections(s,
  b)) = cardinal(s)))

axiom left_injections_l4 :
  (forall s:'a set. forall b:'b1. (left_injections(s,
  b) = map((fc1(b) : ('a,('a, 'b1) tuple2) farray), s)))

axiom disjoint_injections :
  (forall s:'a set. forall b:'b1. forall c:'b1. ((not (b = c)) ->
  is_empty(inter(right_injections(b, s), right_injections(c, s)))))

axiom disjoint_injections1 :
  (forall s:'a set. forall b:'b1. forall c:'b1. ((not (b = c)) ->
  is_empty(inter(left_injections(s, b), left_injections(s, c)))))

axiom induction :
  (forall p:('a set,bool) farray. forall t:'a set.
  ((forall s:'a set. (is_empty(s) -> ((p[s]) = true))) ->
  ((forall s:'a set. (((p[s]) = true) ->
   (forall t1:'a. ((not mem(t1, s)) -> ((p[add(t1, s)]) = true))))) ->
  ((p[t]) = true))))

axiom cardinal_sum :
  (forall s:'a set. forall sqt:'a set. (cardinal(union(s,
  sqt)) = ((cardinal(s) + cardinal(sqt)) - cardinal(inter(s, sqt)))))

axiom cardinal_sum_empty_inter :
  (forall s:'a set. forall sqt:'a set. ((inter(s, sqt) = (empty : 'a set)) ->
  (cardinal(union(s, sqt)) = (cardinal(s) + cardinal(sqt)))))

logic cartesian_product : 'a set, 'b set -> ('a, 'b) tuple2 set

axiom cartesian_product_spec :
  (forall s1:'a set. forall s2:'b set. (cardinal(cartesian_product(s1,
  s2)) = (cardinal(s1) * cardinal(s2))))

axiom cartesian_product_spec1 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a.
  (forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1 },
  cartesian_product(s1, s2)) -> mem(a1, s1)))))

axiom cartesian_product_spec2 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a.
  (forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1 },
  cartesian_product(s1, s2)) -> mem(b1, s2)))))

axiom cartesian_product_spec3 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a.
  (forall b1:'b. ((mem(a1, s1) and mem(b1, s2)) -> mem({ Tuple2_proj_1 = a1;
  Tuple2_proj_2 = b1 }, cartesian_product(s1, s2))))))

axiom cartesian_product_spec4 :
  (forall s1:'a set. forall s2:'b set.
  (forall o:('a, 'b) tuple2. (mem(o, cartesian_product(s1, s2)) ->
  mem(fir(o), s1))))

axiom cartesian_product_spec5 :
  (forall s1:'a set. forall s2:'b set.
  (forall o:('a, 'b) tuple2. (mem(o, cartesian_product(s1, s2)) ->
  mem(sec(o), s2))))

axiom cartesian_product_spec6 :
  (forall s1:'a set. forall s2:'b set.
  (forall o:('a, 'b) tuple2. ((mem(fir(o), s1) and mem(sec(o), s2)) -> mem(o,
  cartesian_product(s1, s2)))))

function commute(o: ('a, 'b) tuple2) : ('b, 'a) tuple2 = { Tuple2_proj_1 =
  (o).Tuple2_proj_2; Tuple2_proj_2 = (o).Tuple2_proj_1 }

axiom commute_inj :
  (forall a:'a1. forall aqt:'a1. forall b:'b1. forall bqt:'b1. (((a = aqt) ->
  (not (b = bqt))) -> (not (commute({ Tuple2_proj_1 = a; Tuple2_proj_2 = b
  }) = commute({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = bqt })))))

logic commute_closure : (('a, 'b) tuple2,('b, 'a) tuple2) farray

axiom commute_closure_def :
  (forall y:('a, 'b) tuple2. (((commute_closure : (('a, 'b) tuple2,('b,
  'a) tuple2) farray)[y]) = commute(y)))

axiom commute_inj_gen :
  (forall s1:'a set. forall s2:'b set. p_injective((commute_closure : (('a,
  'b) tuple2,('b, 'a) tuple2) farray), cartesian_product(s1, s2)))

function commute_product(s1: 'a set, s2: 'b set) : ('b, 'a) tuple2 set =
  map((commute_closure : (('a, 'b) tuple2,('b, 'a) tuple2) farray),
  cartesian_product(s1, s2))

axiom commute_product_spec :
  (forall s1:'a set. forall s2:'b set. (commute_product(s1,
  s2) = cartesian_product(s2, s1)))

function commute_product_el(s1: 'a set, s2: 'b set) : ('b, 'a) tuple2 set =
  map((commute_closure : (('a, 'b) tuple2,('b, 'a) tuple2) farray),
  cartesian_product(s1, s2))

axiom commute_product_el_spec :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1
  }, cartesian_product(s1, s2)) -> mem(a1, s1))))

axiom commute_product_el_spec1 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1
  }, cartesian_product(s1, s2)) -> mem(b1, s2))))

axiom commute_product_el_spec2 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. ((mem(a1, s1) and mem(b1, s2)) -> mem({
  Tuple2_proj_1 = a1; Tuple2_proj_2 = b1 }, cartesian_product(s1, s2)))))

axiom commute_product_el_spec3 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. ((mem(a1, s1) and mem(b1, s2)) -> mem({
  Tuple2_proj_1 = b1; Tuple2_proj_2 = a1 }, commute_product_el(s1, s2)))))

axiom commute_product_el_spec4 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = b1; Tuple2_proj_2 = a1
  }, commute_product_el(s1, s2)) -> mem(a1, s1))))

axiom commute_product_el_spec5 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = b1; Tuple2_proj_2 = a1
  }, commute_product_el(s1, s2)) -> mem(b1, s2))))

axiom cartesian_product_union :
  (forall s1:'a set. forall s2:'b set. forall s3:'b set.
  (cartesian_product(s1, union(s2, s3)) = union(cartesian_product(s1, s2),
  cartesian_product(s1, s3))))

axiom cartesian_union_product :
  (forall s1:'a set. forall s2:'a set. forall s3:'b set.
  (cartesian_product(union(s1, s2), s3) = union(cartesian_product(s1, s3),
  cartesian_product(s2, s3))))

axiom cartesian_product_cardone_r :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s1) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), right_injections(choose(s1), s2))))

axiom cartesian_product_cardone_r1 :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s1) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), map(((Tuple2_closure : ('a,('b,('a,
  'b) tuple2) farray) farray)[choose(s1)]), s2))))

logic fc2 : 'b -> ('a,('a, 'b) tuple2) farray

axiom fc_def2 :
  (forall e:'b. forall e1:'a. (((fc2(e) : ('a,('a,
  'b) tuple2) farray)[e1]) = { Tuple2_proj_1 = e1; Tuple2_proj_2 = e }))

axiom cartesian_product_cardone_l :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s2) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), left_injections(s1, choose(s2)))))

axiom cartesian_product_cardone_l1 :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s2) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), map((fc2(choose(s2)) : ('a,('a,
  'b) tuple2) farray), s1))))

axiom disjoint_cartesian_product_l :
  (forall s1:'a set. forall s2:'a set. forall s3:'b set. ((inter(s1,
  s2) = (empty : 'a set)) -> (inter(cartesian_product(s1, s3),
  cartesian_product(s2, s3)) = (empty : ('a, 'b) tuple2 set))))

axiom disjoint_cartesian_product_r :
  (forall s1:'a set. forall s2:'b set. forall s3:'b set. ((inter(s2,
  s3) = (empty : 'b set)) -> (inter(cartesian_product(s1, s2),
  cartesian_product(s1, s3)) = (empty : ('a, 'b) tuple2 set))))

axiom to_set_spec : (forall e:'a. (cardinal(add(e, (empty : 'a set))) = 1))

axiom to_set_spec1 :
  (forall e:'a. (forall b:'a. (mem(b, add(e, (empty : 'a set))) -> (b = e))))

logic to_fset : int, int -> int set

axiom to_fset_spec :
  (forall i:int. forall j:int. ((i <  j) -> (cardinal(to_fset(i,
  j)) = (j - i))))

axiom to_fset_spec1 :
  (forall i:int. forall j:int. ((j <= i) -> is_empty(to_fset(i, j))))

axiom to_fset_spec2 :
  (forall i:int. forall j:int.
  (forall k:int. (mem(k, to_fset(i, j)) -> (i <= k))))

axiom to_fset_spec3 :
  (forall i:int. forall j:int.
  (forall k:int. (mem(k, to_fset(i, j)) -> (k <  j))))

axiom to_fset_spec4 :
  (forall i:int. forall j:int.
  (forall k:int. (((i <= k) and (k <  j)) -> mem(k, to_fset(i, j)))))

axiom choose_to_fset :
  (forall i:int. forall j:int. ((i <= j) -> (choose(to_fset(i, j)) = i)))

axiom to_fset_unit_ext :
  (forall i:int. forall j:int. ((i <  j) -> (to_fset(i, j) = add(i,
  to_fset((i + 1), j)))))

axiom to_fset_ext :
  (forall i:int. forall iqt:int. forall j:int. (((i <= iqt) and
  (iqt <= j)) -> (to_fset(i, j) = union(to_fset(i, iqt), to_fset(iqt, j)))))

logic op : 'im, 'im -> 'im

logic po : 'im, 'im -> 'im

logic inver : 'im -> 'im

predicate op_neutral_left(op1: ('im,('im,'im) farray) farray, neutral: 'im) =
  (forall e:'im. (((op1[neutral])[e]) = e))

predicate op_neutral_right(op1: ('im,('im,'im) farray) farray,
  neutral: 'im) = (forall e:'im. (((op1[e])[neutral]) = e))

predicate op_assoc(op1: ('im,('im,'im) farray) farray) =
  (forall a:'im. forall b:'im. forall c:'im.
  (((op1[((op1[a])[b])])[c]) = ((op1[a])[((op1[b])[c])])))

predicate op_neutral_left_comm(op1: ('im,('im,'im) farray) farray,
  neutral: 'im) =
  (forall a:'im. ((forall b:'im. (((op1[a])[b]) = b)) -> (a = neutral)))

predicate commut(op1: ('im,('im,'im) farray) farray) =
  (forall a:'im. forall b:'im. (((op1[a])[b]) = ((op1[b])[a])))

predicate assoc(op1: ('im,('im,'im) farray) farray) =
  (forall a:'im. forall b:'im. forall c:'im.
  (((op1[((op1[a])[b])])[c]) = ((op1[a])[((op1[b])[c])])))

predicate opposite_n(op1: ('im,('im,'im) farray) farray,
  po1: ('im,('im,'im) farray) farray, neutral: 'im) =
  (forall a:'im. (((po1[a])[a]) = neutral))

predicate inverse(op1: ('im,('im,'im) farray) farray,
  po1: ('im,('im,'im) farray) farray, inver1: ('im,'im) farray) =
  (forall a:'im. forall b:'im. (((po1[a])[b]) = ((op1[a])[(inver1[b])])))

predicate opposite(op1: ('im,('im,'im) farray) farray,
  po1: ('im,('im,'im) farray) farray) =
  (forall a:'im. forall b:'im. (((op1[((po1[a])[b])])[b]) = a))

predicate opposite_com(op1: ('im,('im,'im) farray) farray,
  po1: ('im,('im,'im) farray) farray) =
  (forall a:'im. forall b:'im. (((po1[((op1[a])[b])])[b]) = a))

axiom refl :
  (forall op1:('im,('im,'im) farray) farray. forall a:'im. forall b:'im.
  (commut(op1) -> (((op1[a])[b]) = ((op1[b])[a]))))

predicate neutral(op1: ('im,('im,'im) farray) farray, neut: 'im) =
  (op_neutral_left(op1, neut) and (op_neutral_right(op1, neut) and
  op_assoc(op1)))

axiom set_neutral :
  (forall op1:('im,('im,'im) farray) farray. forall neut:'im.
  (op_neutral_left(op1, neut) -> (op_neutral_right(op1, neut) ->
  (op_assoc(op1) -> neutral(op1, neut)))))

predicate has_neutral(op1: ('im,('im,'im) farray) farray) =
  (exists e:'im. neutral(op1, e))

predicate iterates(op1: ('im,('im,'im) farray) farray, neutral1: 'im) =
  (op_neutral_left(op1, neutral1) and (op_neutral_right(op1, neutral1) and
  op_assoc(op1)))

axiom iterates_ :
  (forall op1:('im,('im,'im) farray) farray. forall neutral1:'im.
  (op_neutral_left(op1, neutral1) -> (op_neutral_right(op1, neutral1) ->
  (op_assoc(op1) -> iterates(op1, neutral1)))))

predicate iterable(op1: ('im,('im,'im) farray) farray) =
  (exists e:'im. iterates(op1, e))

logic neutral_elt : ('im,('im,'im) farray) farray -> 'im

axiom neutral_elt_spec :
  (forall op1:('im,('im,'im) farray) farray.
  (forall e:'im. (neutral(op1, e) -> (neutral_elt(op1) = e))))

axiom neutral_elt_spec1 :
  (forall op1:('im,('im,'im) farray) farray.
  (forall e:'im. ((neutral_elt(op1) = e) -> neutral(op1, e))))

predicate inverse_tuple(op1: ('im,('im,'im) farray) farray,
  po1: ('im,('im,'im) farray) farray, neutral1: 'im) = (opposite_n(op1, po1,
  neutral1) and (opposite(op1, po1) and opposite_com(op1, po1)))

logic iterate : ('im,('im,'im) farray) farray, 'a set, ('a,'im) farray -> 'im

axiom Iterate_def_empty :
  (forall op1:('im,('im,'im) farray) farray.
  (forall s:'a set.
  (forall f:('a,'im) farray. (is_empty(s) -> (iterate(op1, (empty : 'a set),
  f) = neutral_elt(op1))))))

axiom Iterate_add :
  (forall op1:('im,('im,'im) farray) farray.
  (forall s:'a set.
  (forall f:('a,'im) farray.
  (forall x:'a. ((not mem(x, s)) -> (iterate(op1, add(x, s),
  f) = ((op1[(f[x])])[iterate(op1, s, f)])))))))

axiom minus_zero :
  (forall op1:('im,('im,'im) farray) farray.
  forall po1:('im,('im,'im) farray) farray. forall a:'im. (iterable(op1) ->
  (inverse_tuple(op1, po1, neutral_elt(op1)) ->
  (((po1[a])[neutral_elt(op1)]) = a))))

axiom unic :
  (forall op1:('im,('im,'im) farray) farray.
  forall po1:('im,('im,'im) farray) farray. forall a:'im. forall b:'im.
  forall c:'im. (iterable(op1) -> (commut(op1) ->
  ((((op1[a])[b]) = ((op1[a])[c])) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) -> (b = c))))))

axiom substract_comm :
  (forall op1:('im,('im,'im) farray) farray.
  forall po1:('im,('im,'im) farray) farray. forall a:'im. forall b:'im.
  (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) -> (((po1[((op1[a])[b])])[a]) = b)))))

axiom substract_comm1 :
  (forall op1:('im,('im,'im) farray) farray.
  forall po1:('im,('im,'im) farray) farray. forall a:'im. forall b:'im.
  (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) -> (((po1[((op1[b])[a])])[a]) = b)))))

axiom substract_comm2 :
  (forall op1:('im,('im,'im) farray) farray.
  forall po1:('im,('im,'im) farray) farray. forall a:'im. forall b:'im.
  forall c:'im. (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) ->
  (((po1[a])[((po1[b])[c])]) = ((op1[((po1[a])[b])])[c]))))))

axiom substract_comm3 :
  (forall op1:('im,('im,'im) farray) farray.
  forall po1:('im,('im,'im) farray) farray. forall a:'im. forall b:'im.
  forall c:'im. (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) ->
  (((po1[((op1[a])[b])])[c]) = ((op1[a])[((po1[b])[c])]))))))

logic int_iterate : ('im,('im,'im) farray) farray, (int,'im) farray, int,
  int -> 'im

axiom int_iterate_def :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. ((j <= i) -> (int_iterate(op1, f, i,
  j) = neutral_elt(op1))))

axiom int_iterate_def1 :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. ((not (j <= i)) -> (int_iterate(op1, f, i,
  j) = ((op1[(f[i])])[int_iterate(op1, f, (i + 1), j)]))))

axiom int_iterate_spec :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. ((j <= i) -> (int_iterate(op1, f, i,
  j) = neutral_elt(op1))))

logic int_int_iterate : ('im,('im,'im) farray) farray,
  (int,(int,'im) farray) farray, int, int, int, int -> 'im

logic identity : ('a,'a) farray

axiom identity_def : (forall y:'a. (((identity : ('a,'a) farray)[y]) = y))

axiom int_int_iterate_def :
  (forall op1:('im,('im,'im) farray) farray.
  forall f:(int,(int,'im) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((j <= i) -> (int_int_iterate(op1, f, i, j, k,
  l) = neutral_elt(op1))))

axiom int_int_iterate_def1 :
  (forall op1:('im,('im,'im) farray) farray.
  forall f:(int,(int,'im) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((not (j <= i)) -> (int_int_iterate(op1, f, i,
  j, k, l) = ((op1[int_iterate(op1,
  ((identity : ((int,'im) farray,(int,'im) farray) farray)[(f[i])]), k,
  l)])[int_int_iterate(op1, f, (i + 1), j, k, l)]))))

logic element : 'a set -> 'a

axiom element_def :
  (forall s:'a set. ((cardinal(s) = 1) -> (element(s) = choose(s))))

axiom cardone :
  (forall s:'a set. forall a1:'a. ((forall b:'a. (mem(b, s) <-> (b = a1))) ->
  ((0 <  cardinal(s)) -> (cardinal(s) = 1))))

axiom cardone1 :
  (forall s:'a set. forall a1:'a. ((forall b:'a. (mem(b, s) <-> (b = a1))) ->
  ((0 <  cardinal(s)) -> (element(s) = a1))))

axiom set_cardone :
  (forall s:'a set. ((0 <  cardinal(s)) ->
  ((exists a1:'a. (forall b:'a. (mem(b, s) <-> (b = a1)))) ->
  (cardinal(s) = 1))))

axiom get_cardone :
  (forall s:'a set. ((cardinal(s) = 1) ->
  (exists a1:'a. (forall b:'a. (mem(b, s) <-> (b = a1))))))

axiom set_cardone_elt :
  (forall s:'a set. forall a1:'a. ((0 <  cardinal(s)) ->
  ((forall b:'a. (mem(b, s) <-> (b = a1))) -> (cardinal(s) = 1))))

axiom cardzero :
  (forall s:'a set. ((forall b:'a. (not mem(b, s))) -> (cardinal(s) = 0)))

predicate p_injective_in(f: ('a,'b) farray, s: 'a set, sqt: 'b set) =
  (forall e:'a. (mem(e, s) -> (mem((f[e]), sqt) and
  (forall e1:'a. forall eqt:'a. (mem(e1, s) -> (mem(eqt, s) ->
  ((not (e1 = eqt)) -> (not ((f[e1]) = (f[eqt]))))))))))

predicate equal_func(f: ('a,'b) farray, g: ('a,'b) farray) =
  (forall e:'a. ((f[e]) = (g[e])))

axiom set_equal_func :
  (forall f:('a,'b) farray. forall g:('a,'b) farray.
  ((forall e:'a. ((f[e]) = (g[e]))) -> equal_func(f, g)))

axiom set_equal_func1 :
  (forall f:('a,'b) farray. forall g:('a,'b) farray.
  ((forall e:'a. ((f[e]) = (g[e]))) -> (f = g)))

axiom get_equal_func :
  (forall f:('a,'b) farray. forall g:('a,'b) farray. (equal_func(f, g) ->
  (forall e:'a. ((f[e]) = (g[e])))))

axiom set_injective :
  (forall f:('a,'b) farray. forall s:'a set.
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  p_injective(f, s)))

axiom image_spec :
  (forall f:('a,'b) farray. forall s:'a set.
  (forall a1:'b. (mem(a1, map(f, s)) ->
  (exists antec_a:'a. (mem(antec_a, s) and (a1 = (f[antec_a])))))))

axiom image_spec1 :
  (forall f:('a,'b) farray. forall s:'a set.
  (forall a1:'b.
  ((exists antec_a:'a. (mem(antec_a, s) and (a1 = (f[antec_a])))) -> mem(a1,
  map(f, s)))))

axiom card_image :
  (forall f:('a,'b) farray. forall s:'a set. (cardinal(map(f,
  s)) <= cardinal(s)))

axiom card_image_injective :
  (forall f:('a,'b) farray. forall s:'a set. (p_injective(f, s) ->
  (cardinal(map(f, s)) = cardinal(s))))

axiom get_injective :
  (forall f:('a,'b) farray. forall s:'a set. (p_injective(f, s) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))))

axiom set_injective_in :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  p_injective(f, s))))

axiom get_injective_in :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_injective_in(f, s, sqt) ->
  (forall e:'a. (mem(e, s) -> mem((f[e]), sqt)))))

axiom get_injective_in1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_injective_in(f, s, sqt) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))))

predicate p_surjective(f: ('a,'b) farray, s: 'a set, sqt: 'b set) =
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) and
  (forall eqt:'b. (mem(eqt, sqt) ->
  (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))))

axiom set_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall eqt:'b. (mem(eqt, sqt) ->
   (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))) ->
  p_surjective(f, s, sqt))))

axiom get_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_surjective(f, s, sqt) ->
  (forall e:'a. (mem(e, s) -> mem((f[e]), sqt)))))

axiom get_surjective1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_surjective(f, s, sqt) ->
  (forall eqt:'b. (mem(eqt, sqt) ->
  (exists e:'a. (mem(e, s) and ((f[e]) = eqt)))))))

axiom image_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_surjective(f, s, sqt) -> (map(f, s) = sqt)))

predicate p_bijective(f: ('a,'b) farray, s: 'a set, sqt: 'b set) =
  (p_injective_in(f, s, sqt) and p_surjective(f, s, sqt))

axiom bijective_is_injective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> p_injective(f, s)))

axiom bijective_is_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> p_surjective(f, s, sqt)))

axiom set_bijective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, sqt) ->
   (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))) ->
  p_bijective(f, s, sqt)))))

axiom set_bijective1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, sqt) ->
   (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))) ->
  (map(f, s) = sqt)))))

axiom bijective_image :
  (forall f:('a,'a) farray. forall s:'a set. forall sqt:'a set.
  (p_bijective(f, s, sqt) -> (cardinal(s) = cardinal(sqt))))

axiom bijective_image1 :
  (forall f:('a,'a) farray. forall s:'a set. forall sqt:'a set.
  (p_bijective(f, s, sqt) -> (sqt = map(f, s))))

axiom get_bijective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> (forall e:'a. (mem(e, s) -> mem((f[e]), sqt)))))

axiom get_bijective1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))))

axiom get_bijective2 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  (forall eqt:'b. (mem(eqt, sqt) ->
  (exists e:'a. (mem(e, s) and ((f[e]) = eqt)))))))

axiom get_bijective3 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> (cardinal(s) = cardinal(sqt))))

axiom iterate_empty :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall t:('a,'im) farray. (is_empty(s) -> (iterate(op1, s,
  t) = neutral_elt(op1))))

axiom iterate_add :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall f:('a,'im) farray. forall x:'a. ((not mem(x, s)) -> (iterate(op1,
  add(x, s), f) = ((op1[(f[x])])[iterate(op1, s, f)]))))

logic po_closure : ('im,('im,'im) farray) farray

axiom po_closure_def :
  (forall y:'im. forall y1:'im.
  ((((po_closure : ('im,('im,'im) farray) farray)[y])[y1]) = po(y, y1)))

axiom iterate_remove :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall f:('a,'im) farray. forall x:'a. (commut(op1) -> (iterable(op1) ->
  (inverse_tuple(op1, (po_closure : ('im,('im,'im) farray) farray),
  neutral_elt(op1)) -> (mem(x, s) -> (iterate(op1, remove(x, s),
  f) = po(iterate(op1, s, f), (f[x]))))))))

axiom iterate_def_choose :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall f:('a,'im) farray. (iterable(op1) -> ((not is_empty(s)) ->
  (iterate(op1, s, f) = ((op1[(f[choose(s)])])[iterate(op1, remove(choose(s),
  s), f)])))))

axiom choose_any :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall f:('a,'im) farray. forall t:'a. (iterable(op1) -> (mem(t, s) ->
  (iterate(op1, s, f) = ((op1[(f[t])])[iterate(op1, remove(t, s), f)])))))

logic fc3 : ('im,('im,'im) farray) farray, ('a,'im) farray,
  ('a,'im) farray -> ('a,'im) farray

axiom fc_def3 :
  (forall op1:('im,('im,'im) farray) farray. forall f:('a,'im) farray.
  forall g:('a,'im) farray. forall k:'a. ((fc3(op1, f,
  g)[k]) = ((op1[(f[k])])[(g[k])])))

axiom iterate_comp_iterate :
  (forall op1:('im,('im,'im) farray) farray. forall s1:'a set.
  forall f:('a,'im) farray. forall g:('a,'im) farray. (iterable(op1) ->
  (commut(op1) -> (assoc(op1) -> (iterate(op1, s1, fc3(op1, f,
  g)) = ((op1[iterate(op1, s1, f)])[iterate(op1, s1, g)]))))))

logic fc4 : ('im,('im,'im) farray) farray, ('a,'im) farray,
  ('a,'im) farray -> ('a,'im) farray

axiom fc_def4 :
  (forall op1:('im,('im,'im) farray) farray. forall f:('a,'im) farray.
  forall g:('a,'im) farray. forall k:'a. ((fc4(op1, f,
  g)[k]) = ((op1[(f[k])])[(g[k])])))

axiom iterate_comp_iterate_com :
  (forall op1:('im,('im,'im) farray) farray. forall s1:'a set.
  forall f:('a,'im) farray. forall g:('a,'im) farray. (iterable(op1) ->
  (commut(op1) -> (((op1[iterate(op1, s1, f)])[iterate(op1, s1,
  g)]) = iterate(op1, s1, fc4(op1, f, g))))))

axiom iterate_transitivity :
  (forall op1:('im,('im,'im) farray) farray.
  forall po1:('im,('im,'im) farray) farray. forall s1:'a set.
  forall s2:'a set. forall f:('a,'im) farray. (iterable(op1) ->
  (commut(op1) -> (inverse_tuple(op1, po1, neutral_elt(op1)) -> (iterate(op1,
  union(s1, s2), f) = ((po1[((op1[iterate(op1, s1, f)])[iterate(op1, s2,
  f)])])[iterate(op1, inter(s1, s2), f)]))))))

axiom iterate_disjoint_transitivity :
  (forall op1:('im,('im,'im) farray) farray. forall s1:'a set.
  forall s2:'a set. forall t:('a,'im) farray. (iterable(op1) ->
  (commut(op1) -> ((inter(s1, s2) = (empty : 'a set)) -> (iterate(op1,
  union(s1, s2), t) = ((op1[iterate(op1, s1, t)])[iterate(op1, s2, t)]))))))

axiom iterate_eq :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall f:('a,'im) farray. forall g:('a,'im) farray.
  ((forall x:'a. (mem(x, s) -> ((f[x]) = (g[x])))) -> (iterate(op1, s,
  f) = iterate(op1, s, g))))

logic fc5 : ('b,'a) farray, ('a,'im) farray -> ('b,'im) farray

axiom fc_def5 :
  (forall f:('b,'a) farray. forall t:('a,'im) farray. forall b1:'b. ((fc5(f,
  t)[b1]) = (t[(f[b1])])))

axiom iterate_map :
  (forall op1:('im,('im,'im) farray) farray. forall s:'b set.
  forall f:('b,'a) farray. forall t:('a,'im) farray. (iterable(op1) ->
  (p_injective(f, s) -> (iterate(op1, map(f, s), t) = iterate(op1, s, fc5(f,
  t))))))

axiom iterate_cardone :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall t:('a,'im) farray. (iterable(op1) -> ((cardinal(s) = 1) ->
  (iterate(op1, s, t) = (t[element(s)])))))

axiom iterate_cardzero :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall t:('a,'im) farray. (iterable(op1) -> ((cardinal(s) = 0) ->
  (iterate(op1, s, t) = neutral_elt(op1)))))

logic fc6 : ('a,('b,'im) farray) farray -> (('a, 'b) tuple2,'im) farray

axiom fc_def6 :
  (forall f:('a,('b,'im) farray) farray. forall o:('a, 'b) tuple2.
  ((fc6(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom injec_iterate :
  (forall op1:('im,('im,'im) farray) farray. forall a:'a1. forall s:'b set.
  forall f:('a1,('b,'im) farray) farray. (iterable(op1) -> (commut(op1) ->
  (iterate(op1, s, (f[a])) = iterate(op1, cartesian_product(add(a,
  (empty : 'a1 set)), s), fc6(f))))))

logic fc7 : ('im,('im,'im) farray) farray, 'b set,
  ('a,('b,'im) farray) farray -> ('a,'im) farray

logic fc8 : ('a,('b,'im) farray) farray -> (('a, 'b) tuple2,'im) farray

axiom fc_def7 :
  (forall op1:('im,('im,'im) farray) farray. forall s2:'b set.
  forall f:('a,('b,'im) farray) farray. forall a1:'a. ((fc7(op1, s2,
  f)[a1]) = iterate(op1, s2, (f[a1]))))

axiom fc_def8 :
  (forall f:('a,('b,'im) farray) farray. forall o:('a, 'b) tuple2.
  ((fc8(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom iterate_cartesian_product :
  (forall op1:('im,('im,'im) farray) farray. forall s1:'a set.
  forall s2:'b set. forall f:('a,('b,'im) farray) farray. (iterable(op1) ->
  (commut(op1) -> (iterate(op1, s1, fc7(op1, s2, f)) = iterate(op1,
  cartesian_product(s1, s2), fc8(f))))))

axiom iterate_eq_func :
  (forall op1:('im,('im,'im) farray) farray. forall s:'a set.
  forall f1:('a,'im) farray. forall f2:('a,'im) farray. (iterable(op1) ->
  (p_injective(f1, s) -> (p_injective(f2, s) -> ((map(f1, s) = map(f2, s)) ->
  (iterate(op1, s, f1) = iterate(op1, s, f2)))))))

axiom int_iterate_def_empty :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. ((j <= i) -> (int_iterate(op1, f, i,
  j) = neutral_elt(op1))))

axiom int_iterate_def_plus_one :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. ((i <  j) -> (int_iterate(op1, f, i,
  j) = ((op1[(f[i])])[int_iterate(op1, f, (i + 1), j)]))))

axiom int_iterate_cardone :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. ((j = (i + 1)) -> (iterable(op1) ->
  (int_iterate(op1, f, i, j) = (f[i])))))

axiom int_iterate_def_plus_one_com :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. ((i <  j) -> (((op1[(f[i])])[int_iterate(op1,
  f, (i + 1), j)]) = int_iterate(op1, f, i, j))))

axiom int_iterate_to_iterate :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. (int_iterate(op1, f, i, j) = iterate(op1,
  to_fset(i, j), f)))

axiom int_iterate_right_extension :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall j:int. (assoc(op1) -> ((i <  j) -> (int_iterate(op1,
  f, i, j) = ((op1[int_iterate(op1, f, i, (j - 1))])[(f[(j - 1)])])))))

axiom int_iterate_transitivity :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall i:int. forall k:int. forall j:int. (assoc(op1) ->
  (op_neutral_left(op1, neutral_elt(op1)) -> (((i <= k) and (k <= j)) ->
  (int_iterate(op1, f, i, j) = ((op1[int_iterate(op1, f, i,
  k)])[int_iterate(op1, f, k, j)]))))))

logic fc9 : ('im,('im,'im) farray) farray, (int,'im) farray,
  (int,'im) farray -> (int,'im) farray

axiom fc_def9 :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall g:(int,'im) farray. forall k:int. ((fc9(op1, f,
  g)[k]) = ((op1[(f[k])])[(g[k])])))

axiom int_iterate_comp_iterate :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall g:(int,'im) farray. forall i:int. forall j:int. (assoc(op1) ->
  (op_neutral_right(op1, neutral_elt(op1)) -> (commut(op1) ->
  (int_iterate(op1, fc9(op1, f, g), i, j) = ((op1[int_iterate(op1, f, i,
  j)])[int_iterate(op1, g, i, j)]))))))

axiom int_iterate_attr_no_f :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall op2:('im2,('im2,'im2) farray) farray. forall t1:(int,'im1) farray.
  forall t2:(int,'im2) farray. forall f:('im1,'im2) farray. forall i:int.
  forall j:int.
  ((forall x:int.
   (forall y:'im1. (((op2[(t2[x])])[(f[y])]) = (f[((op1[(t1[x])])[y])])))) ->
  (((f[neutral_elt(op1)]) = neutral_elt(op2)) -> (assoc(op1) ->
  (assoc(op2) -> ((forall i1:int. ((f[(t1[i1])]) = (t2[i1]))) ->
  (int_iterate(op2, t2, i, j) = (f[int_iterate(op1, t1, i, j)]))))))))

logic fc10 : (int,'im1) farray, ('im1,'im2) farray -> (int,'im2) farray

axiom fc_def10 :
  (forall t:(int,'im1) farray. forall f:('im1,'im2) farray. forall e:int.
  ((fc10(t, f)[e]) = (f[(t[e])])))

axiom int_iterate_attr :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall op2:('im2,('im2,'im2) farray) farray. forall t:(int,'im1) farray.
  forall f:('im1,'im2) farray. forall i:int. forall j:int.
  ((forall x:int.
   (forall y:'im1. (((op2[(f[(t[x])])])[(f[y])]) = (f[((op1[(t[x])])[y])])))) ->
  (((f[neutral_elt(op1)]) = neutral_elt(op2)) -> (assoc(op1) ->
  (assoc(op2) -> (int_iterate(op2, fc10(t, f), i, j) = (f[int_iterate(op1, t,
  i, j)])))))))

logic fc11 : (int,'im1) farray, ('im1,'im2) farray -> (int,'im2) farray

axiom fc_def11 :
  (forall t:(int,'im1) farray. forall f:('im1,'im2) farray. forall e:int.
  ((fc11(t, f)[e]) = (f[(t[e])])))

axiom int_iterate_attr_comm :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall op2:('im2,('im2,'im2) farray) farray. forall t:(int,'im1) farray.
  forall f:('im1,'im2) farray. forall i:int. forall j:int.
  ((forall x:int.
   (forall y:'im1. (((op2[(f[(t[x])])])[(f[y])]) = (f[((op1[(t[x])])[y])])))) ->
  (((f[neutral_elt(op1)]) = neutral_elt(op2)) -> (assoc(op1) ->
  (assoc(op2) -> ((f[int_iterate(op1, t, i, j)]) = int_iterate(op2, fc11(t,
  f), i, j)))))))

axiom int_iterate_eq :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall g:(int,'im) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (int_iterate(op1, f, i, j) = int_iterate(op1, g, i, j))))

logic fc12 : (int,'im) farray, int, int -> (int,'im) farray

axiom fc_def12 :
  (forall f:(int,'im) farray. forall l:int. forall h:int. forall a:int.
  ((fc12(f, l, h)[a]) = (f[((h - (a + 1)) + l)])))

axiom int_iterate_left_right :
  (forall op1:('im,('im,'im) farray) farray. forall f:(int,'im) farray.
  forall l:int. forall k:int. forall h:int. (assoc(op1) -> (commut(op1) ->
  (((l <= k) and (k <= h)) -> (int_iterate(op1, f, l, k) = int_iterate(op1,
  fc12(f, l, h), ((h - k) + l), h))))))

axiom int_iterate_eq_func :
  (forall op1:('im,('im,'im) farray) farray. forall i:int. forall j:int.
  forall f1:(int,'im) farray. forall f2:(int,'im) farray. (iterable(op1) ->
  (p_injective(f1, to_fset(i, j)) -> (p_injective(f2, to_fset(i, j)) ->
  ((map(f1, to_fset(i, j)) = map(f2, to_fset(i, j))) -> (int_iterate(op1, f1,
  i, j) = int_iterate(op1, f2, i, j)))))))

logic fc13 : (int,int) farray, (int,'im) farray -> (int,'im) farray

axiom fc_def13 :
  (forall f:(int,int) farray. forall t:(int,'im) farray. forall b:int.
  ((fc13(f, t)[b]) = (t[(f[b])])))

axiom int_iterate_map :
  (forall op1:('im,('im,'im) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. forall f:(int,int) farray.
  forall t:(int,'im) farray. (iterable(op1) -> (p_bijective(f, to_fset(i, j),
  to_fset(k, l)) -> (int_iterate(op1, t, k, l) = int_iterate(op1, fc13(f, t),
  i, j)))))

logic fc14 : (int,int) farray, (int,'im) farray -> (int,'im) farray

axiom fc_def14 :
  (forall f:(int,int) farray. forall t:(int,'im) farray. forall b:int.
  ((fc14(f, t)[b]) = (t[(f[b])])))

axiom int_iterate_map_auto :
  (forall op1:('im,('im,'im) farray) farray. forall i:int. forall j:int.
  forall f:(int,int) farray. forall t:(int,'im) farray. (iterable(op1) ->
  (p_bijective(f, to_fset(i, j), to_fset(i, j)) -> (int_iterate(op1, t, i,
  j) = int_iterate(op1, fc14(f, t), i, j)))))

logic infix_pl_closure : (int,(int,int) farray) farray

logic infix_as_closure : (int,(int,int) farray) farray

axiom infix_pl_closure_def :
  (forall y:int. forall y1:int. (((infix_pl_closure[y])[y1]) = (y + y1)))

axiom infix_as_closure_def :
  (forall y:int. forall y1:int. (((infix_as_closure[y])[y1]) = (y * y1)))

axiom neutrals : (0 = neutral_elt(infix_pl_closure))

axiom neutrals1 : (1 = neutral_elt(infix_as_closure))

function isum(s: 'a set, t: ('a,int) farray) : int =
  iterate(infix_pl_closure, s, t)

axiom isum_iter : iterates(infix_pl_closure, 0)

axiom isum_iter__ : iterable(infix_pl_closure)

logic infix_mn_closure : (int,(int,int) farray) farray

axiom infix_mn_closure_def :
  (forall y:int. forall y1:int. (((infix_mn_closure[y])[y1]) = (y - y1)))

axiom isum_iter_ : opposite_n(infix_pl_closure, infix_mn_closure, 0)

axiom isum_iter_1 : opposite(infix_pl_closure, infix_mn_closure)

axiom isum_iter_2 : opposite_com(infix_pl_closure, infix_mn_closure)

axiom isum_iter_3 : inverse_tuple(infix_pl_closure, infix_mn_closure, 0)

axiom neutral_zero : (neutral_elt(infix_pl_closure) = 0)

function ind_isum(f: (int,int) farray, i: int, j: int) : int =
  int_iterate(infix_pl_closure, f, i, j)

axiom isum_to_iterate :
  (forall f:(int,int) farray. forall i:int. forall j:int. (ind_isum(f, i,
  j) = int_iterate(infix_pl_closure, f, i, j)))

axiom ind_isum_plus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_isum(f, i, j) = ((f[i]) + ind_isum(f, (i + 1), j)))))

logic fc15 : (int,(int,int) farray) farray

axiom fc_def15 : (forall y0:int. forall y1:int. (((fc15[y0])[y1]) = y0))

axiom ind_isum_const :
  (forall k:int. forall i:int. forall j:int. ((i <  j) ->
  (ind_isum((fc15[k]), i, j) = (k * (j - i)))))

axiom ind_isum_right_extension :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <= j) ->
  (ind_isum(f, i, (j + 1)) = (ind_isum(f, i, j) + (f[j])))))

axiom ind_isum_eq :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ind_isum(f, i, j) = ind_isum(g, i, j))))

axiom ind_isum_pos :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> (0 <= (f[k])))) ->
  (0 <= ind_isum(f, i, j)))))

function ind_iproduct(f: (int,int) farray, i: int, j: int) : int =
  int_iterate(infix_as_closure, f, i, j)

axiom ind_iproduct_eq :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ind_iproduct(f, i, j) = ind_iproduct(g, i, j))))

axiom iproduct_to_iterate :
  (forall f:(int,int) farray. forall i:int. forall j:int. (ind_iproduct(f, i,
  j) = int_iterate(infix_as_closure, f, i, j)))

logic fc16 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fc_def16 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc16(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map_auto :
  (forall i:int. forall j:int. forall f:(int,int) farray.
  forall t:(int,int) farray. (p_bijective(f, to_fset(i, j), to_fset(i, j)) ->
  (ind_isum(t, i, j) = ind_isum(fc16(f, t), i, j))))

logic fc17 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fc_def17 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc17(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,int) farray. (p_bijective(f,
  to_fset(i, j), to_fset(k, l)) -> (ind_isum(t, k, l) = ind_isum(fc17(f, t),
  i, j))))

logic fc18 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fc_def18 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc18(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map_auto_bij :
  (forall i:int. forall j:int. forall f:(int,int) farray.
  forall t:(int,int) farray.
  ((forall e:int. (((i <= e) and (e <  j)) -> ((i <= (f[e])) and
   ((f[e]) <  j)))) ->
  ((forall e:int. forall eqt:int. (((i <= e) and (e <  j)) ->
   (((i <= eqt) and (eqt <  j)) -> ((not (e = eqt)) ->
   (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:int. (((i <= eqt) and (eqt <  j)) ->
   (exists e:int. (((i <= e) and (e <  j)) and ((f[e]) = eqt))))) ->
  (ind_isum(t, i, j) = ind_isum(fc18(f, t), i, j))))))

logic fc19 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fc_def19 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc19(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map_bij :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,int) farray.
  ((forall e:int. (((i <= e) and (e <  j)) -> ((k <= (f[e])) and
   ((f[e]) <  l)))) ->
  ((forall e:int. forall eqt:int. (((i <= e) and (e <  j)) ->
   (((i <= eqt) and (eqt <  j)) -> ((not (e = eqt)) ->
   (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:int. (((k <= eqt) and (eqt <  l)) ->
   (exists e:int. (((i <= e) and (e <  j)) and ((f[e]) = eqt))))) ->
  (ind_isum(t, k, l) = ind_isum(fc19(f, t), i, j))))))

axiom ind_iproduct_empty :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((j <= i) ->
  (ind_iproduct(f, i, j) = 1)))

axiom ind_iproduct_plus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_iproduct(f, i, j) = ((f[i]) * ind_iproduct(f, (i + 1), j)))))

axiom ind_iproduct_right_extension :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_iproduct(f, i, j) = (ind_iproduct(f, i, (j - 1)) * (f[(j - 1)])))))

axiom ind_iproduct_right_extension_comm :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  ((ind_iproduct(f, i, (j - 1)) * (f[(j - 1)])) = ind_iproduct(f, i, j))))

axiom positive_iproduct :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> (0 <  (f[k])))) ->
  (0 <  ind_iproduct(f, i, j))))

logic fc20 : (int,int) farray, int, int -> (int,int) farray

axiom fc_def20 :
  (forall f:(int,int) farray. forall l:int. forall h:int. forall a:int.
  ((fc20(f, l, h)[a]) = (f[((h - (a + 1)) + l)])))

axiom ind_iproduct_left_right :
  (forall f:(int,int) farray. forall l:int. forall k:int. forall h:int.
  (((l <= k) and (k <= h)) -> (ind_iproduct(f, l, k) = ind_iproduct(fc20(f,
  l, h), ((h - k) + l), h))))

axiom iterable_imult : iterable(infix_as_closure)

logic fc21 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fc_def21 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc21(f, t)[b]) = (t[(f[b])])))

axiom ind_iproduct_map_auto :
  (forall i:int. forall j:int. forall f:(int,int) farray.
  forall t:(int,int) farray. (p_bijective(f, to_fset(i, j), to_fset(i, j)) ->
  (ind_iproduct(t, i, j) = ind_iproduct(fc21(f, t), i, j))))

logic fc22 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fc_def22 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc22(f, t)[b]) = (t[(f[b])])))

axiom ind_iproduct_map :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,int) farray. (p_bijective(f,
  to_fset(i, j), to_fset(k, l)) -> (ind_iproduct(t, k,
  l) = ind_iproduct(fc22(f, t), i, j))))

axiom ind_iproduct_trans :
  (forall f:(int,int) farray. forall i:int. forall k:int. forall j:int.
  (((i <= k) and (k <= j)) -> (ind_iproduct(f, i, j) = (ind_iproduct(f, i,
  k) * ind_iproduct(f, k, j)))))

logic fc23 : (int,int) farray, int -> (int,int) farray

axiom fc_def23 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc23(f,
  a)[i]) = (a * (f[i]))))

axiom ind_isum_scal :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall a:int.
  ((i <= j) -> (ind_isum(fc23(f, a), i, j) = (a * ind_isum(f, i, j)))))

axiom ind_isum_bound :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) <  (g[k])))) ->
  (ind_isum(f, i, j) <  ind_isum(g, i, j)))))

axiom comp_trans_equal_strict :
  (forall a:int. forall b:int. forall c:int. ((a <= b) -> ((b <  c) ->
  (a <  c))))

axiom ind_isum_bound_eq :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) <= (g[k])))) ->
  (ind_isum(f, i, j) <= ind_isum(g, i, j)))))

logic fc24 : (int,int) farray, int -> (int,int) farray

axiom fc_def24 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc24(f,
  a)[i]) = (a * (f[i]))))

axiom ind_isum_scal_gen :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  (forall a:int. (((i <= a) and (a <  j)) -> (ind_isum(fc24(f, a), i,
  j) = (a * ind_isum(f, i, j))))))

axiom ind_isum_trans :
  (forall f:(int,int) farray. forall i:int. forall k:int. forall j:int.
  (((i <= k) and (k <= j)) -> (ind_isum(f, i, j) = (ind_isum(f, i,
  k) + ind_isum(f, k, j)))))

logic power : int, int -> int

axiom Power_one : (forall i:int. (power(i, 1) = i))

axiom Power_sum :
  (forall x:int. forall y:int. forall i:int. (power(i, (x + y)) = (power(i,
  x) * power(i, y))))

axiom power_plus_one :
  (forall e:int. forall i:int. (power(e, (i + 1)) = (e * power(e, i))))

logic i : int

axiom H : (1 <= i)

axiom H1 : (not (i = 1))

logic o : (int,int) farray

axiom o_def :
  (forall k:int. (((1 <= k) and (k <  (i + 1))) -> ((o[k]) = power(2,
  (k - 1)))))

axiom o_def1 :
  (forall k:int. ((not ((1 <= k) and (k <  (i + 1)))) -> ((o[k]) = 0)))

axiom H2 : (ind_isum(o, 1, i) = ((o[1]) + ind_isum(o, (1 + 1), i)))

goal h : false

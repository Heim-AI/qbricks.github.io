(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require map.Map.

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter tzero: t.

Parameter tone: t.

Parameter infix_asdt: t -> t -> t.

Parameter infix_pldt: t -> t -> t.

Parameter infix_lseqdt: t -> t -> Prop.

Parameter prefix_mn: t -> t.

Axiom Assoc :
  forall (x:t) (y:t) (z:t),
  ((infix_pldt (infix_pldt x y) z) = (infix_pldt x (infix_pldt y z))).

Axiom Unit_def_l : forall (x:t), ((infix_pldt tzero x) = x).

Axiom Unit_def_r : forall (x:t), ((infix_pldt x tzero) = x).

Axiom Inv_def_l : forall (x:t), ((infix_pldt (prefix_mn x) x) = tzero).

Axiom Inv_def_r : forall (x:t), ((infix_pldt x (prefix_mn x)) = tzero).

Axiom Comm : forall (x:t) (y:t), ((infix_pldt x y) = (infix_pldt y x)).

Axiom Assoc1 :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt (infix_asdt x y) z) = (infix_asdt x (infix_asdt y z))).

Axiom Mul_distr_l :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt x (infix_pldt y z)) =
   (infix_pldt (infix_asdt x y) (infix_asdt x z))).

Axiom Mul_distr_r :
  forall (x:t) (y:t) (z:t),
  ((infix_asdt (infix_pldt y z) x) =
   (infix_pldt (infix_asdt y x) (infix_asdt z x))).

Axiom Comm1 : forall (x:t) (y:t), ((infix_asdt x y) = (infix_asdt y x)).

Axiom Unitary : forall (x:t), ((infix_asdt tone x) = x).

Axiom NonTrivialRing : ~ (tzero = tone).

Axiom Refl : forall (x:t), infix_lseqdt x x.

Axiom Trans :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (infix_lseqdt y z) ->
  infix_lseqdt x z.

Axiom Antisymm :
  forall (x:t) (y:t), (infix_lseqdt x y) -> (infix_lseqdt y x) -> (x = y).

(* Why3 assumption *)
Definition infix_mndt (x:t) (y:t) : t := infix_pldt x (prefix_mn y).

(* Why3 assumption *)
Definition infix_lsdt (i:t) (j:t) : Prop := (infix_lseqdt i j) /\ ~ (i = j).

Parameter requal: t -> t -> bool.

Axiom requal_spec : forall (a:t) (b:t), ((requal a b) = true) <-> (a = b).

Axiom ZeroLessOne : infix_lsdt tzero tone.

Axiom absorbing_zero : forall (i:t), ((infix_asdt i tzero) = tzero).

(* Why3 assumption *)
Definition comparable (a:t) (b:t) : Prop :=
  (infix_lseqdt a b) \/ (infix_lseqdt b a).

Axiom Transitive_comparable :
  forall (x:t) (y:t) (z:t), (comparable x y) -> (comparable y z) ->
  comparable x z.

Axiom Unitary_comparable :
  forall (x:t) (y:t), (comparable x y) ->
  (comparable x tzero) /\ (comparable x tone).

Axiom CompatStrictOrderAdd :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (comparable x z) ->
  infix_lsdt (infix_pldt x z) (infix_pldt y z).

Axiom notZeroAdd :
  forall (x:t) (y:t), ~ (x = tzero) -> ~ ((infix_pldt x y) = y).

Axiom CompatOrderMult :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (infix_lsdt tzero z) ->
  infix_lsdt (infix_asdt x z) (infix_asdt y z).

Axiom compatStrictOrderMultComm :
  forall (x:t) (y:t) (z:t), (infix_lsdt x y) -> (infix_lsdt tzero z) ->
  infix_lsdt (infix_asdt z x) (infix_asdt z y).

Axiom compatOrderMult :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (infix_lseqdt tzero z) ->
  infix_lseqdt (infix_asdt x z) (infix_asdt y z).

Axiom compatOrderMultComm :
  forall (x:t) (y:t) (z:t), (infix_lseqdt x y) -> (infix_lseqdt tzero z) ->
  infix_lseqdt (infix_asdt z x) (infix_asdt z y).

Parameter inv: t -> t.

Axiom Inverse :
  forall (x:t), ~ (x = tzero) -> ((infix_asdt x (inv x)) = tone).

(* Why3 assumption *)
Definition infix_sldt (x:t) (y:t) : t := infix_asdt x (inv y).

Axiom add_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sldt (infix_pldt x y) z) =
   (infix_pldt (infix_sldt x z) (infix_sldt y z))).

Axiom sub_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sldt (infix_mndt x y) z) =
   (infix_mndt (infix_sldt x z) (infix_sldt y z))).

Axiom neg_div :
  forall (x:t) (y:t), ~ (y = tzero) ->
  ((infix_sldt (prefix_mn x) y) = (prefix_mn (infix_sldt x y))).

Axiom assoc_mul_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sldt (infix_asdt x y) z) = (infix_asdt x (infix_sldt y z))).

Axiom assoc_div_mul :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sldt (infix_sldt x y) z) = (infix_sldt x (infix_asdt y z))).

Axiom assoc_div_div :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sldt x (infix_sldt y z)) = (infix_sldt (infix_asdt x z) y)).

Axiom inv_mult :
  forall (x:t) (y:t), ~ (x = tzero) -> ~ (y = tzero) ->
  ((infix_asdt (infix_sldt tone x) (infix_sldt tone y)) =
   (infix_sldt tone (infix_asdt x y))).

Axiom set : forall (a:Type), Type.
Parameter set_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set a).
Existing Instance set_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> Prop.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom infix_eqeq_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (infix_eqeq s1 s2) <-> forall (x:a), (mem x s1) <-> (mem x s2).

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq s1 s2) -> (s1 = s2).

Parameter subset:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (subset s1 s2) <-> forall (x:a), (mem x s1) -> mem x s2.

Axiom subset_refl :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set a), subset s s.

Axiom subset_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (s3:set a), (subset s1 s2) ->
  (subset s2 s3) -> subset s1 s3.

Parameter is_empty: forall {a:Type} {a_WT:WhyType a}, (set a) -> Prop.

Axiom is_empty_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (is_empty s) <-> forall (x:a), ~ (mem x s).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, set a.

Axiom empty_def : forall {a:Type} {a_WT:WhyType a}, is_empty (empty : set a).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom add_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (add x s)) <-> ((y = x) \/ (mem y s)).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom remove_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (remove x s)) <-> (~ (y = x) /\ (mem y s)).

Axiom add_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), (mem x s) -> ((add x (remove x s)) = s).

Axiom remove_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), ((remove x (add x s)) = (remove x s)).

Axiom subset_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), subset (remove x s) s.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (union s1 s2)) <-> ((mem x s1) \/ (mem x s2)).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom inter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (inter s1 s2)) <-> ((mem x s1) /\ (mem x s2)).

Parameter diff:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom diff_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (diff s1 s2)) <-> ((mem x s1) /\ ~ (mem x s2)).

Axiom subset_diff :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), subset (diff s1 s2) s1.

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom choose_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> mem (choose s) s.

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set a) -> Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (0%Z <= (cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 0%Z) <-> (is_empty s).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), ~ (mem x s) ->
  ((cardinal (add x s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), (mem x s) ->
  ((cardinal s) = (1%Z + (cardinal (remove x s)))%Z).

Axiom cardinal_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) <= (cardinal s2))%Z.

Axiom subset_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) = (cardinal s2)) -> infix_eqeq s1 s2.

Axiom cardinal1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) ->
  (x = (choose s)).

(* Why3 assumption *)
Definition terms := Z -> t.

Axiom add_zero_left : forall (a:t), ((infix_pldt tzero a) = a).

Axiom add_zero_right : forall (a:t), ((infix_pldt a tzero) = a).

Axiom add_assoc :
  forall (a:t) (b:t) (c:t),
  ((infix_pldt (infix_pldt a b) c) = (infix_pldt a (infix_pldt b c))).

Axiom add_refl : forall (a:t) (b:t), ((infix_pldt a b) = (infix_pldt b a)).

Axiom add_tzero_left_c :
  forall (a:t) (b:t), ((infix_pldt a b) = a) -> (b = tzero).

Axiom opposite : forall (a:t), ((infix_mndt a a) = tzero).

Axiom substract :
  forall (a:t) (b:t), ((infix_mndt a b) = (infix_pldt a (prefix_mn b))).

Axiom substraction :
  forall (a:t) (b:t),
  ((infix_mndt (infix_pldt a b) b) = a) /\
  ((infix_pldt (infix_mndt a b) b) = a).

Axiom minus_zero : forall (a:t), ((infix_mndt a tzero) = a).

Axiom unic :
  forall (a:t) (b:t) (c:t), ((infix_pldt a b) = (infix_pldt a c)) -> (b = c).

Axiom substract_comm :
  forall (a:t) (b:t),
  ((infix_mndt (infix_pldt a b) a) = b) /\
  ((infix_mndt (infix_pldt b a) a) = b).

Parameter sequal: t -> t -> bool.

Axiom sequal_spec : forall (a:t) (b:t), ((sequal a b) = true) <-> (a = b).

Axiom mul_one_left : forall (a:t), ((infix_asdt tone a) = a).

Axiom mul_one_right : forall (a:t), ((infix_asdt a tone) = a).

Axiom mul_assoc :
  forall (a:t) (b:t) (c:t),
  ((infix_asdt (infix_asdt a b) c) = (infix_asdt a (infix_asdt b c))).

Axiom mul_refl : forall (a:t) (b:t), ((infix_asdt a b) = (infix_asdt b a)).

Parameter sum: (Z -> t) -> Z -> Z -> t.

Axiom sum_def :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((j <= i)%Z -> ((sum f i j) = tzero)) /\
  (~ (j <= i)%Z -> ((sum f i j) = (infix_pldt (f i) (sum f (i + 1%Z)%Z j)))).

Axiom Sum_def_empty :
  forall (f:Z -> t) (i:Z) (j:Z), (j <= i)%Z -> ((sum f i j) = tzero).

Axiom Sum_def_non_empty :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((sum f i j) = (infix_pldt (f i) (sum f (i + 1%Z)%Z j))).

Axiom sum_right_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((sum f i j) = (infix_pldt (sum f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom sum_transitivity :
  forall (f:Z -> t) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((sum f i j) = (infix_pldt (sum f i k) (sum f k j))).

Axiom sum_eq :
  forall (f1:Z -> t) (f2:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f1 k) = (f2 k))) ->
  ((sum f1 i j) = (sum f2 i j)).

Axiom sum_lambda_eq :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((sum f i j) = (sum (fun (k:Z) => (f k)) i j)).

Axiom sum_plus_sum :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  ((infix_pldt (sum f i j) (sum g i j)) =
   (sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j)).

Axiom sum_plus_sum_comm :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  ((sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j) =
   (infix_pldt (sum f i j) (sum g i j))).

Axiom sum_plus_sum_lambdas :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  ((infix_pldt (sum (fun (k:Z) => (f k)) i j) (sum (fun (k:Z) => (g k)) i j))
   = (sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j)).

Axiom sum_plus_sum_comm_lambdas :
  forall (f:Z -> t) (g:Z -> t) (i:Z) (j:Z),
  ((sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j) =
   (infix_pldt (sum (fun (k:Z) => (f k)) i j) (sum (fun (k:Z) => (g k)) i j))).

Axiom sum_lambda_eq_comm :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((sum (fun (k:Z) => (f k)) i j) = (sum f i j)).

(* Why3 assumption *)
Definition tterms := Z -> Z -> t.

Parameter sum_sum: (Z -> Z -> t) -> Z -> Z -> Z -> Z -> t.

Axiom sum_sum_def :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z),
  ((j <= i)%Z -> ((sum_sum f i j k l) = tzero)) /\
  (~ (j <= i)%Z ->
   ((sum_sum f i j k l) =
    (infix_pldt (sum (f i) k l) (sum_sum f (i + 1%Z)%Z j k l)))).

Axiom sum_sum_spec :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z),
  ((sum_sum f i j k l) =
   (sum (fun (m:Z) => (sum (fun (n:Z) => ((f m) n)) k l)) i j)).

Axiom sum_sum_spec_comm :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z),
  ((sum (fun (m:Z) => (sum (fun (n:Z) => ((f m) n)) k l)) i j) =
   (sum_sum f i j k l)).

Axiom Sum_sum_def_empty :
  forall (f:Z -> Z -> t) (k:Z) (l:Z) (i:Z) (j:Z), (j <= i)%Z -> (k <= l)%Z ->
  ((sum_sum f i j k l) = tzero).

Axiom Sum_sum_def_non_empty :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z), (i < j)%Z -> (k < l)%Z ->
  ((sum_sum f i j k l) =
   (infix_pldt (sum (f i) k l) (sum_sum f (i + 1%Z)%Z j k l))).

Axiom sum_sum_right_extension :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z), (i < j)%Z -> (k < l)%Z ->
  ((sum_sum f i j k l) =
   (infix_pldt (sum_sum f i (j - 1%Z)%Z k l) (sum (f (j - 1%Z)%Z) k l))).

Axiom sum_sum_transitivity :
  forall (f:Z -> Z -> t) (i:Z) (m:Z) (j:Z) (k:Z) (l:Z),
  ((i <= m)%Z /\ (m <= j)%Z) -> (k <= l)%Z ->
  ((sum_sum f i j k l) =
   (infix_pldt (sum_sum f i m k l) (sum_sum f m j k l))).

Axiom sum_sum_eq :
  forall (f1:Z -> Z -> t) (f2:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z),
  (forall (m:Z) (n:Z), ((i <= m)%Z /\ (m < j)%Z) ->
   ((k <= n)%Z /\ (n < l)%Z) -> (((f1 m) n) = ((f2 m) n))) ->
  ((sum_sum f1 i j k l) = (sum_sum f2 i j k l)).

Axiom sum_sum_lambda_eq :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z),
  ((sum_sum f i j k l) = (sum_sum (fun (m:Z) (n:Z) => ((f m) n)) i j k l)).

Axiom sum_sum_lambda_eq_comm :
  forall (f:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z),
  ((sum_sum (fun (m:Z) (n:Z) => ((f m) n)) i j k l) = (sum_sum f i j k l)).

Parameter product: (Z -> t) -> Z -> Z -> t.

Axiom product_def :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((j <= i)%Z -> ((product f i j) = tone)) /\
  (~ (j <= i)%Z ->
   ((product f i j) = (infix_asdt (f i) (product f (i + 1%Z)%Z j)))).

Axiom Product_def_empty :
  forall (f:Z -> t) (i:Z) (j:Z), (j <= i)%Z -> ((product f i j) = tone).

Axiom Product_def_non_empty :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((product f i j) = (infix_asdt (f i) (product f (i + 1%Z)%Z j))).

Axiom product_right_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((product f i j) = (infix_asdt (product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom product_right_extension_comm :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((infix_asdt (product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z)) = (product f i j)).

Axiom product_transitivity :
  forall (f:Z -> t) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((product f i j) = (infix_asdt (product f i k) (product f k j))).

Axiom product_eq :
  forall (f1:Z -> t) (f2:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f1 k) = (f2 k))) ->
  ((product f1 i j) = (product f2 i j)).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

(* Why3 assumption *)
Definition sterms (a:Type) := a -> t.

Parameter ssum: forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> t) -> t.

Axiom Ssum_def_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> t), ((ssum (empty : set a) f) = tzero).

Axiom ssum_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal s) = 0%Z) -> ((ssum s t1) = tzero).

Axiom Ssum_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), forall (f:a -> t), forall (x:a), ~ (mem x s) ->
  ((ssum (add x s) f) = (infix_pldt (ssum s f) (f x))).

Axiom ssum_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (x:a), ~ (mem x s) ->
  ((ssum (add x s) f) = (infix_pldt (ssum s f) (f x))).

Axiom induction :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:(set a) -> bool) (t1:set a),
  (forall (s:set a), (is_empty s) -> ((p s) = true)) ->
  (forall (s:set a), ((p s) = true) -> forall (t2:a), ~ (mem t2 s) ->
   ((p (add t2 s)) = true)) ->
  ((p t1) = true).

Axiom ssum_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (x:a), (mem x s) ->
  ((ssum (remove x s) f) = (infix_mndt (ssum s f) (f x))).

Axiom ssum_def_choose :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t), ~ (is_empty s) ->
  ((ssum s f) = (infix_pldt (f (choose s)) (ssum (remove (choose s) s) f))).

Axiom choose_any :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (t1:a), (mem t1 s) ->
  ((ssum s f) = (infix_pldt (f t1) (ssum (remove t1 s) f))).

Axiom ssum_plus_ssum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (f:a -> t) (g:a -> t),
  ((ssum s1 (fun (k:a) => (infix_pldt (f k) (g k)))) =
   (infix_pldt (ssum s1 (fun (k:a) => (f k))) (ssum s1 (fun (k:a) => (g k))))).

Axiom ssum_plus_ssum_com :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (f:a -> t) (g:a -> t),
  ((infix_pldt (ssum s1 (fun (k:a) => (f k))) (ssum s1 (fun (k:a) => (g k))))
   = (ssum s1 (fun (k:a) => (infix_pldt (f k) (g k))))).

Axiom ssum_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (f:a -> t),
  ((ssum (union s1 s2) f) =
   (infix_mndt (infix_pldt (ssum s1 f) (ssum s2 f)) (ssum (inter s1 s2) f))).

Axiom ssum_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (t1:a -> t),
  ((inter s1 s2) = (empty : set a)) ->
  ((ssum (union s1 s2) t1) = (infix_pldt (ssum s1 t1) (ssum s2 t1))).

Axiom ssum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> t) (g:a -> t),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> ((ssum s f) = (ssum s g)).

Parameter filter:
  forall {a:Type} {a_WT:WhyType a}, (a -> bool) -> (set a) -> set a.

Axiom filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), forall (x:a),
  (mem x (filter p u)) <-> (((p x) = true) /\ (mem x u)).

Axiom filter_cardinal :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), ((cardinal (filter p u)) <= (cardinal u))%Z.

Parameter map:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> set b.

Axiom map_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (y:b),
  (mem y (map f u)) <-> exists x:a, (mem x u) /\ (y = (f x)).

Axiom map_def2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (x:a), (mem x u) -> mem (f x) (map f u).

Axiom map_cardinal :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((cardinal (map f u)) <= (cardinal u))%Z.

Parameter result: forall {a:Type} {a_WT:WhyType a}, (a -> t) -> a -> bool.

Axiom result_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (t1:a -> t) (a1:a),
  (((result t1) a1) = true) <-> ~ ((t1 a1) = tzero).

(* Why3 assumption *)
Definition nonnull_part {a:Type} {a_WT:WhyType a} (s:set a) (t1:a -> t) :
    set a :=
  filter (result t1) s.

Axiom nonnull_part_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (a1:a),
  (mem a1 (nonnull_part s t1)) <-> ((mem a1 s) /\ ~ ((t1 a1) = tzero)).

Parameter result1: forall {a:Type} {a_WT:WhyType a}, (a -> t) -> a -> bool.

Axiom result_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (t1:a -> t) (a1:a), (((result1 t1) a1) = true) <-> ((t1 a1) = tzero).

(* Why3 assumption *)
Definition null_part {a:Type} {a_WT:WhyType a} (s:set a) (t1:a -> t) : set a :=
  filter (result1 t1) s.

Axiom null_part_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), forall (a1:a),
  (mem a1 (null_part s t1)) <-> ((mem a1 s) /\ ((t1 a1) = tzero)).

Axiom nullity_partition :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  (s = (union (nonnull_part s t1) (null_part s t1))) /\
  ((inter (nonnull_part s t1) (null_part s t1)) = (empty : set a)).

Axiom ssum_zeros :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t),
  (forall (a1:a), (mem a1 s) -> ((t1 a1) = tzero)) -> ((ssum s t1) = tzero).

Axiom ssum_nullity_partition :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((ssum s t1) = (ssum (nonnull_part s t1) t1)).

Parameter element: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom element_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> ((element s) = (choose s)).

Axiom sum_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal s) = 1%Z) ->
  ((ssum s t1) = (t1 (element s))).

Axiom sum_cardzero :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t1:a -> t), ((cardinal s) = 0%Z) -> ((ssum s t1) = tzero).

Axiom cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((cardinal s) = 1%Z) /\ ((element s) = a1).

Axiom union_exchange :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ~ (is_empty s') ->
  ((union (add (choose s') s) (remove (choose s') s')) = (union s s')).

Axiom union_empty_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((cardinal s') = 0%Z) -> ((union s s') = s).

Axiom union_empty_left :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((cardinal s) = 0%Z) -> ((union s s') = s').

Parameter union_bui:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_bui_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((union_bui s s') = (union s s')).

Axiom union_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((union s (add x s')) = (add x (union s s'))).

Axiom union_add_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((add x (union s s')) = (union s (add x s'))).

Axiom inter_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (s = (empty : set a)) ->
  ((inter s s') = (empty : set a)).

Axiom inter_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (s' = (empty : set a)) ->
  ((inter s s') = (empty : set a)).

Parameter to_fset: Z -> Z -> set Z.

Axiom to_fset_spec :
  forall (i:Z) (j:Z),
  ((i <= j)%Z -> ((cardinal (to_fset i j)) = (j - i)%Z)) /\
  (((j < i)%Z -> ((cardinal (to_fset i j)) = 0%Z)) /\
   forall (k:Z), (mem k (to_fset i j)) <-> ((i <= k)%Z /\ (k < j)%Z)).

Axiom to_fset_unit_ext :
  forall (i:Z) (j:Z), (i < j)%Z ->
  ((to_fset i j) = (add i (to_fset (i + 1%Z)%Z j))).

Axiom to_fset_ext :
  forall (i:Z) (i':Z) (j:Z), ((i <= i')%Z /\ (i' <= j)%Z) ->
  ((to_fset i j) = (union (to_fset i i') (to_fset i' j))).

Parameter inverse_pair_set: (set (Z* Z)%type) -> set (Z* Z)%type.

Axiom inverse_pair_set_spec :
  forall (s:set (Z* Z)%type), forall (i:Z) (j:Z),
  (mem (j, i) s) <-> (mem (i, j) (inverse_pair_set s)).

Axiom sum_eq_sum :
  forall (t1:Z -> t) (i:Z) (j:Z), ((ssum (to_fset i j) t1) = (sum t1 i j)).

Axiom cardinal_sum_empty_inter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((inter s s') = (empty : set a)) ->
  ((cardinal (union s s')) = ((cardinal s) + (cardinal s'))%Z).

Parameter to_f_p_set_left: Z -> Z -> Z -> set (Z* Z)%type.

Axiom to_f_p_set_left_spec :
  forall (i:Z) (j:Z) (n:Z),
  ((i <= j)%Z -> ((cardinal (to_f_p_set_left i j n)) = (j - i)%Z)) /\
  (((j < i)%Z -> ((cardinal (to_f_p_set_left i j n)) = 0%Z)) /\
   forall (m:Z) (o:Z),
   (mem (m, o) (to_f_p_set_left i j n)) <->
   ((o = n) /\ (mem m (to_fset i j)))).

Axiom pair_left_sum :
  forall (i:Z) (j:Z) (k:Z) (t1:(Z* Z)%type -> t),
  ((ssum (to_fset i j) (fun (b:Z) => (t1 (b, k)))) =
   (ssum (to_f_p_set_left i j k) t1)).

Parameter indexed_union:
  forall {a:Type} {a_WT:WhyType a}, (Z -> set a) -> Z -> Z -> set a.

Axiom indexed_union_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (t1:Z -> set a) (i:Z) (j:Z),
  ((j <= i)%Z -> ((indexed_union t1 i j) = (empty : set a))) /\
  (~ (j <= i)%Z ->
   ((indexed_union t1 i j) = (union (t1 i) (indexed_union t1 (i + 1%Z)%Z j)))).

Axiom indexed_union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (t1:Z -> set a) (i:Z) (j:Z), forall (a1:a),
  (mem a1 (indexed_union t1 i j)) <->
  exists k:Z, ((i <= k)%Z /\ (k < j)%Z) /\ (mem a1 (t1 k)).

Parameter to_f_p_set: Z -> Z -> Z -> Z -> set (Z* Z)%type.

Axiom to_f_p_set_spec :
  forall (i:Z) (j:Z) (k:Z) (l:Z), (i <= j)%Z -> (k <= l)%Z ->
  (((i <= j)%Z /\ (k <= l)%Z) ->
   ((cardinal (to_f_p_set i j k l)) = ((j - i)%Z * (l - k)%Z)%Z)) /\
  ((((j < i)%Z \/ (l < k)%Z) -> ((cardinal (to_f_p_set i j k l)) = 0%Z)) /\
   ((forall (m:Z) (n:Z),
     (mem (m, n) (to_f_p_set i j k l)) <->
     (((i <= m)%Z /\ (m < j)%Z) /\ ((k <= n)%Z /\ (n < l)%Z))) /\
    ((to_f_p_set i j k l) =
     (indexed_union (fun (m:Z) => (to_f_p_set_left i j m)) k l)))).

Axiom empty_intersections_f_p_set :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (m:Z) (n:Z), ~ (m = n) ->
  ((inter (to_f_p_set_left i j m) (to_f_p_set_left k l n)) =
   (empty : set (Z* Z)%type)).

Axiom empty_intersections_f_p_set_unions :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (m:Z), ~ ((k <= m)%Z /\ (m < l)%Z) ->
  ((inter (to_f_p_set_left i j m)
    (indexed_union (fun (n:Z) => (to_f_p_set_left i j n)) k l))
   = (empty : set (Z* Z)%type)).

(* Why3 assumption *)
Definition inv_func (t1:(Z* Z)%type -> t) (o:(Z* Z)%type) : t :=
  match o with
  | (i, j) => t1 (j, i)
  end.

Axiom inv_sum :
  forall (s:set (Z* Z)%type) (t1:(Z* Z)%type -> t),
  ((ssum s t1) =
   (ssum (inverse_pair_set s)
    ((fun (y0:(Z* Z)%type -> t) (y1:(Z* Z)%type) => (inv_func y0 y1)) t1))).

Axiom sum_eq_sum_pair :
  forall (t1:(Z* Z)%type -> t) (i:Z) (j:Z) (k:Z) (l:Z), (i <= j)%Z ->
  (k <= l)%Z ->
  ((ssum (to_f_p_set i j k l) t1) =
   (sum_sum (fun (a:Z) (b:Z) => (t1 (b, a))) k l i j)).

Axiom comm_sum :
  forall (t1:(Z* Z)%type -> t) (i:Z) (j:Z) (k:Z) (l:Z), (i <= j)%Z ->
  (k <= l)%Z ->
  ((sum_sum (fun (a:Z) (b:Z) => (t1 (b, a))) i j k l) =
   (sum_sum (fun (a:Z) (b:Z) => (t1 (a, b))) k l i j)).

Axiom sum_eq_sum_pair_comm :
  forall (t1:(Z* Z)%type -> t) (i:Z) (j:Z) (k:Z) (l:Z), (i <= j)%Z ->
  (k <= l)%Z ->
  ((ssum (to_f_p_set i j k l) t1) =
   (sum_sum (fun (a:Z) (b:Z) => (t1 (a, b))) i j k l)).

(* Why3 assumption *)
Definition matrix (a:Type) := Z -> Z -> a.

Parameter rows: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z.

Axiom rows_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (0%Z < (rows m))%Z.

Parameter columns: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z.

Axiom columns_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (0%Z < (columns m))%Z.

(* Why3 assumption *)
Definition valid_index {a:Type} {a_WT:WhyType a} (a1:Z -> Z -> a) (r:Z)
    (c:Z) : Prop :=
  ((0%Z <= r)%Z /\ (r < (rows a1))%Z) /\
  ((0%Z <= c)%Z /\ (c < (columns a1))%Z).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z -> Z -> a.

Axiom get_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z), (valid_index a1 r c) ->
  ((get a1 r c) = ((a1 r) c)).

Parameter make: forall {a:Type} {a_WT:WhyType a}, Z -> Z -> a -> Z -> Z -> a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (v:a), ((0%Z <= r)%Z /\ (0%Z <= c)%Z) ->
  ((rows (make r c v)) = r) /\
  (((columns (make r c v)) = c) /\
   forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
   ((((make r c v) i) j) = v)).

Parameter set1:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z -> Z -> a ->
  Z -> Z -> a.

Axiom set_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((set1 a1 r c v) = (map.Map.set a1 r (map.Map.set (a1 r) c v))).

Axiom set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((rows (set1 a1 r c v)) = (rows a1)) /\
  (((columns (set1 a1 r c v)) = (columns a1)) /\
   ((forall (i:Z) (j:Z), (valid_index a1 i j) ->
     (((i = r) /\ (j = c)) -> ((((set1 a1 r c v) i) j) = v)) /\
     (~ ((i = r) /\ (j = c)) -> ((((set1 a1 r c v) i) j) = ((a1 i) j)))) /\
    (((((set1 a1 r c v) r) c) = v) /\
     ((forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (i = r) ->
       ((((set1 a1 r c v) i) j) = ((a1 i) j))) /\
      forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (j = c) ->
      ((((set1 a1 r c v) i) j) = ((a1 i) j)))))).

Parameter equal:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> (Z -> Z -> a) -> Prop.

Axiom equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a),
  (equal m n) <->
  ((((rows m) = (rows n)) /\ ((columns m) = (columns n))) /\
   forall (i:Z) (j:Z), (valid_index m i j) -> (((m i) j) = ((n i) j))).

Parameter square: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Prop.

Axiom square_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (square m) <-> ((rows m) = (columns m)).

Axiom equal_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a), (equal m n) <-> (equal n m).

Axiom equal_rex :
  forall {a:Type} {a_WT:WhyType a}, forall (m:Z -> Z -> a), equal m m.

Axiom equal_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a) (o:Z -> Z -> a), (equal m n) ->
  (equal n o) -> equal m o.

Parameter equal_funct:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> Z -> a) ->
  (Z -> Z -> Z -> a) -> Prop.

Axiom equal_mat_funct :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> Z -> Z -> a) (g:Z -> Z -> Z -> a), forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < j)%Z) ->
  (equal_funct f g) <->
  forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> equal (f k) (g k).

Parameter indic: Z -> Z -> t.

Axiom indic_def :
  forall (i:Z) (j:Z),
  ((i = j) -> ((indic i j) = tone)) /\ (~ (i = j) -> ((indic i j) = tzero)).

Axiom indic_comm : forall (i:Z) (j:Z), ((indic i j) = (indic j i)).

Parameter indic_2: Z -> Z -> Z -> Z -> t.

Axiom indic_2_def :
  forall (i:Z) (j:Z) (il:Z) (jl:Z),
  (((i = j) /\ (il = jl)) -> ((indic_2 i j il jl) = tone)) /\
  (~ ((i = j) /\ (il = jl)) -> ((indic_2 i j il jl) = tzero)).

Axiom indic_2_spec :
  forall (i:Z) (j:Z) (il:Z) (jl:Z),
  ((indic_2 i j il jl) = (infix_asdt (indic i j) (indic il jl))).

Axiom indic_2_comm :
  forall (i:Z) (j:Z) (il:Z) (kl:Z),
  ((indic_2 i j il kl) = (indic_2 j i il kl)) /\
  (((indic_2 i j il kl) = (indic_2 i j kl il)) /\
   ((indic_2 i j il kl) = (indic_2 j i kl il))).

Parameter sum_function_indic: (Z -> t) -> Z -> Z -> Z -> t.

Axiom sum_function_indic_def :
  forall (f:Z -> t) (i:Z) (l:Z) (h:Z),
  ((0%Z <= l)%Z /\ ((l <= i)%Z /\ (i < h)%Z)) ->
  ((sum_function_indic f i l h) =
   (sum (fun (k:Z) => (infix_asdt (f k) (indic k i))) l h)).

Axiom sum_function_indic_spec :
  forall (f:Z -> t) (i:Z) (l:Z) (h:Z),
  ((0%Z <= l)%Z /\ ((l <= i)%Z /\ (i < h)%Z)) ->
  ((sum_function_indic f i l h) = (f i)).

Parameter sum_sum_function_indic:
  (Z -> Z -> t) -> Z -> Z -> Z -> Z -> Z -> Z -> t.

Axiom sum_sum_function_indic_def :
  forall (f:Z -> Z -> t) (i:Z) (l:Z) (h:Z) (il:Z) (ll:Z) (hl:Z),
  ((0%Z <= l)%Z /\ ((l <= i)%Z /\ (i < h)%Z)) ->
  ((0%Z <= ll)%Z /\ ((ll <= il)%Z /\ (il < hl)%Z)) ->
  ((sum_sum_function_indic f i l h il ll hl) =
   (sum_sum (fun (k:Z) (kl:Z) => (infix_asdt ((f k) kl) (indic_2 k i kl il)))
    l h ll hl)).

Axiom sum_sum_function_indic_spec :
  forall (f:Z -> Z -> t) (i:Z) (l:Z) (h:Z) (il:Z) (ll:Z) (hl:Z),
  ((0%Z <= l)%Z /\ ((l <= i)%Z /\ (i < h)%Z)) ->
  ((0%Z <= ll)%Z /\ ((ll <= il)%Z /\ (il < hl)%Z)) ->
  ((sum_sum_function_indic f i l h il ll hl) = ((f i) il)) /\
  ((sum_sum_function_indic f i l h il ll hl) =
   (ssum (to_f_p_set l h ll hl)
    (fun (o:(Z* Z)%type) =>
     match o with
     | (k, kl) => infix_asdt ((f k) kl) (indic_2 k i kl il)
     end))).

Axiom sum_sum_indic_comm :
  forall (f:Z -> Z -> t) (i:Z) (l:Z) (h:Z) (il:Z) (ll:Z) (hl:Z),
  ((0%Z <= l)%Z /\ ((l <= i)%Z /\ (i < h)%Z)) ->
  ((0%Z <= ll)%Z /\ ((ll <= il)%Z /\ (il < hl)%Z)) ->
  ((sum_sum (fun (k:Z) (kl:Z) => (infix_asdt ((f k) kl) (indic_2 i k il kl)))
    l h ll hl)
   = ((f i) il)) /\
  ((sum_sum (fun (k:Z) (kl:Z) => (infix_asdt ((f k) kl) (indic_2 k i kl il)))
    l h ll hl)
   = ((f i) il)).

Parameter infix_asdtdt: t -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom infix_asdtdt_spec :
  forall (s:t) (m:Z -> Z -> t),
  ((columns (infix_asdtdt s m)) = (columns m)) /\
  (((rows (infix_asdtdt s m)) = (rows m)) /\
   ((forall (i:Z) (j:Z), (valid_index (infix_asdtdt s m) i j) ->
     ((((infix_asdtdt s m) i) j) = (infix_asdt s ((m i) j)))) /\
    forall (i:Z) (j:Z),
    (valid_index (infix_asdtdt s m) i j) <-> (valid_index m i j))).

Parameter product1: (Z -> Z -> t) -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom product_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((columns m) = (rows n)) ->
  ((rows (product1 m n)) = (rows m)) /\
  (((columns (product1 m n)) = (columns n)) /\
   forall (i:Z) (j:Z), (valid_index (product1 m n) i j) ->
   ((((product1 m n) i) j) =
    (sum (fun (k:Z) => (infix_asdt ((m i) k) ((n k) j))) 0%Z (columns m)))).

Parameter add_mat: (Z -> Z -> t) -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom add_mat_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (((columns (add_mat m n)) = (columns m)) /\ ((columns m) = (columns n))) /\
  ((((rows (add_mat m n)) = (rows m)) /\ ((rows m) = (rows n))) /\
   forall (i:Z) (j:Z), (valid_index (add_mat m n) i j) ->
   ((((add_mat m n) i) j) = (infix_pldt ((m i) j) ((n i) j))) /\
   ((infix_pldt ((m i) j) ((n i) j)) = (infix_pldt ((n i) j) ((m i) j)))).

Parameter add_neutral: Z -> Z -> Z -> Z -> t.

Axiom add_neutral_def :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((add_neutral r c) = (make r c tzero)).

Axiom add_neutral_spec :
  forall (r:Z) (c:Z), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((rows (add_neutral r c)) = r) /\
  (((columns (add_neutral r c)) = c) /\
   forall (i:Z) (j:Z), (valid_index (add_neutral r c) i j) ->
   ((((add_neutral r c) i) j) = tzero)).

Axiom distr_1_pre :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t) (i:Z) (j:Z),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns o))%Z) ->
  ((((product1 (add_mat m n) o) i) j) =
   (((add_mat (product1 m o) (product1 n o)) i) j)).

Axiom distr_1 :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) ->
  equal (product1 (add_mat m n) o) (add_mat (product1 m o) (product1 n o)).

Axiom distr_2_pre :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t) (i:Z) (j:Z),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) -> (valid_index (product1 m (add_mat n o)) i j) ->
  ((((product1 m (add_mat n o)) i) j) =
   (((add_mat (product1 m n) (product1 m o)) i) j)).

Axiom distr_2 :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t) (o:Z -> Z -> t),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) ->
  equal (product1 m (add_mat n o)) (add_mat (product1 m n) (product1 m o)).

(* Why3 assumption *)
Definition mat_terms := Z -> Z -> Z -> t.

(* Why3 assumption *)
Definition mat_terms_bis := Z -> Z -> Z -> Z -> t.

(* Why3 assumption *)
Definition mat_sterms (a:Type) := a -> Z -> Z -> t.

(* Why3 assumption *)
Definition constant_size {a:Type} {a_WT:WhyType a} (s:set a)
    (f:a -> Z -> Z -> t) : Prop :=
  forall (e:a), (mem e s) ->
  ((rows (f e)) = (rows (f (choose s)))) /\
  ((columns (f e)) = (columns (f (choose s)))).

Parameter s_rows:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z -> Z -> t) -> Z.

Axiom s_rows_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  ((s_rows s f) = (rows (f (choose s)))).

Axiom s_rows_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) -> forall (e:a),
  (mem e s) -> ((rows (f e)) = (s_rows s f)).

Parameter s_columns:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z -> Z -> t) -> Z.

Axiom s_columns_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  ((s_columns s f) = (columns (f (choose s)))).

Axiom s_columns_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) -> forall (e:a),
  (mem e s) -> ((columns (f e)) = (s_columns s f)).

Parameter mat_ssum:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> Z -> Z -> t) ->
  Z -> Z -> t.

Axiom mat_ssum_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  (0%Z < (cardinal s))%Z ->
  (((cardinal s) = 1%Z) -> ((mat_ssum s f) = (f (element s)))) /\
  (~ ((cardinal s) = 1%Z) ->
   ((mat_ssum s f) =
    (add_mat (f (choose s)) (mat_ssum (remove (choose s) s) f)))).

Axiom mat_ssum_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z -> Z -> t), (constant_size s f) ->
  (0%Z < (cardinal s))%Z ->
  ((rows (mat_ssum s f)) = (s_rows s f)) /\
  (((columns (mat_ssum s f)) = (s_columns s f)) /\
   forall (i:Z) (j:Z), (valid_index (mat_ssum s f) i j) ->
   ((((mat_ssum s f) i) j) = (ssum s (fun (e:a) => (((f e) i) j))))).

Parameter mat_sum: (Z -> Z -> Z -> t) -> Z -> Z -> Z -> Z -> Z -> Z -> t.

Axiom mat_sum_def :
  forall (f:Z -> Z -> Z -> t) (r:Z) (c:Z) (i:Z) (j:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((rows (f k)) = r)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((columns (f k)) = c)) ->
  (((i + 1%Z)%Z = j) -> ((mat_sum f r c i j) = (f i))) /\
  (~ ((i + 1%Z)%Z = j) ->
   ((mat_sum f r c i j) = (add_mat (f i) (mat_sum f r c (i + 1%Z)%Z j)))).

Axiom mat_sum_spec :
  forall (f:Z -> Z -> Z -> t) (r:Z) (c:Z) (i:Z) (j:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((rows (f k)) = r)) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((columns (f k)) = c)) ->
  ((rows (mat_sum f r c i j)) = r) /\
  (((columns (mat_sum f r c i j)) = c) /\
   ((forall (o:Z) (l:Z), (valid_index (mat_sum f r c i j) o l) ->
     ((((mat_sum f r c i j) o) l) = (sum (fun (k:Z) => (((f k) o) l)) i j))) /\
    ((forall (o:Z) (l:Z), (valid_index (mat_sum f r c i j) o l) ->
      ((((mat_sum f r c i j) o) l) =
       (ssum (to_fset i j) (fun (k:Z) => (((f k) o) l))))) /\
     (equal (mat_sum f r c i j) (mat_ssum (to_fset i j) f))))).

Parameter f: Z -> Z -> Z -> Z -> t.

Parameter r: Z.

Parameter c: Z.

Parameter i: Z.

Parameter j: Z.

Parameter il: Z.

Parameter jl: Z.

Axiom H : (0%Z < r)%Z.

Axiom H1 : (0%Z < c)%Z.

Axiom H2 :
  forall (k:Z) (l:Z),
  (((i <= k)%Z /\ (k < j)%Z) /\ ((il <= l)%Z /\ (l < jl)%Z)) ->
  ((rows ((f k) l)) = r).

Axiom H3 :
  forall (k:Z) (l:Z),
  (((i <= k)%Z /\ (k < j)%Z) /\ ((il <= l)%Z /\ (l < jl)%Z)) ->
  ((columns ((f k) l)) = c).

Axiom H4 : (i < j)%Z.

Axiom H5 : (il < jl)%Z.

Parameter result2: Z -> Z -> t.

Parameter o: Z -> Z -> t.

Axiom H6 :
  (((i + 1%Z)%Z = j) ->
   let o1 := f i in
   (result2 = (mat_sum o1 r c il jl)) /\
   (((rows result2) = r) /\
    (((columns result2) = c) /\
     ((forall (o2:Z) (l:Z), (valid_index result2 o2 l) ->
       (((result2 o2) l) = (sum (fun (k:Z) => (((o1 k) o2) l)) il jl))) /\
      ((forall (o2:Z) (l:Z), (valid_index result2 o2 l) ->
        (((result2 o2) l) =
         (ssum (to_fset il jl) (fun (k:Z) => (((o1 k) o2) l))))) /\
       (equal result2 (mat_ssum (to_fset il jl) o1))))))) /\
  (~ ((i + 1%Z)%Z = j) ->
   ((rows (mat_sum (f i) r c il jl)) = r) /\
   let o1 := (i + 1%Z)%Z in
   (((rows o) = r) /\
    (((columns o) = c) /\
     ((forall (o2:Z) (oj:Z), (valid_index o o2 oj) ->
       (((o o2) oj) =
        (sum (fun (k:Z) => (((mat_sum (f k) r c il jl) o2) oj)) o1 j))) /\
      ((forall (o2:Z) (oj:Z), (valid_index o o2 oj) ->
        (((o o2) oj) =
         (sum (fun (k:Z) => (sum (fun (l:Z) => ((((f k) l) o2) oj)) il jl))
          o1 j))) /\
       ((forall (o2:Z) (oj:Z), (valid_index o o2 oj) ->
         (((o o2) oj) =
          (sum_sum (fun (k:Z) (l:Z) => ((((f k) l) o2) oj)) o1 j il jl))) /\
        forall (o2:Z) (oj:Z), (valid_index o o2 oj) ->
        (((o o2) oj) =
         (ssum (to_f_p_set o1 j il jl)
          (fun (co:(Z* Z)%type) =>
           match co with
           | (k, l) => (((f k) l) o2) oj
           end)))))))) /\
   let o2 := f i in
   let o3 := mat_sum o2 r c il jl in
   (((rows o3) = r) /\
    (((columns o3) = c) /\
     ((forall (o4:Z) (l:Z), (valid_index o3 o4 l) ->
       (((o3 o4) l) = (sum (fun (k:Z) => (((o2 k) o4) l)) il jl))) /\
      ((forall (o4:Z) (l:Z), (valid_index o3 o4 l) ->
        (((o3 o4) l) = (ssum (to_fset il jl) (fun (k:Z) => (((o2 k) o4) l))))) /\
       (equal o3 (mat_ssum (to_fset il jl) o2)))))) /\
   ((result2 = (add_mat o3 o)) /\
    ((((columns result2) = (columns o3)) /\ ((columns o3) = (columns o))) /\
     ((((rows result2) = (rows o3)) /\ ((rows o3) = (rows o))) /\
      forall (i1:Z) (j1:Z), (valid_index result2 i1 j1) ->
      (((result2 i1) j1) = (infix_pldt ((o3 i1) j1) ((o i1) j1))) /\
      ((infix_pldt ((o3 i1) j1) ((o i1) j1)) =
       (infix_pldt ((o i1) j1) ((o3 i1) j1))))))).

Axiom H7 : ((rows result2) = r).

Axiom H8 : ((columns result2) = c).

Axiom H9 :
  forall (o1:Z) (oj:Z), (valid_index result2 o1 oj) ->
  (((result2 o1) oj) =
   (sum (fun (k:Z) => (((mat_sum (f k) r c il jl) o1) oj)) i j)).

Axiom H10 :
  forall (o1:Z) (oj:Z), (valid_index result2 o1 oj) ->
  (((result2 o1) oj) =
   (sum (fun (k:Z) => (sum (fun (l:Z) => ((((f k) l) o1) oj)) il jl)) i j)).

Parameter o1: Z.

Parameter oj: Z.

Axiom H11 : valid_index result2 o1 oj.

(* Why3 goal *)
Theorem h : ~ (j <= i)%Z.
Proof.


Qed.


(set-logic AUFNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun prefix_mndt (t) t)

(declare-fun infix_sldt (t t) t)

(declare-fun infix_asdt (t t) t)

(declare-fun prefix_mnas (uni) uni)

;; prefix -*_sort
  (assert (forall ((x uni)) (sort real (prefix_mnas x))))

;; NonTrivialRing
  (assert (not (= tzero tone)))

(declare-fun inv (t) t)

;; div_def
  (assert
  (forall ((x t) (y t))
  (=> (not (= y tzero)) (= (infix_sldt x y) (infix_asdt x (inv y))))))

(declare-fun set (ty) ty)

(declare-fun mem (ty uni uni) Bool)

(declare-fun infix_eqeq (ty uni uni) Bool)

;; infix ==_spec
  (assert
  (forall ((a ty))
  (forall ((s1 uni) (s2 uni))
  (and
  (=> (infix_eqeq a s1 s2) (forall ((x uni)) (= (mem a x s1) (mem a x s2))))
  (=> (forall ((x uni)) (=> (sort a x) (= (mem a x s1) (mem a x s2))))
  (infix_eqeq a s1 s2))))))

(declare-fun infix_mngt (ty ty) ty)

(declare-fun infix_at (ty ty uni uni) uni)

;; infix @_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

(declare-fun abs1 (Int) Int)

;; abs_def
  (assert
  (forall ((x Int)) (ite (<= 0 x) (= (abs1 x) x) (= (abs1 x) (- x)))))

(declare-fun cpower (t Int) t)

;; zero_cpower_pos
  (assert (forall ((n Int)) (=> (<= 0 n) (= (cpower tzero n) tzero))))

;; init_exp
  (assert
  (forall ((k t))
  (and (= (cpower k 0) tone)
  (and (= (cpower k 1) k) (= (cpower k 2) (infix_asdt k k))))))

(declare-fun rows (ty uni) Int)

(declare-fun columns (ty uni) Int)

(declare-fun valid_index (ty uni Int Int) Bool)

;; valid_index_def
  (assert
  (forall ((a ty))
  (forall ((a1 uni) (r Int) (c Int))
  (= (valid_index a a1 r c)
  (and (and (<= 0 r) (< r (rows a a1))) (and (<= 0 c) (< c (columns a a1))))))))

(declare-fun infix_asdtdt (t
  (Array Int (Array Int t))) (Array Int (Array Int t)))

(declare-fun t2tb (t) uni)

;; t2tb_sort
  (assert (forall ((x t)) (sort t1 (t2tb x))))

(declare-fun tb2t (uni) t)

;; BridgeL
  (assert (forall ((i t)) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort t1 j) (= (t2tb (tb2t j)) j)) :pattern ((t2tb (tb2t j))) )))

(declare-fun t2tb1 ((Array Int (Array Int t))) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array Int (Array Int t)))) (sort
  (infix_mngt int (infix_mngt int t1)) (t2tb1 x))))

(declare-fun tb2t1 (uni) (Array Int (Array Int t)))

;; BridgeL
  (assert
  (forall ((i (Array Int (Array Int t))))
  (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt int (infix_mngt int t1)) j)
     (= (t2tb1 (tb2t1 j)) j)) :pattern ((t2tb1 (tb2t1 j))) )))

(declare-fun t2tb2 ((Array Int t)) uni)

;; t2tb_sort
  (assert (forall ((x (Array Int t))) (sort (infix_mngt int t1) (t2tb2 x))))

(declare-fun tb2t2 (uni) (Array Int t))

;; BridgeL
  (assert
  (forall ((i (Array Int t)))
  (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (infix_mngt int t1) j) (= (t2tb2 (tb2t2 j)) j)) :pattern (
  (t2tb2 (tb2t2 j))) )))

(declare-fun t2tb3 (Int) uni)

;; t2tb_sort
  (assert (forall ((x Int)) (sort int (t2tb3 x))))

(declare-fun tb2t3 (uni) Int)

;; BridgeL
  (assert
  (forall ((i Int)) (! (= (tb2t3 (t2tb3 i)) i) :pattern ((t2tb3 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb3 (tb2t3 j)) j) :pattern ((t2tb3 (tb2t3 j))) )))

;; infix *.._spec
  (assert
  (forall ((s t) (m (Array Int (Array Int t))))
  (and (= (columns t1 (t2tb1 (infix_asdtdt s m))) (columns t1 (t2tb1 m)))
  (and (= (rows t1 (t2tb1 (infix_asdtdt s m))) (rows t1 (t2tb1 m)))
  (and
  (forall ((i Int) (j Int))
  (=> (valid_index t1 (t2tb1 (infix_asdtdt s m)) i j)
  (= (tb2t
     (infix_at t1 int
     (infix_at (infix_mngt int t1) int (t2tb1 (infix_asdtdt s m)) (t2tb3 i))
     (t2tb3 j))) (infix_asdt s
                 (tb2t
                 (infix_at t1 int
                 (infix_at (infix_mngt int t1) int (t2tb1 m) (t2tb3 i))
                 (t2tb3 j)))))))
  (forall ((i Int) (j Int))
  (= (valid_index t1 (t2tb1 (infix_asdtdt s m)) i j) (valid_index t1
  (t2tb1 m) i j))))))))

(assert
;; VC_test1
 ;; File "qdata/../qdata.mlw", line 889, characters 15-20
  (not false))
(check-sat)

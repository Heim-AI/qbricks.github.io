(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Reals.Rfunctions.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require real.Real.
Require real.RealInfix.
Require real.PowerInt.
Require map.Map.

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

Parameter power: Z -> Z -> Z.

Axiom Assoc :
  forall (x:Z) (y:Z) (z:Z), (((x * y)%Z * z)%Z = (x * (y * z)%Z)%Z).

Axiom Unit_def_l : forall (x:Z), ((1%Z * x)%Z = x).

Axiom Unit_def_r : forall (x:Z), ((x * 1%Z)%Z = x).

Axiom Power_0 : forall (x:Z), ((power x 0%Z) = 1%Z).

Axiom Power_s :
  forall (x:Z) (n:Z), (0%Z <= n)%Z ->
  ((power x (n + 1%Z)%Z) = (x * (power x n))%Z).

Axiom Power_s_alt :
  forall (x:Z) (n:Z), (0%Z < n)%Z ->
  ((power x n) = (x * (power x (n - 1%Z)%Z))%Z).

Axiom Power_1 : forall (x:Z), ((power x 1%Z) = x).

Axiom Power_sum :
  forall (x:Z) (n:Z) (m:Z), (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power x (n + m)%Z) = ((power x n) * (power x m))%Z).

Axiom Power_mult :
  forall (x:Z) (n:Z) (m:Z), (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power x (n * m)%Z) = (power (power x n) m)).

Axiom Power_comm1 :
  forall (x:Z) (y:Z), ((x * y)%Z = (y * x)%Z) -> forall (n:Z),
  (0%Z <= n)%Z -> (((power x n) * y)%Z = (y * (power x n))%Z).

Axiom Power_comm2 :
  forall (x:Z) (y:Z), ((x * y)%Z = (y * x)%Z) -> forall (n:Z),
  (0%Z <= n)%Z -> ((power (x * y)%Z n) = ((power x n) * (power y n))%Z).

Axiom growing_mult :
  forall (n:Z) (m:Z), (0%Z <= n)%Z -> (1%Z <= m)%Z -> (n <= (n * m)%Z)%Z.

Axiom strict_growing_mult :
  forall (n:Z) (m:Z), (1%Z < n)%Z -> (1%Z < m)%Z -> (n < (n * m)%Z)%Z.

Axiom positive_diff : forall (n:Z) (m:Z), (n < m)%Z -> (0%Z < (m - n)%Z)%Z.

Axiom init_exp :
  forall (k:Z),
  ((power k 0%Z) = 1%Z) /\
  (((power k 1%Z) = k) /\ ((power k 2%Z) = (k * k)%Z)).

Axiom sum_exp :
  forall (k:Z) (n:Z) (m:Z), (0%Z <= k)%Z -> (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power k (n + m)%Z) = ((power k n) * (power k m))%Z) /\
  (((power k (n + m)%Z) = ((power k m) * (power k n))%Z) /\
   (((power k (n + 1%Z)%Z) = (k * (power k n))%Z) /\
    (((k * (power k n))%Z = ((power k n) * k)%Z) /\
     ((((power k n) * k)%Z = ((power k 1%Z) * (power k n))%Z) /\
      (((power k 1%Z) * (power k n))%Z = ((power k n) * (power k 1%Z))%Z))))).

Axiom positive_exp :
  forall (k:Z) (n:Z), (0%Z < k)%Z -> (0%Z <= n)%Z ->
  (1%Z <= (power k n))%Z /\
  ((0%Z < (power k n))%Z /\ ((power k n) <= (power k (n + 1%Z)%Z))%Z).

Axiom strict_positive_exp :
  forall (k:Z) (n:Z), (1%Z < k)%Z -> (0%Z < n)%Z ->
  (1%Z < (power k n))%Z /\
  (((power k (n - 1%Z)%Z) < (power k n))%Z /\
   ((power k n) < (power k (n + 1%Z)%Z))%Z).

Axiom growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z <= k)%Z -> ((0%Z <= m)%Z /\ (m <= n)%Z) ->
  ((power k m) <= (power k n))%Z.

Axiom strict_growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> ((0%Z <= m)%Z /\ (m < n)%Z) ->
  ((power k m) < (power k n))%Z.

Axiom unicity_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((power k m) = (power k n)) <-> (m = n).

Axiom div_plus_one :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (((int.EuclideanDivision.div i j) * j)%Z <= i)%Z /\
  (i < (((int.EuclideanDivision.div i j) + 1%Z)%Z * j)%Z)%Z.

Axiom bound_mod :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (0%Z <= (int.EuclideanDivision.mod1 i j))%Z /\
  ((int.EuclideanDivision.mod1 i j) < j)%Z.

Axiom unicity_div_mod :
  forall (i:Z) (j:Z) (q:Z) (r:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z ->
  (0%Z <= r)%Z -> (0%Z < j)%Z -> (i = ((q * j)%Z + r)%Z) ->
  ((0%Z <= r)%Z /\ (r < j)%Z) ->
  (q = (int.EuclideanDivision.div i j)) /\
  (r = (int.EuclideanDivision.mod1 i j)).

Axiom decomp :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i =
   ((j * (int.EuclideanDivision.div i j))%Z +
    (int.EuclideanDivision.mod1 i j))%Z).

Axiom div_plus_quotient :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.div (i + j)%Z j) =
   ((int.EuclideanDivision.div i j) + 1%Z)%Z).

Axiom div_plus_fact_gen_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (i + (k * j)%Z)%Z j) =
   ((int.EuclideanDivision.div i j) + k)%Z).

Axiom mod_plus_fact_gen_mod :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z <= k)%Z ->
  ((int.EuclideanDivision.mod1 ((k * j)%Z + i)%Z j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom bound_div :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z ->
  (0%Z <= ((int.EuclideanDivision.div i q) * q)%Z)%Z /\
  ((((int.EuclideanDivision.div i q) * q)%Z <= i)%Z /\
   (i < (q * ((int.EuclideanDivision.div i q) + 1%Z)%Z)%Z)%Z).

Axiom bound_div_factor :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z -> ((int.EuclideanDivision.div i q) < f)%Z.

Axiom mod_invariant :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1
    ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z +
     (int.EuclideanDivision.mod1 i (q * f)%Z))%Z
    q)
   = (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (q * f)%Z) q)).

Axiom mod_mod :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j) =
   (int.EuclideanDivision.mod1 i j)) /\
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mod_mod_rev :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j)) /\
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j)).

Axiom mod_mod_plus :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j + j)%Z) j)).

Axiom mult_assoc :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z =
   ((q * f)%Z * (int.EuclideanDivision.div i (q * f)%Z))%Z).

Axiom div_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (k * j)%Z)) /\
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (j * k)%Z)).

Axiom mod_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.mod1 i (j * k)%Z) j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.div i j) k)).

Axiom div_sum_exponents :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power k (n + m)%Z) = ((power k n) * (power k m))%Z) /\
  (((power k (n + 1%Z)%Z) = ((power k n) * k)%Z) /\
   (((power k 1%Z) = k) /\
    (((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n))
       (power k m))
      = (int.EuclideanDivision.div i (power k (n + m)%Z))) /\
     ((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n)) k)
      = (int.EuclideanDivision.div i (power k (n + 1%Z)%Z)))))).

Parameter divp: Z -> Z -> Z.

Axiom divp_def :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((divp i j) = ((int.EuclideanDivision.div i j) * j)%Z).

Axiom divp_spec :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i = ((divp i j) + (int.EuclideanDivision.mod1 i j))%Z) /\
  ((((divp i j) <= i)%Z /\ (i < (((divp i j) + 1%Z)%Z * j)%Z)%Z) /\
   ((j < i)%Z -> (0%Z < (divp i j))%Z)).

Parameter to_k_ary: Z -> Z -> Z -> Z.

Axiom to_k_ary_def :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= n)%Z -> (0%Z < k)%Z ->
  ((to_k_ary i k n) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.div i (power k n)) k)).

Axiom to_k_ary_spec :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= n)%Z -> (0%Z < k)%Z ->
  (0%Z <= (to_k_ary i k n))%Z /\ ((to_k_ary i k n) < k)%Z.

Axiom to_k_ary_div_mod :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= n)%Z -> (0%Z < k)%Z ->
  ((to_k_ary i k n) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (power k (n + 1%Z)%Z)) (power k n))).

Parameter weighted_to_k_ary: Z -> Z -> Z -> Z.

Axiom weighted_to_k_ary_def :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= n)%Z -> (0%Z < k)%Z ->
  ((weighted_to_k_ary i k n) = ((to_k_ary i k n) * (power k n))%Z).

Axiom weighted_to_k_ary_spec :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= n)%Z -> (0%Z < k)%Z ->
  ((power k n) < i)%Z ->
  (0%Z <= (weighted_to_k_ary i k n))%Z /\ ((weighted_to_k_ary i k n) <= i)%Z.

Axiom decreasing_div :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= i)%Z -> (0%Z <= n)%Z -> (1%Z < k)%Z ->
  ((power k (n + 1%Z)%Z) < i)%Z ->
  ((int.EuclideanDivision.div i (power k n)) =
   (((int.EuclideanDivision.div i (power k (n + 1%Z)%Z)) * k)%Z +
    (to_k_ary i k n))%Z) /\
  ((int.EuclideanDivision.div i (power k (n + 1%Z)%Z)) <
   (int.EuclideanDivision.div i (power k n)))%Z.

Parameter k_ary_length: Z -> Z -> Z.

Axiom k_ary_length_spec :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (1%Z < k)%Z ->
  ((0%Z < i)%Z ->
   ((power k ((k_ary_length i k) - 1%Z)%Z) <= i)%Z /\
   (i < (power k (k_ary_length i k)))%Z) /\
  (((i < k)%Z -> ((k_ary_length i k) = 1%Z)) /\
   (1%Z <= (k_ary_length i k))%Z).

Axiom no_rest_length :
  forall (i:Z) (k:Z) (l:Z), (0%Z < i)%Z -> (0%Z <= l)%Z -> (1%Z < k)%Z ->
  (i = (power k l)) -> ((k_ary_length i k) = (l + 1%Z)%Z).

Axiom mod_k_ary :
  forall (i:Z) (k:Z) (l:Z) (j:Z), (0%Z <= i)%Z -> (1%Z < k)%Z ->
  (0%Z <= l)%Z -> ((0%Z <= j)%Z /\ (j < l)%Z) ->
  ((to_k_ary (int.EuclideanDivision.mod1 i (power k l)) k j) =
   (to_k_ary i k j)).

Axiom mod_k_ary_comm :
  forall (i:Z) (k:Z) (l:Z) (j:Z), (0%Z <= i)%Z -> (1%Z < k)%Z ->
  ((0%Z <= l)%Z /\ (l < (k_ary_length i k))%Z) ->
  ((0%Z <= j)%Z /\ (j < l)%Z) ->
  ((to_k_ary i k j) =
   (to_k_ary (int.EuclideanDivision.mod1 i (power k l)) k j)).

(* Why3 assumption *)
Definition matrix (a:Type) := Z -> Z -> a.

Parameter rows: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z.

Axiom rows_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (0%Z < (rows m))%Z.

Parameter columns: forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z.

Axiom columns_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a), (0%Z < (columns m))%Z.

(* Why3 assumption *)
Definition valid_index {a:Type} {a_WT:WhyType a} (a1:Z -> Z -> a) (r:Z)
    (c:Z) : Prop :=
  ((0%Z <= r)%Z /\ (r < (rows a1))%Z) /\
  ((0%Z <= c)%Z /\ (c < (columns a1))%Z).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z -> Z -> a.

Axiom get_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z), (valid_index a1 r c) ->
  ((get a1 r c) = ((a1 r) c)).

Parameter equal:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> (Z -> Z -> a) -> Prop.

Axiom equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:Z -> Z -> a) (n:Z -> Z -> a),
  (equal m n) <->
  forall (i:Z) (j:Z),
  ((valid_index m i j) <-> (valid_index n i j)) /\
  ((valid_index m i j) -> ((get m i j) = (get n i j))).

Parameter make: forall {a:Type} {a_WT:WhyType a}, Z -> Z -> a -> Z -> Z -> a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (v:a), ((0%Z <= r)%Z /\ (0%Z <= c)%Z) ->
  ((rows (make r c v)) = r) /\
  (((columns (make r c v)) = c) /\
   forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
   ((((make r c v) i) j) = v)).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, (Z -> Z -> a) -> Z -> Z -> a ->
  Z -> Z -> a.

Axiom set_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((set a1 r c v) = (map.Map.set a1 r (map.Map.set (a1 r) c v))).

Axiom set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Z -> Z -> a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((rows (set a1 r c v)) = (rows a1)) /\
  (((columns (set a1 r c v)) = (columns a1)) /\
   ((forall (i:Z) (j:Z), (valid_index a1 i j) ->
     (((i = r) /\ (j = c)) -> ((((set a1 r c v) i) j) = v)) /\
     (~ ((i = r) /\ (j = c)) -> ((((set a1 r c v) i) j) = ((a1 i) j)))) /\
    (((get (set a1 r c v) r c) = v) /\
     ((forall (i:Z) (j:Z), (valid_index (set a1 r c v) i j) -> ~ (i = r) ->
       ((get (set a1 r c v) i j) = (get a1 i j))) /\
      forall (i:Z) (j:Z), (valid_index (set a1 r c v) i j) -> ~ (j = c) ->
      ((get (set a1 r c v) i j) = (get a1 i j)))))).

Parameter infix_asdtdt: t -> t -> t.

Parameter tensor_neutral: Z -> Z -> t.

Parameter tone: t.

Axiom tensor_neutral1 : (tensor_neutral = (make 1%Z 1%Z tone)).

(* Why3 assumption *)
Definition terms := Z -> t.

Axiom factor_one_left : forall (a:t), ((infix_asdtdt tone a) = a).

Axiom factor_one_right : forall (a:t), ((infix_asdtdt a tone) = a).

Axiom factor_assoc :
  forall (a:t) (b:t) (c:t),
  ((infix_asdtdt (infix_asdtdt a b) c) = (infix_asdtdt a (infix_asdtdt b c))).

Parameter product: (Z -> t) -> Z -> Z -> t.

Axiom product_def :
  forall (f:Z -> t) (i:Z) (j:Z),
  ((j <= i)%Z -> ((product f i j) = tone)) /\
  (~ (j <= i)%Z ->
   ((product f i j) = (infix_asdtdt (f i) (product f (i + 1%Z)%Z j)))).

Axiom Product_def_empty :
  forall (f:Z -> t) (i:Z) (j:Z), (j <= i)%Z -> ((product f i j) = tone).

Axiom Product_def_non_empty :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((product f i j) = (infix_asdtdt (f i) (product f (i + 1%Z)%Z j))).

Axiom product_right_extension :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((product f i j) =
   (infix_asdtdt (product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom product_right_extension_comm :
  forall (f:Z -> t) (i:Z) (j:Z), (i < j)%Z ->
  ((infix_asdtdt (product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z)) =
   (product f i j)).

Axiom product_transitivity :
  forall (f:Z -> t) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((product f i j) = (infix_asdtdt (product f i k) (product f k j))).

Axiom product_eq :
  forall (f1:Z -> t) (f2:Z -> t) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f1 k) = (f2 k))) ->
  ((product f1 i j) = (product f2 i j)).

Parameter tensor: (Z -> Z -> t) -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom tensor_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t),
  ((rows (tensor m n)) = ((rows m) * (rows n))%Z) /\
  (((columns (tensor m n)) = ((columns m) * (columns n))%Z) /\
   forall (i:Z), forall (j:Z), (valid_index (tensor m n) i j) ->
   ((get (tensor m n) i j) =
    (infix_asdtdt
     (get n (int.EuclideanDivision.mod1 i (rows n))
      (int.EuclideanDivision.mod1 j (columns n)))
     (get m (int.EuclideanDivision.div i (rows n))
      (int.EuclideanDivision.div j (columns n)))))).

Parameter pow: (Z -> Z -> t) -> Z -> Z -> Z -> t.

Axiom pow_def :
  forall (m:Z -> Z -> t) (e:Z), (0%Z <= e)%Z ->
  ((e = 0%Z) -> ((pow m e) = tensor_neutral)) /\
  (~ (e = 0%Z) -> ((pow m e) = (tensor m (pow m (e - 1%Z)%Z)))).

Axiom pow_spec :
  forall (m:Z -> Z -> t) (e:Z), (0%Z <= e)%Z ->
  ((rows (pow m e)) = (power (rows m) e)) /\
  ((columns (pow m e)) = (power (columns m) e)).

Parameter get_k_th_comp: (Z -> Z -> t) -> Z -> Z -> Z -> t.

Axiom get_k_th_comp_def :
  forall (m:Z -> Z -> t) (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  (0%Z <= k)%Z ->
  ((get_k_th_comp m i j k) =
   (get m (to_k_ary i (rows m) k) (to_k_ary j (columns m) k))).

Axiom get_k_th_comp_mod :
  forall (m:Z -> Z -> t) (i:Z) (j:Z) (k:Z) (l:Z), (0%Z <= i)%Z ->
  (0%Z <= j)%Z -> ((0%Z < k)%Z /\ (k < l)%Z) ->
  ((get m (to_k_ary i (rows m) k) (to_k_ary j (columns m) k)) =
   (get m
    (to_k_ary (int.EuclideanDivision.mod1 i (power (rows m) l)) (rows m) k)
    (to_k_ary (int.EuclideanDivision.mod1 j (power (columns m) l))
     (columns m) k))).

Axiom pow_product_pre :
  forall (m:Z -> Z -> t) (n:Z) (i:Z) (j:Z), (1%Z <= n)%Z -> (0%Z <= i)%Z ->
  (0%Z <= j)%Z -> (0%Z < n)%Z ->
  ((get (pow m n) (int.EuclideanDivision.mod1 i (rows (pow m n)))
    (int.EuclideanDivision.mod1 j (columns (pow m n))))
   =
   (infix_asdtdt
    (get (pow m (n - 1%Z)%Z)
     (int.EuclideanDivision.mod1 i (rows (pow m (n - 1%Z)%Z)))
     (int.EuclideanDivision.mod1 j (columns (pow m (n - 1%Z)%Z))))
    ((fun (k:Z) =>
      (get m
       (int.EuclideanDivision.div
        (int.EuclideanDivision.mod1 i (rows (pow m (k + 1%Z)%Z)))
        (rows (pow m k)))
       (int.EuclideanDivision.div
        (int.EuclideanDivision.mod1 j (columns (pow m (k + 1%Z)%Z)))
        (columns (pow m k)))))
     (n - 1%Z)%Z))).

Axiom pow_product_no_bound :
  forall (m:Z -> Z -> t) (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  (0%Z <= j)%Z ->
  ((get (pow m n) (int.EuclideanDivision.mod1 i (rows (pow m n)))
    (int.EuclideanDivision.mod1 j (columns (pow m n))))
   =
   (product
    (fun (k:Z) =>
     (get m
      (int.EuclideanDivision.div
       (int.EuclideanDivision.mod1 i (rows (pow m (k + 1%Z)%Z)))
       (rows (pow m k)))
      (int.EuclideanDivision.div
       (int.EuclideanDivision.mod1 j (columns (pow m (k + 1%Z)%Z)))
       (columns (pow m k)))))
    0%Z n)).

Axiom pow_product :
  forall (m:Z -> Z -> t) (i:Z) (j:Z) (n:Z),
  ((0%Z <= i)%Z /\ (i < (power (rows m) n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power (columns m) n))%Z) -> (0%Z <= n)%Z ->
  ((get (pow m n) i j) =
   (product (fun (k:Z) => (get_k_th_comp m i j k)) 0%Z n)).

Axiom pow_product_no_bound_ :
  forall (m:Z -> Z -> t) (n:Z) (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  (0%Z <= n)%Z ->
  ((get (pow m n) (int.EuclideanDivision.mod1 i (power (rows m) n))
    (int.EuclideanDivision.mod1 j (power (columns m) n)))
   = (product (fun (k:Z) => (get_k_th_comp m i j k)) 0%Z n)).

Parameter tzero: t.

Parameter tone1: t.

Parameter infix_pldtdt: t -> t -> t.

Parameter infix_mndtdt: t -> t -> t.

Parameter infix_sl: t -> t -> t.

Parameter modulus: t -> R.

Parameter prefix_mn: t -> t.

Axiom Assoc1 :
  forall (x:t) (y:t) (z:t),
  ((infix_pldtdt (infix_pldtdt x y) z) = (infix_pldtdt x (infix_pldtdt y z))).

Axiom Unit_def_l1 : forall (x:t), ((infix_pldtdt tzero x) = x).

Axiom Unit_def_r1 : forall (x:t), ((infix_pldtdt x tzero) = x).

Axiom Inv_def_l : forall (x:t), ((infix_pldtdt (prefix_mn x) x) = tzero).

Axiom Inv_def_r : forall (x:t), ((infix_pldtdt x (prefix_mn x)) = tzero).

Axiom Comm : forall (x:t) (y:t), ((infix_pldtdt x y) = (infix_pldtdt y x)).

Axiom Assoc2 :
  forall (x:t) (y:t) (z:t),
  ((infix_asdtdt (infix_asdtdt x y) z) = (infix_asdtdt x (infix_asdtdt y z))).

Axiom Mul_distr_l :
  forall (x:t) (y:t) (z:t),
  ((infix_asdtdt x (infix_pldtdt y z)) =
   (infix_pldtdt (infix_asdtdt x y) (infix_asdtdt x z))).

Axiom Mul_distr_r :
  forall (x:t) (y:t) (z:t),
  ((infix_asdtdt (infix_pldtdt y z) x) =
   (infix_pldtdt (infix_asdtdt y x) (infix_asdtdt z x))).

Axiom Comm1 : forall (x:t) (y:t), ((infix_asdtdt x y) = (infix_asdtdt y x)).

Axiom Unitary : forall (x:t), ((infix_asdtdt tone1 x) = x).

Axiom NonTrivialRing : ~ (tzero = tone1).

Parameter inv: t -> t.

Axiom Inverse :
  forall (x:t), ~ (x = tzero) -> ((infix_asdtdt x (inv x)) = tone1).

(* Why3 assumption *)
Definition infix_mn (x:t) (y:t) : t := infix_pldtdt x (prefix_mn y).

(* Why3 assumption *)
Definition infix_sl1 (x:t) (y:t) : t := infix_asdtdt x (inv y).

Axiom add_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sl1 (infix_pldtdt x y) z) =
   (infix_pldtdt (infix_sl1 x z) (infix_sl1 y z))).

Axiom sub_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sl1 (infix_mn x y) z) = (infix_mn (infix_sl1 x z) (infix_sl1 y z))).

Axiom neg_div :
  forall (x:t) (y:t), ~ (y = tzero) ->
  ((infix_sl1 (prefix_mn x) y) = (prefix_mn (infix_sl1 x y))).

Axiom assoc_mul_div :
  forall (x:t) (y:t) (z:t), ~ (z = tzero) ->
  ((infix_sl1 (infix_asdtdt x y) z) = (infix_asdtdt x (infix_sl1 y z))).

Axiom assoc_div_mul :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sl1 (infix_sl1 x y) z) = (infix_sl1 x (infix_asdtdt y z))).

Axiom assoc_div_div :
  forall (x:t) (y:t) (z:t), (~ (y = tzero) /\ ~ (z = tzero)) ->
  ((infix_sl1 x (infix_sl1 y z)) = (infix_sl1 (infix_asdtdt x z) y)).

(* Why3 assumption *)
Definition terms1 := Z -> R.

Axiom add_zero_left : forall (a:R), ((0%R + a)%R = a).

Axiom add_zero_right : forall (a:R), ((a + 0%R)%R = a).

Axiom add_assoc :
  forall (a:R) (b:R) (c:R), (((a + b)%R + c)%R = (a + (b + c)%R)%R).

Parameter sum: (Z -> R) -> Z -> Z -> R.

Axiom sum_def :
  forall (f:Z -> R) (i:Z) (j:Z),
  ((j <= i)%Z -> ((sum f i j) = 0%R)) /\
  (~ (j <= i)%Z -> ((sum f i j) = ((f i) + (sum f (i + 1%Z)%Z j))%R)).

Axiom Sum_def_empty :
  forall (f:Z -> R) (i:Z) (j:Z), (j <= i)%Z -> ((sum f i j) = 0%R).

Axiom Sum_def_non_empty :
  forall (f:Z -> R) (i:Z) (j:Z), (i < j)%Z ->
  ((sum f i j) = ((f i) + (sum f (i + 1%Z)%Z j))%R).

Axiom sum_right_extension :
  forall (f:Z -> R) (i:Z) (j:Z), (i < j)%Z ->
  ((sum f i j) = ((sum f i (j - 1%Z)%Z) + (f (j - 1%Z)%Z))%R).

Axiom sum_transitivity :
  forall (f:Z -> R) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((sum f i j) = ((sum f i k) + (sum f k j))%R).

Axiom sum_eq :
  forall (f1:Z -> R) (f2:Z -> R) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f1 k) = (f2 k))) ->
  ((sum f1 i j) = (sum f2 i j)).

Axiom absorbing_zero : forall (i:t), ((infix_asdtdt i tzero) = tzero).

Parameter is_a_q_bra: (Z -> Z -> t) -> Prop.

Axiom is_a_q_bra1 :
  forall (m:Z -> Z -> t),
  (is_a_q_bra m) <->
  (((rows m) = 1%Z) /\
   exists s:Z, (0%Z <= s)%Z /\ ((columns m) = (power 2%Z s))).

Parameter is_a_q_ket: (Z -> Z -> t) -> Prop.

Axiom is_a_q_ket1 :
  forall (m:Z -> Z -> t),
  (is_a_q_ket m) <->
  (((columns m) = 1%Z) /\
   exists s:Z, (0%Z <= s)%Z /\ ((rows m) = (power 2%Z s))).

Parameter bra_to_ket: (Z -> Z -> t) -> Z -> Z -> t.

Axiom bra_to_ket_spec :
  forall (m:Z -> Z -> t), (is_a_q_bra m) ->
  (is_a_q_ket (bra_to_ket m)) /\
  ((forall (i:Z) (j:Z),
    (valid_index m i j) <-> (valid_index (bra_to_ket m) j i)) /\
   forall (i:Z) (j:Z), (valid_index m i j) ->
   ((get m i j) = (get (bra_to_ket m) j i))).

Axiom t_binary_mult :
  forall (i:t) (j:t), ((i = tone1) \/ (i = tzero)) ->
  ((j = tone1) \/ (j = tzero)) ->
  (((i = tone1) /\ (j = tone1)) -> ((infix_asdtdt i j) = tone1)) /\
  (~ ((i = tone1) /\ (j = tone1)) -> ((infix_asdtdt i j) = tzero)).

Axiom t_binary_mult_alt :
  forall (i:t) (j:t), ((i = tone1) \/ (i = tzero)) ->
  ((j = tone1) \/ (j = tzero)) ->
  (((i = tone1) /\ (j = tone1)) -> ((infix_asdtdt i j) = tone1)) /\
  (~ ((i = tone1) /\ (j = tone1)) -> ((infix_asdtdt i j) = tzero)).

Parameter ket_to_bra: (Z -> Z -> t) -> Z -> Z -> t.

Axiom ket_to_bra_spec :
  forall (m:Z -> Z -> t), (is_a_q_ket m) ->
  (is_a_q_bra (ket_to_bra m)) /\
  ((forall (i:Z) (j:Z),
    (valid_index m i j) <-> (valid_index (ket_to_bra m) j i)) /\
   forall (i:Z) (j:Z), (valid_index m i j) ->
   ((get m i j) = (get (ket_to_bra m) j i))).

Axiom ket_to_bra_to_ket :
  forall (m:Z -> Z -> t), (is_a_q_ket m) ->
  equal (bra_to_ket (ket_to_bra m)) m.

Axiom bra_to_ket_to_bra :
  forall (m:Z -> Z -> t), (is_a_q_bra m) ->
  equal m (ket_to_bra (bra_to_ket m)).

Parameter bra_length: (Z -> Z -> t) -> Z.

Axiom bra_length_def :
  forall (m:Z -> Z -> t), (is_a_q_bra m) ->
  ((bra_length m) = ((k_ary_length (columns m) 2%Z) - 1%Z)%Z).

Axiom bra_length_spec :
  forall (m:Z -> Z -> t), (is_a_q_bra m) ->
  (0%Z <= (bra_length m))%Z /\ ((columns m) = (power 2%Z (bra_length m))).

Parameter ket_length: (Z -> Z -> t) -> Z.

Axiom ket_length_def :
  forall (m:Z -> Z -> t), (is_a_q_ket m) ->
  ((ket_length m) = ((k_ary_length (rows m) 2%Z) - 1%Z)%Z).

Axiom ket_length_spec :
  forall (m:Z -> Z -> t), (is_a_q_ket m) ->
  (0%Z <= (ket_length m))%Z /\ ((rows m) = (power 2%Z (ket_length m))).

Parameter is_a_bra: (Z -> Z -> t) -> Prop.

Axiom is_a_bra1 :
  forall (m:Z -> Z -> t),
  (is_a_bra m) <->
  ((is_a_q_bra m) /\
   ((sum (fun (k:Z) => (Reals.Rfunctions.powerRZ (modulus ((m 0%Z) k)) 2%Z))
     0%Z (columns m))
    = 1%R)).

Parameter is_a_ket: (Z -> Z -> t) -> Prop.

Axiom is_a_ket1 :
  forall (m:Z -> Z -> t),
  (is_a_ket m) <->
  ((is_a_q_ket m) /\
   ((sum (fun (k:Z) => (Reals.Rfunctions.powerRZ (modulus ((m k) 0%Z)) 2%Z))
     0%Z (rows m))
    = 1%R)).

(* Why3 assumption *)
Definition is_a_q_bra_qbit (m:Z -> Z -> t) : Prop :=
  (is_a_q_bra m) /\ ((columns m) = 2%Z).

(* Why3 assumption *)
Definition is_a_q_ket_qbit (m:Z -> Z -> t) : Prop :=
  (is_a_q_ket m) /\ ((rows m) = 2%Z).

Axiom q_bra_qbit_tensor :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), (is_a_q_bra m) -> (is_a_q_bra n) ->
  (is_a_q_bra (tensor m n)) /\
  ((bra_length (tensor m n)) = ((bra_length m) + (bra_length n))%Z).

Axiom q_ket_qbit_tensor :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), (is_a_q_ket m) -> (is_a_q_ket n) ->
  (is_a_q_ket (tensor m n)) /\
  ((ket_length (tensor m n)) = ((ket_length m) + (ket_length n))%Z).

(* Why3 assumption *)
Definition is_a_bra_qbit (m:Z -> Z -> t) : Prop :=
  (is_a_bra m) /\ ((columns m) = 2%Z).

(* Why3 assumption *)
Definition is_a_ket_qbit (m:Z -> Z -> t) : Prop :=
  (is_a_ket m) /\ ((rows m) = 2%Z).

Parameter int_to_bra: Z -> Z -> Z -> Z -> t.

Axiom int_to_bra_def :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_bra i n) = (set (make 1%Z (power 2%Z n) tzero) 0%Z i tone1)).

Axiom int_to_bra_spec :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (is_a_q_bra (int_to_bra i n)) /\
  (((bra_length (int_to_bra i n)) = n) /\
   forall (j:Z) (k:Z), (valid_index (int_to_bra i n) j k) ->
   (((j = 0%Z) /\ (k = i)) -> ((get (int_to_bra i n) j k) = tone1)) /\
   (~ ((j = 0%Z) /\ (k = i)) -> ((get (int_to_bra i n) j k) = tzero))).

Parameter int_to_ket: Z -> Z -> Z -> Z -> t.

Axiom int_to_ket_def :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_ket i n) = (set (make (power 2%Z n) 1%Z tzero) i 0%Z tone1)).

Axiom int_to_ket_spec :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (is_a_q_ket (int_to_ket i n)) /\
  (((ket_length (int_to_ket i n)) = n) /\
   forall (j:Z) (k:Z), (valid_index (int_to_ket i n) j k) ->
   (((j = i) /\ (k = 0%Z)) -> ((get (int_to_ket i n) j k) = tone1)) /\
   (~ ((j = i) /\ (k = 0%Z)) -> ((get (int_to_ket i n) j k) = tzero))).

Axiom get_int_to_bra :
  forall (i:Z) (j:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (valid_index (int_to_bra i n) j k) ->
  (((j = 0%Z) /\ (k = i)) -> ((get (int_to_bra i n) j k) = tone1)) /\
  (~ ((j = 0%Z) /\ (k = i)) -> ((get (int_to_bra i n) j k) = tzero)).

(* Why3 assumption *)
Definition is_a_bra_bits (m:Z -> Z -> t) : Prop :=
  exists i:Z, exists n:Z, (m = (int_to_bra i n)).

(* Why3 assumption *)
Definition is_a_ket_bits (m:Z -> Z -> t) : Prop :=
  exists i:Z, exists n:Z, (m = (int_to_ket i n)).

Parameter tensor_q_bras: (Z -> Z -> t) -> (Z -> Z -> t) -> Z -> Z -> t.

Axiom tensor_q_bras_def :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), (is_a_q_bra m) -> (is_a_q_bra n) ->
  ((tensor_q_bras m n) = (tensor m n)).

Axiom tensor_q_bras_spec :
  forall (m:Z -> Z -> t) (n:Z -> Z -> t), (is_a_q_bra m) -> (is_a_q_bra n) ->
  (is_a_q_bra (tensor_q_bras m n)) /\
  (((bra_length (tensor_q_bras m n)) = ((bra_length m) + (bra_length n))%Z) /\
   forall (k:Z) (l:Z), (valid_index (tensor m n) k l) ->
   ((get (tensor m n) k l) =
    (infix_asdtdt
     (get n (int.EuclideanDivision.mod1 k (rows n))
      (int.EuclideanDivision.mod1 l (columns n)))
     (get m (int.EuclideanDivision.div k (rows n))
      (int.EuclideanDivision.div l (columns n)))))).

Parameter m: Z -> Z -> t.

Parameter n: Z -> Z -> t.

Axiom H : is_a_q_bra m.

Axiom H1 : is_a_q_bra n.

Axiom H2 :
  forall (k:Z) (l:Z),
  (valid_index (tensor m n) k l) <->
  ((k = 0%Z) /\
   ((0%Z <= l)%Z /\ (l < (power 2%Z ((bra_length m) + (bra_length n))%Z))%Z)).

Parameter l: Z.

Axiom H3 :
  (0%Z <= (int.EuclideanDivision.mod1 l (power 2%Z (bra_length m))))%Z.

Axiom H4 :
  ((int.EuclideanDivision.mod1 l (power 2%Z (bra_length m))) <
   (power 2%Z (bra_length m)))%Z.

Axiom H5 :
  (0%Z <= (int.EuclideanDivision.div l (power 2%Z (bra_length m))))%Z.

Axiom H6 :
  ((int.EuclideanDivision.div l (power 2%Z (bra_length m))) <
   (power 2%Z (bra_length n)))%Z.

(* Why3 goal *)
Theorem VC_tensor_indexes : (0%Z <= l)%Z.
Proof.


Qed.


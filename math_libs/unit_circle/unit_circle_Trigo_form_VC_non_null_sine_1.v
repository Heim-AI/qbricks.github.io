(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Reals.R_sqrt.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require real.Real.
Require real.FromInt.
Require real.Square.
Require map.Map.

(* Why3 assumption *)
Definition constant_f {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) : Prop :=
  exists a1:b, (f = ((fun (y0:b) (y1:a) => y0) a1)).

Axiom set : forall (a:Type), Type.
Parameter set_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set a).
Existing Instance set_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> Prop.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom infix_eqeq_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (infix_eqeq s1 s2) <-> forall (x:a), (mem x s1) <-> (mem x s2).

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq s1 s2) -> (s1 = s2).

Parameter subset:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (subset s1 s2) <-> forall (x:a), (mem x s1) -> mem x s2.

Axiom subset_refl :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set a), subset s s.

Axiom subset_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (s3:set a), (subset s1 s2) ->
  (subset s2 s3) -> subset s1 s3.

Parameter is_empty: forall {a:Type} {a_WT:WhyType a}, (set a) -> Prop.

Axiom is_empty_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (is_empty s) <-> forall (x:a), ~ (mem x s).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, set a.

Axiom empty_def : forall {a:Type} {a_WT:WhyType a}, is_empty (empty : set a).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom add_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (add x s)) <-> ((y = x) \/ (mem y s)).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom remove_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (remove x s)) <-> (~ (y = x) /\ (mem y s)).

Axiom add_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), (mem x s) -> ((add x (remove x s)) = s).

Axiom remove_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), ((remove x (add x s)) = (remove x s)).

Axiom subset_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), subset (remove x s) s.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (union s1 s2)) <-> ((mem x s1) \/ (mem x s2)).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom inter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (inter s1 s2)) <-> ((mem x s1) /\ (mem x s2)).

Parameter diff:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom diff_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (diff s1 s2)) <-> ((mem x s1) /\ ~ (mem x s2)).

Axiom subset_diff :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), subset (diff s1 s2) s1.

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom choose_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> mem (choose s) s.

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set a) -> Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (0%Z <= (cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 0%Z) <-> (is_empty s).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), ~ (mem x s) ->
  ((cardinal (add x s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), (mem x s) ->
  ((cardinal s) = (1%Z + (cardinal (remove x s)))%Z).

Axiom cardinal_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) <= (cardinal s2))%Z.

Axiom subset_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) = (cardinal s2)) -> infix_eqeq s1 s2.

Axiom cardinal1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) ->
  (x = (choose s)).

Parameter op: forall {im:Type} {im_WT:WhyType im}, im -> im -> im.

Parameter po: forall {im:Type} {im_WT:WhyType im}, im -> im -> im.

Parameter inver: forall {im:Type} {im_WT:WhyType im}, im -> im.

Parameter filter:
  forall {a:Type} {a_WT:WhyType a}, (a -> bool) -> (set a) -> set a.

Axiom filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), forall (x:a),
  (mem x (filter p u)) <-> (((p x) = true) /\ (mem x u)).

Axiom filter_cardinal :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (u:set a), ((cardinal (filter p u)) <= (cardinal u))%Z.

Parameter map:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> set b.

Axiom map_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (y:b),
  (mem y (map f u)) <-> exists x:a, (mem x u) /\ (y = (f x)).

Axiom map_def2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), forall (x:a), (mem x u) -> mem (f x) (map f u).

Axiom map_cardinal :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((cardinal (map f u)) <= (cardinal u))%Z.

Parameter infix_eqeq1: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom infix_eqeq_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a), (infix_eqeq1 a1 b) <-> (a1 = b).

Axiom assert_equal : True.

Axiom goal_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a), (a1 = b) -> (b = a1).

Parameter fir:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a* b)%type ->
  a.

Parameter sec:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a* b)%type ->
  b.

Axiom projections :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (o:(a* b)%type), (o = (fir o, sec o)).

Axiom get_fir :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (b1:b), ((fir (a1, b1)) = a1).

Axiom get_sec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (b1:b), ((sec (a1, b1)) = b1).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

Axiom set_equal :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (forall (e:a), (mem e s) -> mem e s') ->
  (forall (e:a), (mem e s') -> mem e s) -> (s = s').

Axiom set_equal_eqq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (forall (e:a), (mem e s) -> mem e s') ->
  (forall (e:a), (mem e s') -> mem e s) -> infix_eqeq1 s s'.

Axiom union_exchange :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ~ (is_empty s') ->
  ((union (add (choose s') s) (remove (choose s') s')) = (union s s')).

Axiom get_filter :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (s:set a) (x:a), (mem x (filter p s)) ->
  ((p x) = true) /\ (mem x s).

Axiom set_filter :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:a -> bool) (s:set a) (x:a), ((p x) = true) -> (mem x s) ->
  mem x (filter p s).

Axiom inter_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s) -> is_empty (inter s s').

Axiom inter_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> is_empty (inter s s').

Axiom inter_empty_elts :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (forall (e:a), (mem e s) -> ~ (mem e s')) ->
  is_empty (inter s s').

Axiom inter_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((inter s s') = (inter s' s)).

Axiom union_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((union s s') = (union s' s)).

Axiom union_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s) -> ((union s s') = s').

Axiom union_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> ((union s s') = s).

Axiom union_members :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a),
  (forall (a1:a), (mem a1 (union s s')) -> ~ (mem a1 s) -> mem a1 s') /\
  forall (a1:a), (mem a1 (union s s')) -> ~ (mem a1 s') -> mem a1 s.

Axiom union_alt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (e:a), (mem e (union s s')) -> ~ (mem e s) ->
  mem e s'.

Axiom union_empty_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (is_empty s') -> ((union s s') = s).

Axiom set_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s':set a) (s:set a), (forall (e:a), (mem e s') -> mem e s) ->
  subset s' s.

Axiom set_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (e:a), ~ (mem e s)) ->
  (s = (empty : set a)) /\ (is_empty s).

Axiom get_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (s = (empty : set a)) ->
  (forall (e:a), ~ (mem e s)) /\ (is_empty s).

Axiom get_non_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> exists e:a, mem e s.

Axiom set_non_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (exists e:a, mem e s) ->
  ~ (is_empty s) /\ (0%Z < (cardinal s))%Z.

Axiom set_pos_card_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (mem a1 s) -> (0%Z < (cardinal s))%Z.

Axiom union_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((union s (add x s')) = (add x (union s s'))).

Axiom union_add_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a) (y:a), (mem x (add y (union s s'))) ->
  ~ (mem x s') -> ~ (mem x s) -> (x = y).

Axiom union_add_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (x:a), ~ (mem x s') ->
  ((add x (union s s')) = (union s (add x s'))).

Axiom remove_add1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:a), ~ (mem x s) -> ((remove x (add x s)) = s).

Axiom add_remove1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:a), (mem x s) -> ((add x (remove x s)) = s).

(* Why3 assumption *)
Definition p_injective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) : Prop :=
  forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
  ~ ((f e) = (f e')).

Axiom set_map_mem :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b),
  (exists a1:a, (mem a1 s) /\ (b1 = (f a1))) -> mem b1 (map f s).

Axiom map_add :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (x:a), ~ (mem x s) ->
  ((map f (add x s)) = (add (f x) (map f s))).

Axiom map_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b) (s:set a),
  (forall (e:a), (mem e s) -> ((f e) = (g e))) -> ((map f s) = (map g s)).

Axiom remove_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (e:a) (f:a), (mem e (remove f s)) -> mem e s.

Axiom injective_map_cardinal :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) ->
  ((cardinal (map f s)) = (cardinal s)).

Axiom set_map_mem_el :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b) (a1:a), (mem a1 s) -> (b1 = (f a1)) ->
  mem b1 (map f s).

Axiom set_map_mem_el_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b),
  (exists a1:a, (mem a1 s) /\ (b1 = (f a1))) -> mem b1 (map f s).

Axiom map_antec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (b1:b), (mem b1 (map f s)) ->
  exists a1:a, (mem a1 s) /\ (b1 = (f a1)).

Axiom map_antec_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), forall (b1:b), (mem b1 (map f s)) ->
  exists a1:a, (mem a1 s) /\ (b1 = (f a1)).

Axiom map_remove_choose :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b), (p_injective f s) ->
  ((map f (remove (choose s) s)) = (remove (f (choose s)) (map f s))).

Parameter antec_set:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (a -> b) -> b -> set a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  b -> a -> bool.

Axiom result_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (b1:b) (e:a), (((result f b1) e) = true) <-> ((f e) = b1).

Axiom antec_set_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  ((antec_set s f b1) = (filter (result f b1) s)).

Parameter remove_s:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Parameter result1: forall {a:Type} {a_WT:WhyType a}, (set a) -> a -> bool.

Axiom result_def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s':set a) (e:a), (((result1 s') e) = true) <-> ~ (mem e s').

Axiom remove_s_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (subset s' s) ->
  ((remove_s s s') = (filter (result1 s') s)).

Axiom remove_s_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (subset s' s) -> forall (e:a),
  (mem e (remove_s s s')) <-> ((mem e s) /\ ~ (mem e s')).

Parameter remove_antecs:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (a -> b) -> b -> set a.

Axiom remove_antecs_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  ((remove_antecs s f b1) = (remove_s s (antec_set s f b1))).

Axiom remove_antecs_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  (forall (e:a),
   (mem e (remove_antecs s f b1)) <-> ((mem e s) /\ ~ ((f e) = b1))) /\
  ((cardinal (remove_antecs s f b1)) < (cardinal s))%Z.

Axiom map_remove_antec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (f:a -> b) (b1:b), (mem b1 (map f s)) ->
  ((map f (remove_antecs s f b1)) = (remove b1 (map f s))).

Axiom map_non_empty :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (0%Z < (cardinal s))%Z ->
  (0%Z < (cardinal (map f s)))%Z.

Axiom non_empty_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (0%Z < (cardinal (map f s)))%Z ->
  (0%Z < (cardinal s))%Z.

Parameter right_injections:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, a -> (set b) ->
  set (a* b)%type.

Axiom right_injections_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((is_empty s) -> ((right_injections a1 s) = (empty : set (a* b)%type))) /\
  (~ (is_empty s) ->
   ((right_injections a1 s) =
    (add (a1, choose s) (right_injections a1 (remove (choose s) s))))).

Axiom right_injections_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((cardinal (right_injections a1 s)) = (cardinal s)) /\
  ((forall (a':a), forall (b1:b),
    (mem (a', b1) (right_injections a1 s)) <-> ((a' = a1) /\ (mem b1 s))) /\
   ((right_injections a1 s) = (map (fun (b1:b) => (a1, b1)) s))).

Parameter left_injections:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) -> b ->
  set (a* b)%type.

Axiom left_injections_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  ((is_empty s) -> ((left_injections s b1) = (empty : set (a* b)%type))) /\
  (~ (is_empty s) ->
   ((left_injections s b1) =
    (add (choose s, b1) (left_injections (remove (choose s) s) b1)))).

Axiom left_injections_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  (forall (a1:a), forall (b':b),
   (mem (a1, b') (left_injections s b1)) <-> ((mem a1 s) /\ (b' = b1))) /\
  (((cardinal (left_injections s b1)) = (cardinal s)) /\
   ((left_injections s b1) = (map (fun (a1:a) => (a1, b1)) s))).

Axiom set_map_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (b1:b), (mem b1 s') -> exists a1:a, (mem a1 s) /\ ((f a1) = b1)) ->
  (forall (a1:a), (mem a1 s) -> mem (f a1) s') -> ((map f s) = s').

Axiom right_injections_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (s:set b),
  ((cardinal (right_injections a1 s)) = (cardinal s)) /\
  ((forall (a':a), forall (b1:b),
    (mem (a', b1) (right_injections a1 s)) <-> ((a' = a1) /\ (mem b1 s))) /\
   ((right_injections a1 s) = (map (fun (b1:b) => (a1, b1)) s))).

Axiom left_injections_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b),
  (forall (a1:a), forall (b':b),
   (mem (a1, b') (left_injections s b1)) <-> ((mem a1 s) /\ (b' = b1))) /\
  (((cardinal (left_injections s b1)) = (cardinal s)) /\
   ((left_injections s b1) = (map (fun (a1:a) => (a1, b1)) s))).

Axiom disjoint_injections :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (b1:b) (c:b), ~ (b1 = c) ->
  (is_empty (inter (right_injections b1 s) (right_injections c s))) /\
  (is_empty (inter (left_injections s b1) (left_injections s c))).

Axiom induction :
  forall {a:Type} {a_WT:WhyType a},
  forall (p:(set a) -> bool) (t:set a),
  (forall (s:set a), (is_empty s) -> ((p s) = true)) ->
  (forall (s:set a), ((p s) = true) -> forall (t1:a), ~ (mem t1 s) ->
   ((p (add t1 s)) = true)) ->
  ((p t) = true).

Axiom cardinal_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a),
  ((cardinal (union s s')) =
   (((cardinal s) + (cardinal s'))%Z - (cardinal (inter s s')))%Z).

Axiom cardinal_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), (forall (e:a), (mem e s) -> mem e s') ->
  (forall (e:a), (mem e s') -> mem e s) -> ((cardinal s) = (cardinal s')).

Axiom cardinal_sum_empty_inter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a), ((inter s s') = (empty : set a)) ->
  ((cardinal (union s s')) = ((cardinal s) + (cardinal s'))%Z).

Parameter cartesian_product:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (set a) ->
  (set b) -> set (a* b)%type.

Axiom cartesian_product_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((cardinal (cartesian_product s1 s2)) = ((cardinal s1) * (cardinal s2))%Z) /\
  ((forall (a1:a), forall (b1:b),
    (mem (a1, b1) (cartesian_product s1 s2)) <-> ((mem a1 s1) /\ (mem b1 s2))) /\
   forall (o:(a* b)%type),
   (mem o (cartesian_product s1 s2)) <->
   ((mem (fir o) s1) /\ (mem (sec o) s2))).

(* Why3 assumption *)
Definition commute {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (o:(a* b)%type) : (b* a)%type :=
  match o with
  | (a1, b1) => (b1, a1)
  end.

Axiom commute_inj :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b), ((a1 = a') -> ~ (b1 = b')) ->
  ~ ((commute (a1, b1)) = (commute (a', b'))).

Axiom mem_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (a1:a) (b1:b), (mem a1 s1) -> (mem b1 s2) ->
  mem (a1, b1) (cartesian_product s1 s2).

Axiom commute_inj_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  p_injective (fun (y0:(a* b)%type) => (commute y0))
  (cartesian_product s1 s2).

(* Why3 assumption *)
Definition commute_product {a:Type} {a_WT:WhyType a}
    {b:Type} {b_WT:WhyType b} (s1:set a) (s2:set b) : set (b* a)%type :=
  map (fun (y0:(a* b)%type) => (commute y0)) (cartesian_product s1 s2).

Axiom commute_product_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b),
  ((commute_product s1 s2) = (cartesian_product s2 s1)).

(* Why3 assumption *)
Definition commute_product_el {a:Type} {a_WT:WhyType a}
    {b:Type} {b_WT:WhyType b} (s1:set a) (s2:set b) : set (b* a)%type :=
  map (fun (y0:(a* b)%type) => (commute y0)) (cartesian_product s1 s2).

Axiom commute_product_el_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), forall (o:(a* b)%type),
  match o with
  | (a1, b1) =>
      ((mem o (cartesian_product s1 s2)) <-> ((mem a1 s1) /\ (mem b1 s2))) /\
      (((mem a1 s1) /\ (mem b1 s2)) <->
       (mem (b1, a1) (commute_product_el s1 s2)))
  end.

Axiom cartesian_product_union :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (s3:set b),
  ((cartesian_product s1 (union s2 s3)) =
   (union (cartesian_product s1 s2) (cartesian_product s1 s3))).

Axiom cartesian_union_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set a) (s3:set b),
  ((cartesian_product (union s1 s2) s3) =
   (union (cartesian_product s1 s3) (cartesian_product s2 s3))).

Axiom cartesian_product_cardone_r :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s1) = 1%Z) ->
  (infix_eqeq1 (cartesian_product s1 s2) (right_injections (choose s1) s2)) /\
  (infix_eqeq1 (cartesian_product s1 s2)
   (map (fun (e2:b) => (choose s1, e2)) s2)).

Axiom cartesian_product_cardone_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b), ((cardinal s2) = 1%Z) ->
  (infix_eqeq1 (cartesian_product s1 s2) (left_injections s1 (choose s2))) /\
  (infix_eqeq1 (cartesian_product s1 s2)
   (map (fun (e1:a) => (e1, choose s2)) s1)).

Axiom disjoint_cartesian_product_l :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set a) (s3:set b),
  ((inter s1 s2) = (empty : set a)) ->
  ((inter (cartesian_product s1 s3) (cartesian_product s2 s3)) =
   (empty : set (a* b)%type)).

Axiom disjoint_cartesian_product_r :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (s3:set b),
  ((inter s2 s3) = (empty : set b)) ->
  ((inter (cartesian_product s1 s2) (cartesian_product s1 s3)) =
   (empty : set (a* b)%type)).

Parameter iter_union:
  forall {a:Type} {a_WT:WhyType a}, (set (set a)) -> set a.

Axiom iter_union_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set (set a)),
  ((is_empty s) -> ((iter_union s) = (empty : set a))) /\
  (~ (is_empty s) ->
   ((iter_union s) = (union (choose s) (iter_union (remove (choose s) s))))).

Axiom get_mem_union :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (e:a), (mem e (union s s')) -> ~ (mem e s') ->
  mem e s.

Axiom get_mem_union' :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (e:a), (mem e (union s s')) -> ~ (mem e s) ->
  mem e s'.

Axiom set_mem_union :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (e:a), (mem e s) -> mem e (union s s').

Axiom set_mem_union' :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (e:a), (mem e s') -> mem e (union s s').

(* Why3 assumption *)
Definition op_neutral_left {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neutral:im) : Prop :=
  forall (e:im), (((op1 neutral) e) = e).

(* Why3 assumption *)
Definition op_neutral_right {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neutral:im) : Prop :=
  forall (e:im), (((op1 e) neutral) = e).

(* Why3 assumption *)
Definition op_assoc {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  forall (a:im) (b:im) (c:im),
  (((op1 ((op1 a) b)) c) = ((op1 a) ((op1 b) c))).

(* Why3 assumption *)
Definition op_neutral_left_comm {im:Type} {im_WT:WhyType im}
    (op1:im -> im -> im) (neutral:im) : Prop :=
  forall (a:im), (forall (b:im), (((op1 a) b) = b)) -> (a = neutral).

(* Why3 assumption *)
Definition commut {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  forall (a:im) (b:im), (((op1 a) b) = ((op1 b) a)).

(* Why3 assumption *)
Definition assoc {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  forall (a:im) (b:im) (c:im),
  (((op1 ((op1 a) b)) c) = ((op1 a) ((op1 b) c))).

(* Why3 assumption *)
Definition opposite_n {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) (neutral:im) : Prop :=
  forall (a:im), (((po1 a) a) = neutral).

(* Why3 assumption *)
Definition inverse {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) (inver1:im -> im) : Prop :=
  forall (a:im) (b:im), (((po1 a) b) = ((op1 a) (inver1 b))).

(* Why3 assumption *)
Definition opposite {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) : Prop :=
  forall (a:im) (b:im), (((op1 ((po1 a) b)) b) = a).

(* Why3 assumption *)
Definition opposite_com {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) : Prop :=
  forall (a:im) (b:im), (((po1 ((op1 a) b)) b) = a).

Axiom refl :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (a:im) (b:im), (commut op1) ->
  (((op1 a) b) = ((op1 b) a)).

(* Why3 assumption *)
Definition neutral {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neut:im) : Prop :=
  (op_neutral_left op1 neut) /\
  ((op_neutral_right op1 neut) /\ (op_assoc op1)).

Axiom set_neutral :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (neut:im), (op_neutral_left op1 neut) ->
  (op_neutral_right op1 neut) -> (op_assoc op1) -> neutral op1 neut.

(* Why3 assumption *)
Definition has_neutral {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) :
    Prop :=
  exists e:im, neutral op1 e.

(* Why3 assumption *)
Definition iterates {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (neutral1:im) : Prop :=
  (op_neutral_left op1 neutral1) /\
  ((op_neutral_right op1 neutral1) /\ (op_assoc op1)).

(* Why3 assumption *)
Definition iterable {im:Type} {im_WT:WhyType im} (op1:im -> im -> im) : Prop :=
  exists e:im, iterates op1 e.

Axiom iterates_ :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (neutral1:im),
  (op_neutral_left op1 neutral1) -> (op_neutral_right op1 neutral1) ->
  (op_assoc op1) -> (iterates op1 neutral1) /\ (iterable op1).

Parameter neutral_elt:
  forall {im:Type} {im_WT:WhyType im}, (im -> im -> im) -> im.

Axiom neutral_elt_spec :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im), forall (e:im),
  (neutral op1 e) <-> ((neutral_elt op1) = e).

(* Why3 assumption *)
Definition inverse_tuple {im:Type} {im_WT:WhyType im} (op1:im -> im -> im)
    (po1:im -> im -> im) (neutral1:im) : Prop :=
  (opposite_n op1 po1 neutral1) /\
  ((opposite op1 po1) /\ (opposite_com op1 po1)).

Parameter iterate:
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  (im -> im -> im) -> (set a) -> (a -> im) -> im.

Axiom Iterate_def_empty :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im), forall (s:set a), forall (f:a -> im),
  (commut op1) -> (iterable op1) -> (is_empty s) ->
  ((iterate op1 (empty : set a) f) = (neutral_elt op1)).

Axiom Iterate_one :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im), forall (s:set a), forall (f:a -> im),
  forall (x:a), (is_empty s) -> (commut op1) ->
  ((iterate op1 (add x s) f) = (f x)).

Axiom Iterate_add :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im), forall (s:set a), forall (f:a -> im),
  forall (x:a), (0%Z < (cardinal s))%Z -> (commut op1) -> ~ (mem x s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom minus_zero :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (a:im), (iterable op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  (((po1 a) (neutral_elt op1)) = a).

Axiom unic :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (a:im) (b:im) (c:im),
  (iterable op1) -> (commut op1) -> (((op1 a) b) = ((op1 a) c)) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) -> (b = c).

Axiom substract_comm :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (a:im) (b:im) (c:im),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  (((po1 ((op1 a) b)) a) = b) /\
  ((((po1 ((op1 b) a)) a) = b) /\
   ((((po1 a) ((po1 b) c)) = ((op1 ((po1 a) b)) c)) /\
    (((po1 ((op1 a) b)) c) = ((op1 a) ((po1 b) c))))).

Parameter int_iterate:
  forall {im:Type} {im_WT:WhyType im}, (im -> im -> im) -> (Z -> im) -> 
  Z -> Z -> im.

Axiom int_iterate_def :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z),
  ((j <= i)%Z -> iterable op1) ->
  ((j <= i)%Z -> ((int_iterate op1 f i j) = (neutral_elt op1))) /\
  (~ (j <= i)%Z ->
   ((j = (i + 1%Z)%Z) -> ((int_iterate op1 f i j) = (f i))) /\
   (~ (j = (i + 1%Z)%Z) ->
    ((int_iterate op1 f i j) =
     ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))))).

Axiom int_iterate_spec :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z),
  ((j <= i)%Z -> iterable op1) ->
  ((j <= i)%Z -> ((int_iterate op1 f i j) = (neutral_elt op1))) /\
  ((j = (i + 1%Z)%Z) ->
   ((int_iterate op1 f i j) = ((op1 (f i)) (neutral_elt op1)))).

Parameter int_int_iterate:
  forall {im:Type} {im_WT:WhyType im}, (im -> im -> im) -> (Z -> Z -> im) ->
  Z -> Z -> Z -> Z -> im.

Axiom int_int_iterate_def :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> Z -> im) (i:Z) (j:Z) (k:Z) (l:Z),
  (iterable op1) ->
  ((j <= i)%Z -> ((int_int_iterate op1 f i j k l) = (neutral_elt op1))) /\
  (~ (j <= i)%Z ->
   ((int_int_iterate op1 f i j k l) =
    ((op1 (int_iterate op1 (f i) k l))
     (int_int_iterate op1 f (i + 1%Z)%Z j k l)))).

Axiom to_set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (e:a),
  (forall (b:a), (b = e) -> mem b (add e (empty : set a))) /\
  (((cardinal (add e (empty : set a))) = 1%Z) /\
   forall (b:a), (mem b (add e (empty : set a))) -> (b = e)).

Parameter to_fset: Z -> Z -> set Z.

Axiom to_fset_spec :
  forall (i:Z) (j:Z),
  ((i < j)%Z -> ((cardinal (to_fset i j)) = (j - i)%Z)) /\
  (((j <= i)%Z -> is_empty (to_fset i j)) /\
   forall (k:Z), (mem k (to_fset i j)) <-> ((i <= k)%Z /\ (k < j)%Z)).

Axiom to_fset_bounds :
  forall (i:Z) (k:Z) (j:Z), (i < j)%Z -> (mem k (to_fset i j)) ->
  (i <= k)%Z /\ (k < j)%Z.

Axiom to_fset_unit_ext :
  forall (i:Z) (j:Z), (i < j)%Z ->
  ((to_fset i j) = (add i (to_fset (i + 1%Z)%Z j))).

Axiom to_fset_ext :
  forall (i:Z) (i':Z) (j:Z), ((i <= i')%Z /\ (i' <= j)%Z) ->
  ((to_fset i j) = (union (to_fset i i') (to_fset i' j))).

Axiom card_fset :
  forall (n:Z), (0%Z <= n)%Z -> ((cardinal (to_fset 0%Z n)) = n).

Axiom set_mem_to_fset :
  forall (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k < j)%Z) -> mem k (to_fset i j).

Parameter element: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom element_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> ((element s) = (choose s)).

Axiom cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  (0%Z < (cardinal s))%Z -> ((cardinal s) = 1%Z) /\ ((element s) = a1).

Axiom set_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (0%Z < (cardinal s))%Z ->
  (exists a1:a, forall (b:a), (mem b s) <-> (b = a1)) -> ((cardinal s) = 1%Z).

Axiom get_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) ->
  exists a1:a, forall (b:a), (mem b s) <-> (b = a1).

Axiom get_cardone_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (e:a), ((cardinal s) = 1%Z) -> (mem e s) ->
  (e = (element s)).

Axiom set_cardone_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((cardinal s) = 1%Z) /\ ((element s) = a1).

Axiom set_cardone_elt_ :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (a1:a), (forall (b:a), (mem b s) <-> (b = a1)) ->
  ((cardinal s) = 1%Z).

Axiom cardzero :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (forall (b:a), ~ (mem b s)) -> ((cardinal s) = 0%Z).

(* Why3 assumption *)
Definition p_injective_in {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) (s':set b) : Prop :=
  forall (e:a), (mem e s) ->
  (mem (f e) s') /\
  forall (e1:a) (e':a), (mem e1 s) -> (mem e' s) -> ~ (e1 = e') ->
  ~ ((f e1) = (f e')).

(* Why3 assumption *)
Definition equal_func {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (g:a -> b) : Prop :=
  forall (e:a), ((f e) = (g e)).

Axiom set_equal_func :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b), (forall (e:a), ((f e) = (g e))) -> (f = g).

Axiom get_equal_func :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b), (equal_func f g) -> forall (e:a),
  ((f e) = (g e)).

Axiom set_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a),
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  p_injective f s.

Axiom image_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), forall (a1:b),
  (mem a1 (map f s)) <->
  exists antec_a:a, (mem antec_a s) /\ (a1 = (f antec_a)).

Axiom card_image :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((cardinal (map f s)) <= (cardinal s))%Z.

Axiom card_image_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) ->
  ((cardinal (map f s)) = (cardinal s)).

Axiom get_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), (p_injective f s) -> forall (e:a) (e':a),
  (mem e s) -> (mem e' s) -> ~ (e = e') -> ~ ((f e) = (f e')).

Axiom get_not_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ~ (p_injective f s) ->
  exists e:a, exists e':a,
  (mem e s) /\ ((mem e' s) /\ (~ (e = e') /\ ((f e) = (f e')))).

Axiom set_injective_in :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  p_injective f s.

Axiom get_injective_in :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_injective_in f s s') ->
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
  ~ ((f e) = (f e')).

(* Why3 assumption *)
Definition p_surjective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) (s':set b) : Prop :=
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e').

Axiom set_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  p_surjective f s s'.

Axiom get_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_surjective f s s') ->
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e').

Axiom image_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_surjective f s s') ->
  ((map f s) = s').

(* Why3 assumption *)
Definition p_bijective {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (f:a -> b) (s:set a) (s':set b) : Prop :=
  (p_injective_in f s s') /\ (p_surjective f s s').

Axiom bijective_is_injective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_injective f s.

Axiom bijective_is_surjective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_surjective f s s'.

Axiom set_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b),
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  (p_bijective f s s') /\ ((map f s) = s').

Axiom bijectivity_is_transitive :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {c:Type} {c_WT:WhyType c},
  forall (f:a -> b) (g:b -> c) (s:set a) (s':set b) (s'':set c),
  (p_bijective f s s') -> (p_bijective g s' s'') ->
  p_bijective (fun (k:a) => (g (f k))) s s''.

Axiom bijective_image :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  ((cardinal s) = (cardinal s')) /\ (s' = (map f s)).

Axiom get_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  (forall (e:a), (mem e s) -> mem (f e) s') /\
  ((forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
    ~ ((f e) = (f e'))) /\
   ((forall (e':b), (mem e' s') -> exists e:a, (mem e s) /\ ((f e) = e')) /\
    ((cardinal s) = (cardinal s')))).

Axiom bijective_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  (forall (e:a), (mem e s) -> ((f e) = (g e))) -> p_bijective g s s'.

Axiom bijective_eq_gen :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  forall (g:a -> b), (forall (e:a), (mem e s) -> ((f e) = (g e))) ->
  p_bijective g s s'.

Axiom bij_equal_card :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a), ((cardinal s) = (cardinal (map f s))) ->
  p_bijective f s (map f s).

Axiom set_bijective_auto :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a), (forall (e:a), (mem e s) -> mem (f e) s) ->
  (forall (e':a), (mem e' s) -> exists e:a, (mem e s) /\ ((f e) = e')) ->
  p_bijective f s s.

Axiom iterate_empty :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t:a -> im), (is_empty s) ->
  (commut op1) -> (iterable op1) -> ((iterate op1 s t) = (neutral_elt op1)).

Axiom iterate_one :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t:a -> im), ((cardinal s) = 1%Z) ->
  (commut op1) -> ((iterate op1 s t) = (t (choose s))).

Axiom iterate_add :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (x:a), (commut op1) ->
  (iterable op1) -> ~ (mem x s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom iterate_add_ :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (x:a), (commut op1) ->
  ~ (mem x s) -> ~ (is_empty s) ->
  ((iterate op1 (add x s) f) = ((op1 (f x)) (iterate op1 s f))).

Axiom iterate_remove :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (x:a), (commut op1) ->
  (iterable op1) ->
  (inverse_tuple op1 (fun (y0:im) (y1:im) => (po y0 y1)) (neutral_elt op1)) ->
  (mem x s) -> ((iterate op1 (remove x s) f) = (po (iterate op1 s f) (f x))).

Axiom iterate_def_choose :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im),
  (((cardinal s) = 1%Z) -> iterable op1) -> (commut op1) -> ~ (is_empty s) ->
  ((iterate op1 s f) =
   ((op1 (f (choose s))) (iterate op1 (remove (choose s) s) f))).

Axiom choose_any :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (t:a), (iterable op1) ->
  (commut op1) -> (mem t s) ->
  ((iterate op1 s f) = ((op1 (f t)) (iterate op1 (remove t s) f))).

Axiom iterate_comp_iterate :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (f:a -> im) (g:a -> im),
  (iterable op1) -> (commut op1) -> (assoc op1) ->
  ((iterate op1 s1 (fun (k:a) => ((op1 (f k)) (g k)))) =
   ((op1 (iterate op1 s1 (fun (k:a) => (f k))))
    (iterate op1 s1 (fun (k:a) => (g k))))).

Axiom iterate_comp_iterate_com :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (f:a -> im) (g:a -> im),
  (iterable op1) -> (commut op1) ->
  (((op1 (iterate op1 s1 (fun (k:a) => (f k))))
    (iterate op1 s1 (fun (k:a) => (g k))))
   = (iterate op1 s1 (fun (k:a) => ((op1 (f k)) (g k))))).

Axiom iterate_transitivity :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (po1:im -> im -> im) (s1:set a) (s2:set a)
    (f:a -> im),
  (iterable op1) -> (commut op1) ->
  (inverse_tuple op1 po1 (neutral_elt op1)) ->
  ((iterate op1 (union s1 s2) f) =
   ((po1 ((op1 (iterate op1 s1 f)) (iterate op1 s2 f)))
    (iterate op1 (inter s1 s2) f))).

Axiom iterate_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (s2:set a) (t:a -> im),
  (iterable op1) -> (commut op1) -> ((inter s1 s2) = (empty : set a)) ->
  ((iterate op1 (union s1 s2) t) =
   ((op1 (iterate op1 s1 t)) (iterate op1 s2 t))).

Axiom iterate_eq :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f:a -> im) (g:a -> im),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> (commut op1) ->
  ((is_empty s) -> iterable op1) -> ((iterate op1 s f) = (iterate op1 s g)).

Axiom iterate_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set b) (f:b -> a) (t:a -> im),
  ((is_empty s) -> iterable op1) -> (commut op1) -> (p_injective f s) ->
  ((iterate op1 (map f s) t) = (iterate op1 s (fun (b1:b) => (t (f b1))))).

Axiom iterate_cardone :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t:a -> im), (iterable op1) ->
  (commut op1) -> ((cardinal s) = 1%Z) ->
  ((iterate op1 s t) = (t (element s))).

Axiom iterate_cardzero :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (t:a -> im), (commut op1) ->
  (iterable op1) -> ((cardinal s) = 0%Z) ->
  ((iterate op1 s t) = (neutral_elt op1)).

Axiom injec_iterate :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (a1:a) (s:set b) (f:a -> b -> im),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s (f a1)) =
   (iterate op1 (cartesian_product (add a1 (empty : set a)) s)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s1:set a) (s2:set b) (f:a -> b -> im),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s1 (fun (a1:a) => (iterate op1 s2 (f a1)))) =
   (iterate op1 (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_eq_func :
  forall {a:Type} {a_WT:WhyType a} {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (s:set a) (f1:a -> im) (f2:a -> im),
  (commut op1) -> (iterable op1) -> (p_injective f1 s) ->
  (p_injective f2 s) -> ((map f1 s) = (map f2 s)) ->
  ((iterate op1 s f1) = (iterate op1 s f2)).

Axiom int_iterate_def_empty :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (j <= i)%Z ->
  (iterable op1) -> ((int_iterate op1 f i j) = (neutral_elt op1)).

Axiom int_iterate_def_plus_one :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (i < j)%Z ->
  (((i + 1%Z)%Z = j) -> iterable op1) ->
  ((int_iterate op1 f i j) = ((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j))).

Axiom int_iterate_cardone :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((int_iterate op1 f i j) = (f i)).

Axiom int_iterate_def_plus_one_com :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (i < j)%Z ->
  ((j = (i + 1%Z)%Z) -> iterable op1) ->
  (((op1 (f i)) (int_iterate op1 f (i + 1%Z)%Z j)) = (int_iterate op1 f i j)).

Axiom int_iterate_to_iterate :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z),
  ((j <= i)%Z -> iterable op1) -> (commut op1) ->
  ((int_iterate op1 f i j) = (iterate op1 (to_fset i j) f)).

Axiom int_iterate_right_extension :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (iterable op1) ->
  (i < j)%Z ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i (j - 1%Z)%Z)) (f (j - 1%Z)%Z))).

Axiom int_iterate_right_extension_ :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z), (assoc op1) ->
  ((i + 1%Z)%Z < j)%Z ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i (j - 1%Z)%Z)) (f (j - 1%Z)%Z))).

Axiom int_iterate_transitivity :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (k:Z) (j:Z),
  (iterable op1) -> (iterable op1) ->
  (op_neutral_left op1 (neutral_elt op1)) -> ((i <= k)%Z /\ (k <= j)%Z) ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i k)) (int_iterate op1 f k j))).

Axiom int_iterate_transitivity_ :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (k:Z) (j:Z),
  (op_neutral_left op1 (neutral_elt op1)) -> ((i < k)%Z /\ (k < j)%Z) ->
  ((int_iterate op1 f i j) =
   ((op1 (int_iterate op1 f i k)) (int_iterate op1 f k j))).

Axiom int_iterate_comp_iterate :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (g:Z -> im) (i:Z) (j:Z),
  (iterable op1) -> (op_neutral_right op1 (neutral_elt op1)) ->
  (commut op1) ->
  ((int_iterate op1 (fun (k:Z) => ((op1 (f k)) (g k))) i j) =
   ((op1 (int_iterate op1 f i j)) (int_iterate op1 g i j))).

Axiom int_iterate_attr_no_f :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t1:Z -> im1)
    (t2:Z -> im2) (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (t2 x)) (f y)) = (f ((op1 (t1 x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (iterable op1) ->
  (iterable op2) -> (forall (i1:Z), ((f (t1 i1)) = (t2 i1))) ->
  ((int_iterate op2 t2 i j) = (f (int_iterate op1 t1 i j))).

Axiom int_iterate_attr :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t x))) (f y)) = (f ((op1 (t x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (iterable op1) ->
  (iterable op2) ->
  ((int_iterate op2 (fun (e:Z) => (f (t e))) i j) =
   (f (int_iterate op1 t i j))).

Axiom int_iterate_attr_comm :
  forall {im1:Type} {im1_WT:WhyType im1} {im2:Type} {im2_WT:WhyType im2},
  forall (op1:im1 -> im1 -> im1) (op2:im2 -> im2 -> im2) (t:Z -> im1)
    (f:im1 -> im2) (i:Z) (j:Z),
  (forall (x:Z), forall (y:im1),
   (((op2 (f (t x))) (f y)) = (f ((op1 (t x)) y)))) ->
  ((f (neutral_elt op1)) = (neutral_elt op2)) -> (iterable op1) ->
  (iterable op2) ->
  ((f (int_iterate op1 t i j)) =
   (int_iterate op2 (fun (e:Z) => (f (t e))) i j)).

Axiom int_iterate_eq :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (g:Z -> im) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((j <= i)%Z -> iterable op1) ->
  ((int_iterate op1 f i j) = (int_iterate op1 g i j)).

Axiom int_iterate_left_right :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (l:Z) (k:Z) (h:Z),
  (iterable op1) -> (commut op1) -> ((l <= k)%Z /\ (k <= h)%Z) ->
  ((int_iterate op1 f l k) =
   (int_iterate op1 (fun (a:Z) => (f ((h - (a + 1%Z)%Z)%Z + l)%Z))
    ((h - k)%Z + l)%Z h)).

Axiom int_iterate_eq_func :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (f:Z -> im) (g:Z -> im),
  (iterable op1) -> (commut op1) -> (p_injective f (to_fset i j)) ->
  (p_injective g (to_fset i j)) ->
  ((map f (to_fset i j)) = (map g (to_fset i j))) ->
  ((int_iterate op1 f i j) = (int_iterate op1 g i j)).

Axiom int_iterate_map :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t:Z -> im),
  ((j <= i)%Z -> iterable op1) -> (commut op1) ->
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((int_iterate op1 t k l) = (int_iterate op1 (fun (b:Z) => (t (f b))) i j)).

Axiom int_iterate_transl :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (f:Z -> im) (i:Z) (j:Z) (k:Z),
  (iterable op1) ->
  ((int_iterate op1 f i j) =
   (int_iterate op1 (fun (b:Z) => (f (b + k)%Z)) (i - k)%Z (j - k)%Z)).

Axiom int_iterate_map_auto :
  forall {im:Type} {im_WT:WhyType im},
  forall (op1:im -> im -> im) (i:Z) (j:Z) (f:Z -> Z) (t:Z -> im),
  ((j <= i)%Z -> iterable op1) -> (commut op1) ->
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((int_iterate op1 t i j) = (int_iterate op1 (fun (b:Z) => (t (f b))) i j)).

Axiom leq_trans :
  forall (a:Z) (b:Z) (c:Z), (a <= b)%Z -> (b <= c)%Z -> (a <= c)%Z.

Axiom leq_trans_add :
  forall (a:Z) (b:Z) (c:Z) (d:Z), (a <= c)%Z -> (b <= d)%Z ->
  ((a + b)%Z <= (c + d)%Z)%Z.

Axiom leq_trans_mult :
  forall (a:Z) (b:Z) (c:Z), (0%Z <= c)%Z -> (a <= b)%Z ->
  ((a * c)%Z <= (b * c)%Z)%Z.

Axiom leq_trans_mult_right :
  forall (a:Z) (b:Z) (c:Z), (0%Z <= c)%Z -> (a <= b)%Z ->
  ((c * a)%Z <= (c * b)%Z)%Z.

Axiom compat_int_order_mult :
  forall (a:Z) (b:Z) (c:Z) (d:Z), ((0%Z <= c)%Z /\ (c <= d)%Z) ->
  ((0%Z <= a)%Z /\ (a <= b)%Z) -> ((c * a)%Z <= (d * b)%Z)%Z.

Axiom leq_trans_fact :
  forall (a:Z) (b:Z) (c:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= a)%Z /\ (a <= c)%Z) -> ((0%Z <= b)%Z /\ (b <= (c * n)%Z)%Z) ->
  ((a + b)%Z <= (c * (n + 1%Z)%Z)%Z)%Z.

Axiom leq_trans_facrev :
  forall (a:Z) (b:Z) (c:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= a)%Z /\ (a <= c)%Z) -> ((0%Z <= b)%Z /\ (b <= (c * n)%Z)%Z) ->
  ((b + a)%Z <= (c * (n + 1%Z)%Z)%Z)%Z.

Axiom neutrals :
  (0%Z = (neutral_elt (fun (y0:Z) (y1:Z) => (y0 + y1)%Z))) /\
  ((1%Z = (neutral_elt (fun (y0:Z) (y1:Z) => (y0 * y1)%Z))) /\
   ((iterable (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)) /\
    (iterable (fun (y0:Z) (y1:Z) => (y0 * y1)%Z)))).

(* Why3 assumption *)
Definition isum {a:Type} {a_WT:WhyType a} (s:set a) (t:a -> Z) : Z :=
  iterate (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) s t.

(* Why3 assumption *)
Definition iproduct {a:Type} {a_WT:WhyType a} (s:set a) (t:a -> Z) : Z :=
  iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) s t.

Axiom isum_iter : iterates (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) 0%Z.

Axiom isum_iter__ : iterable (fun (y0:Z) (y1:Z) => (y0 + y1)%Z).

Axiom isum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> Z) (t':a -> Z),
  (forall (e:a), (mem e s) -> ((t e) = (t' e))) -> ((isum s t) = (isum s t')).

Axiom isum_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (t:a -> Z) (t':a -> Z), (s = s') ->
  (forall (e:a), (mem e s) -> ((t e) = (t' e))) -> ((isum s t) = (isum s t')).

Axiom isum_add :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> Z) (x:b), ~ (mem x s) ->
  ((isum (add x s) f) = ((f x) + (isum s f))%Z).

Axiom iproduct_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> Z) (t':a -> Z),
  (forall (e:a), (mem e s) -> ((t e) = (t' e))) ->
  ((iproduct s t) = (iproduct s t')).

Axiom iproduct_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (t:a -> Z) (t':a -> Z), (s = s') ->
  (forall (e:a), (mem e s) -> ((t e) = (t' e))) ->
  ((iproduct s t) = (iproduct s t')).

Axiom iproduct_add :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> Z) (x:b), ~ (mem x s) ->
  ((iproduct (add x s) f) = ((f x) * (iproduct s f))%Z).

Axiom iproduct_from_choose :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> Z), (0%Z < (cardinal s))%Z ->
  ((iproduct s f) = ((f (choose s)) * (iproduct (remove (choose s) s) f))%Z).

Axiom iproduct_map :
  forall (s:set Z) (f:Z -> Z) (t:Z -> Z), (p_injective f s) ->
  ((iproduct (map f s) t) = (iproduct s (fun (b:Z) => (t (f b))))).

Axiom iproduct_map_auto :
  forall (s:set Z) (f:Z -> Z) (t:Z -> Z), (p_bijective f s s) ->
  ((iproduct s t) = (iproduct s (fun (b:Z) => (t (f b))))).

Axiom iproduct_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z), (forall (e:a), (mem e s) -> ((f e) = 1%Z)) ->
  ((iproduct s f) = 1%Z).

Axiom iproduct_one_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z) (e:a), (mem e s) ->
  (forall (e':a), (mem e' s) -> ~ (e' = e) -> ((f e') = 1%Z)) ->
  ((iproduct s f) = (f e)) /\
  ((iproduct s f) = ((f (choose s)) * (iproduct (remove (choose s) s) f))%Z).

Axiom mul_assoc :
  forall (a:Z) (b:Z) (c:Z), (((a * b)%Z * c)%Z = (a * (b * c)%Z)%Z).

Axiom ad_assoc :
  forall (a:Z) (b:Z) (c:Z), (((a + b)%Z + c)%Z = (a + (b + c)%Z)%Z).

Axiom ad_assoc_rev :
  forall (a:Z) (b:Z) (c:Z), ((a + (b + c)%Z)%Z = ((a + b)%Z + c)%Z).

Axiom ad_seq_switch :
  forall (a:Z) (b:Z) (c:Z) (a':Z) (b':Z) (c':Z), (a = a') -> (b = b') ->
  (c = c') -> ((a' + (b' + c')%Z)%Z = (b + (c + a)%Z)%Z).

Axiom mul_comm : forall (a:Z) (b:Z), ((a * b)%Z = (b * a)%Z).

Axiom add_eq_i :
  forall (a:Z) (a':Z) (b:Z) (b':Z), (a = a') -> (b = b') ->
  ((a + b)%Z = (a' + b')%Z).

Axiom mult_eq_i :
  forall (a:Z) (a':Z) (b:Z) (b':Z), (a = a') -> (b = b') ->
  ((a * b)%Z = (a' * b')%Z).

Axiom mul_assoc_rev :
  forall (a:Z) (b:Z) (c:Z), ((a * (b * c)%Z)%Z = ((a * b)%Z * c)%Z).

Axiom mult_add_distr :
  forall (a:Z) (b:Z) (c:Z) (d:Z),
  (((a + b)%Z * (c + d)%Z)%Z =
   ((((a * c)%Z + (a * d)%Z)%Z + (b * c)%Z)%Z + (b * d)%Z)%Z).

Axiom mult_add_right :
  forall (a:Z) (b:Z) (c:Z), (((a + b)%Z * c)%Z = ((a * c)%Z + (b * c)%Z)%Z).

Axiom mult_add_right_rev :
  forall (a:Z) (b:Z) (c:Z), (((a * c)%Z + (b * c)%Z)%Z = ((a + b)%Z * c)%Z).

Axiom mult_add_left :
  forall (a:Z) (b:Z) (c:Z), ((a * (b + c)%Z)%Z = ((a * b)%Z + (a * c)%Z)%Z).

Axiom mult_add_left_rev :
  forall (a:Z) (b:Z) (c:Z), (((a * b)%Z + (a * c)%Z)%Z = (a * (b + c)%Z)%Z).

Axiom mult_add_distr_rev :
  forall (a:Z) (b:Z) (c:Z) (d:Z),
  (((((a * c)%Z + (a * d)%Z)%Z + (b * c)%Z)%Z + (b * d)%Z)%Z =
   ((a + b)%Z * (c + d)%Z)%Z).

Axiom mul_assoc_comm :
  forall (a:Z) (b:Z) (c:Z), (((a * b)%Z * c)%Z = (b * (a * c)%Z)%Z).

Axiom mul_assoc_rev_comm :
  forall (a:Z) (b:Z) (c:Z), ((a * (b * c)%Z)%Z = ((a * c)%Z * b)%Z).

Axiom add_assoc :
  forall (a:Z) (b:Z) (c:Z), (((a + b)%Z + c)%Z = (a + (b + c)%Z)%Z).

Axiom add_assoc_rev :
  forall (a:Z) (b:Z) (c:Z), ((a + (b + c)%Z)%Z = ((a + b)%Z + c)%Z).

Axiom isum_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z), (is_empty s) -> ((isum s f) = 0%Z).

Axiom iproduct_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z), (is_empty s) -> ((iproduct s f) = 1%Z).

Axiom isum_iter_ :
  (opposite_n (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
   (fun (y0:Z) (y1:Z) => (y0 - y1)%Z) 0%Z) /\
  ((opposite (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
    (fun (y0:Z) (y1:Z) => (y0 - y1)%Z)) /\
   ((opposite_com (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
     (fun (y0:Z) (y1:Z) => (y0 - y1)%Z)) /\
    (inverse_tuple (fun (y0:Z) (y1:Z) => (y0 + y1)%Z)
     (fun (y0:Z) (y1:Z) => (y0 - y1)%Z) 0%Z))).

(* Why3 assumption *)
Definition ind_isum (f:Z -> Z) (i:Z) (j:Z) : Z :=
  int_iterate (fun (y0:Z) (y1:Z) => (y0 + y1)%Z) f i j.

Axiom ind_isum_empty :
  forall (f:Z -> Z) (i:Z) (j:Z), (j <= i)%Z -> ((ind_isum f i j) = 0%Z).

Axiom ind_isum_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((ind_isum f i j) = (f i)).

Axiom ind_isum_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum f i j) = ((f i) + (ind_isum f (i + 1%Z)%Z j))%Z).

Axiom ind_isum_to_isum :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum f i j) = (isum (to_fset i j) f)).

Axiom pos_to_strict : forall (a:Z), (1%Z <= a)%Z -> (0%Z < a)%Z.

Axiom pos_by_strict : forall (a:Z), (0%Z < a)%Z -> (1%Z <= a)%Z.

Axiom ind_isum_const :
  forall (k:Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum ((fun (y0:Z) (y1:Z) => y0) k) i j) = (k * (j - i)%Z)%Z).

Axiom ind_isum_null :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = 0%Z)) ->
  ((ind_isum f i j) = 0%Z).

Axiom ind_isum_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((ind_isum f i (j + 1%Z)%Z) = ((ind_isum f i j) + (f j))%Z).

Axiom ind_isum_re :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_isum f i j) = ((ind_isum f i (j - 1%Z)%Z) + (f (j - 1%Z)%Z))%Z).

Axiom ind_isum_re_null :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z -> ((f j) = 0%Z) ->
  ((ind_isum f i (j + 1%Z)%Z) = (ind_isum f i j)).

Axiom ind_isum_null_but_maybe_one_elt :
  forall (l:Z) (h:Z) (t:Z -> Z) (e:Z), ((l <= e)%Z /\ (e < h)%Z) ->
  (forall (a:Z), ((l <= a)%Z /\ (a < h)%Z) -> ~ (a = e) -> ((t a) = 0%Z)) ->
  ((ind_isum t l h) = (t e)).

Axiom ind_isum_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_isum f i j) = (ind_isum g i j)).

Parameter fc: (Z -> Z) -> (Z -> Z) -> (Z -> bool) -> Z -> Z.

Axiom fc_def :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (k:Z),
  (((p k) = true) -> (((fc f g p) k) = (f k))) /\
  (~ ((p k) = true) -> (((fc f g p) k) = (g k))).

Axiom ind_isum_to_guard :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((p k) = true)) ->
  ((ind_isum (fc f g p) i j) = (ind_isum f i j)).

Parameter fc1: (Z -> Z) -> (Z -> Z) -> (Z -> bool) -> Z -> Z.

Axiom fc_def1 :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (k:Z),
  (((p k) = true) -> (((fc1 f g p) k) = (g k))) /\
  (~ ((p k) = true) -> (((fc1 f g p) k) = (f k))).

Axiom ind_isum_no_guard :
  forall (f:Z -> Z) (g:Z -> Z) (p:Z -> bool) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ~ ((p k) = true)) ->
  ((ind_isum (fc1 f g p) i j) = (ind_isum f i j)).

Axiom ind_isum_eq_gen :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (i1:Z) (j:Z) (j1:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) -> (i = i1) ->
  (j = j1) -> ((ind_isum f i j) = (ind_isum g i1 j1)).

Axiom ind_isum_func_const :
  forall (k:Z) (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (l:Z), ((i <= l)%Z /\ (l < j)%Z) -> ((f l) = k)) ->
  ((ind_isum f i j) = (k * (j - i)%Z)%Z).

Axiom ind_isum_pos :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z <= (f k))%Z) ->
  (0%Z <= (ind_isum f i j))%Z.

(* Why3 assumption *)
Definition ind_iproduct (f:Z -> Z) (i:Z) (j:Z) : Z :=
  int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) f i j.

Axiom ind_iproduct_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_iproduct f i j) = (ind_iproduct g i j)).

Axiom ind_iproduct_eq_gen :
  forall (f:Z -> Z) (g:Z -> Z) (i1:Z) (j1:Z) (i2:Z) (j2:Z),
  (forall (k:Z), ((i1 <= k)%Z /\ (k < j1)%Z) -> ((f k) = (g k))) ->
  (i1 = i2) -> (j1 = j2) -> ((ind_iproduct f i1 j1) = (ind_iproduct g i2 j2)).

Axiom ind_iproduct_to_iproduct :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_iproduct f i j) = (iproduct (to_fset i j) f)).

Axiom ind_iproduct_one_but_maybe_one_elt :
  forall (f:Z -> Z) (i:Z) (j:Z) (e:Z), ((i <= e)%Z /\ (e < j)%Z) ->
  (forall (e':Z), ((i <= e')%Z /\ (e' <= j)%Z) -> ~ (e = e') ->
   ((f e') = 1%Z)) ->
  ((ind_iproduct f i j) = (f e)).

Axiom mult_one_int : forall (a:Z) (b:Z), (b = 1%Z) -> ((a * b)%Z = a).

Axiom one_mult_int : forall (a:Z) (b:Z), (a = 1%Z) -> ((a * b)%Z = b).

Axiom mult_zero_int : forall (a:Z) (b:Z), (b = 0%Z) -> ((a * b)%Z = 0%Z).

Axiom zero_mult_int : forall (a:Z) (b:Z), (a = 0%Z) -> ((a * b)%Z = 0%Z).

Axiom iproduct_to_iterate :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_iproduct f i j) =
   (int_iterate (fun (y0:Z) (y1:Z) => (y0 * y1)%Z) f i j)).

Axiom ind_isum_map_auto :
  forall (i:Z) (j:Z) (f:Z -> Z) (t:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((ind_isum t i j) = (ind_isum (fun (b:Z) => (t (f b))) i j)).

Axiom ind_isum_rev :
  forall (i:Z) (j:Z) (f:Z -> Z),
  ((ind_isum f i j) =
   (ind_isum (fun (k:Z) => (f (((j - k)%Z - 1%Z)%Z + i)%Z)) i j)).

Axiom ind_isum_map :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_isum t k l) = (ind_isum (fun (b:Z) => (t (f b))) i j)).

Axiom ind_isum_map_auto_bij :
  forall (i:Z) (j:Z) (f:Z -> Z) (t:Z -> Z),
  (forall (e:Z), ((i <= e)%Z /\ (e < j)%Z) ->
   (i <= (f e))%Z /\ ((f e) < j)%Z) ->
  (forall (e:Z) (e':Z), ((i <= e)%Z /\ (e < j)%Z) ->
   ((i <= e')%Z /\ (e' < j)%Z) -> ~ (e = e') -> ~ ((f e) = (f e'))) ->
  (forall (e':Z), ((i <= e')%Z /\ (e' < j)%Z) ->
   exists e:Z, ((i <= e)%Z /\ (e < j)%Z) /\ ((f e) = e')) ->
  ((ind_isum t i j) = (ind_isum (fun (b:Z) => (t (f b))) i j)).

Axiom ind_isum_map_bij :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t:Z -> Z),
  (forall (e:Z), ((i <= e)%Z /\ (e < j)%Z) ->
   (k <= (f e))%Z /\ ((f e) < l)%Z) ->
  (forall (e:Z) (e':Z), ((i <= e)%Z /\ (e < j)%Z) ->
   ((i <= e')%Z /\ (e' < j)%Z) -> ~ (e = e') -> ~ ((f e) = (f e'))) ->
  (forall (e':Z), ((k <= e')%Z /\ (e' < l)%Z) ->
   exists e:Z, ((i <= e)%Z /\ (e < j)%Z) /\ ((f e) = e')) ->
  ((ind_isum t k l) = (ind_isum (fun (b:Z) => (t (f b))) i j)).

Axiom ind_iproduct_empty :
  forall (f:Z -> Z) (i:Z) (j:Z), (j <= i)%Z -> ((ind_iproduct f i j) = 1%Z).

Axiom ind_iproduct_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_iproduct f i j) = ((f i) * (ind_iproduct f (i + 1%Z)%Z j))%Z).

Axiom ind_iproduct_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_iproduct f i j) =
   ((ind_iproduct f i (j - 1%Z)%Z) * (f (j - 1%Z)%Z))%Z).

Axiom ind_iproduct_right_extension_comm :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (((ind_iproduct f i (j - 1%Z)%Z) * (f (j - 1%Z)%Z))%Z =
   (ind_iproduct f i j)).

Axiom ind_iproduct_comp :
  forall (f:Z -> Z) (g:Z -> Z) (h:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (((f k) * (g k))%Z = (h k))) ->
  ((ind_iproduct h i j) = ((ind_iproduct f i j) * (ind_iproduct g i j))%Z).

Axiom ind_iproduct_one :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = 1%Z)) ->
  ((ind_iproduct f i j) = 1%Z).

Axiom positive_iproduct :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z < (f k))%Z) ->
  (0%Z < (ind_iproduct f i j))%Z.

Axiom ind_iproduct_pos :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z <= (f k))%Z) ->
  (0%Z <= (ind_iproduct f i j))%Z.

Axiom ind_iproduct_strict_pos :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z < (f k))%Z) ->
  (0%Z < (ind_iproduct f i j))%Z.

Axiom iproduct_strict_pos :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z),
  (forall (k:a), (mem k s) -> (0%Z < (f k))%Z) -> (0%Z < (iproduct s f))%Z.

Axiom ind_iproduct_strict_pos_one :
  forall (f:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (0%Z < (f k))%Z) ->
  (1%Z <= (ind_iproduct f i j))%Z.

Axiom ind_iproduct_left_right :
  forall (f:Z -> Z) (l:Z) (k:Z) (h:Z), ((l <= k)%Z /\ (k <= h)%Z) ->
  ((ind_iproduct f l k) =
   (ind_iproduct (fun (a:Z) => (f ((h - (a + 1%Z)%Z)%Z + l)%Z))
    ((h - k)%Z + l)%Z h)).

Axiom iterable_imult : iterable (fun (y0:Z) (y1:Z) => (y0 * y1)%Z).

Axiom int_minus_distr :
  forall (a:Z) (b:Z), ((-(a + b)%Z)%Z = ((-a)%Z + (-b)%Z)%Z).

Axiom int_minus_eq : forall (a:Z) (b:Z), (a = b) -> ((-a)%Z = (-b)%Z).

Axiom ind_iproduct_map_auto :
  forall (i:Z) (j:Z) (f:Z -> Z) (t:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset i j)) ->
  ((ind_iproduct t i j) = (ind_iproduct (fun (b:Z) => (t (f b))) i j)).

Axiom ind_iproduct_map :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t:Z -> Z),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_iproduct t k l) = (ind_iproduct (fun (b:Z) => (t (f b))) i j)).

Axiom ind_iproduct_trans :
  forall (f:Z -> Z) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_iproduct f i j) = ((ind_iproduct f i k) * (ind_iproduct f k j))%Z).

Axiom ind_iproduct_inf :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) ->
   (0%Z <= (f k))%Z /\ ((f k) <= (g k))%Z) ->
  ((ind_iproduct f i j) <= (ind_iproduct g i j))%Z.

Parameter choose_filter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> bool) -> a.

Axiom choose_filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool),
  (exists e:a, (mem e s) /\ ((p e) = true)) ->
  (((p (choose s)) = true) -> ((choose_filter s p) = (choose s))) /\
  (~ ((p (choose s)) = true) ->
   ((choose_filter s p) = (choose_filter (remove (choose s) s) p))).

Axiom choose_filter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool),
  (exists e:a, (mem e s) /\ ((p e) = true)) ->
  ((p (choose_filter s p)) = true) /\ (mem (choose_filter s p) s).

Parameter my_filter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> bool) -> set a.

Axiom my_filter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool),
  ((is_empty s) -> ((my_filter s p) = (empty : set a))) /\
  (~ (is_empty s) ->
   (((p (choose s)) = true) ->
    ((my_filter s p) = (add (choose s) (my_filter (remove (choose s) s) p)))) /\
   (~ ((p (choose s)) = true) ->
    ((my_filter s p) = (my_filter (remove (choose s) s) p)))).

Axiom my_filter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool),
  (forall (e:a), (mem e s) -> ((p e) = true) <-> (mem e (my_filter s p))) /\
  ((forall (e:a), (mem e (my_filter s p)) -> mem e s) /\
   ((0%Z <= (cardinal (my_filter s p)))%Z /\
    ((cardinal (my_filter s p)) <= (cardinal s))%Z)).

Axiom in_my_filter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool) (e:a), (mem e s) -> ((p e) = true) ->
  mem e (my_filter s p).

Axiom not_in_my_filter_set :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool) (e:a), ~ (mem e s) ->
  ~ (mem e (my_filter s p)).

Axiom not_in_my_filter_filter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool) (e:a), ~ ((p e) = true) ->
  ~ (mem e (my_filter s p)).

Axiom in_my_filter_set :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool) (e:a), (mem e (my_filter s p)) -> mem e s.

Axiom in_my_filter_filter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p:a -> bool) (e:a), (mem e (my_filter s p)) ->
  ((p e) = true).

Axiom my_filter_inter :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p1:a -> bool) (p2:a -> bool),
  (forall (e:a), (mem e s) -> ((p1 e) = true) -> ~ ((p2 e) = true)) ->
  ((inter (my_filter s p1) (my_filter s p2)) = (empty : set a)).

Axiom my_filter_union :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (p1:a -> bool) (p2:a -> bool),
  (forall (e:a), (mem e s) -> ~ ((p1 e) = true) -> ((p2 e) = true)) ->
  ((union (my_filter s p1) (my_filter s p2)) = s).

Axiom ind_iproduct_sup_one :
  forall (f:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (1%Z <= (f k))%Z) ->
  (exists k:Z, ((i <= k)%Z /\ (k < j)%Z) /\ ~ ((f k) = 1%Z)) ->
  (1%Z < (ind_iproduct f i j))%Z.

Axiom ind_isum_transl :
  forall (f:Z -> Z) (i:Z) (j:Z) (k:Z),
  ((ind_isum f i j) =
   (ind_isum (fun (b:Z) => (f (b + k)%Z)) (i - k)%Z (j - k)%Z)).

Axiom ind_isum_transl_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_isum f i j) =
   (ind_isum (fun (b:Z) => (f (b - 1%Z)%Z)) (i + 1%Z)%Z (j + 1%Z)%Z)).

Axiom ind_isum_transl_minus_one :
  forall (f:Z -> Z) (i:Z) (j:Z),
  ((ind_isum f i j) =
   (ind_isum (fun (b:Z) => (f (b + 1%Z)%Z)) (i - 1%Z)%Z (j - 1%Z)%Z)).

Axiom ind_isum_scal :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  ((ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j) = (a * (ind_isum f i j))%Z).

Axiom minus_ind_isum :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((-(ind_isum f i j))%Z = (ind_isum (fun (i1:Z) => (-(f i1))%Z) i j)).

Axiom minus_ind_isum_rev :
  forall (f:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  ((ind_isum (fun (i1:Z) => (-(f i1))%Z) i j) = (-(ind_isum f i j))%Z).

Axiom ind_isum_scal_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  ((a * (ind_isum f i j))%Z = (ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j)).

Axiom ind_isum_scal_rev_right :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  (((ind_isum f i j) * a)%Z = (ind_isum (fun (i1:Z) => ((f i1) * a)%Z) i j)).

Axiom ind_isum_scal_right :
  forall (f:Z -> Z) (i:Z) (j:Z) (a:Z), (i <= j)%Z ->
  ((ind_isum (fun (i1:Z) => ((f i1) * a)%Z) i j) = ((ind_isum f i j) * a)%Z).

Axiom ind_isum_bound :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) < (g k))%Z) ->
  ((ind_isum f i j) < (ind_isum g i j))%Z.

Axiom comp_trans_equal_strict :
  forall (a:Z) (b:Z) (c:Z), (a <= b)%Z -> (b < c)%Z -> (a < c)%Z.

Axiom transitive_inf_leq_int :
  forall (a:Z) (b:Z) (c:Z), (a < b)%Z -> (b <= c)%Z -> (a < c)%Z.

Axiom transitive_inf_int :
  forall (a:Z) (b:Z) (c:Z), (a < b)%Z -> (b < c)%Z -> (a < c)%Z.

Axiom compeq_trans_sum :
  forall (a:Z) (b:Z) (c:Z), (b <= c)%Z -> ((a + b)%Z <= (a + c)%Z)%Z.

Axiom compeq_trans_sum_zero :
  forall (a:Z) (b:Z), (0%Z <= b)%Z -> (a <= (a + b)%Z)%Z.

Axiom comp_trans_sum :
  forall (a:Z) (b:Z) (c:Z), (b < c)%Z -> ((a + b)%Z < (a + c)%Z)%Z.

Axiom ind_isum_bound_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) <= (g k))%Z) ->
  ((ind_isum f i j) <= (ind_isum g i j))%Z.

Axiom ind_isum_scal_gen :
  forall (f:Z -> Z) (i:Z) (j:Z), forall (a:Z), ((i <= a)%Z /\ (a < j)%Z) ->
  ((ind_isum (fun (i1:Z) => (a * (f i1))%Z) i j) = (a * (ind_isum f i j))%Z).

Axiom ind_isum_trans :
  forall (f:Z -> Z) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_isum f i j) = ((ind_isum f i k) + (ind_isum f k j))%Z).

Axiom minus_out_int : forall (a:Z) (b:Z), (((-a)%Z * b)%Z = (-(a * b)%Z)%Z).

Parameter power: Z -> Z -> Z.

Axiom power_def :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((i = 0%Z) -> ((power e i) = 1%Z)) /\
  (~ (i = 0%Z) -> ((power e i) = (e * (power e (i - 1%Z)%Z))%Z)).

Axiom Power_zero : forall (i:Z), ((power i 0%Z) = 1%Z).

Axiom Power_one : forall (i:Z), ((power i 1%Z) = i).

Axiom power_plus_one :
  forall (i:Z) (x:Z), (0%Z <= x)%Z ->
  ((power i (x + 1%Z)%Z) = ((power i x) * i)%Z).

Axiom power_sum :
  forall (i:Z) (x:Z) (y:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power i (x + y)%Z) = ((power i x) * (power i y))%Z).

Axiom power_mult :
  forall (i:Z) (x:Z) (y:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power i (x * y)%Z) = (power (power i x) y)).

Axiom Power_sum :
  forall (x:Z) (y:Z) (i:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power i (x + y)%Z) = ((power i x) * (power i y))%Z).

Axiom Power_mult :
  forall (x:Z) (y:Z) (i:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power i (x * y)%Z) = (power (power i x) y)).

Axiom power_to_ind_iproduct :
  forall (e:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) = (ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) 0%Z i)).

Axiom power_transl :
  forall (e:Z) (k:Z) (i:Z), (0%Z <= i)%Z ->
  ((power e i) = (ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) k (k + i)%Z)).

Axiom ind_iproduct_to_power :
  forall (e:Z) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) i j) = (power e (j - i)%Z)).

Axiom ind_iproduct_to_power_gen :
  forall (e:Z), forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((ind_iproduct ((fun (y0:Z) (y1:Z) => y0) e) i j) = (power e (j - i)%Z)).

Axiom power_sum_rev :
  forall (x:Z) (n:Z) (m:Z), (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  (((power x n) * (power x m))%Z = (power x (n + m)%Z)).

Axiom power_eq :
  forall (x:Z) (n:Z) (m:Z), (n = m) -> ((power x n) = (power x m)).

Axiom power_eq_gen :
  forall (x:Z) (y:Z) (n:Z) (m:Z), (n = m) -> (x = y) ->
  ((power x n) = (power y m)).

Axiom power_2_sum :
  forall (i:Z), (1%Z <= i)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z (k + 1%Z)%Z)) 0%Z i) =
   ((power 2%Z (i + 1%Z)%Z) - 2%Z)%Z).

Axiom power_decomp :
  forall (i:Z), (1%Z <= i)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z (k + 1%Z)%Z)) 0%Z i) <
   (power 2%Z (i + 1%Z)%Z))%Z.

Parameter fc2: Z -> Z -> Z.

Axiom fc_def2 :
  forall (i:Z) (k:Z),
  (((1%Z <= k)%Z /\ (k < (i + 1%Z)%Z)%Z) ->
   (((fc2 i) k) = (power 2%Z (k - 1%Z)%Z))) /\
  (~ ((1%Z <= k)%Z /\ (k < (i + 1%Z)%Z)%Z) -> (((fc2 i) k) = 0%Z)).

Axiom power_decomp_minus_one :
  forall (i:Z), (1%Z <= i)%Z ->
  ((ind_isum (fc2 i) 1%Z i) < (power 2%Z (i - 1%Z)%Z))%Z.

Axiom power_decomp_ :
  forall (i:Z), (1%Z <= i)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z k)) 0%Z i) < (power 2%Z i))%Z.

Axiom power_decomp_one :
  forall (i:Z), (1%Z <= i)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z (k + 1%Z)%Z)) 1%Z i) <
   (power 2%Z (i + 1%Z)%Z))%Z.

Axiom power_decomp_one_ :
  forall (i:Z), (1%Z <= i)%Z ->
  ((ind_isum (fun (k:Z) => (power 2%Z k)) 1%Z i) < (power 2%Z i))%Z.

Axiom growing_mult :
  forall (n:Z) (m:Z), (0%Z <= n)%Z -> (1%Z <= m)%Z -> (n <= (n * m)%Z)%Z.

Axiom strict_growing_mult :
  forall (n:Z) (m:Z), (1%Z < n)%Z -> (1%Z < m)%Z -> (n < (n * m)%Z)%Z.

Axiom init_exp :
  forall (k:Z),
  ((power k 0%Z) = 1%Z) /\
  (((power k 1%Z) = k) /\ ((power k 2%Z) = (k * k)%Z)).

Axiom positive_int_exp :
  forall (k:Z) (n:Z), (1%Z <= k)%Z -> (0%Z <= n)%Z ->
  (1%Z <= (power k n))%Z /\
  ((0%Z < (power k n))%Z /\ ((power k n) <= (power k (n + 1%Z)%Z))%Z).

Axiom strict_positive_int_exp :
  forall (k:Z) (n:Z), (1%Z < k)%Z -> (0%Z < n)%Z ->
  (1%Z < (power k n))%Z /\
  (((power k (n - 1%Z)%Z) < (power k n))%Z /\
   ((power k n) < (power k (n + 1%Z)%Z))%Z).

Axiom power_minus_one :
  forall (i:Z), (0%Z <= i)%Z ->
  (((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) -> ((power (-1%Z)%Z i) = 1%Z)) /\
  (((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
   ((power (-1%Z)%Z i) = (-1%Z)%Z)).

Axiom growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z <= k)%Z -> ((0%Z <= m)%Z /\ (m <= n)%Z) ->
  ((power k m) <= (power k n))%Z.

Axiom strict_growing_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> ((0%Z <= m)%Z /\ (m < n)%Z) ->
  ((power k m) < (power k n))%Z.

Axiom unicity_exp :
  forall (k:Z) (m:Z) (n:Z), (1%Z < k)%Z -> (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((power k m) = (power k n)) <-> (m = n).

Axiom bounded_sum_exp :
  forall (i:Z) (j:Z) (m:Z) (n:Z), (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  (((i * (power 2%Z n))%Z + j)%Z < (power 2%Z (m + n)%Z))%Z.

Parameter power_: Z -> Z -> Z.

Axiom power__def :
  forall (e:Z) (i:Z),
  ((0%Z <= i)%Z -> ((power_ e i) = (power e i))) /\
  (~ (0%Z <= i)%Z -> ((power_ e i) = 0%Z)).

Axiom power_to_ :
  forall (i:Z) (x:Z), (0%Z <= x)%Z -> ((power i x) = (power_ i x)).

Axiom power_no_ :
  forall (i:Z) (x:Z), (0%Z <= x)%Z -> ((power_ i x) = (power i x)).

Axiom power__plus_one :
  forall (i:Z) (x:Z), (0%Z <= x)%Z ->
  ((power_ i (x + 1%Z)%Z) = ((power_ i x) * i)%Z).

Axiom power__eq :
  forall (e:Z) (e':Z) (i:Z) (i':Z), (e = e') -> (i = i') ->
  ((power_ e i) = (power_ e' i')).

Axiom power__sum :
  forall (i:Z) (x:Z) (y:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power_ i (x + y)%Z) = ((power_ i x) * (power_ i y))%Z).

Axiom power__sum_rev :
  forall (i:Z) (x:Z) (y:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  (((power_ i x) * (power_ i y))%Z = (power_ i (x + y)%Z)).

Axiom power__mult :
  forall (i:Z) (x:Z) (y:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power_ i (x * y)%Z) = (power_ (power_ i x) y)).

Axiom Power_zero_ : forall (i:Z), ((power_ i 0%Z) = 1%Z).

Axiom Power_one_ : forall (i:Z), ((power_ i 1%Z) = i).

Axiom Power_sum_ :
  forall (x:Z) (y:Z) (i:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power_ i (x + y)%Z) = ((power_ i x) * (power_ i y))%Z).

Axiom Power_mult_ :
  forall (x:Z) (y:Z) (i:Z), (0%Z <= x)%Z -> (0%Z <= y)%Z ->
  ((power i (x * y)%Z) = (power (power i x) y)).

Axiom Power_pos_ : forall (i:Z), (0%Z <= i)%Z -> (0%Z < (power_ i 0%Z))%Z.

Axiom Power_pos_gen_ :
  forall (i:Z) (j:Z), (0%Z < i)%Z -> (0%Z <= j)%Z -> (0%Z < (power_ i j))%Z.

Axiom power_two_ :
  forall (x:Z), (0%Z <= x)%Z -> ((power_ x 2%Z) = (x * x)%Z).

Axiom power_plus_one_two :
  forall (x:Z), (0%Z <= x)%Z ->
  ((power_ 2%Z (x + 1%Z)%Z) = ((power_ 2%Z x) + (power_ 2%Z x))%Z).

Axiom growing_right_power_ :
  forall (a:Z) (b:Z) (i:Z), (0%Z <= i)%Z -> ((0%Z <= a)%Z /\ (a <= b)%Z) ->
  ((power_ a i) <= (power_ b i))%Z.

Axiom power_of_one_ :
  forall (a:Z) (b:Z), (0%Z <= b)%Z -> (a = 1%Z) -> ((power_ a b) = 1%Z).

Axiom bound_power_ :
  forall (i:Z) (a:Z) (k:Z) (n:Z), (0%Z < a)%Z ->
  ((0%Z < k)%Z /\ (k <= n)%Z) -> ((0%Z <= i)%Z /\ (i < (power_ a n))%Z) ->
  ((int.EuclideanDivision.div i (power_ a (n - k)%Z)) < (power_ a k))%Z.

Axiom power_inf :
  forall (a:Z) (n:Z) (n':Z), (1%Z < a)%Z -> ((0%Z < n)%Z /\ (n < n')%Z) ->
  ((power_ a n) < (power_ a n'))%Z.

Axiom power_leq :
  forall (a:Z) (n:Z) (n':Z), (0%Z <= a)%Z -> ((0%Z < n)%Z /\ (n <= n')%Z) ->
  ((power_ a n) <= (power_ a n'))%Z.

Axiom power_rises :
  forall (a:Z) (n:Z), (1%Z < a)%Z -> (1%Z < n)%Z -> (a < (power_ a n))%Z.

Axiom int_expo_rises :
  forall (a:Z) (n:Z), (1%Z < a)%Z -> (1%Z <= n)%Z -> (n < (power_ a n))%Z.

Axiom bound_power_2 :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z (n + 1%Z)%Z))%Z) ->
  ((int.EuclideanDivision.div i (power_ 2%Z n)) < 2%Z)%Z.

Parameter polysquare: Z -> Z -> Z -> Z -> Z.

Axiom polysquare_def :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z), (0%Z < n)%Z -> (0%Z <= a2)%Z ->
  (0%Z <= a1)%Z -> (0%Z <= a0)%Z ->
  ((polysquare n a2 a1 a0) =
   (((a2 * (power_ n 2%Z))%Z + (a1 * n)%Z)%Z + a0)%Z).

Axiom polysquare_spec :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z), (0%Z < n)%Z -> (0%Z <= a2)%Z ->
  (0%Z <= a1)%Z -> (0%Z <= a0)%Z -> (0%Z <= (polysquare n a2 a1 a0))%Z.

Axiom polysquare_leq_trans :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z) (b2:Z) (b1:Z) (b0:Z) (pa:Z) (pb:Z) (ps:Z),
  (0%Z < n)%Z -> (0%Z <= a2)%Z -> (0%Z <= a1)%Z -> (0%Z <= a0)%Z ->
  (0%Z <= b2)%Z -> (0%Z <= b1)%Z -> (0%Z <= b0)%Z ->
  (pa <= (polysquare n a2 a1 a0))%Z -> (pb <= (polysquare n b2 b1 b0))%Z ->
  (ps <= (pa + pb)%Z)%Z ->
  (ps <= (polysquare n (a2 + b2)%Z (a1 + b1)%Z (a0 + b0)%Z))%Z.

Axiom polysquare_leq_trans_sc :
  forall (n:Z) (a2:Z) (a1:Z) (a0:Z) (b2:Z) (b1:Z) (b0:Z) (pa:Z) (sc:Z) (ps:Z),
  (0%Z < n)%Z -> (0%Z <= a2)%Z -> (0%Z <= a1)%Z -> (0%Z <= a0)%Z ->
  (0%Z <= sc)%Z -> ((sc * a2)%Z <= b2)%Z -> ((sc * a1)%Z <= b1)%Z ->
  ((sc * a0)%Z <= b0)%Z -> (pa <= (polysquare n a2 a1 a0))%Z ->
  (ps <= (sc * pa)%Z)%Z -> (ps <= (polysquare n b2 b1 b0))%Z.

Axiom polysquare_update :
  forall (na:Z) (nb:Z) (a2:Z) (a1:Z) (a0:Z) (pa:Z),
  ((0%Z < na)%Z /\ (na <= nb)%Z) -> (0%Z <= a2)%Z -> (0%Z <= a1)%Z ->
  (0%Z <= a0)%Z -> (pa <= (polysquare na a2 a1 a0))%Z ->
  (pa <= (polysquare nb a2 a1 a0))%Z.

Axiom power__minus_one :
  forall (i:Z), (0%Z <= i)%Z ->
  (((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
   ((power_ (-1%Z)%Z i) = (-1%Z)%Z)) /\
  (((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) -> ((power_ (-1%Z)%Z i) = 1%Z)).

Axiom complex : Type.
Parameter complex_WhyType : WhyType complex.
Existing Instance complex_WhyType.

Axiom teq_spec :
  forall (x:complex) (y:complex), (infix_eqeq1 x y) <-> (x = y).

Parameter c_zero: complex.

Parameter c_one: complex.

Parameter prefix_mndt: complex -> complex.

Parameter infix_pldt: complex -> complex -> complex.

Parameter infix_asdt: complex -> complex -> complex.

Parameter inv: complex -> complex.

Axiom Assoc :
  forall (x:complex) (y:complex) (z:complex),
  ((infix_pldt (infix_pldt x y) z) = (infix_pldt x (infix_pldt y z))).

Axiom Unit_def_l : forall (x:complex), ((infix_pldt c_zero x) = x).

Axiom Unit_def_r : forall (x:complex), ((infix_pldt x c_zero) = x).

Axiom Inv_def_l :
  forall (x:complex), ((infix_pldt (prefix_mndt x) x) = c_zero).

Axiom Inv_def_r :
  forall (x:complex), ((infix_pldt x (prefix_mndt x)) = c_zero).

Axiom Comm :
  forall (x:complex) (y:complex), ((infix_pldt x y) = (infix_pldt y x)).

Axiom Assoc1 :
  forall (x:complex) (y:complex) (z:complex),
  ((infix_asdt (infix_asdt x y) z) = (infix_asdt x (infix_asdt y z))).

Axiom Mul_distr_l :
  forall (x:complex) (y:complex) (z:complex),
  ((infix_asdt x (infix_pldt y z)) =
   (infix_pldt (infix_asdt x y) (infix_asdt x z))).

Axiom Mul_distr_r :
  forall (x:complex) (y:complex) (z:complex),
  ((infix_asdt (infix_pldt y z) x) =
   (infix_pldt (infix_asdt y x) (infix_asdt z x))).

Axiom Comm1 :
  forall (x:complex) (y:complex), ((infix_asdt x y) = (infix_asdt y x)).

Axiom Unitary : forall (x:complex), ((infix_asdt c_one x) = x).

Axiom NonTrivialRing : ~ (c_zero = c_one).

Axiom Inverse :
  forall (x:complex), ~ (x = c_zero) -> ((infix_asdt x (inv x)) = c_one).

(* Why3 assumption *)
Definition infix_mn (x:complex) (y:complex) : complex :=
  infix_pldt x (prefix_mndt y).

(* Why3 assumption *)
Definition infix_sl (x:complex) (y:complex) : complex :=
  infix_asdt x (inv y).

Axiom add_div :
  forall (x:complex) (y:complex) (z:complex), ~ (z = c_zero) ->
  ((infix_sl (infix_pldt x y) z) =
   (infix_pldt (infix_sl x z) (infix_sl y z))).

Axiom sub_div :
  forall (x:complex) (y:complex) (z:complex), ~ (z = c_zero) ->
  ((infix_sl (infix_mn x y) z) = (infix_mn (infix_sl x z) (infix_sl y z))).

Axiom neg_div :
  forall (x:complex) (y:complex), ~ (y = c_zero) ->
  ((infix_sl (prefix_mndt x) y) = (prefix_mndt (infix_sl x y))).

Axiom assoc_mul_div :
  forall (x:complex) (y:complex) (z:complex), ~ (z = c_zero) ->
  ((infix_sl (infix_asdt x y) z) = (infix_asdt x (infix_sl y z))).

Axiom assoc_div_mul :
  forall (x:complex) (y:complex) (z:complex),
  (~ (y = c_zero) /\ ~ (z = c_zero)) ->
  ((infix_sl (infix_sl x y) z) = (infix_sl x (infix_asdt y z))).

Axiom assoc_div_div :
  forall (x:complex) (y:complex) (z:complex),
  (~ (y = c_zero) /\ ~ (z = c_zero)) ->
  ((infix_sl x (infix_sl y z)) = (infix_sl (infix_asdt x z) y)).

(* Why3 assumption *)
Definition infix_mndt (x:complex) (y:complex) : complex :=
  infix_pldt x (prefix_mndt y).

Parameter infix_sldt: complex -> complex -> complex.

Axiom infix_sldt_def :
  forall (x:complex) (y:complex), ~ (y = c_zero) ->
  ((infix_sldt x y) = (infix_asdt x (inv y))).

Axiom infix_sldt_spec :
  forall (x:complex) (y:complex), ~ (y = c_zero) ->
  ((infix_sldt x y) = (infix_asdt x (inv y))).

Parameter infix_slas: R -> R -> R.

Axiom infix_slas_def :
  forall (x:R) (y:R), ~ (y = 0%R) -> ((infix_slas x y) = (x / y)%R).

Axiom infix_eqas_spec : forall (x:R) (y:R), (infix_eqeq1 x y) <-> (x = y).

(* Why3 assumption *)
Definition infix_lsgtas (x:R) (y:R) : Prop := ~ (infix_eqeq1 x y).

Axiom infix_lsgtas_spec :
  forall (x:R) (y:R), (infix_lsgtas x y) <-> ~ (x = y).

(* Why3 assumption *)
Definition infix_mnas (x:R) (y:R) : R := (x + (-y)%R)%R.

(* Why3 assumption *)
Definition infix_lsas (x:R) (y:R) : Prop := (x <= y)%R /\ (infix_lsgtas x y).

Parameter from_int: Z -> R.

Axiom from_int_spec : forall (x:Z), ((from_int x) = (BuiltIn.IZR x)).

Axiom Zero : ((from_int 0%Z) = 0%R).

Axiom Add :
  forall (x:Z) (y:Z),
  ((from_int (x + y)%Z) = ((from_int x) + (from_int y))%R).

Axiom One : ((from_int 1%Z) = 1%R).

Axiom Sub :
  forall (x:Z) (y:Z),
  ((from_int (x - y)%Z) = (infix_mnas (from_int x) (from_int y))).

Axiom mul_pos :
  forall (x:Z) (y:Z), (0%Z <= y)%Z ->
  ((from_int (x * y)%Z) = ((from_int x) * (from_int y))%R).

Axiom mul :
  forall (x:Z) (y:Z), (0%Z <= y)%Z ->
  ((from_int (x * y)%Z) = ((from_int x) * (from_int y))%R).

Axiom mul_rev :
  forall (x:Z) (y:Z), (0%Z <= y)%Z ->
  (((from_int x) * (from_int y))%R = (from_int (x * y)%Z)).

Axiom neg : forall (x:Z), ((from_int (-x)%Z) = (-(from_int x))%R).

Axiom injective :
  forall (x:Z) (y:Z), ((from_int x) = (from_int y)) -> (x = y).

Axiom Monotonic :
  forall (x:Z) (y:Z), (x <= y)%Z -> ((from_int x) <= (from_int y))%R.

Axiom positive_inv :
  forall (x:R), (infix_lsas 0%R x) -> infix_lsas 0%R (infix_slas 1%R x).

Axiom r_zeroLessOne : (0%R <= 1%R)%R.

Axiom r_compatOrderAdd :
  forall (x:R) (y:R) (z:R), (x <= y)%R -> ((x + z)%R <= (y + z)%R)%R.

Axiom r_compatOrderMult :
  forall (x:R) (y:R) (z:R), (x <= y)%R -> (0%R <= z)%R ->
  ((x * z)%R <= (y * z)%R)%R.

Axiom inv_order :
  forall (a:R) (b:R), (infix_lsas 0%R a) -> (infix_lsas 0%R b) ->
  (a <= b)%R -> ((1%R / b)%R <= (1%R / a)%R)%R.

Axiom inv_strict_order :
  forall (a:R) (b:R), (infix_lsas 0%R a) -> (infix_lsas 0%R b) ->
  (infix_lsas a b) -> infix_lsas (1%R / b)%R (1%R / a)%R.

Axiom invol_neg : forall (a:complex), ((prefix_mndt (prefix_mndt a)) = a).

Axiom injective_neg :
  forall (a:complex) (b:complex), ((prefix_mndt a) = (prefix_mndt b)) ->
  (a = b).

Axiom find_opposite :
  forall (a:complex) (b:complex), ((infix_mndt a b) = c_zero) -> (a = b).

Axiom add_opposite :
  forall (a:complex), ((infix_pldt a (prefix_mndt a)) = c_zero).

Axiom opposite1 : forall (a:complex), ((infix_mndt a a) = c_zero).

Axiom mult_num :
  forall (a:complex) (b:complex) (c:complex), ~ (c = c_zero) ->
  ((infix_sldt (infix_asdt a b) c) = (infix_asdt a (infix_sldt b c))).

Axiom div_as_mult_inv :
  forall (a:complex) (b:complex), ~ (b = c_zero) ->
  ((infix_sldt a b) = (infix_asdt a (infix_sldt c_one b))).

Axiom div_rev :
  forall (a:complex) (b:complex), ~ (b = c_zero) ->
  ((infix_asdt a (infix_sldt c_one b)) = (infix_sldt a b)).

Axiom mult_div_num :
  forall (a:complex) (b:complex) (c:complex), ~ (c = c_zero) ->
  ((infix_asdt (infix_sldt a c) b) = (infix_sldt (infix_asdt a b) c)).

Axiom mult_denom :
  forall (a:complex) (b:complex) (c:complex), ~ (c = c_zero) ->
  ~ (b = c_zero) ->
  ((infix_sldt a (infix_asdt b c)) =
   (infix_asdt (infix_sldt a b) (infix_sldt c_one c))).

Axiom mult_simpl :
  forall (a:complex) (b:complex) (c:complex), ~ (c = c_zero) ->
  ~ (b = c_zero) ->
  ((infix_sldt (infix_asdt a b) (infix_asdt c b)) = (infix_sldt a c)).

Axiom dic_simpl :
  forall (a:complex) (b:complex) (c:complex), ~ (c = c_zero) ->
  ~ (b = c_zero) ->
  ((infix_asdt (infix_sldt a (infix_asdt c b)) b) = (infix_sldt a c)).

Axiom simpl_with_c_one :
  forall (a:complex) (b:complex), ~ (a = c_zero) -> ~ (b = c_zero) ->
  ((infix_asdt (infix_sldt a b) (infix_sldt c_one a)) = (infix_sldt c_one b)).

Axiom add_op :
  forall (a1:complex) (a2:complex), (a1 = (prefix_mndt a2)) ->
  ((infix_pldt a1 a2) = c_zero).

Axiom mult_eq_t :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_asdt a1 b1) = (infix_asdt a2 b2)).

Axiom mult_eq_t_rev :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_asdt a1 b1) = (infix_asdt b2 a2)).

Axiom mult_comm :
  forall (a:complex) (b:complex), ((infix_asdt a b) = (infix_asdt b a)).

Axiom mult_assoc :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt (infix_asdt a b) c) = (infix_asdt a (infix_asdt b c))).

Axiom mult_abc_to_acb :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt (infix_asdt a b) c) = (infix_asdt (infix_asdt a c) b)).

Axiom zero_mult_t :
  forall (a1:complex) (a2:complex), (a1 = c_zero) ->
  ((infix_asdt a1 a2) = c_zero).

Axiom mult_zero_t :
  forall (a1:complex) (a2:complex), (a1 = c_zero) ->
  ((infix_asdt a2 a1) = c_zero).

Axiom mult_one_t :
  forall (a1:complex) (a2:complex), (a2 = c_one) -> ((infix_asdt a1 a2) = a1).

Axiom add_eq_t :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_pldt a1 b1) = (infix_pldt a2 b2)).

Axiom add_eq_t_rev :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_pldt a1 b1) = (infix_pldt b2 a2)).

Axiom substr_eq_t :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_mndt a1 b1) = (infix_mndt a2 b2)).

Parameter im: complex.

Axiom im_Def : ((infix_asdt im im) = (prefix_mndt c_one)).

Parameter r_to_c: R -> complex.

Axiom r_to_c_zero : ((r_to_c 0%R) = c_zero).

Axiom r_to_c_one : ((r_to_c 1%R) = c_one).

Axiom r_to_c_add :
  forall (i:R) (j:R),
  ((infix_pldt (r_to_c i) (r_to_c j)) = (r_to_c (i + j)%R)).

Axiom r_to_c_add_rev :
  forall (i:R) (j:R),
  ((r_to_c (i + j)%R) = (infix_pldt (r_to_c i) (r_to_c j))).

Axiom r_to_c_opp :
  forall (i:R), ((r_to_c (-i)%R) = (prefix_mndt (r_to_c i))).

Axiom r_to_c_div :
  forall (i:R) (j:R), ~ (j = 0%R) ->
  ((r_to_c (infix_slas i j)) = (infix_sldt (r_to_c i) (r_to_c j))).

Axiom r_to_c_mult :
  forall (i:R) (j:R),
  ((infix_asdt (r_to_c i) (r_to_c j)) = (r_to_c (i * j)%R)).

Axiom r_to_c_mult_rev :
  forall (i:R) (j:R),
  ((r_to_c (i * j)%R) = (infix_asdt (r_to_c i) (r_to_c j))).

Axiom r_to_c_sub :
  forall (i:R) (j:R),
  ((infix_mndt (r_to_c i) (r_to_c j)) = (r_to_c (infix_mnas i j))).

Parameter real_part: complex -> R.

Parameter im_part: complex -> R.

Axiom Real_part_add :
  forall (i:complex) (j:complex),
  ((real_part (infix_pldt i j)) = ((real_part i) + (real_part j))%R).

Axiom Im_part_add :
  forall (i:complex) (j:complex),
  ((im_part (infix_pldt i j)) = ((im_part i) + (im_part j))%R).

Axiom Real_part_opposite :
  forall (i:complex), ((real_part (prefix_mndt i)) = (-(real_part i))%R).

Axiom Im_part_opposite :
  forall (i:complex), ((im_part (prefix_mndt i)) = (-(im_part i))%R).

Axiom Complex_decomp :
  forall (i:complex),
  (i =
   (infix_pldt (r_to_c (real_part i)) (infix_asdt im (r_to_c (im_part i))))).

Axiom Unic_decomp :
  forall (i:complex), forall (x:R) (y:R),
  (i = (infix_pldt (r_to_c x) (infix_asdt im (r_to_c y)))) ->
  (x = (real_part i)) /\ (y = (im_part i)).

(* Why3 assumption *)
Definition real_ (x:complex) : Prop := infix_eqeq1 (im_part x) 0%R.

(* Why3 assumption *)
Definition pure_im_ (x:complex) : Prop := infix_eqeq1 (real_part x) 0%R.

Axiom unic_decomp :
  forall (i:complex) (x:R) (y:R),
  (i = (infix_pldt (r_to_c x) (infix_asdt im (r_to_c y)))) ->
  (x = (real_part i)) /\ (y = (im_part i)).

Axiom r_to_c_real :
  forall (x:complex), (real_ x) -> (x = (r_to_c (real_part x))).

Axiom real_r_to_c : forall (x:R), real_ (r_to_c x).

Axiom r_to_c_pure_im :
  forall (x:complex), (pure_im_ x) ->
  (x = (infix_asdt im (r_to_c (im_part x)))).

Axiom decomp_mult :
  forall (a:complex) (b:complex),
  ((infix_asdt a b) =
   (infix_pldt
    (infix_mndt (infix_asdt (r_to_c (real_part a)) (r_to_c (real_part b)))
     (infix_asdt (r_to_c (im_part a)) (r_to_c (im_part b))))
    (infix_asdt im
     (infix_pldt (infix_asdt (r_to_c (real_part a)) (r_to_c (im_part b)))
      (infix_asdt (r_to_c (real_part b)) (r_to_c (im_part a))))))).

(* Why3 assumption *)
Definition t_real_part (x:complex) : complex := r_to_c (real_part x).

Axiom t_real_part_spec : forall (x:complex), real_ (t_real_part x).

Axiom t_real_part_inv :
  forall (x:complex),
  ((t_real_part (prefix_mndt x)) = (prefix_mndt (t_real_part x))).

(* Why3 assumption *)
Definition t_im_part (x:complex) : complex := r_to_c (im_part x).

Axiom t_im_part_spec : forall (x:complex), real_ (t_im_part x).

Axiom t_im_part_inv :
  forall (x:complex),
  ((t_im_part (prefix_mndt x)) = (prefix_mndt (t_im_part x))).

Axiom decomp_mult_as_reals :
  forall (a:complex) (b:complex),
  ((infix_asdt a b) =
   (infix_pldt
    (infix_mndt (infix_asdt (t_real_part a) (t_real_part b))
     (infix_asdt (t_im_part a) (t_im_part b)))
    (infix_asdt im
     (infix_pldt (infix_asdt (t_real_part a) (t_im_part b))
      (infix_asdt (t_real_part b) (t_im_part a)))))).

Axiom decomp_mult_real_part :
  forall (a:complex) (b:complex),
  ((real_part (infix_asdt a b)) =
   (infix_mnas ((real_part a) * (real_part b))%R
    ((im_part a) * (im_part b))%R)).

Axiom decomp_mult_im_part :
  forall (a:complex) (b:complex),
  ((im_part (infix_asdt a b)) =
   (((real_part a) * (im_part b))%R + ((real_part b) * (im_part a))%R)%R).

Axiom t_mult_real :
  forall (a:complex) (b:complex),
  ((t_real_part (infix_asdt a b)) =
   (infix_mndt (infix_asdt (t_real_part a) (t_real_part b))
    (infix_asdt (t_im_part a) (t_im_part b)))).

Axiom t_mult_im :
  forall (a:complex) (b:complex),
  ((t_im_part (infix_asdt a b)) =
   (infix_pldt (infix_asdt (t_real_part a) (t_im_part b))
    (infix_asdt (t_im_part a) (t_real_part b)))).

Axiom mult_real_real :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (((infix_asdt a b) =
    (infix_asdt (r_to_c (real_part a)) (r_to_c (real_part b)))) /\
   ((infix_asdt (r_to_c (real_part a)) (r_to_c (real_part b))) =
    (r_to_c ((real_part a) * (real_part b))%R))) /\
  (((real_part (infix_asdt a b)) = ((real_part a) * (real_part b))%R) /\
   ((im_part (infix_asdt a b)) = 0%R)).

Axiom complex_squared :
  forall (a:complex),
  ((infix_asdt a a) =
   (infix_pldt
    (infix_mndt (infix_asdt (t_real_part a) (t_real_part a))
     (infix_asdt (t_im_part a) (t_im_part a)))
    (infix_asdt
     (infix_asdt (infix_asdt im (infix_pldt c_one c_one)) (t_real_part a))
     (t_im_part a)))) /\
  (((t_real_part (infix_asdt a a)) =
    (infix_mndt (infix_asdt (t_real_part a) (t_real_part a))
     (infix_asdt (t_im_part a) (t_im_part a)))) /\
   ((t_im_part (infix_asdt a a)) =
    (infix_asdt (infix_asdt (infix_pldt c_one c_one) (t_real_part a))
     (t_im_part a)))).

Axiom complex_real_squared :
  forall (a:complex), (real_ a) ->
  ((infix_asdt a a) = (infix_asdt (t_real_part a) (t_real_part a))).

Axiom decomp_div :
  forall (a:complex) (b:complex), ~ (b = c_zero) ->
  ((infix_sldt a b) =
   (infix_pldt (infix_sldt (t_real_part (infix_asdt a b)) (infix_asdt b b))
    (infix_asdt im
     (infix_sldt (t_im_part (infix_asdt a b)) (infix_asdt b b))))).

Axiom decomp_div_real :
  forall (a:complex) (b:complex), (real_ b) -> ~ (b = c_zero) ->
  ((infix_sldt a b) =
   (infix_pldt (infix_sldt (infix_asdt (t_real_part a) b) (infix_asdt b b))
    (infix_asdt im
     (infix_sldt (infix_asdt (t_im_part a) b) (infix_asdt b b))))).

Axiom complex_prod_fact :
  forall (a:complex) (b:complex),
  ((infix_asdt a b) =
   (infix_pldt (infix_asdt (r_to_c (real_part a)) b)
    (infix_asdt (infix_asdt im (r_to_c (im_part a))) b))).

Axiom non_zero_prod_pre :
  forall (a:complex) (b:complex), ~ (a = c_zero) ->
  ((infix_asdt a b) = c_zero) ->
  ((im_part b) = (real_part b)) /\ ((real_part b) = 0%R).

Axiom non_zero_prod :
  forall (a:complex) (b:complex), ~ (a = c_zero) -> ~ (b = c_zero) ->
  ~ ((infix_asdt a b) = c_zero).

Axiom minus_c_one :
  forall (a:complex), ((prefix_mndt a) = (infix_asdt (prefix_mndt c_one) a)).

Axiom mult_neg_l :
  forall (a:complex) (b:complex),
  ((infix_asdt (prefix_mndt a) b) = (prefix_mndt (infix_asdt a b))).

Axiom mult_neg_r :
  forall (a:complex) (b:complex),
  ((infix_asdt a (prefix_mndt b)) = (prefix_mndt (infix_asdt a b))).

Axiom neg_neg_out : forall (a:complex), ((prefix_mndt (prefix_mndt a)) = a).

Axiom div_neg_l :
  forall (a:complex) (b:complex), ~ (b = c_zero) ->
  ((infix_sldt (prefix_mndt a) b) = (prefix_mndt (infix_sldt a b))).

Axiom eq_to_real :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) -> (a = b) ->
  ((real_part a) = (real_part b)).

Axiom eq_by_real :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  ((real_part a) = (real_part b)) -> (a = b).

Axiom div_neg_r :
  forall (a:complex) (b:complex), ~ (b = c_zero) ->
  ((infix_sldt a (prefix_mndt b)) = (prefix_mndt (infix_sldt a b))).

Axiom invadd :
  forall (i:complex), ((prefix_mndt i) = (infix_asdt (prefix_mndt c_one) i)).

Axiom noc_zeroAdd :
  forall (x:complex) (y:complex), ~ (x = c_zero) -> ~ ((infix_pldt x y) = y).

Axiom Absorbing_zero :
  forall (a:complex) (b:complex),
  ((infix_asdt a b) = c_zero) <-> (~ (a = c_zero) -> (b = c_zero)).

Axiom real_part_add :
  forall (i:complex) (j:complex),
  ((real_part (infix_pldt i j)) = ((real_part i) + (real_part j))%R).

Axiom mult_im_rev :
  forall (a:complex), ((infix_asdt a im) = (infix_asdt im a)).

Axiom im_im_elim :
  forall (a:complex), ((infix_asdt im (infix_asdt im a)) = (prefix_mndt a)).

Axiom im_im_fact :
  forall (a:complex) (b:complex),
  ((infix_asdt (infix_asdt im a) (infix_asdt im b)) =
   (prefix_mndt (infix_asdt a b))).

Axiom minus_minus_fact :
  forall (a:complex) (b:complex),
  ((infix_asdt (prefix_mndt a) (prefix_mndt b)) = (infix_asdt a b)).

Axiom minus_minus_add :
  forall (a:complex) (b:complex),
  ((infix_pldt (prefix_mndt a) (prefix_mndt b)) =
   (prefix_mndt (infix_pldt a b))).

Axiom minus_minus_add_rev :
  forall (a:complex) (b:complex),
  ((prefix_mndt (infix_pldt a b)) =
   (infix_pldt (prefix_mndt a) (prefix_mndt b))).

Axiom minus_out_left :
  forall (a:complex) (b:complex),
  ((infix_asdt (prefix_mndt a) b) = (prefix_mndt (infix_asdt a b))).

Axiom minus_out_right :
  forall (a:complex) (b:complex),
  ((infix_asdt a (prefix_mndt b)) = (prefix_mndt (infix_asdt a b))).

Axiom minus_in_left :
  forall (a:complex) (b:complex),
  ((prefix_mndt (infix_asdt a b)) = (infix_asdt (prefix_mndt a) b)).

Axiom minus_in_right :
  forall (a:complex) (b:complex),
  ((prefix_mndt (infix_asdt a b)) = (infix_asdt a (prefix_mndt b))).

Axiom minus_add_out_left :
  forall (a:complex) (b:complex),
  ((infix_pldt (prefix_mndt a) b) =
   (prefix_mndt (infix_pldt a (prefix_mndt b)))).

Axiom minus_as_add_opp :
  forall (a:complex) (b:complex),
  ((infix_mndt a b) = (infix_pldt a (prefix_mndt b))).

Axiom minus_add_out_right :
  forall (a:complex) (b:complex),
  ((infix_pldt a (prefix_mndt b)) =
   (prefix_mndt (infix_pldt (prefix_mndt a) b))).

Axiom minus_add_in :
  forall (a:complex) (b:complex),
  ((prefix_mndt (infix_pldt a b)) =
   (infix_pldt (prefix_mndt a) (prefix_mndt b))).

Axiom minus_add_out :
  forall (a:complex) (b:complex),
  ((infix_pldt (prefix_mndt a) (prefix_mndt b)) =
   (prefix_mndt (infix_pldt a b))).

Axiom minus_eq :
  forall (a:complex) (b:complex), (a = b) ->
  ((prefix_mndt a) = (prefix_mndt b)).

Axiom im_out_right :
  forall (a:complex) (b:complex),
  ((infix_asdt (infix_asdt im a) b) = (infix_asdt im (infix_asdt a b))).

Axiom im_out_left :
  forall (a:complex) (b:complex),
  ((infix_asdt a (infix_asdt im b)) = (infix_asdt im (infix_asdt a b))).

Axiom im_part_add :
  forall (i:complex) (j:complex),
  ((im_part (infix_pldt i j)) = ((im_part i) + (im_part j))%R).

Axiom injective_real_part :
  forall (i:complex) (j:complex), ~ ((real_part i) = (real_part j)) ->
  ~ (i = j).

Axiom injective_im_part :
  forall (i:complex) (j:complex), ~ ((im_part i) = (im_part j)) -> ~ (i = j).

Axiom minus_distr_four :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_asdt a b)
    (infix_asdt (infix_asdt (prefix_mndt b) c) d))
   = (infix_asdt (infix_mndt a (infix_asdt c d)) b)).

Axiom complex_decomp :
  forall (i:complex),
  (i =
   (infix_pldt (r_to_c (real_part i)) (infix_asdt im (r_to_c (im_part i))))).

Axiom simpl_frac :
  forall (x:complex) (y:complex), ~ (y = c_zero) ->
  ((infix_sldt (infix_asdt x y) y) = x).

Axiom simpl_frac_ :
  forall (x:complex) (y:complex) (z:complex), ~ (y = c_zero) ->
  ~ (z = c_zero) ->
  ((infix_sldt (infix_asdt x y) (infix_asdt z y)) = (infix_sldt x z)).

Axiom fact_frac :
  forall (x:complex) (y:complex) (z:complex), ~ (z = c_zero) ->
  ((infix_sldt (infix_asdt x y) z) = (infix_asdt x (infix_sldt y z))).

Axiom fact_frac_rev :
  forall (x:complex) (y:complex) (z:complex), ~ (z = c_zero) ->
  ((infix_asdt x (infix_sldt y z)) = (infix_sldt (infix_asdt x y) z)).

Axiom mult_sym :
  forall (x:complex) (y:complex), ((infix_asdt x y) = (infix_asdt y x)).

Axiom inv_mult :
  forall (x:complex) (y:complex), ~ (x = c_zero) -> ~ (y = c_zero) ->
  ((infix_asdt (infix_sldt c_one x) (infix_sldt c_one y)) =
   (infix_sldt c_one (infix_asdt x y))).

Axiom div_div :
  forall (x:complex) (y:complex) (z:complex), ~ (y = c_zero) ->
  ~ (z = c_zero) ->
  ((infix_sldt (infix_sldt x y) z) = (infix_sldt x (infix_asdt y z))).

Axiom div_div_rev :
  forall (x:complex) (y:complex) (z:complex), ~ (y = c_zero) ->
  ~ (z = c_zero) ->
  ((infix_sldt x (infix_asdt y z)) = (infix_sldt (infix_sldt x y) z)).

Axiom involutive_inv :
  forall (a:complex), ~ (a = c_zero) ->
  ((infix_sldt c_one (infix_sldt c_one a)) = a).

Axiom twice :
  forall (i:complex),
  ((infix_asdt (infix_pldt c_one c_one) i) = (infix_pldt i i)).

Axiom twice_half :
  ((infix_asdt (infix_pldt c_one c_one)
    (infix_sldt c_one (infix_pldt c_one c_one)))
   = c_one).

Axiom half_plus_half :
  forall (i:complex),
  ((infix_pldt (infix_sldt i (infix_pldt c_one c_one))
    (infix_sldt i (infix_pldt c_one c_one)))
   = i).

Axiom decomp_inv_real :
  forall (a:complex), (real_ a) -> ~ (a = c_zero) ->
  ((infix_sldt c_one a) = (infix_sldt c_one (t_real_part a))) /\
  ((real_ (infix_sldt c_one a)) /\
   (((t_real_part (infix_sldt c_one a)) = (infix_sldt c_one (t_real_part a))) /\
    ((real_part (infix_sldt c_one a)) = (infix_slas 1%R (real_part a))))).

Axiom mult_div_comm :
  forall (x:complex) (y:complex) (z:complex) (t:complex), ~ (z = c_zero) ->
  ~ (t = c_zero) ->
  ((infix_sldt (infix_asdt x y) (infix_asdt z t)) =
   (infix_asdt (infix_sldt x z) (infix_sldt y t))).

Axiom mult_div_comm_rev :
  forall (x:complex) (y:complex) (z:complex) (t:complex), ~ (z = c_zero) ->
  ~ (t = c_zero) ->
  ((infix_asdt (infix_sldt x z) (infix_sldt y t)) =
   (infix_sldt (infix_asdt x y) (infix_asdt z t))).

(* Why3 assumption *)
Definition infix_lseqdt (x:complex) (y:complex) : Prop :=
  ((real_ x) /\ ((real_ y) /\ ((real_part x) <= (real_part y))%R)) \/
  (infix_eqeq1 x y).

(* Why3 assumption *)
Definition infix_lsdt (x:complex) (y:complex) : Prop :=
  (infix_lseqdt x y) /\ ~ (infix_eqeq1 x y).

(* Why3 assumption *)
Definition infix_gtdt (x:complex) (y:complex) : Prop :=
  (infix_lseqdt y x) /\ ~ (infix_eqeq1 x y).

Axiom leq_left_real :
  forall (a:complex) (b:complex), (infix_lseqdt a b) -> (real_ a) -> real_ b.

Axiom leq_right_real :
  forall (a:complex) (b:complex), (infix_lseqdt a b) -> (real_ b) -> real_ a.

Axiom inf_left_real :
  forall (a:complex) (b:complex), (infix_lsdt a b) -> real_ a.

Axiom inf_right_real :
  forall (a:complex) (b:complex), (infix_lsdt a b) -> real_ b.

Axiom inf_from_real :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (infix_lsas (real_part a) (real_part b)) -> infix_lsdt a b.

Axiom inf_to_real :
  forall (a:complex) (b:complex), (infix_lsdt a b) ->
  infix_lsas (real_part a) (real_part b).

Axiom leq_left_not_real_a :
  forall (a:complex) (b:complex), (infix_lseqdt a b) -> ~ (real_ a) ->
  (a = b).

Axiom leq_left_not_real_b :
  forall (a:complex) (b:complex), (infix_lseqdt a b) -> ~ (real_ b) ->
  (a = b).

Axiom Refl : forall (x:complex), infix_lseqdt x x.

Axiom Trans :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt x y) ->
  (infix_lseqdt y z) -> infix_lseqdt x z.

Axiom Antisymm :
  forall (x:complex) (y:complex), (infix_lseqdt x y) -> (infix_lseqdt y x) ->
  (x = y).

Axiom Refl1 : forall (x:complex), infix_lseqdt x x.

Axiom Trans1 :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt y x) ->
  (infix_lseqdt z y) -> infix_lseqdt z x.

Axiom Antisymm1 :
  forall (x:complex) (y:complex), (infix_lseqdt y x) -> (infix_lseqdt x y) ->
  (x = y).

Axiom Trans2 :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (infix_lsdt y z) -> infix_lsdt x z.

Axiom Asymm :
  forall (x:complex) (y:complex), (infix_lsdt x y) -> ~ (infix_lsdt y x).

Axiom Trans3 :
  forall (x:complex) (y:complex) (z:complex), (infix_gtdt x y) ->
  (infix_gtdt y z) -> infix_gtdt x z.

Axiom Asymm1 :
  forall (x:complex) (y:complex), (infix_gtdt x y) -> ~ (infix_gtdt y x).

Axiom r_to_c_inf :
  forall (i:R) (j:R), (infix_lseqdt (r_to_c i) (r_to_c j)) <-> (i <= j)%R.

Axiom reali_is_its_real_part :
  forall (a:complex), (real_ a) -> (a = (r_to_c (real_part a))).

Axiom inf_from_r :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  ((real_part a) <= (real_part b))%R -> infix_lseqdt a b.

Axiom strict_inf_from_r :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (infix_lsas (real_part a) (real_part b)) -> infix_lsdt a b.

Axiom positive_inv_t :
  forall (x:complex), (infix_lsdt c_zero x) ->
  infix_lsdt c_zero (infix_sldt c_one x).

Parameter pi: complex.

Axiom pi_def : infix_lsdt (r_to_c 3%R) pi.

Axiom real_pi : real_ pi.

Axiom pi_sup_one : infix_lsdt c_one pi.

Axiom pi_sup_zero : infix_lsdt c_zero pi.

Axiom compat_order_mult :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lseqdt c_zero z) ->
  infix_lseqdt (infix_asdt x z) (infix_asdt y z).

Axiom compat_order_add :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) ->
  infix_lseqdt (infix_pldt x z) (infix_pldt y z).

Axiom compat_order_substr :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) ->
  infix_lseqdt (infix_mndt x z) (infix_mndt y z).

Axiom compat_inf_mult :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_lsdt (infix_asdt x z) (infix_asdt y z).

Axiom transitive_infeq :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt a b) ->
  (infix_lseqdt b c) -> infix_lseqdt a c.

Axiom transitive_infeq_inf :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt a b) ->
  (infix_lsdt b c) -> infix_lsdt a c.

Axiom transitive_inf_infeq :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt a b) ->
  (infix_lseqdt b c) -> infix_lsdt a c.

Axiom transitive_inf :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt a b) ->
  (infix_lsdt b c) -> infix_lsdt a c.

Axiom pi_sup_ttwo : infix_lsdt (infix_pldt c_one c_one) pi.

Axiom transitive_leq_inv_r :
  forall (a:complex) (b:complex) (c:complex), (real_ a) -> (real_ b) ->
  (real_ c) -> (infix_lseqdt a b) -> (infix_lseqdt b (infix_sldt c_one c)) ->
  (infix_lseqdt c_one c) -> (infix_lseqdt a b) /\ (infix_lseqdt b c_one).

Axiom compat_inf_mult_left :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_lsdt (infix_asdt z x) (infix_asdt z y).

Axiom compat_inf_mult_both :
  forall (x:complex) (y:complex) (z:complex) (t:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) ->
  ((infix_lsdt c_zero z) /\ (infix_lsdt z t)) -> (infix_lsdt c_zero y) ->
  infix_lsdt (infix_asdt z x) (infix_asdt t y).

Axiom compat_inf_add :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) ->
  infix_lsdt (infix_pldt x z) (infix_pldt y z).

Axiom compat_inf_add_left :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) ->
  infix_lsdt (infix_pldt z x) (infix_pldt z y).

Axiom compat_inf_add_both :
  forall (x:complex) (y:complex) (z:complex) (t:complex), (infix_lsdt x y) ->
  (infix_lsdt z t) -> infix_lsdt (infix_pldt x z) (infix_pldt y t).

Axiom compat_inf_substr :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) ->
  infix_lsdt (infix_mndt x z) (infix_mndt y z).

Axiom real_inv :
  forall (x:complex), (real_ x) -> ~ (x = c_zero) ->
  real_ (infix_sldt c_one x).

Axiom compat_order_mult_rev :
  forall (x:complex) (y:complex) (z:complex), (real_ x) -> (real_ y) ->
  (real_ z) -> (infix_lsdt c_zero z) ->
  (infix_lseqdt (infix_asdt x z) (infix_asdt y z)) -> infix_lseqdt x y.

Axiom compat_order_mult_left :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lseqdt c_zero z) ->
  infix_lseqdt (infix_asdt z x) (infix_asdt z y).

Axiom strict_compat_order_mult :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_lsdt (infix_asdt x z) (infix_asdt y z).

Axiom strict_compat_order_mult_left :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_lsdt (infix_asdt z x) (infix_asdt z y).

Axiom complete_order_real :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) -> ~ (x = y) ->
  ~ (infix_lsdt x y) -> infix_lsdt y x.

Axiom complete_order_real_ :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ~ (infix_lsdt x y) -> ~ (infix_lsdt y x) -> (y = x).

Axiom compat_order_mult_both :
  forall (x:complex) (y:complex) (z:complex) (t:complex),
  ((infix_lseqdt c_zero x) /\ (infix_lseqdt x y)) ->
  ((infix_lseqdt c_zero z) /\ (infix_lseqdt z t)) ->
  infix_lseqdt (infix_asdt z x) (infix_asdt t y).

Axiom inf_to_non_sup_eq :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_lsdt x y) -> ~ (infix_lseqdt y x).

Axiom sup_eq_to_non_inf :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_lseqdt y x) -> ~ (infix_lsdt x y).

Axiom sup_to_inf :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_gtdt x y) -> infix_lsdt y x.

Axiom inf_to_sup :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_lsdt x y) -> infix_gtdt y x.

Axiom sup_to_non_inf_eq :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_gtdt x y) -> ~ (infix_lseqdt x y).

Axiom inf_eq_to_non_sup :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_lseqdt x y) -> ~ (infix_gtdt x y).

Axiom non_inf_eq_to_sup :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ~ (infix_lseqdt x y) -> infix_gtdt x y.

Axiom non_sup_toinf_eq :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ~ (infix_gtdt x y) -> infix_lseqdt x y.

Axiom real_mult :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  real_ (infix_asdt x y).

Axiom real_add :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  real_ (infix_pldt x y).

Axiom inv_pos :
  forall (x:complex), (real_ x) -> (infix_lsdt c_zero x) ->
  infix_lsdt c_zero (infix_sldt c_one x).

Axiom lower_over_cons :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt c_zero c) ->
  (infix_lseqdt c_zero a) -> (infix_lseqdt a b) ->
  infix_lseqdt (infix_sldt a c) (infix_sldt b c).

Axiom eq_to_leq_t :
  forall (a:complex) (b:complex), (real_ a) -> (a = b) -> infix_lseqdt a b.

Axiom real_minus : forall (a:complex), (real_ a) -> real_ (prefix_mndt a).

Axiom compat_r_to_c_infeq :
  forall (a:R) (b:R), (a <= b)%R -> infix_lseqdt (r_to_c a) (r_to_c b).

Axiom compat_r_to_c_inf :
  forall (a:R) (b:R), (infix_lsas a b) -> infix_lsdt (r_to_c a) (r_to_c b).

Axiom compat_r_to_c_supeq :
  forall (a:R) (b:R), (b <= a)%R -> infix_lseqdt (r_to_c b) (r_to_c a).

Axiom compat_r_to_c_sup :
  forall (a:R) (b:R), (infix_lsas b a) -> infix_gtdt (r_to_c a) (r_to_c b).

Axiom unic_inv :
  forall (i:complex) (j:complex), ~ (i = c_zero) ->
  ((infix_asdt i j) = c_one) -> (j = (inv i)).

Axiom inf_eq_def :
  forall (x:complex) (y:complex),
  (infix_lseqdt x y) <->
  (((real_ x) /\ ((real_ y) /\ ((real_part x) <= (real_part y))%R)) \/
   (x = y)).

Axiom inf_minus :
  forall (x:complex) (y:complex), (infix_lsdt x y) ->
  infix_lsdt (prefix_mndt y) (prefix_mndt x).

Axiom absorbing_zero :
  forall (a:complex) (b:complex), ((infix_asdt a b) = c_zero) ->
  (~ (a = c_zero) -> (b = c_zero)) /\ (~ (b = c_zero) -> (a = c_zero)).

Axiom inf_zero_inv :
  forall (z:complex), (infix_lsdt c_zero z) ->
  (infix_lsdt c_zero (infix_sldt c_one z)) /\
  (infix_lseqdt c_zero (infix_sldt c_one z)).

Axiom mult_pos :
  forall (x:complex) (y:complex), (infix_lseqdt c_zero x) ->
  (infix_lseqdt c_zero y) -> infix_lseqdt c_zero (infix_asdt x y).

Axiom simpl_leq_mult_div :
  forall (a:complex) (b:complex) (c:complex), (real_ a) ->
  (infix_lsdt c_zero b) -> (infix_lseqdt (infix_asdt a b) c) ->
  infix_lseqdt a (infix_asdt (infix_sldt c_one b) c).

Axiom mult_leq_c_one_leq :
  forall (a:complex) (b:complex), (infix_lseqdt c_zero a) ->
  ((infix_lseqdt c_zero b) /\ (infix_lseqdt b c_one)) ->
  infix_lseqdt (infix_asdt a b) a.

Axiom mult_leq_c_one_leq_gen :
  forall (a:complex) (a':complex) (b:complex), (infix_lseqdt c_zero a) ->
  ((infix_lseqdt c_zero b) /\ (infix_lseqdt b c_one)) -> (a = a') ->
  infix_lseqdt (infix_asdt a b) a'.

Axiom mult_leq_c_one :
  forall (a:complex) (b:complex), (infix_lseqdt c_zero a) ->
  (exists c:complex, (infix_lseqdt a c) /\ (b = (infix_sldt c_one c))) ->
  (infix_lsdt c_zero b) -> infix_lseqdt (infix_asdt a b) c_one.

Axiom mult_leq_c_one_expl :
  forall (a:complex) (b:complex) (d:complex), (infix_lseqdt c_zero a) ->
  (infix_lseqdt a d) -> (infix_lsdt c_zero d) ->
  (b = (infix_sldt c_one d)) -> infix_lseqdt (infix_asdt a b) c_one.

Axiom mult_leq_c_one_rev :
  forall (a:complex) (b:complex), (infix_lseqdt c_zero a) ->
  (infix_lsdt c_zero b) -> (infix_lseqdt (infix_asdt a b) c_one) ->
  infix_lseqdt a (infix_sldt c_one b).

Axiom simpl_leq_mult :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt c_zero b) ->
  (infix_lseqdt a c) -> infix_lseqdt (infix_asdt a b) (infix_asdt c b).

Axiom simpl_leq_mult_inv :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt c_zero a) ->
  (infix_lsdt c_zero b) -> (infix_lsdt c_zero c) ->
  (infix_lseqdt a (infix_sldt c_one (infix_asdt b c))) ->
  infix_lseqdt (infix_asdt a b) (infix_sldt c_one c).

Axiom mult_to_div_leq :
  forall (a:complex) (b:complex) (c:complex), (real_ a) ->
  (infix_lsdt c_zero b) -> (infix_lseqdt (infix_asdt a b) c) ->
  infix_lseqdt a (infix_asdt (infix_sldt c_one b) c).

Axiom mult_div :
  forall (x:complex) (y:complex), (infix_lseqdt c_zero x) ->
  (infix_lsdt c_zero y) -> infix_lseqdt c_zero (infix_sldt x y).

Axiom strict_mult_pos :
  forall (x:complex) (y:complex), (infix_lsdt c_zero x) ->
  (infix_lsdt c_zero y) -> infix_lsdt c_zero (infix_asdt x y).

Axiom rewrite_supeq : True.

Axiom rewrite_sup :
  forall (x:complex) (y:complex), (infix_lsdt x y) -> infix_gtdt y x.

Axiom inv_order_complex :
  forall (a:complex) (b:complex), (infix_lsdt c_zero a) ->
  (infix_lsdt c_zero b) -> (infix_lseqdt a b) ->
  infix_lseqdt (infix_sldt c_one b) (infix_sldt c_one a).

Axiom compat_inv_order :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_lsdt c_zero a) /\ (infix_lseqdt a b)) ->
  (infix_lseqdt c (infix_sldt c_one b)) ->
  infix_lseqdt c (infix_sldt c_one a).

Axiom leq_by_div_simpl :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt c_zero a) ->
  ((infix_lsdt c_zero b) /\ (infix_lseqdt b c)) ->
  infix_lseqdt (infix_sldt a c) (infix_sldt a b).

Axiom leq_by_div :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt c_zero a) ->
  ((infix_lsdt c_zero b) /\ (infix_lseqdt b c)) ->
  infix_lseqdt (infix_sldt a c) (infix_sldt a b).

Axiom inf_def :
  forall (x:complex) (y:complex),
  (infix_lsdt x y) <->
  ((real_ x) /\ ((real_ y) /\ (infix_lsas (real_part x) (real_part y)))).

Axiom sup_eq_def :
  forall (x:complex) (y:complex),
  (infix_lseqdt y x) <->
  (((real_ x) /\ ((real_ y) /\ ((real_part y) <= (real_part x))%R)) \/
   (x = y)).

Axiom sup_def :
  forall (x:complex) (y:complex),
  (infix_gtdt x y) <->
  ((real_ x) /\ ((real_ y) /\ (infix_lsas (real_part y) (real_part x)))).

Axiom assoc_mult_div :
  forall (x:complex) (y:complex) (z:complex), ~ (z = c_zero) ->
  ((infix_asdt x (infix_sldt y z)) = (infix_sldt (infix_asdt x y) z)).

Axiom assoc_mult_div_rev :
  forall (x:complex) (y:complex) (z:complex), ~ (z = c_zero) ->
  ((infix_sldt (infix_asdt x y) z) = (infix_asdt x (infix_sldt y z))).

Axiom subst_zero : forall (a:complex), ((infix_mndt a c_zero) = a).

Axiom subst_zero_gen :
  forall (a:complex) (b:complex), (b = c_zero) -> ((infix_mndt a b) = a).

Axiom transitive_inf_inv_r :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt a b) ->
  (infix_lseqdt b (infix_sldt c_one c)) -> (infix_lsdt c_one c) ->
  (infix_lseqdt a b) /\ (infix_lsdt b c_one).

Axiom infeq_scal_r :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt a c) ->
  (infix_lseqdt c_zero b) -> infix_lseqdt (infix_asdt a b) (infix_asdt c b).

Axiom infeq_scal_l :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt a c) ->
  (infix_lseqdt c_zero b) -> infix_lseqdt (infix_asdt b a) (infix_asdt b c).

Axiom transitive_supeq :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt b a) ->
  (infix_lseqdt c b) -> infix_lseqdt c a.

Axiom transitive_inf_l :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt a b) ->
  (infix_lseqdt b c) -> infix_lsdt a c.

Axiom transitive_sup_l :
  forall (a:complex) (b:complex) (c:complex), (infix_gtdt a b) ->
  (infix_lseqdt c b) -> infix_gtdt a c.

Axiom transitive_inf_r :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt a b) ->
  (infix_lsdt b c) -> infix_lsdt a c.

Axiom transitive_sup_r :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt b a) ->
  (infix_gtdt b c) -> infix_gtdt a c.

Axiom simpl_frac_r :
  forall (x:complex) (y:complex), ~ (x = c_zero) ->
  ((infix_asdt x (infix_sldt y x)) = y).

Axiom compat_mult_sup_eq_right :
  forall (a:complex) (b:complex) (c:complex), (infix_lseqdt c_zero a) ->
  (infix_lseqdt c b) -> infix_lseqdt (infix_asdt a c) (infix_asdt a b).

Axiom compat_mult_sup_right :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt c_zero a) ->
  (infix_gtdt b c) -> infix_gtdt (infix_asdt a b) (infix_asdt a c).

Axiom compat_mult_inf_right :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt c_zero a) ->
  (infix_lsdt b c) -> infix_lsdt (infix_asdt a b) (infix_asdt a c).

Axiom infeq_to_supeq : True.

Axiom infeq_inv :
  forall (a:complex) (b:complex), (infix_lseqdt a b) ->
  infix_lseqdt (prefix_mndt b) (prefix_mndt a).

Axiom infeq_inv_add_l :
  forall (a:complex) (b:complex) (c:complex),
  (infix_lseqdt (infix_pldt a c) b) -> (real_ a) -> (real_ c) ->
  infix_lseqdt a (infix_mndt b c).

Axiom infeq_inv_add_r :
  forall (a:complex) (b:complex) (c:complex), (real_ a) -> (real_ c) ->
  (infix_lseqdt a (infix_pldt b c)) -> infix_lseqdt (infix_mndt a c) b.

Axiom r_to_c_surj :
  forall (x:R) (y:R), ~ (x = y) -> ~ ((r_to_c x) = (r_to_c y)).

Axiom r_to_c_inf_rev :
  forall (x:R) (y:R), (infix_lsas x y) -> infix_lsdt (r_to_c x) (r_to_c y).

Axiom div_simpl :
  forall (a:complex) (b:complex), (infix_lsdt c_zero a) ->
  (infix_lsdt c_zero b) ->
  ((infix_sldt c_one b) = (infix_sldt a (infix_asdt a b))).

Axiom infeq_inv_subs_l :
  forall (a:complex) (b:complex) (c:complex), (real_ a) -> (real_ b) ->
  (real_ c) -> (infix_lseqdt (infix_mndt a c) b) ->
  infix_lseqdt a (infix_pldt b c).

Axiom infeq_inv_subs_r :
  forall (a:complex) (b:complex) (c:complex), (real_ a) -> (real_ b) ->
  (real_ c) -> (infix_lseqdt a (infix_mndt b c)) ->
  infix_lseqdt (infix_pldt a c) b.

Axiom infeq_pos_elim :
  forall (a:complex) (b:complex), (real_ a) -> (infix_lseqdt c_zero b) ->
  infix_lseqdt a (infix_pldt a b).

Axiom infeq_pos_elim_add :
  forall (a:complex) (b:complex) (c:complex), (real_ a) -> (real_ b) ->
  (real_ c) -> (infix_lseqdt c_zero b) -> (infix_lseqdt c a) ->
  infix_lseqdt c (infix_pldt a b).

Axiom supeq_elim_left :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (infix_lseqdt b a) -> infix_lseqdt (infix_mndt b a) c_zero.

Axiom sup_elim_left :
  forall (a:complex) (b:complex), (infix_gtdt a b) ->
  infix_gtdt c_zero (infix_mndt b a).

Axiom infeq_elim_left :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (infix_lseqdt a b) -> infix_lseqdt c_zero (infix_mndt b a).

Axiom inf_elim_left :
  forall (a:complex) (b:complex), (infix_lsdt a b) ->
  infix_lsdt c_zero (infix_mndt b a).

Axiom t_im_real :
  forall (a:complex) (b:complex),
  ((t_im_part (infix_asdt a b)) =
   (infix_pldt (infix_asdt (t_real_part a) (t_im_part b))
    (infix_asdt (t_im_part a) (t_real_part b)))).

Axiom t_decomp_mult :
  forall (a:complex) (b:complex),
  ((infix_asdt a b) =
   (infix_pldt
    (infix_mndt (infix_asdt (t_real_part a) (t_real_part b))
     (infix_asdt (t_im_part a) (t_im_part b)))
    (infix_asdt im
     (infix_pldt (infix_asdt (t_real_part a) (t_im_part b))
      (infix_asdt (t_im_part a) (t_real_part b)))))).

Axiom t_complex_decomp :
  forall (i:complex),
  (i = (infix_pldt (t_real_part i) (infix_asdt im (t_im_part i)))).

Axiom t_unic_decomp :
  forall (i:complex) (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (i = (infix_pldt a (infix_asdt im b))) ->
  (a = (t_real_part i)) /\ (b = (t_im_part i)).

Axiom t_decomp_minus :
  forall (i:complex) (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (i = (infix_mndt a (infix_asdt im b))) ->
  (a = (t_real_part i)) /\ ((prefix_mndt b) = (t_im_part i)).

Axiom real_sum :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  real_ (infix_pldt x y).

Axiom real_diff :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  real_ (infix_mndt x y).

Axiom pure_im_sum :
  forall (x:complex) (y:complex), (pure_im_ x) -> (pure_im_ y) ->
  pure_im_ (infix_pldt x y).

Axiom equal_decomp :
  forall (x:complex) (y:complex), ((real_part x) = (real_part y)) ->
  ((im_part x) = (im_part y)) -> (x = y).

Axiom t_equal_decomp :
  forall (x:complex) (y:complex), ((t_real_part x) = (t_real_part y)) ->
  ((t_im_part x) = (t_im_part y)) -> (x = y).

Axiom pure_im_diff :
  forall (x:complex) (y:complex), (pure_im_ x) -> (pure_im_ y) ->
  pure_im_ (infix_mndt x y).

Axiom real_div :
  forall (x:complex) (y:complex), (real_ x) -> ~ (y = c_zero) -> (real_ y) ->
  real_ (infix_sldt x y).

Axiom mult_im_im :
  forall (a:complex) (b:complex), (pure_im_ a) -> (pure_im_ b) ->
  ((infix_asdt a b) =
   (infix_asdt (infix_asdt im im)
    (infix_asdt (r_to_c (im_part a)) (r_to_c (im_part b))))) /\
  (((infix_asdt a b) = (prefix_mndt (r_to_c ((im_part a) * (im_part b))%R))) /\
   (((real_part (infix_asdt a b)) = (-((im_part a) * (im_part b))%R)%R) /\
    ((im_part (infix_asdt a b)) = 0%R))).

Axiom mult_real_im :
  forall (a:complex) (b:complex), (real_ a) -> (pure_im_ b) ->
  ((infix_asdt a b) =
   (infix_asdt im (infix_asdt (r_to_c (real_part a)) (r_to_c (im_part b))))) /\
  (((infix_asdt a b) =
    (infix_asdt im (r_to_c ((real_part a) * (im_part b))%R))) /\
   (((real_part (infix_asdt a b)) = 0%R) /\
    ((im_part (infix_asdt a b)) = ((real_part a) * (im_part b))%R))).

Axiom mult_im_real :
  forall (a:complex) (b:complex), (pure_im_ a) -> (real_ b) ->
  ((infix_asdt a b) =
   (infix_asdt im (infix_asdt (r_to_c (im_part a)) (r_to_c (real_part b))))) /\
  (((infix_asdt a b) =
    (infix_asdt im (r_to_c ((im_part a) * (real_part b))%R))) /\
   (((real_part (infix_asdt a b)) = 0%R) /\
    ((im_part (infix_asdt a b)) = ((im_part a) * (real_part b))%R))).

Axiom decomp_mult_gen :
  forall (a:complex) (b:complex),
  ((real_part (infix_asdt a b)) =
   (infix_mnas ((real_part a) * (real_part b))%R
    ((im_part a) * (im_part b))%R)) /\
  ((im_part (infix_asdt a b)) =
   (((real_part a) * (im_part b))%R + ((im_part a) * (real_part b))%R)%R).

Axiom inv_real :
  forall (a:complex), ~ (a = c_zero) -> (real_ a) ->
  ((real_part (infix_sldt c_one a)) = (infix_slas 1%R (real_part a))) /\
  (real_ (infix_sldt c_one a)).

Axiom div_real_real :
  forall (a:complex) (b:complex), (real_ a) -> (real_ b) -> ~ (b = c_zero) ->
  ((real_part (infix_sldt a b)) = (infix_slas (real_part a) (real_part b))).

Axiom zeroLessOne : infix_lseqdt c_zero c_one.

Axiom compatOrderAdd :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) ->
  infix_lseqdt (infix_pldt x z) (infix_pldt y z).

Axiom positive_add :
  forall (x:complex) (y:complex), (infix_lseqdt c_zero x) ->
  (infix_lseqdt c_zero y) -> infix_lseqdt c_zero (infix_pldt x y).

Axiom strict_positive_add_l :
  forall (x:complex) (y:complex), (infix_lsdt c_zero x) ->
  (infix_lseqdt c_zero y) -> infix_lsdt c_zero (infix_pldt x y).

Axiom strict_compatOrderAdd :
  forall (x:complex) (y:complex) (z:complex) (t:complex), (infix_lsdt x y) ->
  (infix_lsdt z t) -> (real_ x) -> (real_ y) -> (real_ z) -> (real_ t) ->
  infix_lsdt (infix_pldt x z) (infix_pldt y t).

Axiom compat_sup_add :
  forall (x:complex) (y:complex) (z:complex) (t:complex), (infix_gtdt x y) ->
  (infix_gtdt z t) -> (real_ x) -> (real_ y) -> (real_ z) -> (real_ t) ->
  infix_gtdt (infix_pldt x z) (infix_pldt y t).

Axiom compat_supeq_mult :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt y x) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lseqdt c_zero z) ->
  infix_lseqdt (infix_asdt y z) (infix_asdt x z).

Axiom compat_supeq_div :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt y x) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_lseqdt (infix_sldt y z) (infix_sldt x z).

Axiom compat_infeq_div :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_lseqdt (infix_sldt x z) (infix_sldt y z).

Axiom compat_sup_div :
  forall (x:complex) (y:complex) (z:complex), (infix_gtdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_gtdt (infix_sldt x z) (infix_sldt y z).

Axiom compat_inf_div :
  forall (x:complex) (y:complex) (z:complex), (infix_lsdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_lsdt (infix_sldt x z) (infix_sldt y z).

Axiom positive_prod_itself :
  forall (x:complex), (real_ x) -> infix_lseqdt c_zero (infix_asdt x x).

Axiom strict_positive_prod_itself :
  forall (x:complex), (real_ x) -> ~ (x = c_zero) ->
  infix_lsdt c_zero (infix_asdt x x).

Axiom compat_sup_mult :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt y x) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lseqdt c_zero z) ->
  infix_lseqdt (infix_asdt y z) (infix_asdt x z).

Axiom strict_compat_sup_mult :
  forall (x:complex) (y:complex) (z:complex), (infix_gtdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_gtdt (infix_asdt x z) (infix_asdt y z).

Axiom compat_sup_mult_left :
  forall (x:complex) (y:complex) (z:complex), (infix_lseqdt y x) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lseqdt c_zero z) ->
  infix_lseqdt (infix_asdt z y) (infix_asdt z x).

Axiom strict_compat_sup_mult_left :
  forall (x:complex) (y:complex) (z:complex), (infix_gtdt x y) ->
  (real_ x) -> (real_ y) -> (real_ z) -> (infix_lsdt c_zero z) ->
  infix_gtdt (infix_asdt z x) (infix_asdt z y).

Axiom inv_inf_eq :
  forall (a:complex) (b:complex), (infix_lsdt c_zero a) ->
  (infix_lsdt c_zero b) -> (infix_lseqdt a b) ->
  infix_lseqdt (infix_sldt c_one b) (infix_sldt c_one a).

Axiom inv_sup_eq :
  forall (a:complex) (b:complex), (infix_lsdt c_zero a) ->
  (infix_lsdt c_zero b) -> (infix_lseqdt b a) ->
  infix_lseqdt (infix_sldt c_one a) (infix_sldt c_one b).

Axiom inv_sup :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ((infix_lsdt c_zero x) /\ (infix_lsdt x y)) ->
  infix_gtdt (infix_sldt c_one x) (infix_sldt c_one y).

Axiom inv_eqinf :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ((infix_lsdt c_zero x) /\ (infix_lseqdt x y)) ->
  infix_lseqdt (infix_sldt c_one y) (infix_sldt c_one x).

Axiom inv_eqsup :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ((infix_lseqdt y x) /\ (infix_gtdt y c_zero)) ->
  infix_lseqdt (infix_sldt c_one x) (infix_sldt c_one y).

Axiom inv_inf :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ((infix_gtdt x y) /\ (infix_gtdt y c_zero)) ->
  infix_lsdt (infix_sldt c_one x) (infix_sldt c_one y).

Axiom inv_neg :
  forall (x:complex), (real_ x) -> (infix_lsdt x c_zero) ->
  infix_lsdt (infix_sldt c_one x) c_zero.

Axiom lower_inv :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt c_zero b) ->
  (infix_lseqdt c_zero a) -> (infix_lseqdt b c) ->
  infix_lseqdt (infix_sldt a c) (infix_sldt a b).

Axiom lower_inv_ :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt c_zero b) ->
  (infix_lseqdt c_zero a) -> (infix_lseqdt b c) ->
  infix_lseqdt (infix_sldt a c) (infix_sldt a b).

Axiom zero_add_t :
  forall (a1:complex) (a2:complex), (a1 = c_zero) ->
  ((infix_pldt a1 a2) = a2).

Axiom add_zero_t :
  forall (a1:complex) (a2:complex), (a2 = c_zero) ->
  ((infix_pldt a1 a2) = a1).

Axiom one_mult_t :
  forall (a1:complex) (a2:complex), (a1 = c_one) -> ((infix_asdt a1 a2) = a2).

Axiom one_mult_t_const : forall (a:complex), ((infix_asdt c_one a) = a).

Axiom zero_mult_t_const :
  forall (a:complex), ((infix_asdt c_zero a) = c_zero).

Axiom mult_zero_t_const :
  forall (a:complex), ((infix_asdt a c_zero) = c_zero).

Axiom subs_eq :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_mndt a1 b1) = (infix_mndt a2 b2)).

Axiom subst_itself :
  forall (a1:complex) (a2:complex), (a1 = a2) ->
  ((infix_mndt a1 a2) = c_zero).

Axiom mult_assoc_four :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_asdt (infix_asdt a (infix_asdt b c)) d) =
   (infix_asdt (infix_asdt a b) (infix_asdt c d))).

Axiom mult_assoc_rev :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt a (infix_asdt b c)) = (infix_asdt (infix_asdt a b) c)).

Axiom add_assoc1 :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_pldt (infix_pldt a b) c) = (infix_pldt a (infix_pldt b c))).

Axiom add_assoc_rev1 :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_pldt a (infix_pldt b c)) = (infix_pldt (infix_pldt a b) c)).

Axiom div_mult :
  forall (a:complex) (b:complex) (c:complex), ~ (c = c_zero) ->
  ((infix_asdt a (infix_sldt b c)) = (infix_sldt (infix_asdt a b) c)).

Axiom div_mult_rev :
  forall (a:complex) (b:complex) (c:complex), ~ (c = c_zero) ->
  ((infix_sldt (infix_asdt a b) c) = (infix_asdt a (infix_sldt b c))).

Axiom triang_p :
  forall (a:complex) (b:complex),
  ((infix_asdt (infix_pldt a b) (infix_pldt a b)) =
   (infix_pldt (infix_pldt (infix_asdt a a) (infix_asdt b b))
    (infix_asdt (infix_asdt (infix_pldt c_one c_one) a) b))).

Axiom triang_n :
  forall (a:complex) (b:complex),
  ((infix_asdt (infix_mndt a b) (infix_mndt a b)) =
   (infix_mndt (infix_pldt (infix_asdt a a) (infix_asdt b b))
    (infix_asdt (infix_asdt (infix_pldt c_one c_one) a) b))).

Axiom triang_s :
  forall (a:complex) (b:complex) (c:complex) (d:complex) (e:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c)
    (infix_pldt (infix_mndt d b) e))
   = (infix_pldt (infix_pldt a c) (infix_pldt d e))).

Axiom triang_t :
  forall (a:complex) (b:complex),
  ((infix_asdt (infix_pldt a b) (infix_mndt a b)) =
   (infix_mndt (infix_asdt a a) (infix_asdt b b))).

Axiom triang_sr :
  forall (a:complex) (b:complex) (c:complex) (d:complex) (e:complex),
  ((infix_pldt (infix_pldt (infix_mndt a b) c)
    (infix_pldt (infix_pldt d b) e))
   = (infix_pldt (infix_pldt a c) (infix_pldt d e))).

Axiom add_pos :
  forall (x:complex) (y:complex), (infix_lseqdt c_zero x) ->
  (infix_lseqdt c_zero y) -> infix_lseqdt c_zero (infix_pldt x y).

Axiom add_pos_strit_l :
  forall (x:complex) (y:complex), (infix_lsdt c_zero x) ->
  (infix_lseqdt c_zero y) -> infix_lsdt c_zero (infix_pldt x y).

Axiom add_pos_strit_r :
  forall (x:complex) (y:complex), (infix_lseqdt c_zero x) ->
  (infix_lsdt c_zero y) -> infix_lsdt c_zero (infix_pldt x y).

Axiom modulus_pre_pre :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_asdt a b) (infix_asdt c d))
    (infix_pldt (infix_asdt a d) (infix_asdt c b)))
   =
   (infix_pldt (infix_asdt a (infix_pldt b d))
    (infix_asdt c (infix_pldt b d)))) /\
  ((infix_pldt (infix_pldt (infix_asdt a b) (infix_asdt c d))
    (infix_pldt (infix_asdt a d) (infix_asdt c b)))
   = (infix_asdt (infix_pldt a c) (infix_pldt b d))).

Axiom modulus_pre :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt
    (infix_pldt (infix_asdt (infix_asdt a b) (infix_asdt a b))
     (infix_asdt (infix_asdt c d) (infix_asdt c d)))
    (infix_pldt (infix_asdt (infix_asdt a d) (infix_asdt a d))
     (infix_asdt (infix_asdt c b) (infix_asdt c b))))
   =
   (infix_asdt (infix_pldt (infix_asdt a a) (infix_asdt c c))
    (infix_pldt (infix_asdt b b) (infix_asdt d d)))).

Parameter real_sqrt: R -> R.

Axiom real_sqrt_spec :
  forall (x:R), (0%R <= x)%R ->
  (((real_sqrt x) * (real_sqrt x))%R = x) /\
  ((real_sqrt x) = (Reals.R_sqrt.sqrt x)).

Parameter square_rt: complex -> complex.

Axiom square_rt_def :
  forall (x:complex), (infix_lseqdt c_zero x) ->
  ((square_rt x) = (r_to_c (real_sqrt (real_part x)))).

Axiom square_rt_spec :
  forall (x:complex), (infix_lseqdt c_zero x) ->
  (real_ (square_rt x)) /\
  (((infix_asdt (square_rt x) (square_rt x)) = x) /\
   (infix_lseqdt c_zero (square_rt x))).

Axiom square_rt_eq :
  forall (a:complex) (b:complex), (infix_lseqdt c_zero a) ->
  (infix_lseqdt c_zero b) -> (a = b) -> ((square_rt a) = (square_rt b)).

Axiom real_square_rt :
  forall (x:complex), (real_ x) -> (infix_lseqdt c_zero x) ->
  real_ (square_rt x).

Axiom pos_square_rt :
  forall (x:complex), (real_ x) -> (infix_lseqdt c_zero x) ->
  infix_lseqdt c_zero (square_rt x).

Axiom square_rt_square :
  forall (x:complex), (infix_lseqdt c_zero x) ->
  ((infix_asdt (square_rt x) (square_rt x)) = x).

Axiom square_rt_infeq :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  ((infix_lseqdt c_zero x) /\ (infix_lseqdt x y)) ->
  infix_lseqdt (square_rt x) (square_rt y).

Axiom square_rt_inf :
  forall (x:complex) (y:complex),
  ((infix_lseqdt c_zero x) /\ (infix_lsdt x y)) ->
  infix_lsdt (square_rt x) (square_rt y).

Axiom injective_square_rt :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_lseqdt c_zero x) -> (infix_lseqdt c_zero y) ->
  ((square_rt x) = (square_rt y)) -> (x = y).

Axiom injective_square :
  forall (x:complex) (y:complex), (real_ x) -> (real_ y) ->
  (infix_lseqdt c_zero x) -> (infix_lseqdt c_zero y) ->
  ((infix_asdt x x) = (infix_asdt y y)) -> (x = y).

Axiom square_rt_c_one : ((square_rt c_one) = c_one).

Axiom square_rt_mult :
  forall (t:complex) (t':complex), (real_ t) -> (infix_lseqdt c_zero t) ->
  (real_ t') -> (infix_lseqdt c_zero t') ->
  ((infix_asdt (square_rt t) (square_rt t')) = (square_rt (infix_asdt t t'))).

Axiom square_rt_mult_rev :
  forall (t:complex) (t':complex), (real_ t) -> (infix_lseqdt c_zero t) ->
  (real_ t') -> (infix_lseqdt c_zero t') ->
  ((square_rt (infix_asdt t t')) = (infix_asdt (square_rt t) (square_rt t'))).

(* Why3 assumption *)
Definition modulus (x:complex) : complex :=
  square_rt
  (infix_pldt (infix_asdt (t_real_part x) (t_real_part x))
   (infix_asdt (t_im_part x) (t_im_part x))).

Axiom modulus_spec : forall (x:complex), infix_lseqdt c_zero (modulus x).

(* Why3 assumption *)
Definition c_one_modulus (x:complex) : Prop := ((modulus x) = c_one).

Axiom modulus_eq :
  forall (x:complex) (y:complex),
  ((infix_asdt (t_real_part x) (t_real_part x)) =
   (infix_asdt (t_real_part y) (t_real_part y))) ->
  ((infix_asdt (t_im_part x) (t_im_part x)) =
   (infix_asdt (t_im_part y) (t_im_part y))) ->
  ((modulus x) = (modulus y)).

Axiom modulus_minus :
  forall (x:complex), ((modulus (prefix_mndt x)) = (modulus x)).

Axiom square_rt_simpl :
  forall (x:complex), (infix_lsdt c_zero x) ->
  ((infix_asdt x (infix_sldt c_one (square_rt x))) = (square_rt x)).

Axiom square_rt_simpl_fact :
  forall (x:complex) (a:complex), (infix_lsdt c_zero x) ->
  ((infix_asdt (infix_asdt a (infix_sldt c_one (square_rt x))) x) =
   (infix_asdt a (square_rt x))).

Axiom square_rt_simpl_mult :
  forall (x:complex) (a:complex), (infix_lsdt c_zero x) ->
  ((infix_asdt (infix_asdt (square_rt x) a) (infix_sldt c_one (square_rt x)))
   = a).

Axiom square_rt_simpl_fact_assoc :
  forall (x:complex) (a:complex), (infix_lsdt c_zero x) ->
  ((infix_asdt x (infix_asdt a (infix_sldt c_one (square_rt x)))) =
   (infix_asdt a (square_rt x))).

Axiom modulus_itself :
  forall (x:complex) (y:complex), (x = y) -> ((modulus x) = (modulus y)).

Axiom modulus_real_pos :
  forall (x:complex), (real_ x) -> (infix_lseqdt c_zero x) ->
  ((modulus x) = x).

Axiom modulus_real_pos_inv :
  forall (x:complex), (real_ x) -> (infix_lseqdt c_zero x) ->
  ((modulus (prefix_mndt x)) = x).

Axiom modulus_real_neg :
  forall (x:complex), (real_ x) -> (infix_lseqdt x c_zero) ->
  ((modulus x) = (prefix_mndt x)).

Axiom strict_positive_modulus :
  forall (x:complex), ~ (x = c_zero) -> infix_lsdt c_zero (modulus x).

Axiom not_modulus_zero :
  forall (x:complex), ~ (x = c_zero) -> ~ ((modulus x) = c_zero).

Axiom modulus_real : forall (x:complex), real_ (modulus x).

Axiom t_mult_real_square :
  forall (a:complex) (b:complex),
  ((infix_asdt (t_real_part (infix_asdt a b)) (t_real_part (infix_asdt a b)))
   =
   (infix_mndt
    (infix_pldt
     (infix_asdt (infix_asdt (t_real_part a) (t_real_part a))
      (infix_asdt (t_real_part b) (t_real_part b)))
     (infix_asdt (infix_asdt (t_im_part a) (t_im_part a))
      (infix_asdt (t_im_part b) (t_im_part b))))
    (infix_asdt (infix_pldt c_one c_one)
     (infix_asdt
      (infix_asdt (infix_asdt (t_real_part a) (t_real_part b)) (t_im_part a))
      (t_im_part b))))).

Axiom t_mult_im_square :
  forall (a:complex) (b:complex),
  ((infix_asdt (t_im_part (infix_asdt a b)) (t_im_part (infix_asdt a b))) =
   (infix_pldt
    (infix_pldt
     (infix_asdt (infix_asdt (t_real_part a) (t_real_part a))
      (infix_asdt (t_im_part b) (t_im_part b)))
     (infix_asdt (infix_asdt (t_im_part a) (t_im_part a))
      (infix_asdt (t_real_part b) (t_real_part b))))
    (infix_asdt (infix_pldt c_one c_one)
     (infix_asdt
      (infix_asdt (infix_asdt (t_real_part a) (t_real_part b)) (t_im_part a))
      (t_im_part b))))).

Axiom mult_modulus_pre :
  forall (a:complex) (b:complex),
  ((infix_pldt
    (infix_asdt (t_real_part (infix_asdt a b))
     (t_real_part (infix_asdt a b)))
    (infix_asdt (t_im_part (infix_asdt a b)) (t_im_part (infix_asdt a b))))
   =
   (infix_asdt
    (infix_pldt (infix_asdt (t_real_part a) (t_real_part a))
     (infix_asdt (t_im_part a) (t_im_part a)))
    (infix_pldt (infix_asdt (t_real_part b) (t_real_part b))
     (infix_asdt (t_im_part b) (t_im_part b))))).

Axiom mult_modulus :
  forall (x:complex) (y:complex),
  ((modulus (infix_asdt x y)) = (infix_asdt (modulus x) (modulus y))).

Axiom mult_modulus_rev :
  forall (x:complex) (y:complex),
  ((infix_asdt (modulus x) (modulus y)) = (modulus (infix_asdt x y))).

Axiom mult_real_modulus :
  forall (x:complex) (y:complex), (real_ x) -> (infix_lseqdt c_zero x) ->
  ((modulus (infix_asdt x y)) = (infix_asdt x (modulus y))).

Axiom mult_modulus_real :
  forall (x:complex) (y:complex), (real_ y) -> (infix_lseqdt c_zero y) ->
  ((modulus (infix_asdt x y)) = (infix_asdt (modulus x) y)).

Axiom mult_modulus_non_null :
  forall (x:complex) (y:complex), ~ (x = c_zero) -> ~ (y = c_zero) ->
  ~ ((modulus (infix_asdt x y)) = c_zero).

Axiom modulus_to_non_null :
  forall (x:complex), (infix_lsdt c_zero (modulus x)) -> ~ (x = c_zero).

Axiom mult_c_one_modulus :
  forall (x:complex) (y:complex), (c_one_modulus x) -> (c_one_modulus y) ->
  c_one_modulus (infix_asdt x y).

Axiom modulus_pos :
  forall (x:complex), ~ (x = c_zero) -> infix_lseqdt c_zero (modulus x).

Axiom modulus_infeq :
  forall (x:complex) (b:complex) (c:complex), (real_ x) ->
  (infix_lseqdt b c) -> (infix_lseqdt (modulus x) b) -> infix_lseqdt x c.

Axiom modulus_inf :
  forall (x:complex) (b:complex) (c:complex), (real_ x) ->
  (infix_lsdt b c) -> (infix_lseqdt (modulus x) b) -> infix_lsdt x c.

Axiom modulus_diff_rev :
  forall (a:complex) (b:complex),
  ((modulus (infix_mndt a b)) = (modulus (infix_mndt b a))).

Axiom modulus_simpl_leq :
  forall (a:complex) (b:complex) (c:complex), (real_ a) -> (real_ b) ->
  (real_ c) -> (infix_lsdt c_zero c) ->
  (infix_lseqdt (modulus (infix_asdt a c)) (infix_asdt b c)) ->
  infix_lseqdt (modulus a) b.

Axiom modulus_simpl_leq_rev :
  forall (a:complex) (b:complex) (c:complex), (real_ a) -> (real_ b) ->
  (real_ c) -> (infix_lseqdt c_zero c) -> (infix_lseqdt (modulus a) b) ->
  infix_lseqdt (modulus (infix_asdt a c)) (infix_asdt b c).

Axiom div_eq :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ~ (b1 = c_zero) -> ((infix_sldt a1 b1) = (infix_sldt a2 b2)).

Axiom add_eq_inv_t :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_pldt a1 b1) = (infix_pldt b2 a2)).

Axiom mult_eq_inv_t :
  forall (a1:complex) (a2:complex) (b1:complex) (b2:complex), (a1 = a2) ->
  (b1 = b2) -> ((infix_asdt a1 b1) = (infix_asdt b2 a2)).

Axiom sum_frac :
  forall (a1:complex) (a2:complex) (b:complex), ~ (b = c_zero) ->
  ((infix_pldt (infix_sldt a1 b) (infix_sldt a2 b)) =
   (infix_sldt (infix_pldt a1 a2) b)).

Axiom sum_frac_rev :
  forall (a1:complex) (a2:complex) (b:complex), ~ (b = c_zero) ->
  ((infix_sldt (infix_pldt a1 a2) b) =
   (infix_pldt (infix_sldt a1 b) (infix_sldt a2 b))).

Axiom add_im_re :
  forall (i:complex) (j:complex),
  ((infix_pldt i j) =
   (infix_pldt (infix_pldt (t_real_part i) (t_real_part j))
    (infix_asdt im (infix_pldt (t_im_part i) (t_im_part j))))) /\
  (((t_real_part (infix_pldt i j)) =
    (infix_pldt (t_real_part i) (t_real_part j))) /\
   ((t_im_part (infix_pldt i j)) = (infix_pldt (t_im_part i) (t_im_part j)))).

Axiom add_real_part :
  forall (i:complex) (j:complex),
  ((infix_pldt (t_real_part i) (t_real_part j)) =
   (t_real_part (infix_pldt i j))).

Axiom add_im_part :
  forall (i:complex) (j:complex),
  ((infix_pldt (t_im_part i) (t_im_part j)) = (t_im_part (infix_pldt i j))).

Axiom add_real_part_rev :
  forall (i:complex) (j:complex),
  ((t_real_part (infix_pldt i j)) =
   (infix_pldt (t_real_part i) (t_real_part j))).

Axiom add_im_part_rev :
  forall (i:complex) (j:complex),
  ((t_im_part (infix_pldt i j)) = (infix_pldt (t_im_part i) (t_im_part j))).

Axiom mult_distr_add_r :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt a (infix_pldt b c)) =
   (infix_pldt (infix_asdt a b) (infix_asdt a c))).

Axiom mult_distr_minus :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt a (infix_mndt b c)) =
   (infix_mndt (infix_asdt a b) (infix_asdt a c))).

Axiom minus_out :
  forall (a:complex) (b:complex),
  ((infix_asdt (prefix_mndt a) b) = (prefix_mndt (infix_asdt a b))).

Axiom mult_distr_add_r_rev :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_pldt (infix_asdt a b) (infix_asdt a c)) =
   (infix_asdt a (infix_pldt b c))).

Axiom mult_distr_minus_rev :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_mndt (infix_asdt a b) (infix_asdt a c)) =
   (infix_asdt a (infix_mndt b c))).

Axiom div_distr_add :
  forall (a:complex) (b:complex) (c:complex), ~ (a = c_zero) ->
  ((infix_sldt (infix_pldt b c) a) =
   (infix_pldt (infix_sldt b a) (infix_sldt c a))).

Axiom div_distr_minus :
  forall (a:complex) (b:complex) (c:complex), ~ (a = c_zero) ->
  ((infix_sldt (infix_mndt b c) a) =
   (infix_mndt (infix_sldt b a) (infix_sldt c a))).

Axiom div_distr_add_rev :
  forall (a:complex) (b:complex) (c:complex), ~ (a = c_zero) ->
  ((infix_pldt (infix_sldt b a) (infix_sldt c a)) =
   (infix_sldt (infix_pldt b c) a)).

Axiom div_distr_minus_rev :
  forall (a:complex) (b:complex) (c:complex), ~ (a = c_zero) ->
  ((infix_mndt (infix_sldt b a) (infix_sldt c a)) =
   (infix_sldt (infix_mndt b c) a)).

Axiom mult_distr_add_l :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt (infix_pldt b c) a) =
   (infix_pldt (infix_asdt a b) (infix_asdt a c))).

Axiom mult_distr_minus_r :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt a (infix_mndt b c)) =
   (infix_mndt (infix_asdt a b) (infix_asdt a c))).

Axiom mult_distr_minus_ll :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt (infix_pldt (prefix_mndt b) c) a) =
   (infix_pldt (infix_asdt (prefix_mndt a) b) (infix_asdt a c))).

Axiom mult_distr_minus_ri :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt (infix_mndt b c) a) =
   (infix_mndt (infix_asdt a b) (infix_asdt a c))).

Axiom minus_distr_op :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_mndt a (infix_pldt b c)) = (infix_mndt (infix_mndt a b) c)).

Axiom mult_distr_minus_l :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt (infix_mndt b c) a) =
   (infix_mndt (infix_asdt a b) (infix_asdt a c))).

Axiom assoc_right :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_pldt a (infix_pldt b c)) = (infix_pldt (infix_pldt a b) c)).

Axiom assoc_right_mult :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_asdt a (infix_asdt b c)) = (infix_asdt (infix_asdt a b) c)).

Axiom minus_elim :
  forall (a:complex) (b:complex),
  ((infix_mndt a b) = (infix_pldt a (prefix_mndt b))).

Axiom minus_eq_t :
  forall (a:complex) (b:complex) (a':complex) (b':complex), (a = a') ->
  (b = b') -> ((infix_mndt a b) = (infix_mndt a' b')).

Axiom minus_distr_elim :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_mndt a (infix_pldt b c)) =
   (infix_pldt (infix_pldt a (prefix_mndt b)) (prefix_mndt c))).

Axiom plus_minus_distr_elim :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_pldt a (prefix_mndt (infix_pldt b c))) =
   (infix_pldt (infix_pldt a (prefix_mndt b)) (prefix_mndt c))).

Axiom def_by_minus :
  forall (x:complex) (y:complex) (z:complex), (x = (infix_mndt y z)) ->
  (y = (infix_pldt x z)).

Axiom switch :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_pldt (infix_pldt a b) c) = (infix_pldt (infix_pldt a c) b)).

Axiom meet_a_c :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a c) b) d)).

Axiom meet_a_d :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a d) b) c)).

Axiom meet_b_c :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b c) a) d)).

Axiom meet_b_d :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b d) a) c)).

Axiom meet_c_d :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt c d) a) b)).

Axiom inv_add :
  forall (a:complex) (b:complex),
  ((infix_pldt (infix_pldt a (prefix_mndt a)) b) = b).

Axiom switch_m :
  forall (a:complex) (b:complex) (c:complex),
  ((infix_pldt (infix_pldt a b) c) = (infix_pldt (infix_pldt a c) b)).

Axiom meet_a_c_m :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a c) b) d)).

Axiom meet_a_d_m :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt a d) b) c)).

Axiom meet_b_c_m :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b c) a) d)).

Axiom meet_b_d_m :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt b d) a) c)).

Axiom meet_c_d_m :
  forall (a:complex) (b:complex) (c:complex) (d:complex),
  ((infix_pldt (infix_pldt (infix_pldt a b) c) d) =
   (infix_pldt (infix_pldt (infix_pldt c d) a) b)).

Axiom t_real_part_add :
  forall (a:complex) (b:complex),
  ((t_real_part (infix_pldt a b)) =
   (infix_pldt (t_real_part a) (t_real_part b))).

Axiom t_real_part_subs :
  forall (a:complex) (b:complex),
  ((t_real_part (infix_mndt a b)) =
   (infix_mndt (t_real_part a) (t_real_part b))).

Axiom t_im_part_add :
  forall (a:complex) (b:complex),
  ((t_im_part (infix_pldt a b)) = (infix_pldt (t_im_part a) (t_im_part b))).

Axiom t_im_part_subs :
  forall (a:complex) (b:complex),
  ((t_im_part (infix_mndt a b)) = (infix_mndt (t_im_part a) (t_im_part b))).

Axiom t_real_part_real :
  forall (a:complex), (real_ a) -> ((t_real_part a) = a).

Axiom t_real_part_im :
  forall (a:complex), (pure_im_ a) -> ((t_real_part a) = c_zero).

Axiom im_t_im_part_im :
  forall (a:complex), (pure_im_ a) -> ((infix_asdt im (t_im_part a)) = a).

Axiom t_im_part_im :
  forall (a:complex), (pure_im_ a) ->
  ((t_im_part a) = (infix_asdt (prefix_mndt im) a)).

Axiom t_im_part_real :
  forall (a:complex), (real_ a) -> ((t_im_part a) = c_zero).

Axiom a_div_b_mult_a :
  forall (a:complex) (b:complex) (c:complex) (d:complex), ~ (b = c_zero) ->
  ~ (c = c_zero) -> (d = (infix_sldt c_one b)) -> (a = c) ->
  ((infix_asdt (infix_sldt a b) (infix_sldt c_one c)) = d).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def2 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t:a -> im1) (e:a),
  (((result2 op1 t) e) = true) <-> ~ (neutral op1 (t e)).

(* Why3 assumption *)
Definition nonn_part {a:Type} {a_WT:WhyType a}
    {im1:Type} {im1_WT:WhyType im1} (op1:im1 -> im1 -> im1) (s:set a)
    (t:a -> im1) : set a :=
  filter (result2 op1 t) s.

Axiom nonn_part_spec :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), forall (e:a),
  (mem e (nonn_part op1 s t)) <-> ((mem e s) /\ ~ (neutral op1 (t e))).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def3 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t:a -> im1) (e:a),
  (((result3 op1 t) e) = true) <-> (neutral op1 (t e)).

(* Why3 assumption *)
Definition n_part {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1}
    (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1) : set a :=
  filter (result3 op1 t) s.

Axiom n_part_spec :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), forall (e:a),
  (mem e (n_part op1 s t)) <-> ((mem e s) /\ (neutral op1 (t e))).

Axiom nullity_partition :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), (commut op1) ->
  (s = (union (nonn_part op1 s t) (n_part op1 s t))) /\
  ((inter (nonn_part op1 s t) (n_part op1 s t)) = (empty : set a)).

Axiom iterate_neutral :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), (iterable op1) ->
  (commut op1) ->
  (forall (a1:a), (mem a1 s) -> ((t a1) = (neutral_elt op1))) ->
  ((iterate op1 s t) = (neutral_elt op1)).

Axiom iterate_nullity_partition :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), (iterable op1) ->
  (commut op1) -> ((iterate op1 s t) = (iterate op1 (nonn_part op1 s t) t)).

(* Why3 assumption *)
Definition couple {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1} (f:a -> b -> im1) (o:(a* b)%type) : im1 :=
  match o with
  | (a1, b1) => (f a1) b1
  end.

Axiom null_product :
  forall (a:complex) (b:complex), ((infix_asdt a b) = c_zero) ->
  (a = c_zero) \/ (b = c_zero).

Axiom couple_value :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (f:a -> b -> im1) (o:(a* b)%type),
  ((couple f o) = ((f (fir o)) (sec o))).

Axiom couple_value_dev :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (f:a -> b -> im1) (o:(a* b)%type) (a1:a) (b1:b), (o = (a1, b1)) ->
  ((couple f o) = ((f a1) b1)).

Axiom neutral_c_zero :
  (neutral (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1)) c_zero) /\
  (iterable (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1))).

(* Why3 assumption *)
Definition sum {a:Type} {a_WT:WhyType a} (s:set a) (t:a -> complex) : complex :=
  iterate (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1)) s t.

Axiom sum_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), (is_empty s) -> ((sum s t) = c_zero).

Axiom sum_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), ((cardinal s) = 1%Z) ->
  ((sum s t) = (t (choose s))).

Axiom sum_add :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> complex) (x:b), ~ (mem x s) ->
  ((sum (add x s) f) = (infix_pldt (f x) (sum s f))).

Axiom sum_plus_one :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> complex), (1%Z < (cardinal s))%Z ->
  ((sum s f) = (infix_pldt (f (choose s)) (sum (remove (choose s) s) f))).

Axiom sum_real :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex),
  (forall (a1:a), (mem a1 s) -> real_ (f a1)) -> (0%Z < (cardinal s))%Z ->
  real_ (sum s f).

Axiom map_sum_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> a) (t:a -> complex), (p_injective f s) ->
  ((sum (map f s) t) = (sum s (fun (b1:b) => (t (f b1))))).

Axiom sum_comp :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> complex) (g:b -> complex),
  ((sum s (fun (k:b) => (infix_pldt (f k) (g k)))) =
   (infix_pldt (sum s f) (sum s g))).

Axiom sum_comp_rev :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> complex) (g:b -> complex),
  ((infix_pldt (sum s f) (sum s g)) =
   (sum s (fun (k:b) => (infix_pldt (f k) (g k))))).

Axiom sum_iter_ :
  (opposite_n (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1))
   (fun (y0:complex) (y1:complex) => (infix_mndt y0 y1)) c_zero) /\
  ((opposite (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1))
    (fun (y0:complex) (y1:complex) => (infix_mndt y0 y1))) /\
   ((opposite_com (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1))
     (fun (y0:complex) (y1:complex) => (infix_mndt y0 y1))) /\
    (inverse_tuple (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1))
     (fun (y0:complex) (y1:complex) => (infix_mndt y0 y1)) c_zero))).

Axiom neutral_zero :
  ((neutral_elt (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1))) =
   c_zero).

Axiom sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex) (g:a -> complex),
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> ((sum s f) = (sum s g)).

Axiom sum_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> complex) (g:a -> complex), (s = s') ->
  (forall (x:a), (mem x s) -> ((f x) = (g x))) -> ((sum s f) = (sum s' g)).

Axiom sum_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (t:a -> complex),
  ((inter s1 s2) = (empty : set a)) ->
  ((sum (union s1 s2) t) = (infix_pldt (sum s1 t) (sum s2 t))).

Axiom sum_to_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (f:a -> b -> complex),
  ((sum s1 (fun (a1:a) => (sum s2 (f a1)))) =
   (sum (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))).

Axiom sum_from_cartesian_product :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s1:set a) (s2:set b) (f:a -> b -> complex),
  ((sum (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))
   = (sum s1 (fun (a1:a) => (sum s2 (f a1))))).

(* Why3 assumption *)
Definition ind_sum (f:Z -> complex) (i:Z) (j:Z) : complex :=
  int_iterate (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1)) f i j.

Axiom ind_sum_to_int_iterate :
  forall (f:Z -> complex) (i:Z) (j:Z),
  ((ind_sum f i j) =
   (int_iterate (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1)) f i j)).

Axiom ind_sum_cardone :
  forall (f:Z -> complex) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((ind_sum f i j) = (f i)).

Axiom ind_sum_right_extension :
  forall (f:Z -> complex) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_sum f i j) = (infix_pldt (ind_sum f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom ind_sum_trans :
  forall (f:Z -> complex) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_sum f i j) = (infix_pldt (ind_sum f i k) (ind_sum f k j))).

Axiom ind_sum_plus_one :
  forall (f:Z -> complex) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_sum f i j) = (infix_pldt (f i) (ind_sum f (i + 1%Z)%Z j))).

Axiom real_ind_sum :
  forall (f:Z -> complex) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> real_ (f k)) ->
  real_ (ind_sum f i j).

Axiom positive_ind_sum :
  forall (f:Z -> complex) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> infix_lseqdt c_zero (f k)) ->
  infix_lseqdt c_zero (ind_sum f i j).

Axiom positive_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex),
  (forall (k:a), (mem k s) -> infix_lseqdt c_zero (f k)) ->
  infix_lseqdt c_zero (sum s f).

Axiom ind_sum_eq :
  forall (f:Z -> complex) (g:Z -> complex) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_sum f i j) = (ind_sum g i j)).

Parameter fc3: (Z -> complex) -> complex -> Z -> Z -> Z -> complex.

Axiom fc_def3 :
  forall (f:Z -> complex) (g:complex) (i:Z) (j:Z) (k:Z),
  (((i <= k)%Z /\ (k < j)%Z) -> (((fc3 f g i j) k) = (f k))) /\
  (~ ((i <= k)%Z /\ (k < j)%Z) -> (((fc3 f g i j) k) = g)).

Axiom ind_sum_eq_del_bound :
  forall (f:Z -> complex) (g:complex) (i:Z) (j:Z),
  ((ind_sum (fc3 f g i j) i j) = (ind_sum f i j)).

Parameter fc4: (Z -> complex) -> complex -> Z -> Z -> Z -> complex.

Axiom fc_def4 :
  forall (f:Z -> complex) (g:complex) (i:Z) (j:Z) (k:Z),
  (((i <= k)%Z /\ (k < j)%Z) -> (((fc4 f g i j) k) = (f k))) /\
  (~ ((i <= k)%Z /\ (k < j)%Z) -> (((fc4 f g i j) k) = g)).

Axiom ind_sum_eq_del_bound_rev :
  forall (f:Z -> complex) (g:complex) (i:Z) (j:Z),
  ((ind_sum f i j) = (ind_sum (fc4 f g i j) i j)).

Axiom ind_sum_eq_gen :
  forall (f:Z -> complex) (g:Z -> complex) (i1:Z) (j1:Z) (i2:Z) (j2:Z),
  (i1 = i2) -> (j1 = j2) ->
  (forall (k:Z), ((i1 <= k)%Z /\ (k < j1)%Z) -> ((f k) = (g k))) ->
  ((ind_sum f i1 j1) = (ind_sum g i2 j2)).

Axiom ind_sum_eq_bound :
  forall (f:Z -> complex) (g:Z -> complex) (i:Z) (j:Z), (i = j) ->
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_sum f 0%Z i) = (ind_sum g 0%Z j)).

Axiom ind_sum_comp :
  forall (f:Z -> complex) (g:Z -> complex) (i:Z) (j:Z),
  ((ind_sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j) =
   (infix_pldt (ind_sum f i j) (ind_sum g i j))).

Axiom ind_sum_comp_rev :
  forall (f:Z -> complex) (g:Z -> complex) (i:Z) (i':Z) (j:Z) (j':Z),
  (i = i') -> (j = j') ->
  ((infix_pldt (ind_sum f i j) (ind_sum g i' j')) =
   (ind_sum (fun (k:Z) => (infix_pldt (f k) (g k))) i j)).

Axiom ind_sum_to_iterate :
  forall (f:Z -> complex) (i:Z) (j:Z),
  ((ind_sum f i j) =
   (iterate (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1))
    (to_fset i j) f)).

Axiom ind_sum_to_sum :
  forall (f:Z -> complex) (i:Z) (j:Z),
  ((ind_sum f i j) = (sum (to_fset i j) f)).

Axiom map_ind_sum_eq :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t:Z -> complex),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_sum t k l) = (ind_sum (fun (b:Z) => (t (f b))) i j)).

Axiom sum_scal :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> complex) (s:set a) (c:complex),
  ((sum s (fun (x:a) => (infix_asdt c (f x)))) = (infix_asdt c (sum s f))).

Axiom sum_scal_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> complex) (s:set a) (c:complex),
  ((sum s (fun (x:a) => (infix_asdt (f x) c))) = (infix_asdt (sum s f) c)).

Axiom sum_scal_rev_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> complex) (s:set a) (c:complex),
  ((infix_asdt (sum s f) c) = (sum s (fun (x:a) => (infix_asdt (f x) c)))).

Axiom sum_scal_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> complex) (s:set a) (c:complex),
  ((infix_asdt c (sum s f)) = (sum s (fun (x:a) => (infix_asdt c (f x))))).

Axiom ind_sum_scal :
  forall (f:Z -> complex) (i:Z) (j:Z) (a:complex),
  ((ind_sum (fun (i1:Z) => (infix_asdt a (f i1))) i j) =
   (infix_asdt a (ind_sum f i j))).

Axiom ind_sum_scal_rev :
  forall (f:Z -> complex) (i:Z) (j:Z) (a:complex),
  ((infix_asdt a (ind_sum f i j)) =
   (ind_sum (fun (i1:Z) => (infix_asdt a (f i1))) i j)).

Axiom scal_ind_sum :
  forall (f:Z -> complex) (i:Z) (j:Z) (a:complex),
  ((ind_sum (fun (i1:Z) => (infix_asdt (f i1) a)) i j) =
   (infix_asdt (ind_sum f i j) a)).

Axiom scal_ind_sum_rev :
  forall (f:Z -> complex) (i:Z) (j:Z) (a:complex),
  ((infix_asdt (ind_sum f i j) a) =
   (ind_sum (fun (i1:Z) => (infix_asdt (f i1) a)) i j)).

Axiom sum_scal_gen :
  forall (f:Z -> complex) (s:set Z), forall (a:complex),
  ((sum s (fun (i:Z) => (infix_asdt a (f i)))) = (infix_asdt a (sum s f))).

Axiom ind_sum_scal_gen :
  forall (f:Z -> complex) (i:Z) (j:Z), forall (a:complex),
  ((ind_sum (fun (i1:Z) => (infix_asdt a (f i1))) i j) =
   (infix_asdt a (ind_sum f i j))).

Axiom int_int_iterate_def_empty :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (j <= i)%Z -> (iterable op1) ->
  ((int_int_iterate op1 f i j k l) = (neutral_elt op1)).

Axiom int_int_iterate_def_plus_one :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i < j)%Z -> (iterable op1) ->
  ((int_int_iterate op1 f i j k l) =
   ((op1 (int_iterate op1 (fun (n:Z) => ((f i) n)) k l))
    (int_int_iterate op1 f (i + 1%Z)%Z j k l))).

Axiom int_int_iterate_to_int_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i <= j)%Z -> (iterable op1) ->
  ((int_int_iterate op1 f i j k l) =
   (int_iterate op1 (fun (a:Z) => (int_iterate op1 (f a) k l)) i j)).

Axiom int_iterate_to_int_int_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i <= j)%Z -> (iterable op1) ->
  ((int_iterate op1 (fun (a:Z) => (int_iterate op1 (f a) k l)) i j) =
   (int_int_iterate op1 f i j k l)).

Axiom int_int_iterate_to_iterate :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (i <= j)%Z -> (iterable op1) -> (commut op1) ->
  ((int_int_iterate op1 f i j k l) =
   (iterate op1 (cartesian_product (to_fset i j) (to_fset k l))
    (fun (o:(Z* Z)%type) => ((f (fir o)) (sec o))))).

Axiom iterate_commute :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (s2:set b) (f:a -> b -> im1),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 (cartesian_product s1 s2)
    (fun (o:(a* b)%type) => ((f (fir o)) (sec o))))
   =
   (iterate op1 (cartesian_product s2 s1)
    (fun (o:(b* a)%type) => ((f (sec o)) (fir o))))).

Axiom iterate_commute_ :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s1:set a) (s2:set b) (f:a -> b -> im1),
  (iterable op1) -> (commut op1) ->
  ((iterate op1 s1
    (fun (a1:a) => (iterate op1 s2 (fun (a2:b) => ((f a1) a2)))))
   =
   (iterate op1 s2
    (fun (a2:b) => (iterate op1 s1 (fun (a1:a) => ((f a1) a2)))))).

Axiom int_int_iterate_commute :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (iterable op1) -> (commut op1) -> (i <= j)%Z -> (k <= l)%Z ->
  ((int_int_iterate op1 f i j k l) =
   (int_int_iterate op1 (fun (a:Z) (b:Z) => ((f b) a)) k l i j)).

Axiom int_iterate_commute :
  forall {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (f:Z -> Z -> im1) (i:Z) (j:Z) (k:Z) (l:Z),
  (iterable op1) -> (commut op1) -> (i <= j)%Z -> (k <= l)%Z ->
  ((int_iterate op1 (fun (a:Z) => (int_iterate op1 (f a) k l)) i j) =
   (int_iterate op1
    (fun (a:Z) => (int_iterate op1 (fun (b:Z) => ((f b) a)) i j)) k l)).

Axiom ind_sum_commute :
  forall (f:Z -> Z -> complex) (i:Z) (j:Z) (k:Z) (l:Z), (i <= j)%Z ->
  (k <= l)%Z ->
  ((ind_sum (fun (k1:Z) => (ind_sum (f k1) k l)) i j) =
   (ind_sum (fun (k1:Z) => (ind_sum (fun (k2:Z) => ((f k2) k1)) i j)) k l)).

Axiom sum_commute :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b -> complex) (sa:set a) (sb:set b),
  ((sum sa (fun (a1:a) => (sum sb (f a1)))) =
   (sum sb (fun (b1:b) => (sum sa (fun (a1:a) => ((f a1) b1)))))).

(* Why3 assumption *)
Definition non_c_zero {a:Type} {a_WT:WhyType a} (s:set a) (t:a -> complex) :
    set a :=
  nonn_part (fun (y0:complex) (y1:complex) => (infix_pldt y0 y1)) s t.

Axiom non_c_zero_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), forall (e:a),
  (mem e (non_c_zero s t)) <-> ((mem e s) /\ ~ ((t e) = c_zero)).

Axiom get_non_c_zero_member :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex) (e:a), (mem e (non_c_zero s t)) ->
  (mem e s) /\ ~ ((t e) = c_zero).

Axiom set_non_c_zero_member :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex) (e:a), (mem e s) -> ~ ((t e) = c_zero) ->
  mem e (non_c_zero s t).

Axiom set_non_c_zero_member_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), forall (e:a),
  ((mem e s) /\ ~ ((t e) = c_zero)) -> mem e (non_c_zero s t).

Axiom set_non_c_zero_member_gen_ :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), forall (e:a),
  ((mem e s) /\ ~ ((t e) = c_zero)) -> mem e (non_c_zero s t).

Axiom sum_nullity_partition :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), ((sum s t) = (sum (non_c_zero s t) t)).

Axiom non_null_map :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> a) (t:a -> complex),
  ((non_c_zero (map f s) t) =
   (map f (non_c_zero s (fun (b:a) => (t (f b)))))).

Axiom map_sum_eq_nonnull :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> a) (t:a -> complex),
  (p_bijective f (non_c_zero s (fun (b:a) => (t (f b))))
   (non_c_zero (map f s) t)) ->
  ((sum (non_c_zero (map f s) t) t) =
   (sum (non_c_zero s (fun (b:a) => (t (f b)))) (fun (b:a) => (t (f b))))).

Axiom sum_null_but_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), ((cardinal (non_c_zero s t)) = 1%Z) ->
  ((sum s t) = (t (element (non_c_zero s t)))).

Axiom sum_null :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex), ((cardinal (non_c_zero s t)) = 0%Z) ->
  ((sum s t) = c_zero).

Axiom sum_null_ :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex),
  (forall (e:a), (mem e s) -> ((t e) = c_zero)) -> ((sum s t) = c_zero).

Axiom sum_null_forall :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex),
  (forall (e:a), (mem e s) -> ((t e) = c_zero)) -> ((sum s t) = c_zero).

Axiom ind_sum_null :
  forall (t:Z -> complex) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((t k) = c_zero)) ->
  ((ind_sum t i j) = c_zero).

Axiom sum_null_but_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex) (elt:a),
  ((mem elt s) /\ ~ ((t elt) = c_zero)) ->
  (forall (a1:a), (mem a1 s) -> ~ (a1 = elt) -> ((t a1) = c_zero)) ->
  ((sum s t) = (t elt)).

Axiom sum_null_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (t:a -> complex) (s:set a) (elt:a), (mem elt s) ->
  (forall (k:a), (mem k s) -> ~ (k = elt) -> ((t k) = c_zero)) ->
  ((sum s t) = (t elt)).

Axiom sum_null_but_maybe_two_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (t:a -> complex) (s:set a) (elt:a) (elt':a), (mem elt s) ->
  (mem elt' s) -> ~ (elt = elt') ->
  (forall (k:a), (mem k s) -> ~ (k = elt) -> ~ (k = elt') ->
   ((t k) = c_zero)) ->
  ((sum s t) = (infix_pldt (t elt) (t elt'))).

Axiom ind_sum_null_but_maybe_one_elt :
  forall (t:Z -> complex) (i:Z) (j:Z) (ind:Z),
  ((i <= ind)%Z /\ (ind < j)%Z) ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ~ (k = ind) ->
   ((t k) = c_zero)) ->
  ((ind_sum t i j) = (t ind)).

Axiom ind_sum_null_but_maybe_two_elt :
  forall (t:Z -> complex) (i:Z) (j:Z) (ind:Z) (ind':Z),
  ((i <= ind)%Z /\ (ind < j)%Z) -> ((i <= ind')%Z /\ (ind' < j)%Z) ->
  ~ (ind = ind') ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ~ (k = ind) -> ~ (k = ind') ->
   ((t k) = c_zero)) ->
  ((ind_sum t i j) = (infix_pldt (t ind) (t ind'))).

Axiom ind_sum_map_filter :
  forall (n:Z) (n':Z) (g:Z -> Z) (f:Z -> complex) (p:Z -> bool),
  ((0%Z <= n')%Z /\ (n' <= n)%Z) -> (p_injective g (to_fset 0%Z n')) ->
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < n)%Z) -> ~ ((p k) = true) ->
   ((f k) = c_zero)) ->
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < n')%Z) ->
   (0%Z <= (g k))%Z /\ ((g k) < n)%Z) ->
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
   ((p k) = true) <->
   exists ant:Z, ((0%Z <= ant)%Z /\ (ant < n')%Z) /\ (k = (g ant))) ->
  ((ind_sum f 0%Z n) = (ind_sum (fun (k:Z) => (f (g k))) 0%Z n')).

Axiom neutral_c_one :
  (neutral (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1)) c_one) /\
  (iterable (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1))).

Axiom product_iter :
  (op_neutral_left (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1))
   c_one) /\
  (((op_neutral_right (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1))
     c_one) /\
    (op_assoc (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1)))) /\
   ((commut (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1))) /\
    (iterates (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1)) c_one))).

(* Why3 assumption *)
Definition product {a:Type} {a_WT:WhyType a} (s:set a) (t:a -> complex) :
    complex :=
  iterate (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1)) s t.

Axiom product_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex) (t':a -> complex),
  (forall (e:a), (mem e s) -> ((t e) = (t' e))) ->
  ((product s t) = (product s t')).

Axiom product_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (t:a -> complex) (t':a -> complex), (s = s') ->
  (forall (e:a), (mem e s) -> ((t e) = (t' e))) ->
  ((product s t) = (product s' t')).

Axiom product_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex), (is_empty s) -> ((product s f) = c_one).

Axiom product_iter_ :
  iterable (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1)).

Axiom add_product :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex) (x:a), ~ (mem x s) ->
  ((product (add x s) f) = (infix_asdt (f x) (product s f))).

Axiom product_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex) (x:a), ~ (mem x s) ->
  ((product (add x s) f) = (infix_asdt (product s f) (f x))).

Axiom neutral_one :
  ((neutral_elt (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1))) =
   c_one).

(* Why3 assumption *)
Definition ind_product (f:Z -> complex) (i:Z) (j:Z) : complex :=
  int_iterate (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1)) f i j.

Axiom ind_product_eq :
  forall (f:Z -> complex) (g:Z -> complex) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = (g k))) ->
  ((ind_product f i j) = (ind_product g i j)).

Axiom ind_product_cardone :
  forall (f:Z -> complex) (i:Z) (j:Z), (j = (i + 1%Z)%Z) ->
  ((ind_product f i j) = (f i)).

Axiom ind_product_eq_gen :
  forall (f:Z -> complex) (g:Z -> complex) (i1:Z) (j1:Z) (i2:Z) (j2:Z),
  (forall (k:Z), ((i1 <= k)%Z /\ (k < j1)%Z) -> ((f k) = (g k))) ->
  (i1 = i2) -> (j1 = j2) -> ((ind_product f i1 j1) = (ind_product g i2 j2)).

Axiom ind_product_right_extension :
  forall (f:Z -> complex) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_product f i j) =
   (infix_asdt (ind_product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z))).

Axiom ind_product_left_extension :
  forall (f:Z -> complex) (i:Z) (j:Z), (i < j)%Z ->
  ((ind_product f i j) = (infix_asdt (f i) (ind_product f (i + 1%Z)%Z j))).

Axiom ind_product_to_product :
  forall (f:Z -> complex) (i:Z) (j:Z),
  ((ind_product f i j) = (product (to_fset i j) f)).

Axiom map_product_eq :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> a) (t:a -> complex), (p_injective f s) ->
  ((product (map f s) t) = (product s (fun (b1:b) => (t (f b1))))).

Axiom map_ind_product_eq :
  forall (i:Z) (j:Z) (k:Z) (l:Z) (f:Z -> Z) (t:Z -> complex),
  (p_bijective f (to_fset i j) (to_fset k l)) ->
  ((ind_product t k l) = (ind_product (fun (b:Z) => (t (f b))) i j)).

Axiom ind_product_right_extension_comm :
  forall (f:Z -> complex) (i:Z) (j:Z), (i < j)%Z ->
  ((infix_asdt (ind_product f i (j - 1%Z)%Z) (f (j - 1%Z)%Z)) =
   (ind_product f i j)).

Axiom ind_product_eq_func :
  forall (i:Z) (j:Z) (f1:Z -> complex) (f2:Z -> complex),
  (p_injective f1 (to_fset i j)) -> (p_injective f2 (to_fset i j)) ->
  ((map f1 (to_fset i j)) = (map f2 (to_fset i j))) ->
  ((ind_product f1 i j) = (ind_product f2 i j)).

Axiom ind_product_trans :
  forall (f:Z -> complex) (i:Z) (k:Z) (j:Z), ((i <= k)%Z /\ (k <= j)%Z) ->
  ((ind_product f i j) =
   (infix_asdt (ind_product f i k) (ind_product f k j))).

Axiom ind_product_zero_pre :
  forall (f:Z -> complex) (i:Z) (t:Z) (j:Z), ((i <= t)%Z /\ (t < j)%Z) ->
  ((f t) = c_zero) -> ((ind_product f i j) = c_zero).

Axiom ind_product_zero :
  forall (f:Z -> complex) (i:Z) (j:Z), (i <= j)%Z ->
  (exists t:Z, ((i <= t)%Z /\ (t < j)%Z) /\ ((f t) = c_zero)) ->
  ((ind_product f i j) = c_zero).

Axiom ind_product_zero_elt :
  forall (f:Z -> complex) (i:Z) (j:Z) (t:Z), (i <= j)%Z ->
  ((i <= t)%Z /\ (t < j)%Z) -> ((f t) = c_zero) ->
  ((ind_product f i j) = c_zero).

Axiom ind_product_const_c_one :
  forall (f:Z -> complex) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (t:Z), ((i <= t)%Z /\ (t < j)%Z) -> ((f t) = c_one)) ->
  ((ind_product f i j) = c_one).

Axiom real : forall (x:complex), (real_ x) -> (x = (r_to_c (real_part x))).

Axiom pure_im :
  forall (x:complex), (pure_im_ x) ->
  (x = (infix_asdt im (r_to_c (im_part x)))).

Axiom im_dec : ((real_part im) = 0%R) /\ ((im_part im) = 1%R).

Axiom c_one_dec : ((real_part c_one) = 1%R) /\ ((im_part c_one) = 0%R).

Axiom c_zero_dec : ((real_part c_zero) = 0%R) /\ ((im_part c_zero) = 0%R).

Axiom ttwo_dec :
  ((real_part (infix_pldt c_one c_one)) = 2%R) /\
  ((im_part (infix_pldt c_one c_one)) = 0%R).

(* Why3 assumption *)
Definition i_to_c (i:Z) : complex := r_to_c (from_int i).

Axiom i_to_c_spec : forall (i:Z), real_ (i_to_c i).

Axiom i_to_c_zero : ((i_to_c 0%Z) = c_zero).

Axiom i_to_c_surj :
  forall (i:Z) (j:Z), ~ (i = j) -> ~ ((i_to_c i) = (i_to_c j)).

Axiom i_to_c_eq : forall (i:Z) (j:Z), (i = j) -> ((i_to_c i) = (i_to_c j)).

Axiom i_to_c_inf :
  forall (i:Z) (j:Z), (i < j)%Z -> infix_lsdt (i_to_c i) (i_to_c j).

Axiom i_to_c_nzero : forall (i:Z), ~ (i = 0%Z) -> ~ ((i_to_c i) = c_zero).

Axiom i_to_c_one : ((i_to_c 1%Z) = c_one).

Axiom i_to_c_add :
  forall (i:Z) (j:Z),
  ((infix_pldt (i_to_c i) (i_to_c j)) = (i_to_c (i + j)%Z)).

Axiom i_to_c_add_rev :
  forall (i:Z) (j:Z),
  ((i_to_c (i + j)%Z) = (infix_pldt (i_to_c i) (i_to_c j))).

Axiom i_to_c_ttwo : ((i_to_c 2%Z) = (infix_pldt c_one c_one)).

Axiom i_to_c_pos :
  forall (a:Z), (0%Z <= a)%Z -> infix_lseqdt c_zero (i_to_c a).

Axiom i_to_c_minus :
  forall (a:Z), ((i_to_c (-a)%Z) = (prefix_mndt (i_to_c a))).

Axiom i_to_c_strict_pos :
  forall (a:Z), (0%Z < a)%Z -> infix_lsdt c_zero (i_to_c a).

Axiom i_to_c_mult_pos :
  forall (i:Z) (j:Z), (0%Z <= j)%Z ->
  ((infix_asdt (i_to_c i) (i_to_c j)) = (i_to_c (i * j)%Z)).

Axiom i_to_c_mult :
  forall (i:Z) (j:Z),
  ((infix_asdt (i_to_c i) (i_to_c j)) = (i_to_c (i * j)%Z)).

Axiom i_to_c_mult_rev :
  forall (i:Z) (j:Z),
  ((i_to_c (i * j)%Z) = (infix_asdt (i_to_c i) (i_to_c j))).

Axiom i_to_c_mult_assoc :
  forall (x:complex) (i:Z) (j:Z),
  ((infix_asdt x (i_to_c (i * j)%Z)) =
   (infix_asdt (infix_asdt x (i_to_c i)) (i_to_c j))).

Axiom i_to_c_mult_assoc_rev :
  forall (x:complex) (i:Z) (j:Z),
  ((infix_asdt (infix_asdt x (i_to_c i)) (i_to_c j)) =
   (infix_asdt x (i_to_c (i * j)%Z))).

Axiom i_to_c_sub :
  forall (i:Z) (j:Z),
  ((infix_mndt (i_to_c i) (i_to_c j)) = (i_to_c (i - j)%Z)).

Axiom i_to_c_opp :
  forall (i:Z), ((i_to_c (-i)%Z) = (prefix_mndt (i_to_c i))).

Axiom i_to_c_div :
  forall (i:Z) (j:Z), ~ (j = 0%Z) ->
  ((infix_sldt (i_to_c (i * j)%Z) (i_to_c j)) = (i_to_c i)).

Axiom i_to_c_minus_mult :
  forall (i:Z) (j:Z),
  ((infix_asdt (i_to_c (-i)%Z) (i_to_c j)) =
   (infix_asdt (i_to_c i) (i_to_c (-j)%Z))).

Axiom i_to_c_div_leq_c_one :
  forall (a:Z) (b:Z), ((0%Z <= a)%Z /\ (a < b)%Z) ->
  infix_lseqdt (infix_sldt (i_to_c a) (i_to_c b)) c_one.

Axiom compat_i_to_c_infeq :
  forall (a:Z) (b:Z), (a <= b)%Z -> infix_lseqdt (i_to_c a) (i_to_c b).

Axiom compat_i_to_c_inf :
  forall (a:Z) (b:Z), (a < b)%Z -> infix_lsdt (i_to_c a) (i_to_c b).

Axiom compat_i_to_c_supeq :
  forall (a:Z) (b:Z), (b <= a)%Z -> infix_lseqdt (i_to_c b) (i_to_c a).

Axiom compat_i_to_c_sup :
  forall (a:Z) (b:Z), (b < a)%Z -> infix_gtdt (i_to_c a) (i_to_c b).

Axiom positive_int_squrt :
  forall (i:Z), (0%Z < i)%Z -> infix_gtdt (square_rt (i_to_c i)) c_zero.

Axiom non_null_int_squrt :
  forall (i:Z), (0%Z < i)%Z -> ~ ((square_rt (i_to_c i)) = c_zero).

Axiom ind_sum_constant :
  forall (f:Z -> complex) (valu:complex) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> ((f k) = valu)) ->
  ((ind_sum f i j) = (infix_asdt valu (i_to_c (j - i)%Z))).

Axiom ind_sum_constant_from_z :
  forall (f:Z -> complex) (valu:complex) (j:Z), (0%Z <= j)%Z ->
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < j)%Z) -> ((f k) = valu)) ->
  ((ind_sum f 0%Z j) = (infix_asdt valu (i_to_c j))).

Axiom sum_constant :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex) (x:complex),
  (forall (e:a), (mem e s) -> ((t e) = x)) ->
  ((sum s t) = (infix_asdt (i_to_c (cardinal s)) x)).

Axiom ind_sum_constant_case :
  forall (n:Z) (t:Z -> complex) (p:Z -> bool) (x:complex) (y:complex) (k1:Z),
  (0%Z <= n)%Z -> ((cardinal (my_filter (to_fset 0%Z n) p)) = k1) ->
  (forall (e:Z), ((0%Z <= e)%Z /\ (e < n)%Z) -> ((p e) = true) ->
   ((t e) = x)) ->
  (forall (e:Z), ((0%Z <= e)%Z /\ (e < n)%Z) -> ~ ((p e) = true) ->
   ((t e) = y)) ->
  ((ind_sum t 0%Z n) =
   (infix_pldt (infix_asdt (i_to_c k1) x) (infix_asdt (i_to_c (n - k1)%Z) y))).

Axiom sum_const_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex),
  (forall (e:a), (mem e s) -> ((t e) = c_one)) ->
  ((sum s t) = (i_to_c (cardinal s))).

Axiom abs_eqinf :
  forall (x:Z) (y:Z), ((x <= y)%Z /\ (y <= 0%Z)%Z) ->
  ((ZArith.BinInt.Z.abs y) <= (ZArith.BinInt.Z.abs x))%Z.

Axiom abs_inf :
  forall (x:Z) (y:Z), ((0%Z < x)%Z /\ ((x < y)%Z /\ (y <= 0%Z)%Z)) ->
  ((ZArith.BinInt.Z.abs y) < (ZArith.BinInt.Z.abs x))%Z.

Axiom abs_eqsup :
  forall (x:Z) (y:Z), ((x <= 0%Z)%Z /\ (y <= x)%Z) ->
  ((ZArith.BinInt.Z.abs x) <= (ZArith.BinInt.Z.abs y))%Z.

Axiom abs_sup :
  forall (x:Z) (y:Z), ((x <= 0%Z)%Z /\ (y < x)%Z) ->
  ((ZArith.BinInt.Z.abs x) < (ZArith.BinInt.Z.abs y))%Z.

Axiom inv_negeq :
  forall (x:Z), (x <= 0%Z)%Z -> (0%Z <= (ZArith.BinInt.Z.abs x))%Z.

Axiom inv_neg1 :
  forall (x:Z), (x < 0%Z)%Z -> (0%Z < (ZArith.BinInt.Z.abs x))%Z.

Parameter cpower: complex -> Z -> complex.

Axiom Cpower_zero : forall (i:complex), ((cpower i 0%Z) = c_one).

Axiom Cpower_one : forall (i:complex), ((cpower i 1%Z) = i).

Axiom Cpower_sum :
  forall (i:complex), forall (n:Z) (m:Z), ((i = c_zero) -> ~ (n = (-m)%Z)) ->
  ((cpower i (n + m)%Z) = (infix_asdt (cpower i n) (cpower i m))).

Axiom zero_poower :
  forall (e:Z), ~ (e = 0%Z) -> ((cpower c_zero e) = c_zero).

Axiom cpower_ttwo_two :
  ((cpower (infix_pldt c_one c_one) 2%Z) = (i_to_c 4%Z)).

Axiom real_squarert_two : real_ (square_rt (infix_pldt c_one c_one)).

Axiom squarertTwo :
  ((cpower (square_rt (infix_pldt c_one c_one)) 2%Z) =
   (infix_pldt c_one c_one)).

Axiom complete_rt_two :
  forall (a:complex),
  (a =
   (infix_sldt (square_rt (infix_pldt c_one c_one)) (infix_pldt c_one c_one))) ->
  ((infix_asdt (square_rt (infix_pldt c_one c_one)) a) = c_one).

Axiom cpower_sum :
  forall (x:complex) (n:Z) (m:Z), ((x = c_zero) -> ~ (n = (-m)%Z)) ->
  ((cpower x (n + m)%Z) = (infix_asdt (cpower x n) (cpower x m))).

Axiom cpower_one : forall (x:complex) (n:Z), (n = 1%Z) -> ((cpower x n) = x).

Axiom cpower_two :
  forall (x:complex) (n:Z), (n = 2%Z) -> ((cpower x n) = (infix_asdt x x)).

Axiom cpower_two_rev :
  forall (x:complex), ((infix_asdt x x) = (cpower x 2%Z)).

Axiom cpower_sum_rev :
  forall (x:complex) (n:Z) (m:Z), ((x = c_zero) -> ~ (n = (-m)%Z)) ->
  ((infix_asdt (cpower x n) (cpower x m)) = (cpower x (n + m)%Z)).

Axiom cpower_plus_one :
  forall (e:complex) (i:Z), ((e = c_zero) -> ~ (i = (-1%Z)%Z)) ->
  ((cpower e (i + 1%Z)%Z) = (infix_asdt (cpower e i) e)).

Axiom cpower_zero : forall (e:complex), ((cpower e 0%Z) = c_one).

Axiom cpower_eq :
  forall (e:complex) (e':complex) (i:Z) (i':Z), (e = e') -> (i = i') ->
  ((cpower e i) = (cpower e' i')).

Axiom cpower_inv :
  forall (e:complex) (i:Z), ~ (e = c_zero) ->
  ((infix_asdt (cpower e i) (cpower e (-i)%Z)) = c_one).

Axiom compat_cpower_leq :
  forall (a:complex) (b:complex) (i:Z),
  ((infix_lseqdt c_zero a) /\ (infix_lseqdt a b)) -> (0%Z <= i)%Z ->
  (infix_lseqdt c_zero (cpower a i)) /\
  (infix_lseqdt (cpower a i) (cpower b i)).

Axiom cpower_inv_rew :
  forall (e:complex) (i:Z), ~ (e = c_zero) ->
  ((cpower e i) = (infix_sldt c_one (cpower e (-i)%Z))).

Axiom inv_cpower :
  forall (e:complex) (i:Z), ~ ((cpower e i) = c_zero) ->
  ((infix_sldt c_one (cpower e i)) = (cpower e (-i)%Z)).

Axiom cpower_div :
  forall (x:complex) (y:complex) (n:Z), (0%Z <= n)%Z -> ~ (y = c_zero) ->
  ((cpower (infix_sldt x y) n) = (infix_sldt (cpower x n) (cpower y n))).

Axiom cpower_div_rev :
  forall (x:complex) (y:complex) (n:Z), (0%Z <= n)%Z -> ~ (y = c_zero) ->
  ((infix_sldt (cpower x n) (cpower y n)) = (cpower (infix_sldt x y) n)).

Axiom cpower_pi_bound_square_inv :
  infix_lseqdt (infix_sldt (i_to_c 4%Z) (cpower pi 2%Z)) c_one.

Axiom cpower_mult_split :
  forall (x:complex) (y:complex) (m:Z), (0%Z <= m)%Z ->
  ((cpower (infix_asdt x y) m) = (infix_asdt (cpower x m) (cpower y m))).

Axiom not_cpower_zero :
  forall (e:complex) (i:Z), ~ (e = c_zero) -> ~ ((cpower e i) = c_zero).

Axiom cpower_inv_out :
  forall (x:complex) (y:complex), (infix_lsdt c_zero y) ->
  ((infix_asdt (cpower (infix_asdt (infix_sldt c_one (square_rt y)) x) 2%Z)
    y)
   = (cpower x 2%Z)).

Axiom squarert_inv :
  forall (x:complex), (infix_lsdt c_zero x) ->
  ((infix_sldt c_one (square_rt x)) = (square_rt (infix_sldt c_one x))).

Axiom squarert_inv_rev :
  forall (x:complex), (infix_lsdt c_zero x) ->
  ((square_rt (infix_sldt c_one x)) = (infix_sldt c_one (square_rt x))).

Axiom cpower_squarert_two :
  forall (i:Z), (0%Z <= i)%Z ->
  ((cpower (square_rt (infix_pldt c_one c_one)) i) =
   (square_rt (i_to_c (power_ 2%Z i)))).

Axiom cpower_square_rt_raise :
  forall (x:complex) (y:complex), (infix_lsdt c_zero y) ->
  ((cpower (infix_sldt x (square_rt y)) 2%Z) =
   (infix_sldt (infix_asdt (cpower x 2%Z) c_one) y)).

Axiom cpower_subst :
  forall (x:complex) (n:Z) (m:Z), ~ (x = c_zero) ->
  ((infix_asdt (infix_sldt c_one (cpower x n)) (cpower x m)) =
   (cpower x (m - n)%Z)).

Axiom cpower_c_one_pos :
  forall (m:Z), (0%Z <= m)%Z -> ((cpower c_one m) = c_one).

Axiom mult_cpower :
  forall (x:complex) (x':complex) (i:Z), (0%Z <= i)%Z ->
  ((infix_asdt (cpower x i) (cpower x' i)) = (cpower (infix_asdt x x') i)).

Axiom mult_cpower_rev :
  forall (x:complex) (x':complex) (i:Z), (0%Z <= i)%Z ->
  ((cpower (infix_asdt x x') i) = (infix_asdt (cpower x i) (cpower x' i))).

Axiom cpower_iterate :
  forall (e:complex) (i:Z), (0%Z <= i)%Z ->
  ((cpower e i) =
   (int_iterate (fun (y0:complex) (y1:complex) => (infix_asdt y0 y1))
    ((fun (y0:complex) (y1:Z) => y0) e) 0%Z i)).

Axiom cpower_modulus :
  forall (x:complex) (n:Z), (0%Z <= n)%Z ->
  ((modulus (cpower x n)) = (cpower (modulus x) n)) /\
  (((0%Z < n)%Z -> (infix_lsdt (modulus x) c_one) ->
    infix_lsdt (modulus (cpower x n)) c_one) /\
   (((0%Z < n)%Z -> ((modulus x) = c_one) ->
     ((modulus (cpower x n)) = c_one)) /\
    (((0%Z < n)%Z -> (infix_gtdt (modulus x) c_one) ->
      infix_gtdt (modulus (cpower x n)) c_one) /\
     (((0%Z < n)%Z -> (infix_lsdt (modulus (cpower x n)) c_one) ->
       infix_lsdt (modulus x) c_one) /\
      (((0%Z < n)%Z -> ((modulus (cpower x n)) = c_one) ->
        ((modulus x) = c_one)) /\
       ((0%Z < n)%Z -> (infix_gtdt (modulus (cpower x n)) c_one) ->
        infix_gtdt (modulus x) c_one)))))).

Axiom cpower_mult_pre :
  forall (x:complex) (n:Z) (m:Z), (0%Z <= m)%Z ->
  ((cpower x (n * m)%Z) = (cpower (cpower x n) m)).

Axiom cpower_mult :
  forall (x:complex) (n:Z) (m:Z),
  ((cpower x (n * m)%Z) = (cpower (cpower x n) m)).

Axiom cpower_mult_rev :
  forall (x:complex) (n:Z) (m:Z),
  ((cpower (cpower x n) m) = (cpower x (n * m)%Z)).

Axiom non_zero_cpower_pos :
  forall (i:complex) (n:Z), ~ (i = c_zero) -> (0%Z <= n)%Z ->
  ~ ((cpower i n) = c_zero).

Axiom inv_cpower_ :
  forall (e:complex) (i:Z), ~ (e = c_zero) ->
  ((infix_sldt c_one (cpower e i)) = (cpower e (-i)%Z)).

Axiom zero_cpower_pos :
  forall (n:Z), (0%Z < n)%Z -> ((cpower c_zero n) = c_zero).

Axiom zero_cpower :
  forall (n:Z), ~ (n = 0%Z) -> ((cpower c_zero n) = c_zero).

Axiom non_zero_cpower :
  forall (i:complex) (n:Z), ~ (i = c_zero) -> ~ ((cpower i n) = c_zero).

Axiom real_cpower_pos :
  forall (elt:complex) (i:Z), (real_ elt) -> (0%Z <= i)%Z ->
  real_ (cpower elt i).

Axiom real_cpower :
  forall (elt:complex) (i:Z), (real_ elt) -> real_ (cpower elt i).

Axiom real_cpower_is_pos :
  forall (elt:complex) (i:Z), (real_ elt) -> (infix_lseqdt c_zero elt) ->
  (0%Z <= i)%Z -> infix_lseqdt c_zero (cpower elt i).

Axiom real_cpower_is_strict_pos :
  forall (elt:complex) (i:Z), (real_ elt) -> (infix_lsdt c_zero elt) ->
  (0%Z <= i)%Z -> infix_lsdt c_zero (cpower elt i).

Axiom real_modulus_square :
  forall (x:complex), (real_ x) ->
  ((cpower (modulus x) 2%Z) = (cpower x 2%Z)).

Axiom real_modulus_pos :
  forall (x:complex), (real_ x) -> (infix_lseqdt c_zero x) ->
  ((modulus x) = x).

(* Why3 assumption *)
Definition conjugate (i:complex) : complex :=
  infix_mndt (t_real_part i) (infix_asdt im (t_im_part i)).

Axiom real_part_conjugate :
  forall (i:complex), ((t_real_part (conjugate i)) = (t_real_part i)).

Axiom im_part_conjugate :
  forall (i:complex),
  ((t_im_part (conjugate i)) = (prefix_mndt (t_im_part i))).

Axiom invol_conjugate : forall (i:complex), ((conjugate (conjugate i)) = i).

Axiom add_conjugate :
  forall (i:complex) (j:complex),
  ((conjugate (infix_pldt i j)) = (infix_pldt (conjugate i) (conjugate j))).

Axiom add_own_conjugate :
  forall (i:complex),
  ((infix_pldt i (conjugate i)) =
   (infix_asdt (infix_pldt c_one c_one) (t_real_part i))).

Axiom itself_times_conjugate :
  forall (i:complex),
  (real_ (infix_asdt i (conjugate i))) /\
  ((infix_asdt i (conjugate i)) =
   (infix_pldt (infix_asdt (t_real_part i) (t_real_part i))
    (infix_asdt (t_im_part i) (t_im_part i)))).

Axiom conjugate_to_modulus :
  forall (i:complex),
  ((modulus i) = (square_rt (infix_asdt i (conjugate i)))).

Axiom conjugate_times_itself_pos :
  forall (i:complex), infix_lseqdt c_zero (infix_asdt i (conjugate i)).

Axiom sum_conjugate :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex),
  ((conjugate (sum s f)) = (sum s (fun (x:a) => (conjugate (f x))))).

Axiom conjugate_module_one :
  forall (i:complex), ((modulus i) = c_one) -> ((conjugate i) = (inv i)).

Axiom conjugate_module_one_rev :
  forall (i:complex), ~ (i = c_zero) -> ((conjugate i) = (inv i)) ->
  ((modulus i) = c_one).

Axiom conjugate_real : forall (i:complex), (real_ i) -> ((conjugate i) = i).

Axiom conjugate_real_gen :
  forall (i:complex), (real_ i) -> ((conjugate i) = i).

Axiom conjugate_one :
  forall (x:complex), (x = c_one) -> ((conjugate x) = c_one).

Axiom conjugate_c_zero :
  forall (x:complex), (x = c_zero) -> ((conjugate x) = c_zero).

Parameter result4:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def4 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t:a -> im1) (e:a),
  (((result4 op1 t) e) = true) <-> ~ (neutral op1 (t e)).

(* Why3 assumption *)
Definition nonn_part1 {a:Type} {a_WT:WhyType a}
    {im1:Type} {im1_WT:WhyType im1} (op1:im1 -> im1 -> im1) (s:set a)
    (t:a -> im1) : set a :=
  filter (result4 op1 t) s.

Axiom nonn_part_spec1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), forall (e:a),
  (mem e (nonn_part1 op1 s t)) <-> ((mem e s) /\ ~ (neutral op1 (t e))).

Parameter result5:
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  (im1 -> im1 -> im1) -> (a -> im1) -> a -> bool.

Axiom result_def5 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (t:a -> im1) (e:a),
  (((result5 op1 t) e) = true) <-> (neutral op1 (t e)).

(* Why3 assumption *)
Definition n_part1 {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1}
    (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1) : set a :=
  filter (result5 op1 t) s.

Axiom n_part_spec1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), forall (e:a),
  (mem e (n_part1 op1 s t)) <-> ((mem e s) /\ (neutral op1 (t e))).

Axiom nullity_partition1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), (commut op1) ->
  (s = (union (nonn_part1 op1 s t) (n_part1 op1 s t))) /\
  ((inter (nonn_part1 op1 s t) (n_part1 op1 s t)) = (empty : set a)).

Axiom iterate_neutral1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), (iterable op1) ->
  (commut op1) ->
  (forall (a1:a), (mem a1 s) -> ((t a1) = (neutral_elt op1))) ->
  ((iterate op1 s t) = (neutral_elt op1)).

Axiom iterate_nullity_partition1 :
  forall {a:Type} {a_WT:WhyType a} {im1:Type} {im1_WT:WhyType im1},
  forall (op1:im1 -> im1 -> im1) (s:set a) (t:a -> im1), (iterable op1) ->
  (commut op1) -> ((iterate op1 s t) = (iterate op1 (nonn_part1 op1 s t) t)).

Parameter indic: forall {a:Type} {a_WT:WhyType a}, a -> a -> complex.

Axiom indic_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((infix_eqeq1 a1 a') -> ((indic a1 a') = c_one)) /\
  (~ (infix_eqeq1 a1 a') -> ((indic a1 a') = c_zero)).

Axiom indic_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic a1 a') = c_one)) /\
  (~ (a1 = a') -> ((indic a1 a') = c_zero)).

Axiom get_indic :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic a1 a') = c_one)) /\
  (~ (a1 = a') -> ((indic a1 a') = c_zero)).

Parameter indic_bool: forall {a:Type} {a_WT:WhyType a}, a -> a -> bool.

Axiom indic_bool_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((infix_eqeq1 a1 a') -> ((indic_bool a1 a') = true)) /\
  (~ (infix_eqeq1 a1 a') -> ((indic_bool a1 a') = false)).

Axiom indic_bool_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a),
  ((a1 = a') -> ((indic_bool a1 a') = true)) /\
  (~ (a1 = a') -> ((indic_bool a1 a') = false)).

Axiom indic_comm :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (a':a), ((indic a1 a') = (indic a' a1)).

Axiom indic_transl_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a) (c:a), (b = c) -> ((indic a1 b) = (indic a1 c)).

Axiom indic_transl_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:a) (b:a) (c:a), (b = c) -> ((indic b a1) = (indic c a1)).

Parameter indic_2:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, a -> a -> b ->
  b -> complex.

Axiom indic_2_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((((indic_bool a1 a') = true) /\ ((indic_bool b1 b') = true)) ->
   ((indic_2 a1 a' b1 b') = c_one)) /\
  (~ (((indic_bool a1 a') = true) /\ ((indic_bool b1 b') = true)) ->
   ((indic_2 a1 a' b1 b') = c_zero)).

Axiom indic_2_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (infix_asdt (indic a1 a') (indic b1 b'))) /\
  ((indic_2 a1 a' b1 b') = (indic (a1, b1) (a', b'))).

Axiom indic_2_if :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (i:a) (k:a) (j:b) (l:b),
  (((i = k) /\ (j = l)) -> ((indic_2 i k j l) = c_one)) /\
  (~ ((i = k) /\ (j = l)) -> ((indic_2 i k j l) = c_zero)).

Axiom indic_2_comm :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (a1:a) (a':a) (b1:b) (b':b),
  ((indic_2 a1 a' b1 b') = (indic_2 a' a1 b1 b')) /\
  (((indic_2 a1 a' b1 b') = (indic_2 a1 a' b' b1)) /\
   ((indic_2 a1 a' b1 b') = (indic_2 a' a1 b' b1))).

(* Why3 assumption *)
Definition sum_indic {a:Type} {a_WT:WhyType a} (s:set a) (t:a -> complex)
    (i:a) : complex :=
  sum s (fun (e:a) => (infix_asdt (t e) (indic i e))).

Parameter bool_to_c: bool -> complex.

Axiom bool_to_c_def :
  forall (a:bool),
  ((a = true) -> ((bool_to_c a) = c_one)) /\
  (~ (a = true) -> ((bool_to_c a) = c_zero)).

Parameter ind_sum_indic: (Z -> complex) -> Z -> Z -> Z -> complex.

Axiom ind_sum_indic_def :
  forall (t:Z -> complex) (l:Z) (h:Z) (i:Z), (l < h)%Z ->
  ((ind_sum_indic t l h i) =
   (ind_sum (fun (e:Z) => (infix_asdt (t e) (indic i e))) l h)).

Axiom ind_sum_indic_spec :
  forall (t:Z -> complex) (l:Z) (h:Z) (i:Z), (l < h)%Z ->
  ((ind_sum_indic t l h i) = (sum_indic (to_fset l h) t i)).

Axiom sum_indic_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex) (i:a), (mem i s) ->
  ((sum_indic s t i) = (t i)).

Axiom sum_indic_ts :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (t:a -> complex) (i:a), (mem i s) ->
  ((sum s (fun (e:a) => (infix_asdt (t e) (indic i e)))) = (t i)).

Axiom ind_sum_indic_t :
  forall (t:Z -> complex) (l:Z) (h:Z) (i:Z), ((l <= i)%Z /\ (i < h)%Z) ->
  ((ind_sum_indic t l h i) = (t i)) /\
  ((ind_sum (fun (e:Z) => (infix_asdt (t e) (indic i e))) l h) = (t i)).

Axiom ind_sum_indic_t_quant :
  forall (t:Z -> complex) (l:Z) (h:Z), forall (i:Z),
  ((l <= i)%Z /\ (i < h)%Z) ->
  ((ind_sum (fun (e:Z) => (infix_asdt (t e) (indic i e))) l h) = (t i)).

Axiom conjugate_indic :
  forall {a:Type} {a_WT:WhyType a},
  forall (i:a) (j:a), ((conjugate (indic i j)) = (indic i j)).

Axiom conjugate_indic_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (i:a) (j:a), ((indic i j) = (conjugate (indic i j))).

Axiom conjugate_indic_gen_int :
  forall (i:Z) (j:Z), ((conjugate (indic i j)) = (indic i j)).

Axiom conjugate_pure_im :
  forall (i:complex), (pure_im_ i) -> ((conjugate i) = (prefix_mndt i)).

Axiom conjugate_im : ((conjugate im) = (prefix_mndt im)).

Axiom conjugate_value :
  forall (c:complex) (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (c = (infix_pldt a (infix_asdt im b))) ->
  ((conjugate c) = (infix_mndt a (infix_asdt im b))).

Axiom conjugate_minus_value :
  forall (c:complex) (a:complex) (b:complex), (real_ a) -> (real_ b) ->
  (c = (infix_mndt a (infix_asdt im b))) ->
  ((conjugate c) = (infix_pldt a (infix_asdt im b))).

Axiom prod_conjugate :
  forall (a:complex) (b:complex),
  ((infix_asdt a (conjugate b)) =
   (infix_pldt
    (infix_pldt (infix_asdt (t_real_part a) (t_real_part b))
     (infix_asdt (t_im_part a) (t_im_part b)))
    (infix_asdt im
     (infix_mndt (infix_asdt (t_real_part b) (t_im_part a))
      (infix_asdt (t_im_part b) (t_real_part a)))))).

Axiom mult_conjugate :
  forall (a:complex) (b:complex),
  ((conjugate (infix_asdt a b)) = (infix_asdt (conjugate a) (conjugate b))).

Axiom conjugate_prod :
  forall (a:complex) (b:complex),
  ((infix_asdt (conjugate a) b) =
   (infix_pldt
    (infix_pldt (infix_asdt (t_real_part a) (t_real_part b))
     (infix_asdt (t_im_part a) (t_im_part b)))
    (infix_asdt im
     (infix_mndt (infix_asdt (t_real_part a) (t_im_part b))
      (infix_asdt (t_real_part b) (t_im_part a)))))).

Axiom conj_conj_prod :
  forall (a:complex) (b:complex),
  ((conjugate (infix_asdt (conjugate a) b)) = (infix_asdt a (conjugate b))).

Axiom conj_prod_conj :
  forall (a:complex) (b:complex),
  ((conjugate (infix_asdt a (conjugate b))) = (infix_asdt (conjugate a) b)).

Axiom itself_prod_conjugate_modulus_one :
  forall (a:complex), ((modulus a) = c_one) ->
  ((infix_asdt a (conjugate a)) = c_one).

Axiom conjugate_prod_itself_modulus_one :
  forall (a:complex), ((modulus a) = c_one) ->
  ((infix_asdt a (conjugate a)) = c_one).

Axiom modulus_opposite :
  forall (a:complex), (real_ a) -> (infix_lseqdt c_zero a) ->
  ((modulus a) = (modulus (prefix_mndt a))).

Axiom modulus_conjugate :
  forall (a:complex), ((modulus a) = (modulus (conjugate a))).

Axiom modulus_pos1 :
  forall (a:complex), (real_ a) -> (infix_lseqdt c_zero a) ->
  ((modulus a) = a).

Axiom modulus_neg :
  forall (a:complex), (real_ a) -> (infix_lseqdt a c_zero) ->
  ((modulus a) = (prefix_mndt a)).

Axiom inv_rewrite :
  forall (x:complex), ~ (x = c_zero) ->
  ((infix_sldt c_one x) =
   (infix_sldt (conjugate x) (cpower (modulus x) 2%Z))) /\
  ((infix_sldt c_one x) =
   (infix_asdt (conjugate x) (infix_sldt c_one (cpower (modulus x) 2%Z)))).

Axiom inv_modulus :
  forall (x:complex), ~ (x = c_zero) ->
  ((modulus (infix_sldt c_one x)) = (infix_sldt c_one (modulus x))).

Axiom div_modulus :
  forall (x:complex) (y:complex), ~ (x = c_zero) ->
  ((modulus (infix_sldt y x)) = (infix_sldt (modulus y) (modulus x))).

Axiom square_frac_modulus :
  forall (x:complex) (y:complex), ~ (y = c_zero) ->
  ((cpower (modulus (infix_sldt x y)) 2%Z) =
   (infix_sldt (cpower (modulus x) 2%Z) (cpower (modulus y) 2%Z))).

Axiom extract_2_sq_modulus :
  forall (x:complex) (y:complex) (a:complex), ~ (a = c_zero) ->
  ~ (y = c_zero) ->
  ((infix_sldt (cpower (modulus x) 2%Z) (cpower (modulus y) 2%Z)) =
   (infix_sldt (infix_asdt a (cpower (modulus x) 2%Z))
    (infix_asdt a (cpower (modulus y) 2%Z)))).

Axiom cpower_2_modulus_simpl :
  forall (x:complex) (y:complex) (z:complex), ~ (x = c_zero) ->
  ~ (y = c_zero) -> ~ (z = c_zero) ->
  ((infix_sldt (cpower (modulus (infix_asdt x y)) 2%Z)
    (cpower (modulus (infix_asdt z y)) 2%Z))
   = (infix_sldt (cpower (modulus x) 2%Z) (cpower (modulus z) 2%Z))).

Axiom cpower_div_leq_one :
  forall (a:complex) (b:complex) (i:Z),
  ((infix_lseqdt c_zero a) /\ (infix_lseqdt a b)) -> (infix_lsdt c_zero b) ->
  (0%Z <= i)%Z ->
  (infix_lseqdt c_zero (infix_sldt (cpower a i) (cpower b i))) /\
  (infix_lseqdt (infix_sldt (cpower a i) (cpower b i)) c_one).

Axiom cpower_cpower :
  forall (x:complex) (a:Z) (b:Z),
  ((cpower (cpower x a) b) = (cpower x (a * b)%Z)).

Axiom pre_cond_int_ :
  forall (a:complex) (b:complex) (c:complex), (infix_lsdt a b) ->
  (infix_lsdt c_zero c) -> infix_lsdt (infix_asdt a c) (infix_asdt b c).

Axiom growing_mult1 :
  forall (n:complex) (m:complex), (infix_lseqdt c_zero n) ->
  (infix_lseqdt c_one m) -> infix_lseqdt n (infix_asdt n m).

Axiom strict_growing_mult_pos :
  forall (n:complex) (m:complex), (infix_lsdt c_one n) ->
  (infix_lsdt c_one m) -> infix_lsdt n (infix_asdt n m).

Axiom init_exp1 :
  forall (k:complex),
  ((cpower k 0%Z) = c_one) /\
  (((cpower k 1%Z) = k) /\ ((cpower k 2%Z) = (infix_asdt k k))).

Axiom int_exp_pos :
  forall (k:complex) (n:Z), (infix_lseqdt c_one k) -> (0%Z <= n)%Z ->
  (infix_lseqdt c_one (cpower k n)) /\
  ((infix_gtdt (cpower k n) c_zero) /\
   (infix_lseqdt (cpower k n) (cpower k (n + 1%Z)%Z))).

Axiom strict_int_exp_pos :
  forall (k:complex) (n:Z), (infix_lsdt c_one k) -> (0%Z < n)%Z ->
  (infix_gtdt (cpower k n) c_one) /\
  ((infix_lsdt (cpower k (n - 1%Z)%Z) (cpower k n)) /\
   (infix_lsdt (cpower k n) (cpower k (n + 1%Z)%Z))).

Axiom strict_int_exp_neg :
  forall (k:complex) (n:Z), (infix_lsdt c_one k) -> (n < 0%Z)%Z ->
  (infix_lsdt (cpower k n) c_one) /\
  ((infix_lsdt (cpower k (n - 1%Z)%Z) (cpower k n)) /\
   (infix_lsdt (cpower k n) (cpower k (n + 1%Z)%Z))).

Axiom int_exp_neg :
  forall (k:complex) (n:Z), (infix_lseqdt c_one k) -> (n < 0%Z)%Z ->
  (infix_lseqdt (cpower k n) c_one) /\
  ((infix_gtdt (cpower k n) c_zero) /\
   (infix_lseqdt (cpower k n) (cpower k (n + 1%Z)%Z))).

Axiom positive_exp :
  forall (k:complex) (m:Z), (infix_lseqdt c_one k) ->
  infix_lsdt c_zero (cpower k m).

Axiom growing_exp_pos :
  forall (k:complex) (m:Z) (n:Z), (infix_lseqdt c_one k) ->
  ((0%Z <= m)%Z /\ (m <= n)%Z) -> infix_lseqdt (cpower k m) (cpower k n).

Axiom growing_exp1 :
  forall (k:complex) (m:Z) (n:Z), (infix_lseqdt c_one k) -> (m <= n)%Z ->
  infix_lseqdt (cpower k m) (cpower k n).

Axiom growing_exp_arg :
  forall (k:complex) (k':complex) (n:Z),
  ((infix_lseqdt c_zero k) /\ (infix_lseqdt k k')) -> (0%Z <= n)%Z ->
  infix_lseqdt (cpower k n) (cpower k' n).

Axiom strict_growing_exp1 :
  forall (k:complex) (m:Z) (n:Z), (infix_lsdt c_one k) -> (m < n)%Z ->
  infix_lsdt (cpower k m) (cpower k n).

Axiom cpower_comm_pos :
  forall (x:complex) (y:complex) (n:Z), (infix_lseqdt c_one x) ->
  (infix_lseqdt c_one y) -> (0%Z <= n)%Z ->
  ((cpower (infix_asdt x y) n) = (infix_asdt (cpower x n) (cpower y n))).

Axiom cpower_comm :
  forall (x:complex) (y:complex) (n:Z), (infix_lseqdt c_one x) ->
  (infix_lseqdt c_one y) ->
  ((cpower (infix_asdt x y) n) = (infix_asdt (cpower x n) (cpower y n))).

Axiom unicity_exp1 :
  forall (k:complex) (m:Z) (n:Z), (infix_lsdt c_one k) ->
  ((cpower k m) = (cpower k n)) <-> (m = n).

Axiom cpower_i_to_c :
  forall (a:Z) (b:Z), (0%Z <= b)%Z ->
  ((i_to_c (power_ a b)) = (cpower (i_to_c a) b)).

Axiom cpower_i_to_c_rev :
  forall (a:Z) (b:Z), (0%Z <= b)%Z ->
  ((cpower (i_to_c a) b) = (i_to_c (power_ a b))).

Axiom geometric_series :
  forall (a:complex) (q:complex) (n:Z), (1%Z <= n)%Z -> ~ (c_one = q) ->
  ((sum (to_fset 0%Z n) (fun (i:Z) => (infix_asdt a (cpower q i)))) =
   (infix_sldt (infix_asdt a (infix_mndt c_one (cpower q n)))
    (infix_mndt c_one q))).

Axiom ind_geometric_series_r :
  forall (a:complex) (q:complex) (n:Z), (1%Z <= n)%Z -> ~ (c_one = q) ->
  ((ind_sum (fun (i:Z) => (infix_asdt a (cpower q i))) 0%Z n) =
   (infix_sldt (infix_asdt a (infix_mndt c_one (cpower q n)))
    (infix_mndt c_one q))).

Axiom ind_geometric_series :
  forall (q:complex) (n:Z), (1%Z <= n)%Z -> ~ (c_one = q) ->
  ((ind_sum (fun (i:Z) => (cpower q i)) 0%Z n) =
   (infix_sldt (infix_mndt c_one (cpower q n)) (infix_mndt c_one q))).

Axiom geometric_series_init_one :
  forall (q:complex) (n:Z), (1%Z <= n)%Z -> ~ (c_one = q) ->
  ((sum (to_fset 0%Z n) (fun (i:Z) => (cpower q i))) =
   (infix_sldt (infix_mndt c_one (cpower q n)) (infix_mndt c_one q))).

Axiom geometric_series_c_one :
  forall (a:complex) (q:complex) (n:Z), (1%Z <= n)%Z -> (q = c_one) ->
  ((sum (to_fset 0%Z n) (fun (i:Z) => (infix_asdt a (cpower q i)))) =
   (infix_asdt a (i_to_c n))).

Axiom geometric_series_c_one_init_one :
  forall (q:complex) (n:Z), (1%Z <= n)%Z -> (q = c_one) ->
  ((sum (to_fset 0%Z n) (fun (i:Z) => (cpower q i))) = (i_to_c n)).

Axiom positive_cpower_2 :
  forall (x:complex), (real_ x) -> ~ (c_zero = x) ->
  infix_lsdt c_zero (cpower x 2%Z).

Axiom positive_cpower_2_mod :
  forall (x:complex), infix_lseqdt c_zero (cpower (modulus x) 2%Z).

Axiom cpower_2_mod_non_null :
  forall (x:complex), ~ (x = c_zero) ->
  infix_lsdt c_zero (cpower (modulus x) 2%Z).

Axiom cpower_2_mod_mult_non_null :
  forall (x:complex) (y:complex), ~ (x = c_zero) -> ~ (y = c_zero) ->
  infix_lsdt c_zero (cpower (modulus x) 2%Z).

Axiom growing_cpower_2 :
  forall (x:complex) (y:complex),
  ((infix_lseqdt c_zero x) /\ (infix_lseqdt x y)) ->
  infix_lseqdt (cpower x 2%Z) (cpower y 2%Z).

Axiom cpower_incr_power_2 :
  forall (k:Z), (0%Z <= k)%Z ->
  ((cpower (i_to_c (power_ 2%Z k)) 2%Z) = (i_to_c (power_ 2%Z (2%Z * k)%Z))).

Axiom cpower_modulus_incr_power_2 :
  forall (k:Z), (0%Z <= k)%Z ->
  ((cpower (modulus (i_to_c (power_ 2%Z k))) 2%Z) =
   (i_to_c (power_ 2%Z (2%Z * k)%Z))).

Axiom cpower_modulus_supeq :
  forall (x:complex) (y:complex) (i:Z), (1%Z <= i)%Z ->
  (infix_lseqdt (modulus y) (modulus x)) ->
  infix_lseqdt (cpower (modulus y) i) (cpower (modulus x) i).

Axiom cpower_modulus_div_simpl :
  forall (x:complex) (y:complex) (z:complex) (i:Z), (1%Z <= i)%Z ->
  (infix_lseqdt c_zero x) -> (infix_lsdt c_zero y) ->
  (infix_lsdt c_zero z) ->
  ((infix_sldt (cpower x i) (cpower y i)) =
   (infix_sldt (cpower (modulus (infix_asdt x z)) i)
    (cpower (modulus (infix_asdt y z)) i))).

Axiom cpower_two_modulus_div_simpl :
  forall (x:complex) (y:complex) (z:complex), (real_ x) -> (real_ y) ->
  (real_ z) -> ~ (c_zero = y) -> ~ (c_zero = z) ->
  ((infix_sldt (cpower x 2%Z) (cpower y 2%Z)) =
   (infix_sldt (cpower (modulus (infix_asdt x z)) 2%Z)
    (cpower (modulus (infix_asdt y z)) 2%Z))).

Parameter exp: complex -> complex.

Axiom e_mod : forall (x:complex), ((modulus (exp x)) = c_one).

Axiom e_diff_c_zero : forall (x:complex), ~ ((exp x) = c_zero).

Axiom Exp_one : real_ (exp c_one).

Axiom Exp_zero : ((exp c_zero) = c_one).

Axiom Exp_sum :
  forall (x:complex) (y:complex),
  ((exp (infix_pldt x y)) = (infix_asdt (exp x) (exp y))).

Axiom exp_one : real_ (exp c_one).

Axiom Exp_quarter_pi :
  ((exp (infix_sldt (infix_asdt im pi) (i_to_c 4%Z))) =
   (infix_pldt
    (infix_sldt (square_rt (infix_pldt c_one c_one))
     (infix_pldt c_one c_one))
    (infix_asdt im
     (infix_sldt (square_rt (infix_pldt c_one c_one))
      (infix_pldt c_one c_one))))).

Axiom exp_sum :
  forall (x:complex) (y:complex),
  ((exp (infix_pldt x y)) = (infix_asdt (exp x) (exp y))).

Axiom exp_eq :
  forall (t1:complex) (t2:complex), (t1 = t2) -> ((exp t1) = (exp t2)).

Axiom exp_sum_rev :
  forall (x:complex) (y:complex),
  ((infix_asdt (exp x) (exp y)) = (exp (infix_pldt x y))).

Axiom exp_inv :
  forall (i:complex), ~ ((exp i) = c_zero) ->
  ((exp (prefix_mndt i)) = (infix_sldt c_one (exp i))).

Axiom exp_inv_rev :
  forall (i:complex), ~ ((exp i) = c_zero) ->
  ((infix_sldt c_one (exp i)) = (exp (prefix_mndt i))).

Axiom exp_mult_pre :
  forall (x:complex) (y:Z), (0%Z <= y)%Z ->
  ((exp (infix_asdt x (i_to_c y))) = (cpower (exp x) y)).

Axiom exp_mult :
  forall (x:complex) (y:Z),
  ((exp (infix_asdt x (i_to_c y))) = (cpower (exp x) y)).

Axiom cpower_to_exp :
  forall (x:complex) (y:Z),
  ((cpower (exp x) y) = (exp (infix_asdt x (i_to_c y)))).

Axiom exp_h_pi :
  ((exp (infix_sldt (infix_asdt im pi) (infix_pldt c_one c_one))) = im).

Axiom exp_pi : ((exp (infix_asdt im pi)) = (prefix_mndt c_one)).

Axiom exp_two_pi :
  ((exp (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))) = c_one).

Axiom exp_two_pi_mul :
  forall (k:Z),
  ((exp
    (infix_asdt (i_to_c k)
     (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))))
   = c_one).

Axiom exp_two_pi_mul_den :
  forall (k:Z) (l:Z), ~ (k = 0%Z) ->
  ((exp
    (infix_sldt
     (infix_asdt (i_to_c (k * l)%Z)
      (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one)))
     (i_to_c k)))
   = c_one).

Axiom exp_two_pi_mul_den_add :
  forall (k:Z) (l:Z) (m:Z),
  ((exp
    (infix_asdt (i_to_c ((k * m)%Z + l)%Z)
     (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))))
   =
   (exp
    (infix_asdt (i_to_c l)
     (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))))).

Axiom angle : Type.
Parameter angle_WhyType : WhyType angle.
Existing Instance angle_WhyType.

Parameter ang_inv: angle -> angle.

Parameter ang_add: angle -> angle -> angle.

Parameter ang_meas: angle -> complex.

Axiom ang_meas_spec :
  forall (o:angle),
  (infix_lseqdt c_zero (ang_meas o)) /\ (infix_lsdt (ang_meas o) c_one).

Axiom real_ang_meas : forall (o:angle), real_ (ang_meas o).

Parameter real_to_ang: complex -> angle.

Parameter ang_zero: angle.

Axiom Assoc2 :
  forall (x:angle) (y:angle) (z:angle),
  ((ang_add (ang_add x y) z) = (ang_add x (ang_add y z))).

Axiom Unit_def_l1 : forall (x:angle), ((ang_add ang_zero x) = x).

Axiom Unit_def_r1 : forall (x:angle), ((ang_add x ang_zero) = x).

Axiom Inv_def_l1 : forall (x:angle), ((ang_add (ang_inv x) x) = ang_zero).

Axiom Inv_def_r1 : forall (x:angle), ((ang_add x (ang_inv x)) = ang_zero).

Axiom Comm2 : forall (x:angle) (y:angle), ((ang_add x y) = (ang_add y x)).

Axiom Real_To_Ang_one :
  forall (phi:complex), (real_ phi) -> ((real_to_ang c_one) = ang_zero).

Axiom Real_To_Ang_inv :
  forall (phi:complex), (real_ phi) ->
  ((ang_inv (real_to_ang phi)) = (real_to_ang (prefix_mndt phi))).

Axiom Real_To_Ang_add :
  forall (phi:complex) (phi':complex), (real_ phi) -> (real_ phi') ->
  ((ang_add (real_to_ang phi) (real_to_ang phi')) =
   (real_to_ang (infix_pldt phi phi'))).

Axiom meas_value :
  forall (phi:complex), (real_ phi) ->
  ((infix_lseqdt c_zero phi) /\ (infix_lsdt phi c_one)) ->
  ((ang_meas (real_to_ang phi)) = phi).

Axiom Equal_angle :
  forall (o:angle) (o':angle),
  ((exp
    (infix_asdt (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))
     (ang_meas o)))
   =
   (exp
    (infix_asdt (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))
     (ang_meas o')))) <->
  (o = o').

Axiom set_equal_angle_meas :
  forall (o:angle) (o':angle), (o = o') -> ((ang_meas o) = (ang_meas o')).

Axiom get_equal_angle_meas :
  forall (o:angle) (o':angle), ((ang_meas o) = (ang_meas o')) -> (o = o').

Axiom meas_real_to_ang : forall (o:angle), ((real_to_ang (ang_meas o)) = o).

Axiom meas_real_to_ang_rev :
  forall (o:angle), (o = (real_to_ang (ang_meas o))).

Axiom ang_add_rev :
  forall (o:angle) (o':angle), ((ang_add o o') = (ang_add o' o)).

Axiom real_to_ang_zero : ((real_to_ang c_zero) = ang_zero).

(* Why3 assumption *)
Definition ang_exp (o:angle) : complex :=
  exp
  (infix_asdt (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))
   (ang_meas o)).

Axiom ang_exp_spec : forall (o:angle), ~ ((ang_exp o) = c_zero).

Axiom set_equal_angle_exp :
  forall (o:angle) (o':angle), (o = o') -> ((ang_exp o) = (ang_exp o')).

Axiom get_equal_angle_exp :
  forall (o:angle) (o':angle), ((ang_exp o) = (ang_exp o')) -> (o = o').

Axiom meas_value_plus_one :
  forall (phi:complex), (real_ phi) ->
  ((exp
    (infix_asdt (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))
     (ang_meas (real_to_ang phi))))
   =
   (exp
    (infix_asdt (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one))
     (infix_pldt (ang_meas (real_to_ang phi)) c_one)))).

Axiom ang_exp_pi_over_four :
  ((ang_exp (real_to_ang (infix_sldt c_one (i_to_c 8%Z)))) =
   (infix_pldt
    (infix_sldt (square_rt (infix_pldt c_one c_one))
     (infix_pldt c_one c_one))
    (infix_asdt im
     (infix_sldt (square_rt (infix_pldt c_one c_one))
      (infix_pldt c_one c_one))))).

Axiom ang_exp_pi_over_two :
  ((ang_exp (real_to_ang (infix_sldt c_one (i_to_c 4%Z)))) = im).

Axiom ang_exp_pi :
  ((ang_exp (real_to_ang (infix_sldt c_one (i_to_c 2%Z)))) =
   (prefix_mndt c_one)).

Axiom real_to_ang_c_one : ((real_to_ang c_one) = ang_zero).

Axiom set_ang_meas_eq :
  forall (o:angle) (o':angle), (o = o') -> ((ang_meas o) = (ang_meas o')).

Axiom get_ang_meas_eq :
  forall (o:angle) (o':angle), ((ang_meas o) = (ang_meas o')) -> (o = o').

Axiom ang_exp_zero : ((ang_exp ang_zero) = c_one).

Axiom ang_exp_two_pi : ((ang_exp (real_to_ang (i_to_c 1%Z))) = c_one).

Axiom ang_exp_c_one : ((ang_exp (real_to_ang c_one)) = c_one).

Axiom ang_meas_add_inf_c_one :
  forall (o:angle) (o':angle),
  (infix_lsdt (infix_pldt (ang_meas o) (ang_meas o')) c_one) ->
  ((ang_meas (ang_add o o')) = (infix_pldt (ang_meas o) (ang_meas o'))).

Axiom set_ang_exp_eq :
  forall (o:angle) (o':angle), (o = o') -> ((ang_exp o) = (ang_exp o')).

Axiom get_ang_exp_meas_eq :
  forall (o:angle) (o':angle), ((ang_exp o) = (ang_exp o')) ->
  ((ang_meas o) = (ang_meas o')).

Axiom get_ang_exp_eq :
  forall (o:angle) (o':angle), ((ang_exp o) = (ang_exp o')) -> (o = o').

Axiom ang_meas_zero : ((ang_meas ang_zero) = c_zero).

Axiom real_to_ang_add_one :
  forall (x:complex), (real_ x) ->
  ((real_to_ang (infix_pldt x c_one)) = (real_to_ang x)).

Parameter truncate: R -> Z.

Axiom Truncate_int : forall (i:Z), ((truncate (BuiltIn.IZR i)) = i).

Axiom Truncate_down_pos :
  forall (x:R), (0%R <= x)%R ->
  ((BuiltIn.IZR (truncate x)) <= x)%R /\
  (x < (BuiltIn.IZR ((truncate x) + 1%Z)%Z))%R.

Axiom Truncate_up_neg :
  forall (x:R), (x <= 0%R)%R ->
  ((BuiltIn.IZR ((truncate x) - 1%Z)%Z) < x)%R /\
  (x <= (BuiltIn.IZR (truncate x)))%R.

Axiom Real_of_truncate :
  forall (x:R),
  ((x - 1%R)%R <= (BuiltIn.IZR (truncate x)))%R /\
  ((BuiltIn.IZR (truncate x)) <= (x + 1%R)%R)%R.

Axiom Truncate_monotonic :
  forall (x:R) (y:R), (x <= y)%R -> ((truncate x) <= (truncate y))%Z.

Axiom Truncate_monotonic_int1 :
  forall (x:R) (i:Z), (x <= (BuiltIn.IZR i))%R -> ((truncate x) <= i)%Z.

Axiom Truncate_monotonic_int2 :
  forall (x:R) (i:Z), ((BuiltIn.IZR i) <= x)%R -> (i <= (truncate x))%Z.

Parameter floor: R -> Z.

Parameter ceil: R -> Z.

Axiom Floor_int : forall (i:Z), ((floor (BuiltIn.IZR i)) = i).

Axiom Ceil_int : forall (i:Z), ((ceil (BuiltIn.IZR i)) = i).

Axiom Floor_down :
  forall (x:R),
  ((BuiltIn.IZR (floor x)) <= x)%R /\
  (x < (BuiltIn.IZR ((floor x) + 1%Z)%Z))%R.

Axiom Ceil_up :
  forall (x:R),
  ((BuiltIn.IZR ((ceil x) - 1%Z)%Z) < x)%R /\ (x <= (BuiltIn.IZR (ceil x)))%R.

Axiom Floor_monotonic :
  forall (x:R) (y:R), (x <= y)%R -> ((floor x) <= (floor y))%Z.

Axiom Ceil_monotonic :
  forall (x:R) (y:R), (x <= y)%R -> ((ceil x) <= (ceil y))%Z.

Parameter int_part: complex -> complex.

Axiom int_part_def :
  forall (x:complex), (real_ x) ->
  ((int_part x) = (i_to_c (floor (real_part x)))).

Axiom int_part_spec :
  forall (x:complex), (real_ x) ->
  (real_ (int_part x)) /\
  ((exists i:Z, ((int_part x) = (i_to_c i))) /\
   ((infix_lseqdt (int_part x) x) /\
    (infix_lsdt x (infix_pldt (int_part x) c_one)))).

Parameter int_part_int: complex -> Z.

Axiom int_part_int_def :
  forall (x:complex), (real_ x) -> ((int_part_int x) = (floor (real_part x))).

Axiom int_part_int_spec :
  forall (x:complex), (real_ x) ->
  ((i_to_c (int_part_int x)) = (int_part x)) /\
  ((infix_lseqdt (i_to_c (int_part_int x)) x) /\
   (infix_lsdt x (infix_pldt (i_to_c (int_part_int x)) c_one))).

Parameter dec_part: complex -> complex.

Axiom dec_part_def :
  forall (x:complex), (real_ x) ->
  ((dec_part x) = (infix_mndt x (int_part x))).

Axiom dec_part_spec :
  forall (x:complex), (real_ x) ->
  (real_ (dec_part x)) /\
  ((exists i:Z, ((dec_part x) = (infix_mndt x (i_to_c i)))) /\
   ((infix_lseqdt c_zero (dec_part x)) /\ (infix_lsdt (dec_part x) c_one))).

Axiom dec_part_decomp :
  forall (x:complex), (real_ x) ->
  (x = (infix_pldt (dec_part x) (int_part x))).

Axiom dec_part_decomp_rev :
  forall (x:complex), (real_ x) ->
  ((infix_pldt (dec_part x) (int_part x)) = x).

Axiom dec_part_decomp_int :
  forall (x:complex), (real_ x) ->
  (x = (infix_pldt (dec_part x) (i_to_c (int_part_int x)))).

Axiom dec_part_decomp_int_rev :
  forall (x:complex), (real_ x) ->
  ((infix_pldt (dec_part x) (i_to_c (int_part_int x))) = x).

Axiom ang_exp_add_b :
  forall (o:angle) (o':angle),
  (infix_lsdt (infix_pldt (ang_meas o) (ang_meas o')) c_one) ->
  ((ang_exp (ang_add o o')) = (infix_asdt (ang_exp o) (ang_exp o'))).

Axiom ang_exp_add_b_rev :
  forall (o:angle) (o':angle),
  (infix_lsdt (infix_pldt (ang_meas o) (ang_meas o')) c_one) ->
  ((infix_asdt (ang_exp o) (ang_exp o')) = (ang_exp (ang_add o o'))).

Axiom real_to_ang_add :
  forall (x:complex) (x':complex), (real_ x) -> (real_ x') ->
  ((real_to_ang (infix_pldt x x')) =
   (ang_add (real_to_ang x) (real_to_ang x'))).

Axiom real_to_ang_add_rev :
  forall (x:complex) (x':complex), (real_ x) -> (real_ x') ->
  ((ang_add (real_to_ang x) (real_to_ang x')) =
   (real_to_ang (infix_pldt x x'))).

Axiom ang_inv_add :
  forall (o:angle) (o':angle),
  ((ang_inv (ang_add o o')) = (ang_add (ang_inv o) (ang_inv o'))).

Axiom ang_inv_add_rev :
  forall (o:angle) (o':angle),
  ((ang_add (ang_inv o) (ang_inv o')) = (ang_inv (ang_add o o'))).

Axiom ang_exp_add_pre :
  forall (o:angle) (o':angle),
  (infix_lseqdt c_one (infix_pldt (ang_meas o) (ang_meas o'))) ->
  (infix_lseqdt (ang_meas o) (ang_meas o')) ->
  ((ang_exp (ang_add o o')) = (infix_asdt (ang_exp o) (ang_exp o'))).

Axiom ang_exp_add :
  forall (o:angle) (o':angle),
  ((ang_exp (ang_add o o')) = (infix_asdt (ang_exp o) (ang_exp o'))).

Axiom ang_meas_add :
  forall (o:angle) (o':angle),
  ((real_to_ang (ang_meas (ang_add o o'))) = (ang_add o o')).

Axiom ang_exp_add_rev :
  forall (o:angle) (o':angle),
  ((infix_asdt (ang_exp o) (ang_exp o')) = (ang_exp (ang_add o o'))).

Axiom real_to_ang_int_pre :
  forall (k:Z), (0%Z <= k)%Z -> ((ang_exp (real_to_ang (i_to_c k))) = c_one).

Axiom real_to_ang_int :
  forall (k:Z), ((ang_exp (real_to_ang (i_to_c k))) = c_one).

Axiom real_to_ang_int_ : forall (k:Z), ((real_to_ang (i_to_c k)) = ang_zero).

Axiom real_to_ang_value_add :
  forall (phi:complex) (k:Z),
  ((infix_lseqdt c_zero phi) /\ (infix_lsdt phi c_one)) ->
  ((ang_exp (real_to_ang (infix_pldt phi (i_to_c k)))) =
   (exp
    (infix_asdt (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one)) phi))).

Axiom real_to_ang_value :
  forall (phi:complex), (real_ phi) ->
  ((ang_exp (real_to_ang phi)) =
   (exp
    (infix_asdt (infix_asdt (infix_asdt im pi) (infix_pldt c_one c_one)) phi))).

Axiom ang_exp_zero_ : ((ang_exp ang_zero) = c_one).

Parameter ang_mult_int_: angle -> Z -> angle.

Axiom ang_mult_int__def :
  forall (theta:angle) (i:Z), (0%Z <= i)%Z ->
  ((i = 0%Z) -> ((ang_mult_int_ theta i) = ang_zero)) /\
  (~ (i = 0%Z) ->
   ((ang_mult_int_ theta i) =
    (ang_add (ang_mult_int_ theta (i - 1%Z)%Z) theta))).

Axiom ang_mult_int__spec :
  forall (theta:angle) (i:Z), (0%Z <= i)%Z ->
  ((ang_mult_int_ theta i) =
   (real_to_ang (infix_asdt (ang_meas theta) (i_to_c i)))).

Parameter ang_mult_int: angle -> Z -> angle.

Axiom ang_mult_int_def :
  forall (theta:angle) (i:Z),
  ((0%Z <= i)%Z -> ((ang_mult_int theta i) = (ang_mult_int_ theta i))) /\
  (~ (0%Z <= i)%Z ->
   ((ang_mult_int theta i) = (ang_inv (ang_mult_int_ theta (-i)%Z)))).

Axiom ang_mult_int_to_real_to_ang :
  forall (theta:angle) (i:Z),
  ((ang_mult_int theta i) =
   (real_to_ang (infix_asdt (ang_meas theta) (i_to_c i)))).

Axiom ang_mult_int_plus_one_pos :
  forall (theta:angle) (i:Z), (0%Z < i)%Z ->
  ((ang_mult_int theta i) = (ang_add (ang_mult_int theta (i - 1%Z)%Z) theta)).

Axiom ang_mult_int_inv :
  forall (theta:angle) (i:Z), (i < 0%Z)%Z ->
  ((ang_mult_int theta i) = (ang_inv (ang_mult_int theta (-i)%Z))).

Axiom real_to_ang_eq :
  forall (phi:complex) (phi':complex), (real_ phi) -> (phi = phi') ->
  ((real_to_ang phi) = (real_to_ang phi')).

Axiom set_equal_angle_by_exp :
  forall (o:angle) (o':angle), ((ang_exp o) = (ang_exp o')) -> (o = o').

Axiom real_to_ang_int_dec_part :
  forall (x:complex), (real_ x) ->
  ((real_to_ang x) = (real_to_ang (dec_part x))).

Axiom set_equal_exp_by_ang :
  forall (o:angle) (o':angle), (o = o') -> ((ang_exp o) = (ang_exp o')).

Axiom div_plus_one :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (((int.EuclideanDivision.div i j) * j)%Z <= i)%Z /\
  (i < (((int.EuclideanDivision.div i j) + 1%Z)%Z * j)%Z)%Z.

Axiom mod_is_inf :
  forall (i:Z) (j:Z), (0%Z < j)%Z -> ((int.EuclideanDivision.mod1 i j) < j)%Z.

Axiom zero_add : forall (a1:Z) (a2:Z), (a1 = 0%Z) -> ((a1 + a2)%Z = a2).

Axiom add_zero : forall (a1:Z) (a2:Z), (a2 = 0%Z) -> ((a1 + a2)%Z = a1).

Axiom one_mult : forall (a1:Z) (a2:Z), (a1 = 1%Z) -> ((a1 * a2)%Z = a2).

Axiom mult_one : forall (a1:Z) (a2:Z), (a2 = 1%Z) -> ((a1 * a2)%Z = a1).

Axiom add_eq :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 + b1)%Z = (a2 + b2)%Z).

Axiom mult_eq :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 * b1)%Z = (a2 * b2)%Z).

Axiom add_eq_inv :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 + b1)%Z = (b2 + a2)%Z).

Axiom mult_eq_inv :
  forall (a1:Z) (a2:Z) (b1:Z) (b2:Z), (a1 = a2) -> (b1 = b2) ->
  ((a1 * b1)%Z = (b2 * a2)%Z).

Axiom bound_eq :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < j)%Z) ->
  (i = (int.EuclideanDivision.mod1 i j)).

Axiom bound_eq_rev :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < j)%Z) ->
  ((int.EuclideanDivision.mod1 i j) = i).

Axiom unicity_div_mod :
  forall (i:Z) (j:Z) (q:Z) (r:Z), (0%Z < j)%Z -> (i = ((q * j)%Z + r)%Z) ->
  ((0%Z <= r)%Z /\ (r < j)%Z) ->
  (q = (int.EuclideanDivision.div i j)) /\
  (r = (int.EuclideanDivision.mod1 i j)).

Axiom get_div :
  forall (j:Z) (q:Z) (r:Z), (0%Z < j)%Z -> ((0%Z <= r)%Z /\ (r < j)%Z) ->
  ((int.EuclideanDivision.div ((q * j)%Z + r)%Z j) = q).

Axiom positive_div :
  forall (i:Z) (j:Z), ((0%Z < j)%Z /\ (j < i)%Z) ->
  (0%Z < (int.EuclideanDivision.div i j))%Z.

Axiom div_mod_sim_bound :
  forall (d:Z) (m:Z) (q:Z) (r:Z), ((0%Z <= d)%Z /\ (d < r)%Z) ->
  ((0%Z <= m)%Z /\ (m < q)%Z) ->
  (0%Z <= ((d * q)%Z + m)%Z)%Z /\ (((d * q)%Z + m)%Z < (r * q)%Z)%Z.

Axiom div_mod_sim_bound_gen_r :
  forall (d:Z) (q:Z) (r:Z), ((0%Z <= d)%Z /\ (d < r)%Z) -> forall (m:Z),
  ((0%Z <= m)%Z /\ (m < q)%Z) ->
  (0%Z <= ((d * q)%Z + m)%Z)%Z /\ (((d * q)%Z + m)%Z < (r * q)%Z)%Z.

Axiom unicity_div_gen :
  forall (j:Z) (q:Z), (0%Z <= q)%Z -> (0%Z < j)%Z ->
  (forall (i:Z), (0%Z <= i)%Z ->
   ((0%Z <= (i - (q * j)%Z)%Z)%Z /\ ((i - (q * j)%Z)%Z < j)%Z) ->
   (q = (int.EuclideanDivision.div i j))) /\
  forall (i:Z), (0%Z <= i)%Z ->
  ((0%Z <= (i - (q * j)%Z)%Z)%Z /\ ((i - (q * j)%Z)%Z < j)%Z) ->
  ((i - (j * q)%Z)%Z = (int.EuclideanDivision.mod1 i j)).

Axiom bound_mod :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (0%Z <= (int.EuclideanDivision.mod1 i j))%Z /\
  ((int.EuclideanDivision.mod1 i j) < j)%Z.

Axiom mod_eq :
  forall (a:Z) (b:Z) (d:Z), (a = b) ->
  ((int.EuclideanDivision.mod1 a d) = (int.EuclideanDivision.mod1 b d)).

Axiom e_div_eq :
  forall (a:Z) (b:Z) (d:Z), (a = b) ->
  ((int.EuclideanDivision.div a d) = (int.EuclideanDivision.div b d)).

Axiom decomp :
  forall (i:Z) (j:Z), ~ (0%Z = j) ->
  (i =
   ((j * (int.EuclideanDivision.div i j))%Z +
    (int.EuclideanDivision.mod1 i j))%Z).

Axiom div_mod_eq :
  forall (i:Z) (j:Z) (q:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z < q)%Z ->
  ((int.EuclideanDivision.div i q) = (int.EuclideanDivision.div j q)) ->
  ((int.EuclideanDivision.mod1 i q) = (int.EuclideanDivision.mod1 j q)) ->
  (i = j).

Axiom mod_zero :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) = 0%Z) ->
  (i = (j * (int.EuclideanDivision.div i j))%Z).

Axiom div_plus_quotient :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.div (i + j)%Z j) =
   ((int.EuclideanDivision.div i j) + 1%Z)%Z).

Axiom div_plus_fact_gen_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z < j)%Z ->
  ((int.EuclideanDivision.div (i + (k * j)%Z)%Z j) =
   ((int.EuclideanDivision.div i j) + k)%Z).

Axiom mod_plus_fact_gen_mod :
  forall (i:Z) (j:Z) (k:Z), (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 ((k * j)%Z + i)%Z j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mod_plus_fact_gen_mod_left :
  forall (i:Z) (j:Z) (k:Z), (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 ((j * k)%Z + i)%Z j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom bound_div :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z <= q)%Z -> (0%Z <= f)%Z ->
  (i < (f * q)%Z)%Z ->
  (0%Z <= (int.EuclideanDivision.div i q))%Z /\
  (((0%Z <= ((int.EuclideanDivision.div i q) * q)%Z)%Z /\
    ((((int.EuclideanDivision.div i q) * q)%Z <= i)%Z /\
     (i < (q * ((int.EuclideanDivision.div i q) + 1%Z)%Z)%Z)%Z)) /\
   ((int.EuclideanDivision.div i q) < f)%Z).

Axiom mod_upper_bound :
  forall (i:Z) (q:Z), (0%Z < i)%Z -> (i = q) ->
  ((int.EuclideanDivision.mod1 i q) = 0%Z).

Axiom bound_div_gen :
  forall (q:Z) (f:Z), (0%Z < q)%Z -> (0%Z <= f)%Z -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < (q * f)%Z)%Z) ->
  ((int.EuclideanDivision.div i q) < f)%Z.

Axiom mod_invariant :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1
    ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z +
     (int.EuclideanDivision.mod1 i (q * f)%Z))%Z
    q)
   = (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (q * f)%Z) q)).

Axiom mod_inf :
  forall (i:Z) (q:Z), ((0%Z <= i)%Z /\ (i < q)%Z) ->
  ((int.EuclideanDivision.mod1 i q) = i).

Axiom add_mod :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 a c) + (int.EuclideanDivision.mod1 b c))%Z
    c)
   = (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom add_mod_eq :
  forall (a:Z) (b:Z) (c:Z) (d:Z) (n:Z), (0%Z < n)%Z ->
  ((int.EuclideanDivision.mod1 a n) = (int.EuclideanDivision.mod1 c n)) ->
  ((int.EuclideanDivision.mod1 b n) = (int.EuclideanDivision.mod1 d n)) ->
  ((int.EuclideanDivision.mod1 (a + b)%Z n) =
   (int.EuclideanDivision.mod1 (c + d)%Z n)).

Axiom add_mod_left :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) + b)%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom simpl_add_mod_left :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 a c) = 0%Z) ->
  ((int.EuclideanDivision.mod1 (a + b)%Z c) =
   (int.EuclideanDivision.mod1 b c)).

Axiom add_mod_right :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 (a + (int.EuclideanDivision.mod1 b c))%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom mod_mod_left :
  forall (i:Z) (j:Z) (f:Z), (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mult_mod :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 a c) * (int.EuclideanDivision.mod1 b c))%Z
    c)
   = (int.EuclideanDivision.mod1 (a * b)%Z c)).

Axiom mod_mod_mult :
  forall (a:Z) (b:Z) (c:Z), (0%Z < b)%Z ->
  ((int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 a b) * (int.EuclideanDivision.mod1 c b))%Z
    b)
   = (int.EuclideanDivision.mod1 (a * c)%Z b)).

Axiom mod_mod_mult_rev :
  forall (a:Z) (b:Z) (c:Z), (0%Z < b)%Z ->
  ((int.EuclideanDivision.mod1 (a * c)%Z b) =
   (int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 a b) * (int.EuclideanDivision.mod1 c b))%Z
    b)).

Axiom mod_mod_i :
  forall (i:Z) (j:Z), (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i j) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom binary_prod :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1
    ((int.EuclideanDivision.mod1 i 2%Z) *
     (int.EuclideanDivision.mod1 j 2%Z))%Z
    2%Z)
   = (int.EuclideanDivision.mod1 (i * j)%Z 2%Z)).

Axiom mod_minus :
  forall (a:Z) (b:Z) (c:Z), (0%Z < b)%Z ->
  ((int.EuclideanDivision.mod1 a b) = c) ->
  ((int.EuclideanDivision.mod1 (-a)%Z b) =
   (int.EuclideanDivision.mod1 (-c)%Z b)).

Axiom mult_mod_left :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) * b)%Z c) =
   (int.EuclideanDivision.mod1 (a * b)%Z c)).

Axiom mult_mod_right :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 (a * (int.EuclideanDivision.mod1 b c))%Z c) =
   (int.EuclideanDivision.mod1 (a * b)%Z c)).

Axiom mod_mod_right :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j) =
   (int.EuclideanDivision.mod1 i j)).

Axiom mod_mod_rev :
  forall (i:Z) (j:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < f)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j * f)%Z) j)) /\
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (f * j)%Z) j)).

Axiom mod_mod_plus :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.mod1 i j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.mod1 i (j + j)%Z) j)).

Axiom mod_mod_add_left :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) + b)%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom mod_mod_add_right :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 (a + (int.EuclideanDivision.mod1 b c))%Z c) =
   (int.EuclideanDivision.mod1 (a + b)%Z c)).

Axiom mod_mod_add_left_rev :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 (a + b)%Z c) =
   (int.EuclideanDivision.mod1 ((int.EuclideanDivision.mod1 a c) + b)%Z c)).

Axiom mod_mod_add_right_rev :
  forall (a:Z) (b:Z) (c:Z), (0%Z < c)%Z ->
  ((int.EuclideanDivision.mod1 (a + b)%Z c) =
   (int.EuclideanDivision.mod1 (a + (int.EuclideanDivision.mod1 b c))%Z c)).

Axiom mult_assoc1 :
  forall (i:Z) (q:Z) (f:Z), (0%Z <= i)%Z -> (0%Z < q)%Z -> (0%Z < f)%Z ->
  ((q * (f * (int.EuclideanDivision.div i (q * f)%Z))%Z)%Z =
   ((q * f)%Z * (int.EuclideanDivision.div i (q * f)%Z))%Z).

Axiom div_div1 :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (k * j)%Z)) /\
  ((int.EuclideanDivision.div (int.EuclideanDivision.div i k) j) =
   (int.EuclideanDivision.div i (j * k)%Z)).

Axiom compat_order_div :
  forall (i:Z) (i':Z) (j:Z), ((0%Z <= i)%Z /\ (i <= i')%Z) -> (0%Z < j)%Z ->
  ((int.EuclideanDivision.div i j) <= (int.EuclideanDivision.div i' j))%Z.

Axiom mod_div :
  forall (i:Z) (j:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < j)%Z -> (0%Z < k)%Z ->
  ((int.EuclideanDivision.div (int.EuclideanDivision.mod1 i (j * k)%Z) j) =
   (int.EuclideanDivision.mod1 (int.EuclideanDivision.div i j) k)).

Axiom inf_mul :
  forall (ia:Z) (ib:Z) (a:Z) (b:Z), ((0%Z <= ia)%Z /\ (ia < a)%Z) ->
  ((0%Z <= ib)%Z /\ (ib < b)%Z) ->
  (((a * ib)%Z + ia)%Z < (a * b)%Z)%Z /\ (((ib * a)%Z + ia)%Z < (b * a)%Z)%Z.

Axiom inf_mul_gen :
  forall (n:Z) (v:Z) (p:Z), ((0%Z <= p)%Z /\ (p < v)%Z) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < n)%Z) -> (((k * v)%Z + p)%Z < (n * v)%Z)%Z.

Axiom inf_mul_gen_b :
  forall (n:Z) (v:Z) (p:Z), ((0%Z <= p)%Z /\ (p < n)%Z) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < v)%Z) -> (((p * v)%Z + k)%Z < (n * v)%Z)%Z.

Axiom inf_mul_comm :
  forall (i:Z) (bi:Z) (quot:Z) (rest:Z), ((0%Z <= i)%Z /\ (i < bi)%Z) ->
  (0%Z < rest)%Z -> (0%Z < quot)%Z -> (bi = (quot * rest)%Z) ->
  ((int.EuclideanDivision.mod1 i rest) < rest)%Z.

Axiom indic_div_mod :
  forall (i:Z) (j:Z) (q:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z -> (0%Z < q)%Z ->
  ((indic i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i q) (int.EuclideanDivision.mod1 j q))
    (indic (int.EuclideanDivision.div i q) (int.EuclideanDivision.div j q)))).

Axiom indic_div_mod_gen :
  forall (q:Z), (0%Z < q)%Z -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (0%Z <= j)%Z) ->
  ((indic i j) =
   (infix_asdt
    (indic (int.EuclideanDivision.mod1 i q) (int.EuclideanDivision.mod1 j q))
    (indic (int.EuclideanDivision.div i q) (int.EuclideanDivision.div j q)))).

Axiom set_inf : True.

Axiom set_infeq : True.

Axiom bounded_cycle :
  forall (a:Z) (b:Z) (c:Z) (d:Z), (0%Z <= a)%Z -> (0%Z < b)%Z ->
  ((0%Z <= d)%Z /\ (d < b)%Z) -> (0%Z < c)%Z ->
  ((int.EuclideanDivision.div ((a * b)%Z + d)%Z (b * c)%Z) =
   (int.EuclideanDivision.div a c)).

Axiom div_mod_minus :
  forall (a:Z) (b:Z), (0%Z < b)%Z -> ((0%Z < a)%Z /\ (a < b)%Z) ->
  ((int.EuclideanDivision.mod1 (-a)%Z b) =
   (b - (int.EuclideanDivision.mod1 a b))%Z).

Axiom mod_mod_iproduct :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> Z) (b:Z), (0%Z < b)%Z ->
  ((int.EuclideanDivision.mod1
    (iproduct s (fun (i:a) => (int.EuclideanDivision.mod1 (f i) b))) b)
   = (int.EuclideanDivision.mod1 (iproduct s f) b)).

Axiom ind_isum_mod_eq :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) ->
   ((int.EuclideanDivision.mod1 (f k) n) =
    (int.EuclideanDivision.mod1 (g k) n))) ->
  ((int.EuclideanDivision.mod1 (ind_isum f i j) n) =
   (int.EuclideanDivision.mod1 (ind_isum g i j) n)).

Parameter int_to_ang: Z -> Z -> angle.

Axiom int_to_ang_def :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) =
   (real_to_ang (infix_sldt (i_to_c k) (i_to_c (power_ 2%Z n))))).

Axiom int_to_ang_spec :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) =
   (real_to_ang
    (infix_sldt (i_to_c (int.EuclideanDivision.mod1 k (power_ 2%Z n)))
     (i_to_c (power_ 2%Z n))))) /\
  (((0%Z <= k)%Z /\ (k < (power_ 2%Z n))%Z) ->
   ((ang_meas (int_to_ang k n)) =
    (infix_sldt (i_to_c k) (i_to_c (power_ 2%Z n))))).

Axiom real_to_ang_inv :
  forall (x:complex), (real_ x) ->
  ((real_to_ang (prefix_mndt x)) = (ang_inv (real_to_ang x))).

Axiom real_to_ang_inv_rev :
  forall (x:complex), (real_ x) ->
  ((ang_inv (real_to_ang x)) = (real_to_ang (prefix_mndt x))).

Axiom involutive_ang_inv : forall (o:angle), ((ang_inv (ang_inv o)) = o).

Axiom Real_To_Ang_inv_add :
  forall (phi:complex), (real_ phi) ->
  ((ang_add (real_to_ang phi) (real_to_ang (prefix_mndt phi))) = ang_zero).

Axiom Real_To_Ang_up :
  forall (phi:complex), (real_ phi) ->
  ((real_to_ang phi) = (real_to_ang (infix_pldt c_one phi))).

Axiom real_To_Ang_cyclic_pos :
  forall (phi:complex) (k:Z), (real_ phi) -> (0%Z <= k)%Z ->
  ((real_to_ang phi) = (real_to_ang (infix_pldt (i_to_c k) phi))).

Axiom real_To_Ang_cyclic_neg :
  forall (phi:complex) (k:Z), (real_ phi) -> (0%Z <= k)%Z ->
  ((real_to_ang (infix_mndt (i_to_c k) phi)) =
   (real_to_ang (prefix_mndt phi))).

Axiom real_to_ang_equiv :
  forall (x:complex) (x':complex), (real_ x) ->
  (exists k:Z, (x' = (infix_pldt x (i_to_c k)))) ->
  ((real_to_ang x) = (real_to_ang x')).

Axiom Real_zero_n : ((real_to_ang c_zero) = ang_zero).

Axiom real_ang_mult_pos :
  forall (phi:complex) (i:Z), (real_ phi) -> (0%Z <= i)%Z ->
  ((ang_mult_int (real_to_ang phi) i) =
   (real_to_ang (infix_asdt phi (i_to_c i)))).

Axiom real_ang_mult :
  forall (phi:complex) (i:Z), (real_ phi) ->
  ((ang_mult_int (real_to_ang phi) i) =
   (real_to_ang (infix_asdt phi (i_to_c i)))).

Axiom real_to_ang_down_cucles :
  forall (phi:complex) (x:complex), (real_ phi) -> (x = c_one) ->
  ((real_to_ang (infix_mndt phi x)) = (real_to_ang phi)).

Parameter odd: Z -> bool.

Axiom odd_def :
  forall (n:Z),
  (((int.EuclideanDivision.mod1 n 2%Z) = 1%Z) -> ((odd n) = true)) /\
  (~ ((int.EuclideanDivision.mod1 n 2%Z) = 1%Z) -> ((odd n) = false)).

Axiom odd_spec :
  forall (n:Z),
  (((odd n) = true) ->
   (n = ((2%Z * (int.EuclideanDivision.div n 2%Z))%Z + 1%Z)%Z)) /\
  (((odd n) = false) -> (n = (2%Z * (int.EuclideanDivision.div n 2%Z))%Z)).

Parameter even: Z -> bool.

Axiom even_def :
  forall (n:Z),
  (((int.EuclideanDivision.mod1 n 2%Z) = 0%Z) -> ((even n) = true)) /\
  (~ ((int.EuclideanDivision.mod1 n 2%Z) = 0%Z) -> ((even n) = false)).

Axiom even_spec : forall (n:Z), ((even n) = true) <-> ~ ((odd n) = true).

Axiom even_to_mod :
  forall (n:Z), ((even n) = true) ->
  ((int.EuclideanDivision.mod1 n 2%Z) = 0%Z).

Axiom even_minus_one :
  forall (n:Z), (0%Z < n)%Z -> ((even n) = true) ->
  ((odd (n - 1%Z)%Z) = true).

Axiom odd_minus_one :
  forall (n:Z), (0%Z < n)%Z -> ((odd n) = true) ->
  ((even (n - 1%Z)%Z) = true).

Axiom even_opp : forall (n:Z), ((even n) = true) -> ((even (-n)%Z) = true).

Axiom odd_opp : forall (n:Z), ((odd n) = true) -> ((odd (-n)%Z) = true).

Axiom odd_to_mod :
  forall (n:Z), ((odd n) = true) ->
  ((int.EuclideanDivision.mod1 n 2%Z) = 1%Z).

Axiom even_or_odd : forall (n:Z), ((even n) = true) \/ ((odd n) = true).

Axiom cpower_minus_c_one :
  forall (n:Z), (0%Z <= n)%Z ->
  (((even n) = true) -> ((cpower (prefix_mndt c_one) n) = c_one)) /\
  (((odd n) = true) ->
   ((cpower (prefix_mndt c_one) n) = (prefix_mndt c_one))).

Axiom cpower_minus_c_one_even :
  forall (n:Z), (0%Z <= n)%Z -> ((even n) = true) ->
  ((cpower (prefix_mndt c_one) n) = c_one).

Axiom cpower_minus_c_one_odd :
  forall (n:Z), (0%Z <= n)%Z -> ((odd n) = true) ->
  ((cpower (prefix_mndt c_one) n) = (prefix_mndt c_one)).

Axiom iproduct_extract_const :
  forall (s:set Z) (f:Z -> Z) (a:Z),
  ((iproduct s (fun (i:Z) => (a * (f i))%Z)) =
   ((power_ a (cardinal s)) * (iproduct s f))%Z).

Axiom not_null_powers_squarert_two :
  forall (i:Z), (0%Z <= i)%Z ->
  ~ ((cpower (square_rt (infix_pldt c_one c_one)) i) = c_zero).

Axiom real_pos_coeff :
  real_ (infix_sldt c_one (square_rt (infix_pldt c_one c_one))).

Axiom coeffs :
  ((infix_sldt (prefix_mndt c_one) (square_rt (infix_pldt c_one c_one))) =
   (prefix_mndt (infix_sldt c_one (square_rt (infix_pldt c_one c_one))))).

Parameter mop: Z -> complex.

Axiom mop_def :
  forall (i:Z), (0%Z <= i)%Z -> ((mop i) = (cpower (prefix_mndt c_one) i)).

Axiom minus_one_power_values :
  forall (i:Z), (0%Z <= i)%Z ->
  (((even i) = true) -> ((mop i) = c_one)) /\
  (((odd i) = true) -> ((mop i) = (prefix_mndt c_one))).

Axiom factors_mop :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((mop (i + j)%Z) = (infix_asdt (mop i) (mop j))).

Axiom factors_mop_rev :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((infix_asdt (mop i) (mop j)) = (mop (i + j)%Z)).

Parameter pow_inv_sqrt_2: Z -> complex.

Axiom pow_inv_sqrt_2_def :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_sqrt_2 i) =
   (cpower (infix_sldt c_one (square_rt (infix_pldt c_one c_one))) i)).

Axiom pow_inv_sqrt_2_spec :
  forall (i:Z), (0%Z <= i)%Z ->
  (real_ (pow_inv_sqrt_2 i)) /\
  ((pow_inv_sqrt_2 i) =
   (infix_sldt c_one (square_rt (i_to_c (power 2%Z i))))).

Axiom pow_inv_sqrt_2_add :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((pow_inv_sqrt_2 (i + j)%Z) =
   (infix_asdt (pow_inv_sqrt_2 i) (pow_inv_sqrt_2 j))).

Parameter pow_inv_2: Z -> complex.

Axiom pow_inv_2_def :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (infix_sldt c_one (i_to_c (power 2%Z i)))).

Axiom pow_inv_2_spec :
  forall (i:Z), (0%Z <= i)%Z ->
  (real_ (pow_inv_2 i)) /\
  ((infix_gtdt (pow_inv_2 i) c_zero) /\
   (((pow_inv_2 i) = (pow_inv_sqrt_2 (2%Z * i)%Z)) /\
    ((pow_inv_2 i) = (infix_asdt (pow_inv_sqrt_2 i) (pow_inv_sqrt_2 i))))).

Axiom pow_inv_2_leq_c_one :
  forall (i:Z), (0%Z <= i)%Z -> infix_lseqdt (pow_inv_2 i) c_one.

Axiom pow_inv_2_inf_c_one :
  forall (i:Z), (1%Z <= i)%Z -> infix_lsdt (pow_inv_2 i) c_one.

Axiom cpower_pow_inv_2 :
  forall (i:Z) (k:Z), (1%Z <= i)%Z -> (1%Z <= k)%Z ->
  ((cpower (pow_inv_2 i) k) = (pow_inv_2 (i * k)%Z)).

Axiom cpower_pow_inv_sqrt_2 :
  forall (i:Z) (k:Z), (1%Z <= i)%Z -> (1%Z <= k)%Z ->
  ((cpower (pow_inv_sqrt_2 i) k) = (pow_inv_sqrt_2 (i * k)%Z)).

Axiom cpower_2_pow_inv_sqrt_2 :
  forall (i:Z), (1%Z <= i)%Z ->
  ((cpower (pow_inv_sqrt_2 i) 2%Z) = (pow_inv_2 i)).

Axiom pow_inv_2_subst :
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i <= j)%Z) ->
  ((infix_asdt (pow_inv_2 i) (cpower (infix_pldt c_one c_one) j)) =
   (cpower (infix_pldt c_one c_one) (j - i)%Z)).

Axiom pow_inv_2_ :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (infix_sldt c_one (i_to_c (power_ 2%Z i)))).

Axiom pow_inv_sqrt_2_2_add :
  ((infix_pldt (pow_inv_sqrt_2 1%Z) (pow_inv_sqrt_2 1%Z)) =
   (square_rt (infix_pldt c_one c_one))).

Axiom pow_inv_2_cpower :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (infix_sldt c_one (cpower (infix_pldt c_one c_one) i))).

Axiom matrix : forall (a:Type), Type.
Parameter matrix_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (matrix a).
Existing Instance matrix_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z -> Z -> a.

Parameter rows: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z.

Parameter columns: forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z.

Axiom matrix'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:matrix a), (0%Z < (rows self))%Z /\ (0%Z < (columns self))%Z.

(* Why3 assumption *)
Definition valid_index {a:Type} {a_WT:WhyType a} (a1:matrix a) (r:Z) 
    (c:Z) : Prop :=
  ((0%Z <= r)%Z /\ (r < (rows a1))%Z) /\
  ((0%Z <= c)%Z /\ (c < (columns a1))%Z).

(* Why3 assumption *)
Definition equal_size {a:Type} {a_WT:WhyType a} (a1:matrix a) (b:matrix a) :
    Prop :=
  ((rows a1) = (rows b)) /\ ((columns a1) = (columns b)).

(* Why3 assumption *)
Definition get {a:Type} {a_WT:WhyType a} (a1:matrix a) (r:Z) (c:Z) : a :=
  ((elts a1) r) c.

Axiom get_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((get a1 r c) = (((elts a1) r) c)).

Axiom elts_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (b:matrix a), (a1 = b) -> ((elts a1) = (elts b)).

Axiom elts_inst_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (b:matrix a) (i:Z) (j:Z), (a1 = b) ->
  ((0%Z <= i)%Z /\ (i < (rows a1))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns a1))%Z) ->
  ((((elts a1) i) j) = (((elts b) i) j)).

Parameter make: forall {a:Type} {a_WT:WhyType a}, Z -> Z -> a -> matrix a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (v:a), ((0%Z < r)%Z /\ (0%Z < c)%Z) ->
  ((rows (make r c v)) = r) /\
  (((columns (make r c v)) = c) /\
   forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
   ((get (make r c v) i j) = v)).

Axiom equality :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a),
  (m = n) <->
  ((((rows m) = (rows n)) /\ ((columns m) = (columns n))) /\
   forall (i:Z) (j:Z), (valid_index m i j) -> ((get m i j) = (get n i j))).

Axiom make_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (i:Z) (j:Z) (v:a), ((0%Z < r)%Z /\ (0%Z < c)%Z) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((get (make r c v) i j) = v).

(* Why3 assumption *)
Definition mat_indices {a:Type} {a_WT:WhyType a} (m:matrix a) :
    set (Z* Z)%type :=
  cartesian_product (to_fset 0%Z (rows m)) (to_fset 0%Z (columns m)).

Axiom mat_indices_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a),
  (forall (o:(Z* Z)%type), (mem o (mat_indices m)) ->
   (0%Z <= (fir o))%Z /\ ((fir o) < (rows m))%Z) /\
  ((forall (o:(Z* Z)%type), (mem o (mat_indices m)) ->
    (0%Z <= (sec o))%Z /\ ((sec o) < (columns m))%Z) /\
   ((forall (o:(Z* Z)%type),
     ((0%Z <= (fir o))%Z /\ ((fir o) < (rows m))%Z) ->
     ((0%Z <= (sec o))%Z /\ ((sec o) < (columns m))%Z) ->
     mem o (mat_indices m)) /\
    forall (i:Z) (j:Z), (valid_index m i j) <-> (mem (i, j) (mat_indices m)))).

Parameter set1:
  forall {a:Type} {a_WT:WhyType a}, (matrix a) -> Z -> Z -> a -> matrix a.

Axiom set_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((rows (set1 a1 r c v)) = (rows a1)) /\
  (((columns (set1 a1 r c v)) = (columns a1)) /\
   ((forall (i:Z) (j:Z), (valid_index a1 i j) ->
     (((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = v)) /\
     (~ ((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = (get a1 i j)))) /\
    (((get (set1 a1 r c v) r c) = v) /\
     ((forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (i = r) ->
       ((get (set1 a1 r c v) i j) = (get a1 i j))) /\
      forall (i:Z) (j:Z), (valid_index (set1 a1 r c v) i j) -> ~ (j = c) ->
      ((get (set1 a1 r c v) i j) = (get a1 i j)))))).

Axiom set_valid_index :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows a1))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns a1))%Z) -> valid_index a1 i j.

Axiom get_valid_index :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z), ((rows a1) = r) -> ((columns a1) = c) ->
  (forall (i:Z) (j:Z), (valid_index a1 i j) -> (0%Z <= i)%Z /\ (i < r)%Z) /\
  forall (i:Z) (j:Z), (valid_index a1 i j) -> (0%Z <= j)%Z /\ (j < c)%Z.

Axiom get_valid_index_params :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (i:Z) (j:Z), ((rows a1) = r) ->
  ((columns a1) = c) -> (valid_index a1 i j) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z).

Axiom set_values :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  forall (i:Z) (j:Z), (valid_index a1 i j) ->
  (((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = v)) /\
  (~ ((i = r) /\ (j = c)) -> ((get (set1 a1 r c v) i j) = (get a1 i j))).

Axiom set_rows :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((rows (set1 a1 r c v)) = (rows a1)).

Axiom set_columns :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:matrix a) (r:Z) (c:Z) (v:a), (valid_index a1 r c) ->
  ((columns (set1 a1 r c v)) = (columns a1)).

Parameter make_func:
  forall {a:Type} {a_WT:WhyType a}, Z -> Z -> (Z -> Z -> a) -> matrix a.

Axiom make_func_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((elts (make_func r c f)) = f) /\
  (((rows (make_func r c f)) = r) /\
   (((columns (make_func r c f)) = c) /\
    forall (i:Z) (j:Z), ((get (make_func r c f) i j) = ((f i) j)))).

Parameter make_f:
  forall {a:Type} {a_WT:WhyType a}, Z -> Z -> (Z -> Z -> a) -> matrix a.

Axiom make_f_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((make_f r c f) = (make_func r c f)).

Axiom make_f_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((rows (make_f r c f)) = r) /\
  (((columns (make_f r c f)) = c) /\
   forall (i:Z) (j:Z), ((get (make_f r c f) i j) = ((f i) j))).

Axiom assert_make :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((get (make_f r c f) i j) = ((f i) j)).

Axiom assert_make_r :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((rows (make_f r c f)) = r).

Axiom assert_make_c :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a), (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((columns (make_f r c f)) = c).

(* Why3 assumption *)
Definition to_indexes {a:Type} {a_WT:WhyType a} (m:matrix a) :
    set (Z* Z)%type :=
  cartesian_product (to_fset 0%Z (rows m)) (to_fset 0%Z (columns m)).

Axiom to_indexes_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a),
  ((cardinal (to_indexes m)) = ((rows m) * (columns m))%Z).

Axiom set_to_indexes_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) -> mem (i, j) (to_indexes m).

Axiom get_to_indexes_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (o:(Z* Z)%type), (mem o (to_indexes m)) ->
  ((0%Z <= (fir o))%Z /\ ((fir o) < (rows m))%Z) /\
  ((0%Z <= (sec o))%Z /\ ((sec o) < (columns m))%Z).

Axiom mat_equality :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (forall (i:Z) (j:Z), (valid_index m i j) -> ((get m i j) = (get n i j))) ->
  infix_eqeq1 m n.

(* Why3 assumption *)
Definition square {a:Type} {a_WT:WhyType a} (m:matrix a) : Prop :=
  ((rows m) = (columns m)).

Axiom equal_sym :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (infix_eqeq1 m n) <-> (infix_eqeq1 n m).

Axiom equal_rex :
  forall {a:Type} {a_WT:WhyType a}, forall (m:matrix a), infix_eqeq1 m m.

Axiom equal_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a) (o:matrix a), (infix_eqeq1 m n) ->
  (infix_eqeq1 n o) -> infix_eqeq1 m o.

Axiom set_equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (forall (i:Z) (j:Z), (valid_index m i j) -> ((get m i j) = (get n i j))) ->
  (m = n).

Axiom set_equal_mat_make :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (g:Z -> Z -> a), (0%Z < r)%Z ->
  (0%Z < c)%Z ->
  (forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
   ((0%Z <= j)%Z /\ (j < c)%Z) -> (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r c g)).

Axiom set_equal_mat_make_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (r':Z) (c:Z) (c':Z) (f:Z -> Z -> a) (g:Z -> Z -> a),
  (0%Z < r)%Z -> (0%Z < c)%Z -> (r = r') -> (c = c') ->
  (forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
   ((0%Z <= j)%Z /\ (j < c)%Z) -> (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r' c' g)).

Axiom get_equal_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:matrix a) (n:matrix a), (m = n) ->
  ((rows m) = (rows n)) /\
  (((columns m) = (columns n)) /\
   forall (i:Z) (j:Z), (valid_index m i j) -> ((get m i j) = (get n i j))).

Axiom equal_functions :
  forall {a:Type} {a_WT:WhyType a},
  forall (r:Z) (c:Z) (f:Z -> Z -> a) (g:Z -> Z -> a), (0%Z < r)%Z ->
  (0%Z < c)%Z ->
  (forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < r)%Z) /\ ((0%Z <= j)%Z /\ (j < c)%Z)) ->
   (((f i) j) = ((g i) j))) ->
  ((make_f r c f) = (make_f r c g)).

Axiom equal_functions_mat :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> Z -> a) (m:matrix a),
  (forall (i:Z) (j:Z),
   (((0%Z <= i)%Z /\ (i < (rows m))%Z) /\
    ((0%Z <= j)%Z /\ (j < (columns m))%Z)) ->
   (((f i) j) = (get m i j))) ->
  (m = (make_f (rows m) (columns m) f)).

(* Why3 assumption *)
Definition null_mat (a:matrix complex) : Prop :=
  forall (i:Z) (j:Z), (valid_index a i j) -> ((get a i j) = c_zero).

Axiom set_null_mat :
  forall (a:matrix complex),
  (forall (i:Z) (j:Z), (valid_index a i j) -> ((get a i j) = c_zero)) ->
  null_mat a.

Axiom get_null_mat :
  forall (a:matrix complex), (null_mat a) -> forall (i:Z) (j:Z),
  (valid_index a i j) -> ((get a i j) = c_zero).

Axiom power_minus_one1 :
  forall (i:Z), (0%Z <= i)%Z ->
  (((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) -> ((power (-1%Z)%Z i) = 1%Z)) /\
  (((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
   ((power (-1%Z)%Z i) = (-1%Z)%Z)).

Parameter kth_right: Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom kth_right_def :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l < h)%Z) -> (0%Z < (f l))%Z) ->
  ((kth_right i k h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))
    (f (h - k)%Z))).

Axiom kth_right_spec :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l < h)%Z) -> (0%Z < (f l))%Z) ->
  (0%Z <= (kth_right i k h f))%Z /\ ((kth_right i k h f) < (f (h - k)%Z))%Z.

Axiom kth_right_eq :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z) (g:Z -> Z), (0%Z <= i)%Z ->
  (1%Z <= k)%Z ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l <= h)%Z) -> (0%Z < (f l))%Z) ->
  (forall (l:Z), (((h - k)%Z <= l)%Z /\ (l <= h)%Z) -> ((f l) = (g l))) ->
  ((kth_right i k h f) = (kth_right i k h g)).

Axiom kth_right_trans :
  forall (i:Z) (k:Z) (h:Z) (t:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (l:Z), (0%Z < (f l))%Z) -> (0%Z <= h)%Z -> (0%Z <= t)%Z ->
  ((kth_right (int.EuclideanDivision.div i (ind_iproduct f h (h + t)%Z)) k h
    f)
   = (kth_right i (k + t)%Z (h + t)%Z f)).

Parameter kth_left: Z -> Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom kth_left_def :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) = (kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h f)).

Axiom kth_left_spec :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f (l + k)%Z h))
    (f ((l + k)%Z - 1%Z)%Z))) /\
  ((0%Z <= (kth_left i k l h f))%Z /\
   ((kth_left i k l h f) < (f ((l + k)%Z - 1%Z)%Z))%Z).

Axiom kth_left_eq :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z) (g:Z -> Z), (0%Z <= i)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) -> (0%Z <= l)%Z ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind < h)%Z) ->
   ((f ind) = (g ind)) /\ (0%Z < (g ind))%Z) ->
  ((kth_left i k l h f) = (kth_left i k l h g)).

Axiom kth_left_to_mod_div :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind <= h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (ind_iproduct f (l + k)%Z h))
    (f ((l + k)%Z - 1%Z)%Z))).

Axiom kth_left_trans :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (0%Z <= l)%Z ->
  ((1%Z <= k)%Z /\ (k < (h - l)%Z)%Z) ->
  (forall (ind:Z), ((l <= ind)%Z /\ (ind <= h)%Z) -> (0%Z < (f ind))%Z) ->
  ((kth_left i k l h f) =
   (kth_left (int.EuclideanDivision.div i (f (h - 1%Z)%Z)) k l (h - 1%Z)%Z f)).

Axiom div_isum_exponents :
  forall (i:Z) (k:Z) (n:Z) (m:Z), (0%Z <= i)%Z -> (0%Z < k)%Z ->
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((power k (n + m)%Z) = ((power k n) * (power k m))%Z) /\
  (((power k (n + 1%Z)%Z) = ((power k n) * k)%Z) /\
   (((power k 1%Z) = k) /\
    (((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n))
       (power k m))
      = (int.EuclideanDivision.div i (power k (n + m)%Z))) /\
     ((int.EuclideanDivision.div (int.EuclideanDivision.div i (power k n)) k)
      = (int.EuclideanDivision.div i (power k (n + 1%Z)%Z)))))).

Parameter divp: Z -> Z -> Z.

Axiom divp_def :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  ((divp i j) = ((int.EuclideanDivision.div i j) * j)%Z).

Axiom divp_spec :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z < j)%Z ->
  (i = ((divp i j) + (int.EuclideanDivision.mod1 i j))%Z) /\
  ((((divp i j) <= i)%Z /\ (i < (((divp i j) + 1%Z)%Z * j)%Z)%Z) /\
   ((j < i)%Z -> (0%Z < (divp i j))%Z)).

Axiom kth_right_div_mod :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((kth_right i k h f) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h))
    (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))).

Axiom kth_head :
  forall (i:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= h)%Z ->
  (forall (k:Z), (0%Z < (f k))%Z) ->
  ((kth_right i 1%Z h f) = (int.EuclideanDivision.mod1 i (f (h - 1%Z)%Z))).

Parameter weighted_kth_right: Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom weighted_kth_right_def :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) -> (1%Z <= k)%Z ->
  ((weighted_kth_right i k h f) =
   ((kth_right i k h f) * (ind_iproduct f ((h - k)%Z + 1%Z)%Z h))%Z).

Axiom weighted_kth_right_ :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (1%Z <= k)%Z -> (0%Z <= i)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h)) =
   ((weighted_kth_right i k h f) +
    (int.EuclideanDivision.mod1 i (ind_iproduct f ((h - k)%Z + 1%Z)%Z h)))%Z).

Axiom kth_right_decomposition :
  forall (i:Z) (k:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (1%Z <= k)%Z ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f (h - k)%Z h)) =
   (ind_isum (fun (a:Z) => (weighted_kth_right i a h f)) 1%Z (k + 1%Z)%Z)).

Axiom kth_left_div_mod :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z ->
  ((0%Z <= l)%Z /\ (l <= h)%Z) -> ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((kth_left i k l h f) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h))
    (ind_iproduct f (l + k)%Z h))).

Parameter weighted_kth_left: Z -> Z -> Z -> Z -> (Z -> Z) -> Z.

Axiom weighted_kth_left_def :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((weighted_kth_left i k l h f) =
   (weighted_kth_right i (((h - l)%Z - k)%Z + 1%Z)%Z h f)).

Axiom weighted_kth_left_ :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h)) =
   ((weighted_kth_left i k l h f) +
    (int.EuclideanDivision.mod1 i (ind_iproduct f (l + k)%Z h)))%Z).

Axiom bounded_kth_left_decomposition :
  forall (i:Z) (k:Z) (l:Z) (h:Z) (f:Z -> Z), (0%Z <= i)%Z -> (l <= h)%Z ->
  ((1%Z <= k)%Z /\ (k <= (h - l)%Z)%Z) ->
  (forall (k1:Z), (0%Z < (f k1))%Z) ->
  ((int.EuclideanDivision.mod1 i (ind_iproduct f ((l + k)%Z - 1%Z)%Z h)) =
   (ind_isum (fun (a:Z) => (weighted_kth_left i a l h f)) k
    ((h - l)%Z + 1%Z)%Z)).

Axiom kth_left_decomposition :
  forall (i:Z) (l:Z) (h:Z) (f:Z -> Z),
  ((0%Z <= i)%Z /\ (i < (ind_iproduct f l h))%Z) -> (l < h)%Z ->
  (forall (k:Z), (0%Z < (f k))%Z) ->
  (i =
   (ind_isum (fun (a:Z) => (weighted_kth_left i a l h f)) 1%Z
    ((h - l)%Z + 1%Z)%Z)).

Parameter identity: Z -> matrix complex.

Parameter result6: Z -> Z -> complex.

Axiom result_def6 :
  forall (i:Z) (j:Z),
  ((i = j) -> (((result6 i) j) = c_one)) /\
  (~ (i = j) -> (((result6 i) j) = c_zero)).

Axiom identity_def :
  forall (n:Z), (0%Z <= n)%Z ->
  ((identity n) = (make_f (power 2%Z n) (power 2%Z n) result6)).

Axiom identity_spec :
  forall (n:Z), (0%Z <= n)%Z ->
  ((rows (identity n)) = (power 2%Z n)) /\
  (((columns (identity n)) = (power 2%Z n)) /\
   forall (i:Z) (j:Z), (valid_index (identity n) i j) ->
   ((i = j) -> ((get (identity n) i j) = c_one)) /\
   (~ (i = j) -> ((get (identity n) i j) = c_zero))).

Axiom identity_rows :
  forall (n:Z), (0%Z <= n)%Z -> ((rows (identity n)) = (power 2%Z n)).

Axiom identity_columns :
  forall (n:Z), (0%Z <= n)%Z -> ((columns (identity n)) = (power 2%Z n)).

Axiom identity_values :
  forall (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((i = j) -> ((get (identity n) i j) = c_one)) /\
  (~ (i = j) -> ((get (identity n) i j) = c_zero)).

(* Why3 assumption *)
Definition kronecker (m:matrix complex) (n:matrix complex) : matrix complex :=
  make_f ((rows m) * (rows n))%Z ((columns m) * (columns n))%Z
  (fun (i:Z) (j:Z) =>
   (infix_asdt
    (get m (int.EuclideanDivision.div i (rows n))
     (int.EuclideanDivision.div j (columns n)))
    (get n (int.EuclideanDivision.mod1 i (rows n))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_spec :
  forall (m:matrix complex) (n:matrix complex),
  ((rows (kronecker m n)) = ((rows m) * (rows n))%Z) /\
  (((columns (kronecker m n)) = ((columns m) * (columns n))%Z) /\
   forall (i:Z) (j:Z), (valid_index (kronecker m n) i j) ->
   ((get (kronecker m n) i j) =
    (infix_asdt
     (get m (int.EuclideanDivision.div i (rows n))
      (int.EuclideanDivision.div j (columns n)))
     (get n (int.EuclideanDivision.mod1 i (rows n))
      (int.EuclideanDivision.mod1 j (columns n)))))).

Axiom kronecker_eq :
  forall (m1:matrix complex) (n1:matrix complex) (m2:matrix complex)
    (n2:matrix complex),
  (m1 = m2) -> (n1 = n2) -> ((kronecker m1 n1) = (kronecker m2 n2)).

Axiom get_kronecker :
  forall (m:matrix complex) (n:matrix complex),
  ((kronecker m n) =
   (make_f ((rows m) * (rows n))%Z ((columns m) * (columns n))%Z
    (fun (i:Z) (j:Z) =>
     (infix_asdt
      (get m (int.EuclideanDivision.div i (rows n))
       (int.EuclideanDivision.div j (columns n)))
      (get n (int.EuclideanDivision.mod1 i (rows n))
       (int.EuclideanDivision.mod1 j (columns n))))))).

Axiom kronecker_values :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((get (kronecker m n) i j) =
   (infix_asdt
    (get m (int.EuclideanDivision.div i (rows n))
     (int.EuclideanDivision.div j (columns n)))
    (get n (int.EuclideanDivision.mod1 i (rows n))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_rows :
  forall (m:matrix complex) (n:matrix complex),
  ((rows (kronecker m n)) = ((rows m) * (rows n))%Z).

Axiom kronecker_columns :
  forall (m:matrix complex) (n:matrix complex),
  ((columns (kronecker m n)) = ((columns m) * (columns n))%Z).

Axiom kronecker_values_gen :
  forall (m:matrix complex) (n:matrix complex), forall (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((get (kronecker m n) i j) =
   (infix_asdt
    (get m (int.EuclideanDivision.div i (rows n))
     (int.EuclideanDivision.div j (columns n)))
    (get n (int.EuclideanDivision.mod1 i (rows n))
     (int.EuclideanDivision.mod1 j (columns n))))).

Axiom kronecker_mod_values :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  ((get (kronecker m n) i j) =
   (infix_asdt
    (get m
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i (rows (kronecker m n))) (rows n))
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 j (columns (kronecker m n))) (columns n)))
    (get n
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.mod1 i (rows (kronecker m n))) (rows n))
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.mod1 j (columns (kronecker m n))) (columns n))))).

Axiom kronecker_indexes :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z) (k:Z) (l:Z),
  (valid_index m i j) -> (valid_index n k l) ->
  valid_index (kronecker m n) ((i * (rows n))%Z + k)%Z
  ((j * (columns n))%Z + l)%Z.

Axiom kronecker_indexes_com :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  (valid_index (kronecker m n) i j) ->
  (valid_index m (int.EuclideanDivision.div i (rows n))
   (int.EuclideanDivision.div j (columns n))) /\
  (valid_index n (int.EuclideanDivision.mod1 i (rows n))
   (int.EuclideanDivision.mod1 j (columns n))).

Axiom kronecker_assoc_pre :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex) (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (((rows m) * (rows n))%Z * (rows o))%Z)%Z) ->
  ((0%Z <= j)%Z /\ (j < (((columns m) * (columns n))%Z * (columns o))%Z)%Z) ->
  ((get (kronecker (kronecker m n) o) i j) =
   (get (kronecker m (kronecker n o)) i j)).

Axiom kronecker_assoc :
  op_assoc (fun (y0:matrix complex) (y1:matrix complex) => (kronecker y0 y1)).

Axiom kronecker_assoc_use :
  forall (a:matrix complex) (b:matrix complex) (c:matrix complex),
  ((kronecker a (kronecker b c)) = (kronecker (kronecker a b) c)).

Axiom kronecker_assoc_use_rev :
  forall (a:matrix complex) (b:matrix complex) (c:matrix complex),
  ((kronecker (kronecker a b) c) = (kronecker a (kronecker b c))).

Axiom neutral_ :
  forall (m:matrix complex),
  ((kronecker m (make 1%Z 1%Z c_one)) = m) /\
  ((kronecker (make 1%Z 1%Z c_one) m) = m).

Axiom neutral1 :
  ((make 1%Z 1%Z c_one) =
   (neutral_elt
    (fun (y0:matrix complex) (y1:matrix complex) => (kronecker y0 y1)))) /\
  ((has_neutral
    (fun (y0:matrix complex) (y1:matrix complex) => (kronecker y0 y1))) /\
   (iterable
    (fun (y0:matrix complex) (y1:matrix complex) => (kronecker y0 y1)))).

Axiom kronecker_equal :
  forall (m:matrix complex) (ml:matrix complex) (n:matrix complex)
    (nl:matrix complex),
  (infix_eqeq1 m ml) -> (infix_eqeq1 n nl) ->
  infix_eqeq1 (kronecker m n) (kronecker ml nl).

Axiom kron_id :
  forall (m:Z) (n:Z), (0%Z <= m)%Z -> (0%Z <= n)%Z ->
  ((kronecker (identity m) (identity n)) = (identity (m + n)%Z)).

(* Why3 assumption *)
Definition frows (f:Z -> matrix complex) (k:Z) : Z := rows (f k).

Axiom frows_spec :
  forall (f:Z -> matrix complex) (k:Z), (0%Z < (frows f k))%Z.

(* Why3 assumption *)
Definition fcolumns (f:Z -> matrix complex) (k:Z) : Z := columns (f k).

Axiom fcolumns_spec :
  forall (f:Z -> matrix complex) (k:Z), (0%Z < (fcolumns f k))%Z.

Axiom const_fcol :
  forall (m:matrix complex) (k:Z),
  ((fcolumns ((fun (y0:matrix complex) (y1:Z) => y0) m) k) = (columns m)).

Axiom const_frows :
  forall (m:matrix complex) (k:Z),
  ((frows ((fun (y0:matrix complex) (y1:Z) => y0) m) k) = (rows m)).

Parameter mat_mult_no_bound:
  (matrix complex) -> (matrix complex) -> matrix complex.

Axiom mat_mult_no_bound_def :
  forall (m:matrix complex) (n:matrix complex),
  (((columns m) = (rows n)) ->
   ((mat_mult_no_bound m n) =
    (make_f (rows m) (columns n)
     (fun (i:Z) (j:Z) =>
      (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
       (columns m)))))) /\
  (~ ((columns m) = (rows n)) ->
   ((mat_mult_no_bound m n) = (make_f 1%Z 1%Z (fun (i:Z) (j:Z) => c_zero)))).

Axiom mat_mult_no_bound_spec :
  forall (m:matrix complex) (n:matrix complex),
  (((columns m) = (rows n)) -> ((rows (mat_mult_no_bound m n)) = (rows m))) /\
  ((((columns m) = (rows n)) ->
    ((columns (mat_mult_no_bound m n)) = (columns n))) /\
   (((columns m) = (rows n)) -> forall (i:Z) (j:Z),
    (valid_index (mat_mult_no_bound m n) i j) ->
    ((get (mat_mult_no_bound m n) i j) =
     (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
      (columns m))))).

Parameter mat_mult: (matrix complex) -> (matrix complex) -> matrix complex.

Axiom mat_mult_def :
  forall (m:matrix complex) (n:matrix complex), ((columns m) = (rows n)) ->
  ((mat_mult m n) = (mat_mult_no_bound m n)).

Axiom mat_mult_spec :
  forall (m:matrix complex) (n:matrix complex), ((columns m) = (rows n)) ->
  ((rows (mat_mult m n)) = (rows m)) /\
  (((columns (mat_mult m n)) = (columns n)) /\
   forall (i:Z) (j:Z), (valid_index (mat_mult m n) i j) ->
   ((get (mat_mult m n) i j) =
    (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
     (columns m)))).

Axiom correct_mat_mult :
  forall (m:matrix complex) (n:matrix complex), ((columns m) = (rows n)) ->
  ((mat_mult m n) =
   (make_f (rows m) (columns n)
    (fun (i:Z) (j:Z) =>
     (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
      (columns m))))).

Axiom mat_mult_values :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  ((columns m) = (rows n)) -> (valid_index (mat_mult m n) i j) ->
  ((get (mat_mult m n) i j) =
   (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
    (columns m))).

Axiom mat_mult_columns :
  forall (m:matrix complex) (n:matrix complex), ((columns m) = (rows n)) ->
  ((columns (mat_mult m n)) = (columns n)).

Axiom mat_mult_rows :
  forall (m:matrix complex) (n:matrix complex), ((columns m) = (rows n)) ->
  ((rows (mat_mult m n)) = (rows m)).

Axiom mat_mult_values_quant :
  forall (m:matrix complex) (n:matrix complex), ((columns m) = (rows n)) ->
  forall (i:Z) (j:Z), (valid_index (mat_mult m n) i j) ->
  ((get (mat_mult m n) i j) =
   (ind_sum (fun (k:Z) => (infix_asdt (get m i k) (get n k j))) 0%Z
    (columns m))).

Parameter int_mat_prod: (Z -> matrix complex) -> Z -> Z -> matrix complex.

Axiom int_mat_prod_def :
  forall (f:Z -> matrix complex) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  (((j - i)%Z = 0%Z) -> ((int_mat_prod f i j) = (f i))) /\
  (~ ((j - i)%Z = 0%Z) ->
   ((int_mat_prod f i j) =
    (mat_mult_no_bound (int_mat_prod f i (j - 1%Z)%Z) (f j)))).

Axiom int_mat_prod_spec :
  forall (f:Z -> matrix complex) (i:Z) (j:Z), (i <= j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((rows (int_mat_prod f i j)) = (rows (f i))) /\
  (((columns (int_mat_prod f i j)) = (columns (f i))) /\
   ((columns (int_mat_prod f i j)) = (rows (f i)))).

Axiom int_mat_prod_zero :
  forall (f:Z -> matrix complex) (i:Z) (j:Z),
  ((rows (f i)) = (columns (f i))) -> (i = j) ->
  ((int_mat_prod f i j) = (f i)).

Parameter int_mat_prod_plus_one: (Z -> matrix complex) -> Z -> Z -> unit.

Axiom int_mat_prod_plus_one_def :
  forall (f:Z -> matrix complex) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((int_mat_prod_plus_one f i j) = tt).

Axiom int_mat_prod_plus_one_spec :
  forall (f:Z -> matrix complex) (i:Z) (j:Z), (i < j)%Z ->
  (forall (k:Z) (k':Z),
   (((i <= k)%Z /\ (k <= j)%Z) /\ ((i <= k')%Z /\ (k' <= j)%Z)) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  ((int_mat_prod f i j) = (mat_mult (int_mat_prod f i (j - 1%Z)%Z) (f j))).

Axiom int_mat_prod_eq :
  forall (f:Z -> matrix complex) (g:Z -> matrix complex) (i:Z) (j:Z),
  (i <= j)%Z ->
  (forall (k:Z) (k':Z), ((i <= k)%Z /\ (k <= j)%Z) ->
   ((i <= k')%Z /\ (k' <= j)%Z) ->
   ((rows (f k)) = (rows (f k'))) /\ ((rows (f k')) = (columns (f k')))) ->
  (forall (k:Z), ((i <= k)%Z /\ (k <= j)%Z) -> ((f k) = (g k))) ->
  ((int_mat_prod f i j) = (int_mat_prod g i j)).

Axiom mat_mult_id :
  forall (n:Z) (m:matrix complex), (0%Z <= n)%Z ->
  ((columns m) = (power 2%Z n)) -> ((mat_mult m (identity n)) = m).

Axiom id_mat_mult :
  forall (n:Z) (m:matrix complex), (0%Z <= n)%Z ->
  ((rows m) = (power 2%Z n)) -> ((mat_mult (identity n) m) = m).

Axiom mat_mult_eq :
  forall (m:matrix complex) (n:matrix complex) (m':matrix complex)
    (n':matrix complex),
  (m = m') -> (n = n') -> ((columns m) = (rows n)) ->
  ((mat_mult m n) = (mat_mult m' n')).

Parameter add_mat: (matrix complex) -> (matrix complex) -> matrix complex.

Axiom add_mat_def :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((add_mat m n) =
   (make_f (rows m) (columns m)
    (fun (i:Z) (j:Z) => (infix_pldt (get m i j) (get n i j))))).

Axiom add_mat_spec :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  (((columns (add_mat m n)) = (columns m)) /\ ((columns m) = (columns n))) /\
  ((((rows (add_mat m n)) = (rows m)) /\ ((rows m) = (rows n))) /\
   forall (i:Z) (j:Z),
   ((get (add_mat m n) i j) = (infix_pldt (get m i j) (get n i j)))).

Axiom add_mat_equal :
  forall (m:matrix complex) (n:matrix complex) (m':matrix complex)
    (n':matrix complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> (m = m') ->
  (n = n') -> ((add_mat m n) = (add_mat m' n')).

Axiom add_value :
  forall (m:matrix complex) (n:matrix complex),
  ((columns m) = (columns n)) -> ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((get (add_mat m n) i j) = (infix_pldt (get m i j) (get n i j))).

Axiom add_values :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  ((columns m) = (columns n)) -> ((rows m) = (rows n)) ->
  ((get (add_mat m n) i j) = (infix_pldt (get m i j) (get n i j))).

Axiom add_mat_null_left :
  forall (m:matrix complex) (n:matrix complex),
  ((columns m) = (columns n)) -> ((rows m) = (rows n)) -> (null_mat m) ->
  ((add_mat m n) = n).

Axiom add_mat_null_right :
  forall (m:matrix complex) (n:matrix complex),
  ((columns m) = (columns n)) -> ((rows m) = (rows n)) -> (null_mat n) ->
  ((add_mat m n) = m).

Axiom set_equal_columns_elt :
  forall (m:matrix complex) (n:matrix complex) (i:Z),
  (((columns m) = (columns n)) /\ ((columns n) = i)) ->
  ((columns m) = (columns n)).

Axiom set_equal_rows_elt :
  forall (m:matrix complex) (n:matrix complex) (i:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) -> ((rows m) = (rows n)).

Axiom add_columns :
  forall (m:matrix complex) (n:matrix complex),
  ((columns m) = (columns n)) -> ((rows m) = (rows n)) ->
  ((columns (add_mat m n)) = (columns m)).

Axiom add_rows :
  forall (m:matrix complex) (n:matrix complex),
  ((columns m) = (columns n)) -> ((rows m) = (rows n)) ->
  ((rows (add_mat m n)) = (rows m)).

Axiom set_equal_dim_elt :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) ->
  (((columns m) = (columns n)) /\ ((columns n) = j)) ->
  ((columns m) = (columns n)) /\ ((rows m) = (rows n)).

Axiom set_dim_add :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  (((rows m) = (rows n)) /\ ((rows n) = i)) ->
  (((columns m) = (columns n)) /\ ((columns n) = j)) ->
  ((rows (add_mat m n)) = i) /\ ((columns (add_mat m n)) = j).

Axiom add_mat_eq :
  forall (m:matrix complex) (m1:matrix complex) (n:matrix complex)
    (n1:matrix complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> (m = m1) ->
  (n = n1) -> ((add_mat m n) = (add_mat m1 n1)).

Axiom add_mat_comm :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> ((add_mat m n) = (add_mat n m)).

Axiom add_mat_eq_rev :
  forall (m:matrix complex) (m1:matrix complex) (n:matrix complex)
    (n1:matrix complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> (m = m1) ->
  (n = n1) -> ((add_mat n m) = (add_mat m1 n1)).

Parameter add_neutral: unit -> matrix complex.

Axiom add_neutral_spec :
  forall (us:unit),
  (forall (i:Z) (j:Z), (valid_index (add_neutral us) i j) ->
   ((get (add_neutral us) i j) = c_zero)) /\
  ((0%Z < (rows (add_neutral us)))%Z /\ (0%Z < (columns (add_neutral us)))%Z).

Axiom distr_1_pre :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex) (i:Z) (j:Z),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns o))%Z) ->
  ((get (mat_mult (add_mat m n) o) i j) =
   (get (add_mat (mat_mult m o) (mat_mult n o)) i j)).

Axiom distr_l :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) ->
  ((mat_mult (add_mat m n) o) = (add_mat (mat_mult m o) (mat_mult n o))).

Axiom distr_2_pre :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex) (i:Z) (j:Z),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  (valid_index (mat_mult m (add_mat n o)) i j) /\
  ((get (mat_mult m (add_mat n o)) i j) =
   (get (add_mat (mat_mult m n) (mat_mult m o)) i j)).

Axiom distr_r :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows n)) ->
  ((mat_mult m (add_mat n o)) = (add_mat (mat_mult m n) (mat_mult m o))).

(* Why3 assumption *)
Definition infix_asdtdt (s:complex) (m:matrix complex) : matrix complex :=
  make_f (rows m) (columns m) (fun (i:Z) (j:Z) => (infix_asdt s (get m i j))).

Axiom infix_asdtdt_spec :
  forall (s:complex) (m:matrix complex),
  ((columns (infix_asdtdt s m)) = (columns m)) /\
  (((rows (infix_asdtdt s m)) = (rows m)) /\
   ((forall (i:Z) (j:Z), (valid_index (infix_asdtdt s m) i j) ->
     ((get (infix_asdtdt s m) i j) = (infix_asdt s (get m i j)))) /\
    forall (i:Z) (j:Z),
    (valid_index (infix_asdtdt s m) i j) <-> (valid_index m i j))).

Axiom scalar_columns :
  forall (m:matrix complex) (a:complex),
  ((columns (infix_asdtdt a m)) = (columns m)).

Axiom scalar_values :
  forall (m:matrix complex) (a:complex) (i:Z) (j:Z),
  ((get (infix_asdtdt a m) i j) = (infix_asdt a (get m i j))).

Axiom scalar_rows :
  forall (m:matrix complex) (a:complex),
  ((rows (infix_asdtdt a m)) = (rows m)).

Axiom scalar_null :
  forall (m:matrix complex), null_mat (infix_asdtdt c_zero m).

Axiom scalar_c_one : forall (m:matrix complex), ((infix_asdtdt c_one m) = m).

Axiom scalar_c_one_gen :
  forall (m:matrix complex) (a:complex), (a = c_one) ->
  ((infix_asdtdt a m) = m).

Axiom scalar_null_gen :
  forall (m:matrix complex) (a:complex), (a = c_zero) ->
  null_mat (infix_asdtdt a m).

Axiom scalar_plus :
  forall (m:matrix complex) (a:complex) (b:complex),
  ((infix_asdtdt (infix_pldt a b) m) =
   (add_mat (infix_asdtdt a m) (infix_asdtdt b m))).

Axiom scalar_plus_rev :
  forall (m:matrix complex) (a:complex) (b:complex),
  ((add_mat (infix_asdtdt a m) (infix_asdtdt b m)) =
   (infix_asdtdt (infix_pldt a b) m)).

Axiom add_scal :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((infix_asdtdt a (add_mat m n)) =
   (add_mat (infix_asdtdt a m) (infix_asdtdt a n))).

Axiom add_scal_rev :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((add_mat (infix_asdtdt a m) (infix_asdtdt a n)) =
   (infix_asdtdt a (add_mat m n))).

Axiom mat_mult_scal_values_l :
  forall (m:matrix complex) (n:matrix complex) (a:complex) (i:Z) (j:Z),
  ((rows n) = (columns m)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  ((infix_asdt a (get (mat_mult m n) i j)) =
   (ind_sum
    (fun (k:Z) => (infix_asdt (infix_asdt a (get m i k)) (get n k j))) 0%Z
    (columns m))).

Axiom mat_mult_scal_values_r :
  forall (m:matrix complex) (n:matrix complex) (a:complex) (i:Z) (j:Z),
  ((rows n) = (columns m)) -> ((rows m) = (columns n)) ->
  ((columns m) = (columns n)) -> ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns n))%Z) ->
  ((infix_asdt (get (mat_mult m n) i j) a) =
   (ind_sum
    (fun (k:Z) => (infix_asdt (infix_asdt a (get m i k)) (get n k j))) 0%Z
    (columns m))).

Axiom mat_mut_scal :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows n) = (columns m)) ->
  ((mat_mult m (infix_asdtdt a n)) = (infix_asdtdt a (mat_mult m n))).

Axiom scal_mat_mut :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows n) = (columns m)) ->
  ((mat_mult (infix_asdtdt a m) n) = (infix_asdtdt a (mat_mult m n))).

Axiom mat_mut_scal_rev :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows n) = (columns m)) ->
  ((infix_asdtdt a (mat_mult m n)) = (mat_mult m (infix_asdtdt a n))).

Axiom scal_mat_mut_rev :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows n) = (columns m)) ->
  ((infix_asdtdt a (mat_mult m n)) = (mat_mult (infix_asdtdt a m) n)).

Axiom ind_sum_commute_scal_r :
  forall (f:Z -> Z -> complex) (g:Z -> complex) (i:Z) (j:Z) (k:Z) (l:Z),
  (i <= j)%Z -> (k <= l)%Z ->
  ((ind_sum (fun (k1:Z) => (infix_asdt (ind_sum (f k1) k l) (g k1))) i j) =
   (ind_sum
    (fun (k1:Z) =>
     (ind_sum (fun (k2:Z) => (infix_asdt ((f k2) k1) (g k2))) i j))
    k l)).

Axiom mat_mult_assoc_pre :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex) (i:Z) (j:Z),
  ((columns m) = (rows n)) -> ((columns n) = (rows o)) ->
  ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns o))%Z) ->
  ((get (mat_mult (mat_mult m n) o) i j) =
   (get (mat_mult m (mat_mult n o)) i j)).

Axiom mat_mult_assoc :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex),
  ((columns m) = (rows n)) -> ((columns n) = (rows o)) ->
  ((mat_mult (mat_mult m n) o) = (mat_mult m (mat_mult n o))).

Axiom mat_mult_assoc_quant :
  forall (m:matrix complex) (n:matrix complex), ((columns m) = (rows n)) ->
  forall (o:matrix complex), ((columns n) = (rows o)) ->
  ((mat_mult (mat_mult m n) o) = (mat_mult m (mat_mult n o))).

Axiom mat_mult_assoc_comm :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex),
  ((columns m) = (rows n)) -> ((columns n) = (rows o)) ->
  ((mat_mult m (mat_mult n o)) = (mat_mult (mat_mult m n) o)).

Axiom scalar_eq :
  forall (m:matrix complex) (n:matrix complex) (a:complex), (m = n) ->
  ((infix_asdtdt a m) = (infix_asdtdt a n)).

Axiom scalar_eq_gen :
  forall (m:matrix complex) (n:matrix complex) (a:complex) (b:complex),
  (m = n) -> (a = b) -> ((infix_asdtdt a m) = (infix_asdtdt b n)).

Axiom scalar_add :
  forall (m:matrix complex) (a:complex) (b:complex),
  ((infix_asdtdt (infix_pldt a b) m) =
   (add_mat (infix_asdtdt a m) (infix_asdtdt b m))).

Axiom scalar_assoc :
  forall (m:matrix complex) (a:complex) (b:complex),
  ((infix_asdtdt a (infix_asdtdt b m)) = (infix_asdtdt (infix_asdt a b) m)).

Axiom scalar_assoc_rev :
  forall (m:matrix complex) (a:complex) (b:complex),
  ((infix_asdtdt (infix_asdt a b) m) = (infix_asdtdt a (infix_asdtdt b m))).

Axiom scalars_inv :
  forall (m:matrix complex) (a:complex) (b:complex) (a':complex) (b':complex),
  (a = a') -> (b = b') ->
  ((infix_asdtdt a' (infix_asdtdt b' m)) =
   (infix_asdtdt b (infix_asdtdt a m))).

Axiom eq_scalar :
  forall (m:matrix complex) (a:complex) (b:complex),
  (exists i:Z, exists j:Z, (valid_index m i j) /\ ~ ((get m i j) = c_zero)) ->
  ((infix_asdtdt a m) = (infix_asdtdt b m)) -> (a = b).

Parameter mat_substr: (matrix complex) -> (matrix complex) -> matrix complex.

Axiom mat_substr_def :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((mat_substr m n) = (add_mat m (infix_asdtdt (prefix_mndt c_one) n))).

Axiom mat_substr_spec :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ((rows (mat_substr m n)) = (rows m)) /\
  (((columns (mat_substr m n)) = (columns m)) /\
   forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
   ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
   ((get (mat_substr m n) i j) = (infix_mndt (get m i j) (get n i j)))).

Axiom substr_rows :
  forall (m:matrix complex) (n:matrix complex) (r:Z),
  (((rows m) = (rows n)) /\ ((rows n) = r)) -> ((columns m) = (columns n)) ->
  ((rows (mat_substr m n)) = r).

Axiom substr_columns :
  forall (m:matrix complex) (n:matrix complex) (c:Z),
  ((rows m) = (rows n)) ->
  (((columns m) = (columns n)) /\ ((columns n) = c)) ->
  ((columns (mat_substr m n)) = c).

Axiom substr_value :
  forall (m:matrix complex) (n:matrix complex) (i:Z) (j:Z),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((0%Z <= i)%Z /\ (i < (rows m))%Z) ->
  ((0%Z <= j)%Z /\ (j < (columns m))%Z) ->
  ((get (mat_substr m n) i j) = (infix_mndt (get m i j) (get n i j))).

Axiom distr_l_substr :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((columns m) = (rows o)) ->
  ((mat_mult (mat_substr m n) o) =
   (mat_substr (mat_mult m o) (mat_mult n o))).

Axiom distr_r_substr :
  forall (m:matrix complex) (n:matrix complex) (o:matrix complex),
  ((rows n) = (rows o)) -> ((columns n) = (columns o)) ->
  ((columns m) = (rows o)) ->
  ((mat_mult m (mat_substr n o)) =
   (mat_substr (mat_mult m n) (mat_mult m o))).

Axiom mat_substr_eq :
  forall (m:matrix complex) (m':matrix complex) (n:matrix complex)
    (n':matrix complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) -> (m = m') ->
  (n = n') -> ((mat_substr m n) = (mat_substr m' n')).

Axiom substr_decomp :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> (m = (add_mat n (mat_substr m n))).

Axiom subtr_scal :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((infix_asdtdt a (mat_substr m n)) =
   (mat_substr (infix_asdtdt a m) (infix_asdtdt a n))).

Axiom subtr_scal_rev :
  forall (m:matrix complex) (n:matrix complex) (a:complex),
  ((rows m) = (rows n)) -> ((columns m) = (columns n)) ->
  ((mat_substr (infix_asdtdt a m) (infix_asdtdt a n)) =
   (infix_asdtdt a (mat_substr m n))).

Axiom get_equal_mat_to_substr :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) -> (m = n) ->
  ((mat_substr m n) = (make (rows m) (columns m) c_zero)).

Axiom set_inequal_mat_by_substr :
  forall (m:matrix complex) (n:matrix complex), ((rows m) = (rows n)) ->
  ((columns m) = (columns n)) ->
  ~ (m = n) <-> ~ ((mat_substr m n) = (make (rows m) (columns m) c_zero)).

Axiom pow_inv_2_scal :
  forall (i:Z) (x:matrix complex), (0%Z <= i)%Z ->
  ((infix_asdtdt (pow_inv_2 i) x) =
   (infix_asdtdt (pow_inv_sqrt_2 i) (infix_asdtdt (pow_inv_sqrt_2 i) x))).

Axiom pow_inv_2_from_int :
  forall (n:Z), (0%Z <= n)%Z ->
  ((pow_inv_2 n) = (infix_sldt c_one (i_to_c (power 2%Z n)))).

Axiom pow_inv_2_sq_rt :
  forall (n:Z), (0%Z <= n)%Z ->
  ((square_rt (pow_inv_2 n)) = (pow_inv_sqrt_2 n)).

Axiom pow_inv_sqrt_2_double :
  forall (n:Z), (0%Z <= n)%Z ->
  ((pow_inv_sqrt_2 (2%Z * n)%Z) = (pow_inv_2 n)).

Axiom pos_pow_inv_2 :
  forall (i:Z), (0%Z <= i)%Z -> infix_lseqdt c_zero (pow_inv_2 i).

Axiom pos_pow_inv_sqrt_2 :
  forall (i:Z), (0%Z <= i)%Z -> infix_lseqdt c_zero (pow_inv_sqrt_2 i).

Axiom strict_pos_pow_inv_2 :
  forall (i:Z), (0%Z <= i)%Z -> infix_lsdt c_zero (pow_inv_2 i).

Axiom pow_inv_2_add :
  forall (i:Z) (j:Z), (0%Z <= i)%Z -> (0%Z <= j)%Z ->
  ((pow_inv_2 (i + j)%Z) = (infix_asdt (pow_inv_2 i) (pow_inv_2 j))).

Axiom pow_inv_2_plus_one :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 (i + 1%Z)%Z) =
   (infix_asdt (infix_sldt c_one (infix_pldt c_one c_one)) (pow_inv_2 i))).

Axiom pow_inv_2_plus_one_rev :
  forall (i:Z), (0%Z <= i)%Z ->
  ((infix_asdt (infix_sldt c_one (infix_pldt c_one c_one)) (pow_inv_2 i)) =
   (pow_inv_2 (i + 1%Z)%Z)).

Axiom pow_inv_2_with_ :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_2 i) = (infix_sldt c_one (i_to_c (power_ 2%Z i)))).

Axiom pow_inv_2_to_one :
  forall (i:Z), (0%Z <= i)%Z ->
  ((infix_asdt (i_to_c (power_ 2%Z i)) (pow_inv_2 i)) = c_one).

Axiom pow_inv_2_one :
  forall (i:Z), (i = 1%Z) ->
  ((i_to_c (power_ 2%Z i)) = (infix_pldt c_one c_one)).

Axiom pow_inv_2_to_one_gen :
  forall (i:Z) (x:complex), (0%Z <= i)%Z -> (x = (i_to_c (power_ 2%Z i))) ->
  ((infix_asdt (pow_inv_2 i) x) = c_one).

Axiom pow_inv_to_pow_2 :
  forall (k:Z) (l:Z), (0%Z <= l)%Z -> (l <= k)%Z ->
  ((infix_asdt (pow_inv_2 k) (i_to_c (power_ 2%Z l))) =
   (pow_inv_2 (k - l)%Z)).

Parameter neg_pow_inv_sqrt_2: Z -> complex.

Axiom neg_pow_inv_sqrt_2_def :
  forall (i:Z), (0%Z <= i)%Z ->
  ((neg_pow_inv_sqrt_2 i) =
   (cpower
    (infix_sldt (prefix_mndt c_one) (square_rt (infix_pldt c_one c_one))) i)).

Axiom inv_pow_inv_sqrt_2 :
  ((infix_asdt (pow_inv_sqrt_2 1%Z) (square_rt (infix_pldt c_one c_one))) =
   c_one).

Axiom pow_inv_sqrt_2_values :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_sqrt_2 i) =
   (infix_sldt c_one (cpower (square_rt (infix_pldt c_one c_one)) i))).

Axiom neg_pow_inv_sqrt_2_values :
  forall (i:Z), (0%Z <= i)%Z ->
  ((neg_pow_inv_sqrt_2 i) =
   (infix_asdt (mop i)
    (infix_sldt c_one (cpower (square_rt (infix_pldt c_one c_one)) i)))).

Axiom ppos_neg_coeff_values :
  forall (i:Z), (0%Z <= i)%Z ->
  (((even i) = true) -> ((pow_inv_sqrt_2 i) = (neg_pow_inv_sqrt_2 i))) /\
  ((((odd i) = true) ->
    ((pow_inv_sqrt_2 i) = (prefix_mndt (neg_pow_inv_sqrt_2 i)))) /\
   ((neg_pow_inv_sqrt_2 i) = (infix_asdt (mop i) (pow_inv_sqrt_2 i)))).

Parameter pow_inv_sqrt_2_neg: Z -> complex.

Axiom pow_inv_sqrt_2_neg_def :
  forall (i:Z), (0%Z <= i)%Z ->
  ((pow_inv_sqrt_2_neg i) = (prefix_mndt (pow_inv_sqrt_2 i))).

Axiom int_to_ang_to_real_to_ang :
  forall (theta:angle) (k:Z) (n:Z), (0%Z <= n)%Z ->
  (theta = (int_to_ang k n)) ->
  (theta = (real_to_ang (infix_asdt (i_to_c k) (pow_inv_2 n)))).

Axiom real_to_ang_to_int_to_ang :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((real_to_ang (infix_asdt (i_to_c k) (pow_inv_2 n))) = (int_to_ang k n)).

Axiom real_to_ang_to_int_to_ang_add :
  forall (k:Z) (k':Z) (n:Z), (0%Z <= n)%Z ->
  ((real_to_ang
    (infix_asdt (infix_pldt (i_to_c k) (i_to_c k')) (pow_inv_2 n)))
   = (int_to_ang (k + k')%Z n)).

Axiom int_to_ang_to_real_to_ang_gen :
  forall (k:Z) (n:Z) (kx:complex), (0%Z <= n)%Z -> (kx = (i_to_c k)) ->
  ((int_to_ang k n) = (real_to_ang (infix_asdt kx (pow_inv_2 n)))).

Axiom Int_To_Ang_inv :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((ang_inv (int_to_ang k n)) = (int_to_ang (-k)%Z n)).

Axiom Int_To_Ang_inv_add :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((ang_add (int_to_ang k n) (int_to_ang (-k)%Z n)) = ang_zero).

Axiom Int_To_Ang_add :
  forall (k:Z) (k':Z) (n:Z), (0%Z <= n)%Z ->
  ((ang_add (int_to_ang k n) (int_to_ang k' n)) = (int_to_ang (k + k')%Z n)).

Axiom Int_To_Ang_up :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) = (int_to_ang (2%Z * k)%Z (n + 1%Z)%Z)).

Axiom Int_To_Ang_cyclic :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) = (int_to_ang (k + (power_ 2%Z n))%Z n)).

Axiom Zero_n : forall (n:Z), (0%Z <= n)%Z -> ((int_to_ang 0%Z n) = ang_zero).

Axiom set_ang_minus_one_by_int :
  forall (a:Z) (b:Z), (a = 1%Z) -> (b = 1%Z) ->
  ((int_to_ang a b) = (int_to_ang 1%Z 1%Z)).

Axiom ang_minus_one_from_real :
  ((int_to_ang 1%Z 1%Z) =
   (real_to_ang (infix_sldt c_one (infix_pldt c_one c_one)))).

Axiom ang_exp_minus_one :
  ((ang_exp (int_to_ang 1%Z 1%Z)) = (prefix_mndt c_one)).

Axiom set_ang_zero_by_int :
  forall (a:Z) (b:Z), (a = 0%Z) -> (0%Z <= b)%Z ->
  ((int_to_ang a b) = ang_zero).

Axiom ang_minus_one_twice :
  forall (a1:angle) (a2:angle), (a1 = (int_to_ang 1%Z 1%Z)) ->
  (a2 = (int_to_ang 1%Z 1%Z)) -> ((ang_add a1 a2) = ang_zero).

(* Why3 assumption *)
Definition div_two (d:angle) : angle :=
  real_to_ang (infix_sldt (ang_meas d) (infix_pldt c_one c_one)).

Axiom div_two_spec :
  forall (d:angle),
  ((ang_meas (div_two d)) =
   (infix_sldt (ang_meas d) (infix_pldt c_one c_one))) /\
  ((ang_add (div_two d) (div_two d)) = d).

Axiom Div_two : forall (d:angle), ((ang_add (div_two d) (div_two d)) = d).

Axiom div_two_int_to_ang :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= k)%Z /\ (k < (power_ 2%Z n))%Z) ->
  ((div_two (int_to_ang k n)) = (int_to_ang k (n + 1%Z)%Z)).

Axiom ang_exp_mult :
  forall (x:angle) (x':angle),
  ((infix_asdt (ang_exp x) (ang_exp x')) = (ang_exp (ang_add x x'))).

Axiom ang_exp_modulus : forall (x:angle), ((modulus (ang_exp x)) = c_one).

Axiom ang_exp_not_one :
  forall (i:complex), ((infix_lsdt c_zero i) /\ (infix_lsdt i c_one)) ->
  ~ ((ang_exp (real_to_ang i)) = c_one).

Axiom ang_exp_not_by_modulus :
  forall (i:complex), ((infix_lsdt c_zero i) /\ (infix_lsdt i c_one)) ->
  ~ ((ang_exp (real_to_ang (modulus i))) = c_one).

Parameter k_int_to_ang: Z -> angle.

Axiom k_int_to_ang_def :
  forall (k:Z), (0%Z <= k)%Z -> ((k_int_to_ang k) = (int_to_ang 1%Z k)).

Axiom K_int_to_angplus_one :
  forall (k:Z), (0%Z < k)%Z ->
  ((ang_add (k_int_to_ang k) (k_int_to_ang k)) = (k_int_to_ang (k - 1%Z)%Z)).

Parameter phase_inv_pre: Z -> angle -> angle.

Axiom phase_inv_pre_def :
  forall (i:Z) (d:angle), (0%Z <= i)%Z ->
  ((i = 0%Z) -> ((phase_inv_pre i d) = d)) /\
  (~ (i = 0%Z) ->
   ((phase_inv_pre i d) = (ang_inv (phase_inv_pre (i - 1%Z)%Z d)))).

Axiom phase_inv_pre_spec :
  forall (i:Z) (d:angle), (0%Z <= i)%Z ->
  (((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) -> ((phase_inv_pre i d) = d)) /\
  (((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
   ((phase_inv_pre i d) = (ang_inv d))).

Parameter phase_inv_: Z -> angle -> angle.

Axiom phase_inv__def :
  forall (i:Z) (d:angle),
  ((0%Z <= i)%Z -> ((phase_inv_ i d) = (phase_inv_pre i d))) /\
  (~ (0%Z <= i)%Z -> ((phase_inv_ i d) = (phase_inv_pre (-i)%Z d))).

Axiom phase_inv__spec :
  forall (i:Z) (d:angle),
  (((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) -> ((phase_inv_ i d) = d)) /\
  (((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
   ((phase_inv_ i d) = (ang_inv d))).

Axiom Even_phase_inv :
  forall (d:angle), forall (i:Z),
  ((int.EuclideanDivision.mod1 i 2%Z) = 0%Z) -> ((phase_inv_ i d) = d).

Axiom Odd_phase_inv :
  forall (d:angle), forall (i:Z),
  ((int.EuclideanDivision.mod1 i 2%Z) = 1%Z) ->
  ((phase_inv_ i d) = (ang_inv d)).

Axiom Gen_phase_inv :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  ((phase_inv_ i (int_to_ang k n)) =
   (int_to_ang ((power_ (-1%Z)%Z i) * k)%Z n)).

Axiom Gen_phase_inv_neg :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z -> (i < 0%Z)%Z ->
  ((phase_inv_ i (int_to_ang k n)) =
   (int_to_ang ((power_ (-1%Z)%Z (-i)%Z) * k)%Z n)).

Axiom Ang_exp_inv :
  forall (o:angle), ((ang_exp (ang_inv o)) = (infix_sldt c_one (ang_exp o))).

Axiom ang_inv_to_conjugate :
  forall (o:angle), ((ang_exp (ang_inv o)) = (conjugate (ang_exp o))).

Axiom exp_minus :
  forall (x:complex), (real_ x) ->
  ((exp (infix_asdt im (prefix_mndt x))) =
   (conjugate (exp (infix_asdt im x)))).

Axiom conjugate_to_ang_inv :
  forall (o:angle), ((conjugate (ang_exp o)) = (ang_exp (ang_inv o))).

Axiom conjugate_inv_elim :
  forall (o:angle), ((conjugate (ang_exp (ang_inv o))) = (ang_exp o)).

Axiom ang_exp_neg_conjugate :
  forall (x:complex), (real_ x) ->
  ((ang_exp (real_to_ang (prefix_mndt x))) =
   (conjugate (ang_exp (real_to_ang x)))).

Axiom ang_exp_neg_conjugate_rev :
  forall (x:complex), (real_ x) ->
  ((conjugate (ang_exp (real_to_ang x))) =
   (ang_exp (real_to_ang (prefix_mndt x)))).

Axiom ang_mult_int_in :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((ang_mult_int (int_to_ang k n) i) = (int_to_ang (i * k)%Z n)).

Axiom ang_mult_int_out :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang (i * k)%Z n) = (ang_mult_int (int_to_ang k n) i)).

Axiom int_to_ang_cycles :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  ((int_to_ang (k + (i * (power_ 2%Z n))%Z)%Z n) = (int_to_ang k n)).

Axiom int_to_ang_eq :
  forall (k1:Z) (k2:Z) (n1:Z) (n2:Z), (k1 = k2) -> (n1 = n2) ->
  ((int_to_ang k1 n1) = (int_to_ang k2 n2)).

Axiom int_to_ang_cycles_neg :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z -> (i <= 0%Z)%Z ->
  ((int_to_ang (k + (i * (power_ 2%Z n))%Z)%Z n) = (int_to_ang k n)).

Axiom int_to_ang_cycles_gen :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((int_to_ang (k + (i * (power_ 2%Z n))%Z)%Z n) = (int_to_ang k n)).

Axiom int_to_ang_cycles_zero :
  forall (n':Z) (n:Z), ((0%Z <= n)%Z /\ (n <= n')%Z) ->
  ((int_to_ang (power_ 2%Z n') n) = ang_zero).

Axiom int_to_ang_cycles_zero_mult :
  forall (k:Z) (n':Z) (n:Z), ((0%Z <= n)%Z /\ (n <= n')%Z) ->
  ((int_to_ang (k * (power_ 2%Z n'))%Z n) = ang_zero).

Axiom int_to_ang_cycles_zero_mult_ :
  forall (k:Z) (n':Z) (n:Z), ((0%Z <= n)%Z /\ (n <= n')%Z) ->
  ((int_to_ang (k * (power_ 2%Z n'))%Z n) = ang_zero).

Axiom int_to_ang_up :
  forall (k:Z) (n:Z) (n':Z), (0%Z <= n)%Z -> (0%Z <= n')%Z ->
  ((int_to_ang (k * (power_ 2%Z n'))%Z (n + n')%Z) = (int_to_ang k n)).

Axiom int_to_ang_mod :
  forall (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang k n) =
   (int_to_ang (int.EuclideanDivision.mod1 k (power_ 2%Z n)) n)).

Axiom int_to_ang_equiv :
  forall (k1:Z) (k2:Z) (n1:Z) (n2:Z), (0%Z <= n1)%Z ->
  ((int.EuclideanDivision.mod1 k1 (power_ 2%Z n1)) =
   (int.EuclideanDivision.mod1 k2 (power_ 2%Z n1))) ->
  (n1 = n2) -> ((int_to_ang k1 n1) = (int_to_ang k2 n2)).

Axiom int_to_ang_red :
  forall (k:Z) (n:Z), (1%Z <= n)%Z -> ~ (0%Z = k) ->
  ((int.EuclideanDivision.mod1 k 2%Z) = 0%Z) ->
  ((int_to_ang k n) =
   (int_to_ang (int.EuclideanDivision.div k 2%Z) (n - 1%Z)%Z)).

Axiom int_to_ang_bin_rev :
  forall (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  (j = (n - 1%Z)%Z) ->
  ((int_to_ang (-(i * (power_ 2%Z j))%Z)%Z n) =
   (int_to_ang (i * (power_ 2%Z (n - 1%Z)%Z))%Z n)).

Axiom int_to_ang_bin_rev_ :
  forall (n:Z) (i:Z) (j:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  (j = (n - 1%Z)%Z) ->
  ((int_to_ang (-(i * (power_ 2%Z j))%Z)%Z n) =
   (int_to_ang (i * (power_ 2%Z (n - 1%Z)%Z))%Z n)).

Axiom int_to_ang_add_rev :
  forall (i:Z) (j:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_ang (i + j)%Z n) = (ang_add (int_to_ang i n) (int_to_ang j n))).

Axiom int_to_ang_ind_isum_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (f i) n) (int_to_ang (ind_isum f (i + 1%Z)%Z j) n))).

Axiom int_to_ang_ind_isum_plus_one_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (ind_isum f (i + 1%Z)%Z j) n) (int_to_ang (f i) n))).

Axiom int_to_ang_ind_isum_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (ind_isum f i (j - 1%Z)%Z) n)
    (int_to_ang (f (j - 1%Z)%Z) n))).

Axiom int_to_ang_ind_isum_right_extension_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (ind_isum f i j) n) =
   (ang_add (int_to_ang (f (j - 1%Z)%Z) n)
    (int_to_ang (ind_isum f i (j - 1%Z)%Z) n))).

Axiom minus_int_to_ang_ind_isum_plus_one :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(f i))%Z n)
    (int_to_ang (-(ind_isum f (i + 1%Z)%Z j))%Z n))).

Axiom minus_int_to_ang_ind_isum_plus_one_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(ind_isum f (i + 1%Z)%Z j))%Z n)
    (int_to_ang (-(f i))%Z n))).

Axiom minus_int_to_ang_ind_isum_right_extension :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(ind_isum f i (j - 1%Z)%Z))%Z n)
    (int_to_ang (-(f (j - 1%Z)%Z))%Z n))).

Axiom minus_int_to_ang_ind_isum_right_extension_rev :
  forall (f:Z -> Z) (i:Z) (j:Z) (n:Z), (i < j)%Z -> (0%Z <= n)%Z ->
  ((int_to_ang (-(ind_isum f i j))%Z n) =
   (ang_add (int_to_ang (-(f (j - 1%Z)%Z))%Z n)
    (int_to_ang (-(ind_isum f i (j - 1%Z)%Z))%Z n))).

Axiom int_to_ang_simpl :
  forall (k:Z) (n1:Z) (n2:Z), (0%Z <= n1)%Z -> (0%Z <= n2)%Z ->
  ((int_to_ang (k * (power_ 2%Z n1))%Z (n2 + n1)%Z) = (int_to_ang k n2)).

Axiom ang_add_eq :
  forall (d1:angle) (d2:angle) (e1:angle) (e2:angle), (d1 = e1) ->
  (d2 = e2) -> ((ang_add d1 d2) = (ang_add e1 e2)).

Axiom ang_add_comm :
  forall (d1:angle) (d2:angle), ((ang_add d1 d2) = (ang_add d2 d1)).

Axiom ang_add_eq_comm :
  forall (d1:angle) (d2:angle) (d3:angle) (d4:angle), (d1 = d3) ->
  (d2 = d4) -> ((ang_add d1 d2) = (ang_add d4 d3)).

Axiom ang_mult_int_zero :
  forall (theta:angle), ((ang_mult_int theta 0%Z) = ang_zero).

Axiom ang_div :
  forall (k:Z) (n:Z) (i:Z), (0%Z <= n)%Z -> (0%Z <= i)%Z ->
  ((int_to_ang k n) = (ang_mult_int (int_to_ang k (n + i)%Z) (power_ 2%Z i))).

Axiom ang_zero_add :
  forall (d':angle) (d:angle), (d' = ang_zero) -> ((ang_add d' d) = d).

Axiom int_to_ang_rev :
  forall (k:Z) (l:Z) (n:Z) (m:Z), (0%Z < n)%Z -> (0%Z <= k)%Z ->
  (n = (m + 1%Z)%Z) ->
  ((int_to_ang (((-k)%Z * l)%Z * (power_ 2%Z m))%Z n) =
   (int_to_ang ((k * l)%Z * (power_ 2%Z m))%Z n)).

Axiom int_to_ang_rev_ :
  forall (k:Z) (l:Z) (n:Z) (m:Z), (0%Z < n)%Z -> (0%Z <= k)%Z ->
  (0%Z <= l)%Z -> (n = (m + 1%Z)%Z) ->
  ((int_to_ang (((-k)%Z * l)%Z * (power_ 2%Z m))%Z n) =
   (int_to_ang ((k * l)%Z * (power_ 2%Z m))%Z n)).

Axiom ang_add_zero_d :
  forall (d':angle) (d:angle), (d' = ang_zero) -> ((ang_add d d') = d).

Axiom real_to_ang_distr_minus :
  forall (x:complex) (z:complex) (t:complex), forall (y:Z), (real_ x) ->
  (real_ z) -> (real_ t) ->
  ((ang_add (real_to_ang (infix_asdt x (i_to_c y)))
    (real_to_ang (infix_asdt (infix_asdt (i_to_c y) (prefix_mndt z)) t)))
   = (ang_mult_int (real_to_ang (infix_mndt x (infix_asdt z t))) y)).

Axiom ang_mult_int_exp_pos :
  forall (o:angle) (i:Z), (0%Z <= i)%Z ->
  ((ang_exp (ang_mult_int o i)) = (cpower (ang_exp o) i)).

Axiom ang_mult_int_exp :
  forall (o:angle) (i:Z),
  ((ang_exp (ang_mult_int o i)) = (cpower (ang_exp o) i)).

Axiom ang_mult_int_exp_rev :
  forall (o:angle) (i:Z),
  ((cpower (ang_exp o) i) = (ang_exp (ang_mult_int o i))).

Axiom cpower_ang_exp_real :
  forall (x:complex) (i:Z), (real_ x) ->
  ((cpower (ang_exp (real_to_ang x)) i) =
   (ang_exp (real_to_ang (infix_asdt x (i_to_c i))))).

Axiom ang_mult_int_add :
  forall (o:angle) (i:Z) (i':Z),
  ((ang_mult_int o (i + i')%Z) =
   (ang_add (ang_mult_int o i) (ang_mult_int o i'))).

Axiom ang_mult_int_plus_one :
  forall (o:angle) (i:Z),
  ((ang_add o (ang_mult_int o i)) = (ang_mult_int o (i + 1%Z)%Z)).

Axiom ang_mult_int_plus_one_rev :
  forall (o:angle) (i:Z),
  ((ang_mult_int o (1%Z + i)%Z) = (ang_add o (ang_mult_int o i))).

Axiom ang_mult_int_double :
  forall (o:angle) (i:Z),
  ((ang_mult_int o (2%Z * i)%Z) =
   (ang_add (ang_mult_int o i) (ang_mult_int o i))).

Axiom ang_mult_int_inv_one :
  forall (o:angle), ((ang_mult_int o (-1%Z)%Z) = (ang_inv o)).

Axiom ang_mult_int_one :
  forall (o:angle) (n:Z), (n = 1%Z) -> ((ang_mult_int o n) = o).

Axiom ang_mult_int_inv_rev :
  forall (o:angle), ((ang_inv o) = (ang_mult_int o (-1%Z)%Z)).

Axiom ang_mult_int_comp :
  forall (o:angle) (i:Z) (j:Z),
  ((ang_mult_int (ang_mult_int o i) j) = (ang_mult_int o (i * j)%Z)).

Axiom ang_mult_int_comp_rev :
  forall (o:angle) (i:Z) (j:Z),
  ((ang_mult_int o (i * j)%Z) = (ang_mult_int (ang_mult_int o i) j)).

Axiom add_ang_mult_int_pos :
  forall (o:angle) (o':angle) (i:Z), (0%Z <= i)%Z ->
  ((ang_add (ang_mult_int o i) (ang_mult_int o' i)) =
   (ang_mult_int (ang_add o o') i)).

Axiom add_ang_mult_int :
  forall (o:angle) (o':angle) (i:Z),
  ((ang_add (ang_mult_int o i) (ang_mult_int o' i)) =
   (ang_mult_int (ang_add o o') i)).

(* Why3 assumption *)
Definition ang_substr (o:angle) (o':angle) : angle := ang_add o (ang_inv o').

Axiom ang_substr_inv :
  forall (o:angle) (o':angle),
  ((ang_substr o (ang_mult_int o' (-1%Z)%Z)) = (ang_add o o')).

Axiom ang_mult_int_distr :
  forall (o:angle) (o':angle) (n:Z),
  ((ang_mult_int (ang_add o o') n) =
   (ang_add (ang_mult_int o n) (ang_mult_int o' n))).

Axiom ang_mult_int_distr_rev :
  forall (o:angle) (n1:Z) (n2:Z),
  ((ang_add (ang_mult_int o n1) (ang_mult_int o n2)) =
   (ang_mult_int o (n1 + n2)%Z)).

Axiom ang_add_assoc :
  forall (o:angle) (o':angle) (o'':angle),
  ((ang_add o (ang_add o' o'')) = (ang_add (ang_add o o') o'')).

Axiom ang_add_assoc_rev :
  forall (o:angle) (o':angle) (o'':angle),
  ((ang_add (ang_add o o') o'') = (ang_add o (ang_add o' o''))).

Axiom ang_add_own_inv :
  forall (o:angle), ((ang_add (ang_mult_int o (-1%Z)%Z) o) = ang_zero).

Axiom ang_exp_inv :
  forall (o:angle), ((ang_exp (ang_inv o)) = (conjugate (ang_exp o))).

(* Why3 assumption *)
Definition binary (t:Z -> Z) : Prop :=
  forall (k:Z), (0%Z <= (t k))%Z /\ ((t k) < 2%Z)%Z.

Axiom set_binary :
  forall (t:Z -> Z), (forall (k:Z), (0%Z <= (t k))%Z /\ ((t k) < 2%Z)%Z) ->
  binary t.

Axiom get_binary :
  forall (t:Z -> Z), (binary t) -> forall (k:Z),
  (0%Z <= (t k))%Z /\ ((t k) < 2%Z)%Z.

(* Why3 assumption *)
Definition shift {a:Type} {a_WT:WhyType a} (f:Z -> a) (i:Z) (k:Z) : a :=
  f (k + i)%Z.

Axiom shift_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (i:Z) (k:Z), ((shift f i k) = (f (k + i)%Z)).

Axiom shiftz :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z), ((shift f 0%Z k) = (f k)).

Axiom shiftz_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (i:Z) (k:Z), (i = 0%Z) -> ((shift f i k) = (f k)).

Axiom shiftz_quant :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a),
  ((((fun (y0:Z -> a) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) 0%Z) = f).

Axiom shiftz_quant_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a),
  (f = (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) 0%Z)).

Parameter concat_fun:
  forall {a:Type} {a_WT:WhyType a}, (Z -> a) -> (Z -> a) -> Z -> Z -> a.

Axiom concat_fun_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (g:Z -> a) (i:Z) (k:Z),
  ((k < i)%Z -> ((concat_fun f g i k) = (f k))) /\
  (~ (k < i)%Z -> ((concat_fun f g i k) = (g (k - i)%Z))).

Axiom shift_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (i:Z) (j:Z) (k:Z),
  ((shift (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) j) i k) =
   (shift f (i + j)%Z k)).

Axiom concat_fun_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (g:Z -> a) (i:Z) (k:Z),
  ((k < i)%Z -> ((concat_fun f g i k) = (f k))) /\
  (~ (k < i)%Z -> ((concat_fun f g i k) = (g (k - i)%Z))).

Axiom concat_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (f1:Z -> a) (g1:Z -> a) (f2:Z -> a) (g2:Z -> a) (i1:Z) (i2:Z) (k:Z),
  (forall (l:Z), (l < i1)%Z -> ((f1 l) = (f2 l))) ->
  (forall (l:Z), (0%Z <= l)%Z -> ((g1 l) = (g2 l))) -> (i1 = i2) ->
  ((concat_fun f1 g1 i1 k) = (concat_fun f2 g2 i2 k)).

Parameter mod_func:
  forall {a:Type} {a_WT:WhyType a}, (Z -> a) -> Z -> Z -> a.

Axiom mod_func_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (0%Z < k)%Z ->
  ((mod_func f k i) = (f (int.EuclideanDivision.mod1 i k))).

Axiom mod_func_inf :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < k)%Z) -> ((mod_func f k i) = (f i)).

Axiom shift_mod :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (0%Z < k)%Z ->
  ((mod_func f k i) =
   (shift (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (mod_func y0 y1 y2)) f) k) k i)).

Axiom shift_mod_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:Z -> a) (k:Z) (i:Z), (0%Z < k)%Z ->
  ((shift (((fun (y0:Z -> a) (y1:Z) (y2:Z) => (mod_func y0 y1 y2)) f) k) k i)
   = (mod_func f k i)).

Parameter head_bit: Z -> Z -> Z.

Axiom head_bit_def :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((head_bit i k) = (int.EuclideanDivision.div i (power 2%Z (k - 1%Z)%Z))).

Axiom head_bit_spec :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  (0%Z <= (head_bit i k))%Z /\ ((head_bit i k) <= 1%Z)%Z.

Parameter tail_bits: Z -> Z -> Z.

Axiom tail_bits_def :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((tail_bits i k) = (int.EuclideanDivision.mod1 i (power 2%Z (k - 1%Z)%Z))).

Axiom tail_bits_spec :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  (0%Z <= (tail_bits i k))%Z /\
  ((tail_bits i k) <= (power 2%Z (k - 1%Z)%Z))%Z.

Parameter ht_to_int: Z -> Z -> Z -> Z.

Axiom ht_to_int_def :
  forall (hi:Z) (ti:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= hi)%Z /\ (hi < 2%Z)%Z) ->
  ((0%Z <= ti)%Z /\ (ti < (power 2%Z (k - 1%Z)%Z))%Z) ->
  ((ht_to_int hi ti k) = ((hi * (power 2%Z (k - 1%Z)%Z))%Z + ti)%Z).

Axiom head_tail_inv :
  forall (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((ht_to_int (head_bit i k) (tail_bits i k) k) = i).

Axiom ht_to_int_head :
  forall (i:Z) (ti:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((0%Z <= ti)%Z /\ (ti < (power 2%Z (k - 1%Z)%Z))%Z) ->
  ((head_bit (ht_to_int (head_bit i k) ti k) k) = (head_bit i k)).

Axiom ht_to_int_tail :
  forall (hi:Z) (i:Z) (k:Z), (0%Z < k)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((0%Z <= hi)%Z /\ (hi < 2%Z)%Z) ->
  ((tail_bits (ht_to_int hi (tail_bits i k) k) k) = (tail_bits i k)).

Axiom concat_fun_bin_i :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z) (k:Z), (binary f) -> (binary g) ->
  (0%Z <= (concat_fun f g i k))%Z /\ ((concat_fun f g i k) < 2%Z)%Z.

Axiom shift_bin_i :
  forall (f:Z -> Z) (i:Z) (k:Z), (binary f) ->
  (0%Z <= (shift f i k))%Z /\ ((shift f i k) < 2%Z)%Z.

Axiom concat_fun_bin :
  forall (f:Z -> Z) (g:Z -> Z) (i:Z), (binary f) -> (binary g) ->
  binary
  ((((fun (y0:Z -> Z) (y1:Z -> Z) (y2:Z) (y3:Z) => (concat_fun y0 y1 y2 y3))
     f)
    g)
   i).

Axiom mod_func_bin :
  forall (f:Z -> Z) (k:Z), (0%Z < k)%Z -> (binary f) ->
  binary (((fun (y0:Z -> Z) (y1:Z) (y2:Z) => (mod_func y0 y1 y2)) f) k).

Axiom shift_bin :
  forall (f:Z -> Z) (i:Z), (binary f) ->
  binary (((fun (y0:Z -> Z) (y1:Z) (y2:Z) => (shift y0 y1 y2)) f) i).

Axiom binary_comp :
  forall (f:Z -> Z) (g:Z -> Z), (binary f) -> binary (fun (x:Z) => (f (g x))).

Axiom set_is_all_binary :
  forall (t:Z -> Z), (forall (k:Z), (0%Z <= (t k))%Z /\ ((t k) < 2%Z)%Z) ->
  binary t.

Parameter nary_length: Z -> Z -> Z.

Axiom nary_length_spec :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z ->
  ((0%Z < i)%Z ->
   ((power n ((nary_length i n) - 1%Z)%Z) <= i)%Z /\
   (i < (power n (nary_length i n)))%Z) /\
  (((i < n)%Z -> ((nary_length i n) = 1%Z)) /\
   ((1%Z <= (nary_length i n))%Z /\
    (i = (int.EuclideanDivision.mod1 i (power n (nary_length i n)))))).

Parameter binary_length: Z -> Z.

Axiom binary_length_def :
  forall (i:Z), (0%Z <= i)%Z -> ((binary_length i) = (nary_length i 2%Z)).

Axiom binary_length_spec :
  forall (i:Z), (0%Z <= i)%Z ->
  ((0%Z < i)%Z ->
   ((power 2%Z ((binary_length i) - 1%Z)%Z) <= i)%Z /\
   (i < (power 2%Z (binary_length i)))%Z) /\
  (((i < 2%Z)%Z -> ((binary_length i) = 1%Z)) /\
   ((1%Z <= (binary_length i))%Z /\
    (i = (int.EuclideanDivision.mod1 i (power 2%Z (binary_length i)))))).

Axiom set_binary_length :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z <= k)%Z ->
  ((0%Z < i)%Z -> ((power 2%Z (k - 1%Z)%Z) <= i)%Z /\ (i < (power 2%Z k))%Z) ->
  ((i < 2%Z)%Z -> (k = 1%Z)) -> (k = (binary_length i)).

Axiom set_binary_length_b :
  forall (i:Z) (k:Z), (0%Z <= i)%Z -> (0%Z < k)%Z -> (i < (power 2%Z k))%Z ->
  ((binary_length i) <= k)%Z.

(* Why3 assumption *)
Definition constant_size {a:Type} {a_WT:WhyType a} (s:set a)
    (f:a -> matrix complex) : Prop :=
  forall (e:a), (mem e s) ->
  ((rows (f e)) = (rows (f (choose s)))) /\
  ((columns (f e)) = (columns (f (choose s)))).

Axiom set_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex),
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((rows (f e)) = (rows (f e')))) ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((columns (f e)) = (columns (f e')))) ->
  constant_size s f.

Axiom set_constant_size_exists :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex),
  (exists r:Z, forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (exists c:Z, forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  constant_size s f.

Axiom set_constant_size_t :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z) (c:Z),
  (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) -> constant_size s f.

Parameter fc5:
  forall {a:Type} {a_WT:WhyType a}, (a -> matrix complex) -> (a -> bool) ->
  (matrix complex) -> a -> matrix complex.

Axiom fc_def5 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (p:a -> bool) (m:matrix complex) (j:a),
  (((p j) = true) -> (((fc5 f p m) j) = (f j))) /\
  (~ ((p j) = true) -> (((fc5 f p m) j) = m)).

Axiom guarded_set_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (p:a -> bool) (m:matrix complex),
  (constant_size s f) -> (forall (e:a), (mem e s) -> ((p e) = true)) ->
  constant_size s (fc5 f p m).

Axiom set_constant_size_set :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> complex) (m:matrix complex) (i:Z) (j:Z),
  (valid_index m i j) -> constant_size s (fun (e:a) => (set1 m i j (f e))).

Axiom get_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((rows (f e)) = (rows (f e')))) /\
  forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
  ((columns (f e)) = (columns (f e'))).

Parameter s_rows:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix complex) -> Z.

Axiom s_rows_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  ((s_rows s f) = (rows (f (choose s)))).

Axiom s_rows_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  (0%Z < (s_rows s f))%Z /\
  ((forall (e:a), (mem e s) -> ((rows (f e)) = (s_rows s f))) /\
   forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((rows (f e)) = (rows (f e')))).

Parameter s_columns:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix complex) -> Z.

Axiom s_columns_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  ((s_columns s f) = (columns (f (choose s)))).

Axiom s_columns_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  (0%Z < (s_columns s f))%Z /\
  ((forall (e:a), (mem e s) -> ((columns (f e)) = (s_columns s f))) /\
   forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((columns (f e)) = (columns (f e')))).

Axiom set_s_rows :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z), (constant_size s f) ->
  ((rows (f (choose s))) = r) -> ((s_rows s f) = r).

Axiom set_s_rows_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (elt:a), (constant_size s f) ->
  (mem elt s) -> ((s_rows s f) = (rows (f elt))).

Axiom set_s_columns :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z), (constant_size s f) ->
  ((columns (f (choose s))) = r) -> ((s_columns s f) = r).

Axiom set_s_columns_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (elt:a), (constant_size s f) ->
  (mem elt s) -> ((s_columns s f) = (columns (f elt))).

Axiom s_rows_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (g:a -> matrix complex),
  (constant_size s f) -> (0%Z < (cardinal s))%Z ->
  (forall (e:a), (mem e s) -> ((f e) = (g e))) ->
  ((s_rows s f) = (s_rows s g)).

Axiom set_constant_size_give :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z) (c:Z),
  (0%Z < (cardinal s))%Z ->
  (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  (constant_size s f) /\
  ((forall (e:a), (mem e s) -> ((rows (f e)) = r)) /\
   ((forall (e:a), (mem e s) -> ((columns (f e)) = c)) /\
    (((s_rows s f) = r) /\ ((s_columns s f) = c)))).

Axiom s_columns_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (g:a -> matrix complex),
  (constant_size s f) -> (0%Z < (cardinal s))%Z ->
  (forall (e:a), (mem e s) -> ((f e) = (g e))) ->
  ((s_columns s f) = (s_columns s g)).

Axiom subset_constant_size :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix complex), (constant_size s f) ->
  ~ (is_empty s') -> (subset s' s) ->
  (constant_size s' f) /\
  (((s_rows s' f) = (s_rows s f)) /\ ((s_columns s' f) = (s_columns s f))).

Axiom set_s_rows_rem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (1%Z < (cardinal s))%Z ->
  (constant_size s f) ->
  (constant_size (remove (choose s) s) f) /\
  ((s_rows (remove (choose s) s) f) = (rows (f (choose s)))).

Axiom set_s_columns_rem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (1%Z < (cardinal s))%Z ->
  (constant_size s f) ->
  (constant_size (remove (choose s) s) f) /\
  ((s_columns (remove (choose s) s) f) = (columns (f (choose s)))).

Axiom set_s_rows_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (x:a), (0%Z < (cardinal s))%Z ->
  (constant_size s f) -> ((columns (f x)) = (s_columns s f)) ->
  ((rows (f x)) = (s_rows s f)) -> ((s_rows (add x s) f) = (s_rows s f)).

Axiom set_s_columns_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (x:a), (0%Z < (cardinal s))%Z ->
  (constant_size s f) -> ((columns (f x)) = (s_columns s f)) ->
  ((rows (f x)) = (s_rows s f)) ->
  ((s_columns (add x s) f) = (s_columns s f)).

Axiom set_s_rows_columns_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (x:a), (0%Z < (cardinal s))%Z ->
  (constant_size s f) -> ((columns (f x)) = (s_columns s f)) ->
  ((rows (f x)) = (s_rows s f)) ->
  ((s_columns (add x s) f) = (s_columns s f)) /\
  ((s_rows (add x s) f) = (s_rows s f)).

Parameter mat_sum:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix complex) ->
  matrix complex.

Axiom mat_sum_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  (0%Z < (cardinal s))%Z ->
  (((cardinal s) = 1%Z) -> ((mat_sum s f) = (f (element s)))) /\
  (~ ((cardinal s) = 1%Z) ->
   ((mat_sum s f) =
    (add_mat (f (choose s)) (mat_sum (remove (choose s) s) f)))).

Axiom mat_sum_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  (0%Z < (cardinal s))%Z ->
  ((rows (mat_sum s f)) = (s_rows s f)) /\
  (((columns (mat_sum s f)) = (s_columns s f)) /\
   ((forall (e:a), (mem e s) -> ((rows (f e)) = (s_rows s f))) /\
    forall (e:a), (mem e s) -> ((columns (f e)) = (s_columns s f)))).

Axiom columns_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (n:Z), ~ ((cardinal s) = 0%Z) ->
  (constant_size s f) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = n)) ->
  ((columns (mat_sum s f)) = n).

Axiom rows_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (n:Z), ~ ((cardinal s) = 0%Z) ->
  (constant_size s f) -> (forall (e:a), (mem e s) -> ((rows (f e)) = n)) ->
  ((rows (mat_sum s f)) = n).

Axiom mat_sum_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), ((cardinal s) = 1%Z) ->
  ((mat_sum s f) = (f (element s))).

Axiom mat_sum_to_sum_pre :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (i:Z) (j:Z),
  (constant_size s f) -> (0%Z < (cardinal s))%Z ->
  ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
  ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
  ((get (mat_sum s f) i j) = (sum s (fun (e:a) => (get (f e) i j)))).

Axiom mat_sum_to_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (constant_size s f) ->
  (0%Z < (cardinal s))%Z ->
  ((mat_sum s f) =
   (make_f (s_rows s f) (s_columns s f)
    (fun (i:Z) (j:Z) => (sum s (fun (e:a) => (get (f e) i j)))))).

Axiom mat_sum_value :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (i:Z) (j:Z),
  (constant_size s f) -> (0%Z < (cardinal s))%Z ->
  (valid_index (mat_sum s f) i j) ->
  ((get (mat_sum s f) i j) = (sum s (fun (e:a) => (get (f e) i j)))).

Axiom mat_sum_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (x:a), (0%Z < (cardinal s))%Z ->
  (constant_size s f) -> ((rows (f x)) = (s_rows s f)) ->
  ((columns (f x)) = (s_columns s f)) -> ~ (mem x s) ->
  ((mat_sum (add x s) f) = (add_mat (f x) (mat_sum s f))).

Axiom mat_sum_plus_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex), (1%Z < (cardinal s))%Z ->
  (constant_size s f) ->
  ((mat_sum s f) =
   (add_mat (f (choose s)) (mat_sum (remove (choose s) s) f))).

Axiom mat_sum_comp_pre :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix complex) (g:b -> matrix complex) (i:Z)
    (j:Z),
  (constant_size s f) -> (constant_size s g) ->
  ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
  ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
  ((s_rows s f) = (s_rows s g)) -> ((s_columns s f) = (s_columns s g)) ->
  (0%Z < (cardinal s))%Z ->
  ((get (mat_sum s (fun (k:b) => (add_mat (f k) (g k)))) i j) =
   (get (add_mat (mat_sum s f) (mat_sum s g)) i j)).

Axiom mat_sum_comp :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix complex) (g:b -> matrix complex),
  (constant_size s f) -> (constant_size s g) ->
  ((s_rows s f) = (s_rows s g)) -> ((s_columns s f) = (s_columns s g)) ->
  (0%Z < (cardinal s))%Z ->
  ((mat_sum s (fun (k:b) => (add_mat (f k) (g k)))) =
   (add_mat (mat_sum s f) (mat_sum s g))).

Axiom mat_sum_comp_rec :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix complex) (g:b -> matrix complex),
  (constant_size s f) -> (constant_size s g) ->
  ((s_rows s f) = (s_rows s g)) -> ((s_columns s f) = (s_columns s g)) ->
  (0%Z < (cardinal s))%Z ->
  ((add_mat (mat_sum s f) (mat_sum s g)) =
   (mat_sum s (fun (k:b) => (add_mat (f k) (g k))))).

Axiom mat_sum_to_sum_fun :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (s':set b) (f:a -> b -> matrix complex) (r:Z) (c:Z) 
    (i:Z) (j:Z),
  (0%Z < (cardinal s))%Z -> (0%Z < (cardinal s'))%Z ->
  (forall (e:a), forall (e1:b), (mem e s) -> (mem e1 s') ->
   ((rows ((f e) e1)) = r)) ->
  (forall (e:a), forall (e1:b), (mem e s) -> (mem e1 s') ->
   ((columns ((f e) e1)) = c)) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  ((sum s (fun (e:a) => (get (mat_sum s' (f e)) i j))) =
   (sum s (fun (e:a) => (sum s' (fun (e1:b) => (get ((f e) e1) i j)))))).

Axiom mat_sum_to_sum_double_pre :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (s':set b) (f:a -> b -> matrix complex) (r:Z) (c:Z) 
    (i:Z) (j:Z),
  (forall (e:a) (e':b), (mem e s) -> (mem e' s') -> ((rows ((f e) e')) = r)) ->
  (forall (e:a) (e':b), (mem e s) -> (mem e' s') ->
   ((columns ((f e) e')) = c)) ->
  ((0%Z <= i)%Z /\ (i < r)%Z) -> ((0%Z <= j)%Z /\ (j < c)%Z) ->
  (0%Z < (cardinal s))%Z -> (0%Z < (cardinal s'))%Z ->
  ((get (mat_sum s (fun (e:a) => (mat_sum s' (f e)))) i j) =
   (sum s (fun (e:a) => (sum s' (fun (e':b) => (get ((f e) e') i j)))))).

Axiom mat_mult_sum_out_l :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (n:matrix complex),
  (0%Z < (cardinal s))%Z ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = (rows n))) ->
  (exists r:Z, forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  ((mat_mult (mat_sum s f) n) =
   (mat_sum s (fun (e:a) => (mat_mult (f e) n)))).

Parameter mat_sum_dim:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (a -> matrix complex) -> 
  Z -> Z -> matrix complex.

Axiom mat_sum_dim_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  (((cardinal s) = 0%Z) -> ((mat_sum_dim s f r c) = (make r c c_zero))) /\
  (~ ((cardinal s) = 0%Z) -> ((mat_sum_dim s f r c) = (mat_sum s f))).

Axiom mat_sum_dim_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  ((0%Z < (cardinal s))%Z -> ((mat_sum_dim s f r c) = (mat_sum s f))) /\
  ((((cardinal s) = 0%Z) -> ((mat_sum_dim s f r c) = (make r c c_zero))) /\
   (((rows (mat_sum_dim s f r c)) = r) /\
    ((columns (mat_sum_dim s f r c)) = c))).

Axiom mat_sum_dim_to_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z) (c:Z),
  (0%Z < (cardinal s))%Z -> (0%Z < r)%Z -> (0%Z < c)%Z ->
  (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  ((mat_sum_dim s f r c) = (mat_sum s f)).

Axiom mat_sum_dim_to_make_zero :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (r:Z) (c:Z),
  ((cardinal s) = 0%Z) -> (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) -> (0%Z < r)%Z ->
  (0%Z < c)%Z -> ((mat_sum_dim s f r c) = (make r c c_zero)).

Axiom mat_sum_dim_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (x:a) (r:Z) (c:Z),
  (0%Z <= (cardinal s))%Z -> ~ (mem x s) ->
  (forall (e:a), (mem e (add x s)) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e (add x s)) -> ((columns (f e)) = c)) ->
  (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((mat_sum_dim (add x s) f r c) = (add_mat (f x) (mat_sum_dim s f r c))).

Axiom mat_sum_scalar :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (a1:complex),
  (constant_size s f) -> (0%Z < (cardinal s))%Z ->
  ((mat_sum s (fun (k:a) => (infix_asdtdt a1 (f k)))) =
   (infix_asdtdt a1 (mat_sum s f))).

Axiom mat_sum_scalar_rev :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (a1:complex),
  (constant_size s f) -> (0%Z < (cardinal s))%Z ->
  ((infix_asdtdt a1 (mat_sum s f)) =
   (mat_sum s (fun (k:a) => (infix_asdtdt a1 (f k))))).

Axiom mat_sum_const :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:matrix complex), (0%Z < (cardinal s))%Z ->
  ((mat_sum s (fun (us:a) => x)) = (infix_asdtdt (i_to_c (cardinal s)) x)).

Axiom mat_sum_quot :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (x:matrix complex), (0%Z < (cardinal s))%Z ->
  (x =
   (infix_asdtdt (infix_sldt c_one (i_to_c (cardinal s)))
    (mat_sum s (fun (us:a) => x)))).

Axiom mat_sum_scalar_right :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (m:matrix complex) (i:Z) (j:Z),
  (constant_size s f) -> (0%Z < (cardinal s))%Z ->
  ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
  ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
  ((infix_asdtdt (get (mat_sum s f) i j) m) =
   (mat_sum s (fun (k:a) => (infix_asdtdt (get (f k) i j) m)))).

Axiom mat_sum_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (g:a -> matrix complex),
  (0%Z < (cardinal s))%Z -> (constant_size s f) ->
  (forall (a1:a), (mem a1 s) -> ((f a1) = (g a1))) ->
  ((mat_sum s f) = (mat_sum s g)).

Axiom mat_sum_eq_gen :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s':set a) (f:a -> matrix complex) (g:a -> matrix complex),
  (0%Z < (cardinal s))%Z -> (s = s') -> (constant_size s f) ->
  (forall (a1:a), (mem a1 s) -> ((f a1) = (g a1))) ->
  ((mat_sum s f) = (mat_sum s' g)).

Axiom mat_sum_eq_gen_int :
  forall (i1:Z) (i2:Z) (o1:Z) (o2:Z) (f:Z -> matrix complex)
    (g:Z -> matrix complex),
  (i1 < o1)%Z -> (i1 = o1) -> (i2 = o2) ->
  (constant_size (to_fset i1 o1) f) ->
  (forall (a:Z), (mem a (to_fset i1 o1)) -> ((f a) = (g a))) ->
  ((mat_sum (to_fset i1 o1) f) = (mat_sum (to_fset i2 o2) g)).

Axiom mat_sum_comp_eq :
  forall {b:Type} {b_WT:WhyType b},
  forall (s:set b) (f:b -> matrix complex) (g:b -> matrix complex)
    (h:b -> matrix complex),
  (constant_size s f) -> (constant_size s g) -> (constant_size s h) ->
  (((s_rows s f) = (s_rows s g)) /\ ((s_rows s g) = (s_rows s h))) ->
  (((s_columns s f) = (s_columns s g)) /\
   ((s_columns s g) = (s_columns s h))) ->
  (0%Z < (cardinal s))%Z ->
  (forall (e:b), forall (i:Z) (j:Z), (mem e s) ->
   ((0%Z <= i)%Z /\ (i < (s_rows s f))%Z) ->
   ((0%Z <= j)%Z /\ (j < (s_columns s f))%Z) ->
   ((infix_pldt (get (f e) i j) (get (g e) i j)) = (get (h e) i j))) ->
  ((add_mat (mat_sum s f) (mat_sum s g)) = (mat_sum s h)).

Axiom mat_sum_dim_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex) (g:a -> matrix complex) (r:Z)
    (c:Z),
  (0%Z < r)%Z -> (0%Z < c)%Z ->
  (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  (forall (e:a), (mem e s) -> ((f e) = (g e))) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim s g r c)).

Axiom constant_size_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> matrix complex) (s:set a) (t:a -> b),
  (constant_size s (fun (a1:a) => (f (t a1)))) -> constant_size (map t s) f.

Axiom map_mat_sum :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> matrix complex) (s:set a) (t:a -> b),
  (0%Z < (cardinal s))%Z -> (constant_size s (fun (a1:a) => (f (t a1)))) ->
  (p_injective t s) ->
  ((mat_sum (map t s) f) = (mat_sum s (fun (a1:a) => (f (t a1))))).

Axiom map_mat_sum_rec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:b -> matrix complex) (s:set a) (t:a -> b),
  (0%Z < (cardinal s))%Z -> (constant_size s (fun (a1:a) => (f (t a1)))) ->
  (p_injective t s) ->
  ((mat_sum s (fun (a1:a) => (f (t a1)))) = (mat_sum (map t s) f)).

Axiom mat_sum_id :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a), (0%Z < (cardinal s))%Z ->
  (constant_size s f) ->
  (constant_size (map f s) (fun (y0:matrix complex) => y0)) ->
  (p_injective f s) ->
  ((mat_sum (map f s) (fun (y0:matrix complex) => y0)) = (mat_sum s f)).

Parameter nonn_mat_subset:
  forall {a:Type} {a_WT:WhyType a}, (a -> matrix complex) -> (set a) ->
  set a.

Parameter result7:
  forall {a:Type} {a_WT:WhyType a}, (a -> matrix complex) -> (set a) ->
  a -> bool.

Axiom result_def7 :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a) (e:a),
  (((result7 f s) e) = true) <->
  ~ (infix_eqeq1 (f e) (make (s_rows s f) (s_columns s f) c_zero)).

Axiom nonn_mat_subset_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a), (constant_size s f) ->
  ((nonn_mat_subset f s) = (filter (result7 f s) s)).

Axiom nonn_mat_subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a), (constant_size s f) ->
  (subset (nonn_mat_subset f s) s) /\
  ((forall (e:a), (mem e (nonn_mat_subset f s)) -> mem e s) /\
   ((constant_size (nonn_mat_subset f s) f) /\
    ((~ ((nonn_mat_subset f s) = (empty : set a)) ->
      ((s_rows (nonn_mat_subset f s) f) = (s_rows s f))) /\
     (~ ((nonn_mat_subset f s) = (empty : set a)) ->
      ((s_columns (nonn_mat_subset f s) f) = (s_columns s f)))))).

Axiom mat_subset_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a), (constant_size s f) ->
  forall (e:a), (mem e (nonn_mat_subset f s)) -> mem e s.

Axiom mat_subset_nonn_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a), (constant_size s f) ->
  forall (e:a), (mem e (nonn_mat_subset f s)) ->
  ~ ((f e) = (make (s_rows s f) (s_columns s f) c_zero)).

Axiom nonn_mat_sum_cardzero :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a) (r:Z) (c:Z),
  ((cardinal s) = 0%Z) -> (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom nonn_mat_sum_cardone :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a) (r:Z) (c:Z),
  ((cardinal s) = 1%Z) -> (0%Z < r)%Z -> (0%Z < c)%Z ->
  ((rows (f (choose s))) = r) -> ((columns (f (choose s))) = c) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom mat_sum_null_but_maybe_one_elt :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a) (e:a), (1%Z < (cardinal s))%Z ->
  (constant_size s f) -> (mem e s) ->
  (forall (e':a), (mem e' s) -> ~ (e = e') -> null_mat (f e')) ->
  ((mat_sum s f) = (f e)).

Axiom nonn_mat_sum_plus_one :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a) (r:Z) (c:Z),
  (1%Z < (cardinal s))%Z -> (0%Z < r)%Z -> (0%Z < c)%Z ->
  (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  ((mat_sum_dim (remove (choose s) s) f r c) =
   (mat_sum_dim (nonn_mat_subset f (remove (choose s) s)) f r c)) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom nonn_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a) (r:Z) (c:Z), (0%Z < r)%Z ->
  (0%Z < c)%Z -> (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  ((mat_sum_dim s f r c) = (mat_sum_dim (nonn_mat_subset f s) f r c)).

Axiom mat_sum_map_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    {c:Type} {c_WT:WhyType c},
  forall (s1:set a) (s2:set b) (t1:a -> c) (t2:b -> c)
    (f:c -> matrix complex),
  (0%Z < (cardinal s1))%Z -> (p_injective t1 s1) ->
  (constant_size s1 (fun (a1:a) => (f (t1 a1)))) ->
  (0%Z < (cardinal s2))%Z -> (p_injective t2 s2) ->
  (constant_size s2 (fun (a1:b) => (f (t2 a1)))) ->
  ((map t1 s1) = (map t2 s2)) ->
  ((mat_sum (map t1 s1) f) = (mat_sum (map t2 s2) f)).

Axiom mat_sum_disjoint_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s1:set a) (s2:set a) (f:a -> matrix complex),
  (constant_size s f) -> ((inter s1 s2) = (empty : set a)) ->
  ((union s1 s2) = s) -> (0%Z < (cardinal s1))%Z ->
  (0%Z < (cardinal s2))%Z ->
  ((add_mat (mat_sum s1 f) (mat_sum s2 f)) = (mat_sum s f)).

Axiom mat_sum_null :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a), (1%Z < (cardinal s))%Z ->
  (constant_size s f) ->
  (forall (e:a), (mem e s) -> forall (i:Z) (j:Z), (valid_index (f e) i j) ->
   ((get (f e) i j) = c_zero)) ->
  forall (i:Z) (j:Z), (valid_index (mat_sum s f) i j) ->
  ((get (mat_sum s f) i j) = c_zero).

Axiom mat_sum_null_b :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> matrix complex) (s:set a) (r:Z) (c:Z),
  (1%Z < (cardinal s))%Z ->
  (forall (e:a), (mem e s) -> ((rows (f e)) = r)) ->
  (forall (e:a), (mem e s) -> ((columns (f e)) = c)) ->
  (forall (e:a), (mem e s) -> forall (i:Z) (j:Z), (valid_index (f e) i j) ->
   ((get (f e) i j) = c_zero)) ->
  forall (i:Z) (j:Z), ((0%Z <= i)%Z /\ (i < r)%Z) ->
  ((0%Z <= j)%Z /\ (j < c)%Z) -> ((get (mat_sum s f) i j) = c_zero).

Axiom map_add_mat_sum_t :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (s:set a) (s':set b) (f:b -> matrix complex) (injz:a -> b)
    (injo:a -> b),
  (constant_size s' f) -> (0%Z < (cardinal s))%Z ->
  ((inter (map injz s) (map injo s)) = (empty : set b)) ->
  ((union (map injz s) (map injo s)) = s') -> (p_injective injo s) ->
  (p_injective injz s) ->
  ((mat_sum s (fun (e:a) => (add_mat (f (injz e)) (f (injo e))))) =
   (mat_sum s' f)).

Axiom map_add_mat_sum :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (s1:set a) (s2:set a) (s':set a) (f:a -> matrix complex)
    (g:a -> matrix complex) (h:a -> matrix complex),
  (constant_size s' h) -> (constant_size s f) -> (constant_size s g) ->
  (((s_rows s' h) = (s_rows s f)) /\ ((s_rows s f) = (s_rows s g))) ->
  (((s_columns s' h) = (s_columns s f)) /\
   ((s_columns s f) = (s_columns s g))) ->
  (0%Z < (cardinal s))%Z -> (p_injective f s) -> (p_injective g s) ->
  (p_injective h s') -> ((map f s) = (map h s1)) ->
  ((map g s) = (map h s2)) -> ((inter s1 s2) = (empty : set a)) ->
  ((union s1 s2) = s') ->
  ((mat_sum s (fun (e:a) => (add_mat (f e) (g e)))) =
   (mat_sum s' (fun (e:a) => (h e)))).

Axiom bitvec : Type.
Parameter bitvec_WhyType : WhyType bitvec.
Existing Instance bitvec_WhyType.

Parameter value: bitvec -> Z -> Z.

Parameter length: bitvec -> Z.

Axiom bitvec'invariant :
  forall (self:bitvec),
  (0%Z <= (length self))%Z /\
  ((forall (i:Z), ((0%Z <= i)%Z /\ (i < (length self))%Z) ->
    (0%Z <= ((value self) i))%Z /\ (((value self) i) < 2%Z)%Z) /\
   forall (i:Z), ~ ((0%Z <= i)%Z /\ (i < (length self))%Z) ->
   (((value self) i) = 0%Z)).

(* Why3 assumption *)
Definition bvlength (f:Z -> Z) (i:Z) : Prop :=
  forall (k:Z), ((0%Z <= k)%Z /\ (k < i)%Z) ->
  (0%Z <= (f k))%Z /\ ((f k) < 2%Z)%Z.

Axiom binary_mult :
  forall (a:Z) (b:Z),
  ((int.EuclideanDivision.mod1 (a * b)%Z 2%Z) =
   ((int.EuclideanDivision.mod1 a 2%Z) *
    (int.EuclideanDivision.mod1 b 2%Z))%Z).

Axiom getbv_spec : forall (a:bitvec), binary (value a).

Parameter to_bool: Z -> bool.

Axiom to_bool_def :
  forall (i:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  (~ (i = 0%Z) -> ((to_bool i) = true)) /\
  ((i = 0%Z) -> ((to_bool i) = false)).

Axiom getbv_bound :
  forall (bv:bitvec) (i:Z),
  (0%Z <= ((value bv) i))%Z /\ (((value bv) i) < 2%Z)%Z.

Axiom getbv_eq :
  forall (bvx:bitvec) (bvy:bitvec) (i:Z), (bvx = bvy) ->
  (((value bvx) i) = ((value bvy) i)).

Axiom getbv_eq_gen :
  forall (bvx:bitvec) (bvy:bitvec) (i:Z) (j:Z), (bvx = bvy) -> (i = j) ->
  (((value bvx) i) = ((value bvy) j)).

Parameter setbv: (Z -> Z) -> Z -> Z -> Z -> Z.

Axiom setbv_def :
  forall (bv:Z -> Z) (i:Z) (j:Z) (k:Z),
  ((k = i) -> (((setbv bv i j) k) = j)) /\
  (~ (k = i) -> (((setbv bv i j) k) = (bv k))).

Axiom setbv_spec :
  forall (bv:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ~ (k = i) -> (((setbv bv i j) k) = (bv k))) /\
  (((setbv bv i j) i) = j).

Parameter setbv_int: (Z -> Z) -> (Z -> Z) -> Z -> Z -> Z -> Z.

Axiom setbv_int_def :
  forall (bv1:Z -> Z) (bv2:Z -> Z) (i:Z) (j:Z) (k:Z),
  (((i < k)%Z /\ (k <= j)%Z) ->
   (((setbv_int bv1 bv2 i j) k) = (bv2 (k - i)%Z))) /\
  (~ ((i < k)%Z /\ (k <= j)%Z) -> (((setbv_int bv1 bv2 i j) k) = (bv1 k))).

Axiom setbv_int_spec :
  forall (bv1:Z -> Z) (bv2:Z -> Z) (i:Z) (j:Z),
  (forall (k:Z), ((i < k)%Z /\ (k <= j)%Z) ->
   (((setbv_int bv1 bv2 i j) k) = (bv2 (k - i)%Z))) /\
  ((forall (k:Z), (k <= i)%Z -> (((setbv_int bv1 bv2 i j) k) = (bv1 k))) /\
   forall (k:Z), (j < k)%Z -> (((setbv_int bv1 bv2 i j) k) = (bv1 k))).

Axiom set_bvlength :
  forall (bv:bitvec) (i:Z),
  (forall (k:Z), ((1%Z <= k)%Z /\ (k < i)%Z) ->
   (0%Z <= ((value bv) k))%Z /\ (((value bv) k) < 2%Z)%Z) ->
  bvlength (value bv) i.

Axiom null_product_bitvec :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 1%Z)) ->
  ((ind_iproduct (value x) 0%Z n) = 1%Z).

Axiom non_null_product_bitvec :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 1%Z)) ->
  ((ind_iproduct (value x) 0%Z n) = 0%Z).

Axiom null_product_bitvec_inv :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 0%Z)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((value x) i))%Z) 0%Z n) = 1%Z).

Axiom non_null_product_bitvec_inv :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 0%Z)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((value x) i))%Z) 0%Z n) = 0%Z).

Axiom null_product_bitvec_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (value x) 0%Z n) = 1%Z) -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 1%Z).

Axiom non_null_product_bitvec_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (value x) 0%Z n) = 0%Z) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 1%Z)).

Axiom null_product_bitvec_inv_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((value x) i))%Z) 0%Z n) = 1%Z) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 0%Z).

Axiom inter1 :
  forall (x:bitvec) (n:Z) (k:Z), (n = (length x)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((value x) i))%Z) 0%Z n) = 0%Z) ->
  ((0%Z <= k)%Z /\ (k <= n)%Z) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 0%Z)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((value x) i))%Z) 0%Z k) = 1%Z).

Axiom non_null_product_bitvec_inv_rev :
  forall (x:bitvec) (n:Z), (n = (length x)) ->
  ((ind_iproduct (fun (i:Z) => (1%Z - ((value x) i))%Z) 0%Z n) = 0%Z) ->
  ~ (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (((value x) i) = 0%Z)).

Axiom set_flength :
  forall (f:Z -> Z) (i:Z),
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < i)%Z) ->
   (0%Z <= (f k))%Z /\ ((f k) < 2%Z)%Z) ->
  bvlength f i.

Axiom get_bvlength :
  forall (f:Z -> Z) (i:Z), (bvlength f i) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < i)%Z) -> (0%Z <= (f k))%Z /\ ((f k) < 2%Z)%Z.

Axiom set_bv_to :
  forall (f:Z -> Z) (i:Z), (0%Z < i)%Z ->
  (forall (j:Z), ((0%Z <= j)%Z /\ (j < i)%Z) ->
   (0%Z <= (f j))%Z /\ ((f j) <= 1%Z)%Z) ->
  bvlength f i.

Axiom set_in_range_val :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  (0%Z <= ((value bv) i))%Z /\ (((value bv) i) < 2%Z)%Z.

Axiom bvlengthm :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  bvlength (value bv) i.

(* Why3 assumption *)
Definition in_range (bv:bitvec) (r:Z) : Prop :=
  (0%Z <= r)%Z /\ (r < (length bv))%Z.

Axiom binary_bv :
  forall (bv:bitvec) (i:Z), (in_range bv i) ->
  (0%Z <= ((value bv) i))%Z /\ (((value bv) i) <= 1%Z)%Z.

Axiom equal_bv :
  forall (m:bitvec) (n:bitvec),
  (m = n) <->
  (((length m) = (length n)) /\
   forall (i:Z), (in_range m i) -> (((value m) i) = ((value n) i))).

Axiom set_equal_bv :
  forall (bv:bitvec) (bv':bitvec), ((length bv) = (length bv')) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
   (((value bv) i) = ((value bv') i))) ->
  (bv = bv').

Axiom get_equal_bv :
  forall (bv:bitvec) (bv':bitvec), (bv = bv') ->
  ((length bv) = (length bv')) /\
  forall (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  (((value bv) i) = ((value bv') i)).

Parameter make_bv: (Z -> Z) -> Z -> bitvec.

Axiom make_bv_spec :
  forall (f:Z -> Z) (s:Z),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (0%Z <= s)%Z ->
  ((length (make_bv f s)) = s) /\
  ((forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
    (((value (make_bv f s)) i) = (f i))) /\
   forall (i:Z), ~ ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (((value (make_bv f s)) i) = 0%Z)).

Parameter make_bv_m: (Z -> Z) -> Z -> bitvec.

Axiom make_bv_m_def :
  forall (f:Z -> Z) (s:Z), (0%Z <= s)%Z ->
  ((make_bv_m f s) =
   (make_bv (fun (k:Z) => (int.EuclideanDivision.mod1 (f k) 2%Z)) s)).

Axiom make_bv_m_spec :
  forall (f:Z -> Z) (s:Z), (0%Z <= s)%Z ->
  ((length (make_bv_m f s)) = s) /\
  ((forall (i:Z), bvlength (value (make_bv_m f s)) i) /\
   ((forall (k:Z), ((0%Z <= k)%Z /\ (k < s)%Z) ->
     (((value (make_bv_m f s)) k) = (int.EuclideanDivision.mod1 (f k) 2%Z))) /\
    forall (k:Z), ~ ((0%Z <= k)%Z /\ (k < s)%Z) ->
    (((value (make_bv_m f s)) k) = 0%Z))).

(* Why3 assumption *)
Definition bitvec_null : bitvec := make_bv (fun (i:Z) => 0%Z) 0%Z.

Axiom assert_make_bv_no_bound :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  ((1%Z <= i)%Z /\ (i <= s)%Z) -> (((value (make_bv f 0%Z)) i) = 0%Z).

Axiom make_bv_length :
  forall (f:Z -> Z) (s:Z),
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  (0%Z <= s)%Z -> ((length (make_bv f s)) = s).

Axiom assert_make_bv :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z ->
  (((0%Z <= i)%Z /\ (i < s)%Z) -> (((value (make_bv f s)) i) = (f i))) /\
  (~ ((0%Z <= i)%Z /\ (i < s)%Z) -> (((value (make_bv f s)) i) = 0%Z)).

Axiom assert_make_m :
  forall (f:Z -> Z) (s:Z) (i:Z), (0%Z <= s)%Z ->
  (((0%Z <= i)%Z /\ (i < s)%Z) ->
   (((value (make_bv_m f s)) i) = (int.EuclideanDivision.mod1 (f i) 2%Z))) /\
  (~ ((0%Z <= i)%Z /\ (i < s)%Z) -> (((value (make_bv_m f s)) i) = 0%Z)).

Axiom make_bv_eq :
  forall (f:Z -> Z) (f':Z -> Z) (n:Z) (n':Z), (0%Z <= n)%Z -> (n = n') ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ((f i) = (f' i))) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) ->
   (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
  ((make_bv f n) = (make_bv f' n')).

Axiom assert_make_bv_b :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  ((0%Z <= i)%Z /\ (i < s)%Z) -> (((value (make_bv f s)) i) = (f i)).

Axiom assert_make_m_b :
  forall (f:Z -> Z) (s:Z) (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
  (0%Z <= s)%Z ->
  (((value (make_bv_m f s)) i) = (int.EuclideanDivision.mod1 (f i) 2%Z)).

Axiom make_m_bv_length :
  forall (f:Z -> Z) (s:Z) (i:Z), (0%Z <= s)%Z ->
  bvlength (value (make_bv_m f s)) i.

Axiom make_m_length :
  forall (f:Z -> Z) (s:Z), (0%Z <= s)%Z -> ((length (make_bv_m f s)) = s).

Axiom set_equal_bv_make :
  forall (f:Z -> Z) (g:Z -> Z) (s:Z),
  (forall (i:Z), (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) -> (0%Z <= s)%Z ->
  (forall (i:Z), ((f i) = (g i))) -> ((make_bv f s) = (make_bv g s)).

Axiom set_equal_bv_m_make :
  forall (f:Z -> Z) (g:Z -> Z) (s:Z), (0%Z <= s)%Z ->
  (forall (i:Z),
   ((int.EuclideanDivision.mod1 (f i) 2%Z) =
    (int.EuclideanDivision.mod1 (g i) 2%Z))) ->
  ((make_bv_m f s) = (make_bv_m g s)).

Axiom make_bv_itself :
  forall (x:bitvec) (n:Z), ((length x) = n) ->
  ((make_bv (fun (i:Z) => ((value x) i)) n) = x).

Parameter head: bitvec -> Z.

Axiom head_def :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  ((head bv) = ((value bv) 0%Z)).

Axiom head_spec :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  (0%Z <= (head bv))%Z /\ ((head bv) <= 1%Z)%Z.

Parameter makes_bv: (Z -> Z) -> Z -> bitvec.

Parameter result8: (Z -> Z) -> Z -> Z.

Axiom result_def8 :
  forall (f:Z -> Z) (i:Z),
  ((let q1_ := f i in (0%Z <= q1_)%Z /\ (q1_ < 2%Z)%Z) ->
   (((result8 f) i) = (f i))) /\
  (~ (let q1_ := f i in (0%Z <= q1_)%Z /\ (q1_ < 2%Z)%Z) ->
   (((result8 f) i) = 0%Z)).

Axiom makes_bv_def :
  forall (f:Z -> Z) (s:Z), (0%Z <= s)%Z ->
  ((makes_bv f s) = (make_bv (result8 f) s)).

Axiom makes_bv_spec :
  forall (f:Z -> Z) (s:Z), (0%Z <= s)%Z ->
  ((length (makes_bv f s)) = s) /\
  ((forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
    ((0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
    (((value (makes_bv f s)) i) = (f i))) /\
   (((forall (i:Z), ((0%Z <= i)%Z /\ (i < s)%Z) ->
      (0%Z <= (f i))%Z /\ ((f i) < 2%Z)%Z) ->
     ((makes_bv f s) = (make_bv f s))) /\
    forall (i:Z), ~ ((0%Z <= i)%Z /\ (i < s)%Z) ->
    (((value (makes_bv f s)) i) = 0%Z))).

Axiom assert_makes_bv_c :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z ->
  (((0%Z <= i)%Z /\ (i < s)%Z) -> (((value (makes_bv f s)) i) = (f i))) /\
  (~ ((0%Z <= i)%Z /\ (i < s)%Z) -> (((value (makes_bv f s)) i) = 0%Z)).

Axiom assert_makes_bv_b :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z -> ((0%Z <= i)%Z /\ (i < s)%Z) ->
  (((value (makes_bv f s)) i) = (f i)).

Axiom assert_makes_bv :
  forall (f:Z -> Z) (s:Z) (i:Z),
  (forall (i1:Z), ((0%Z <= i1)%Z /\ (i1 < s)%Z) ->
   (0%Z <= (f i1))%Z /\ ((f i1) < 2%Z)%Z) ->
  (0%Z <= s)%Z ->
  ((((0%Z <= i)%Z /\ (i < s)%Z) /\ (0%Z <= (f i))%Z) ->
   (((value (makes_bv f s)) i) = (f i))) /\
  (~ (((0%Z <= i)%Z /\ (i < s)%Z) /\ (0%Z <= (f i))%Z) ->
   (((value (makes_bv f s)) i) = 0%Z)).

Axiom makes_bv_length :
  forall (f:Z -> Z) (s:Z), (0%Z <= s)%Z -> ((length (makes_bv f s)) = s).

Parameter tail: bitvec -> bitvec.

Axiom tail_def :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  ((tail bv) =
   (make_bv (fun (i:Z) => ((value bv) (i + 1%Z)%Z)) ((length bv) - 1%Z)%Z)).

Axiom tail_spec :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  ((length (tail bv)) = ((length bv) - 1%Z)%Z) /\
  forall (i:Z), (in_range (tail bv) i) ->
  (((value (tail bv)) i) = ((value bv) (i + 1%Z)%Z)).

Parameter concat_l: bitvec -> Z -> bitvec.

Parameter result9: bitvec -> Z -> Z -> Z.

Axiom result_def9 :
  forall (bv:bitvec) (i:Z) (k:Z),
  ((k = 0%Z) -> (((result9 bv i) k) = i)) /\
  (~ (k = 0%Z) -> (((result9 bv i) k) = ((value bv) (k - 1%Z)%Z))).

Axiom concat_l_def :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((concat_l bv i) = (make_bv (result9 bv i) ((length bv) + 1%Z)%Z)).

Axiom concat_l_spec :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((length (concat_l bv i)) = ((length bv) + 1%Z)%Z) /\
  ((((value (concat_l bv i)) 0%Z) = i) /\
   forall (j:Z), (in_range bv j) ->
   (((value (concat_l bv i)) (j + 1%Z)%Z) = ((value bv) j))).

Axiom concat_l_value :
  forall (bv:bitvec) (i:Z) (k:Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((k = 0%Z) -> (((value (concat_l bv i)) k) = i)) /\
  (~ (k = 0%Z) ->
   (((0%Z < k)%Z /\ (k <= ((length bv) + 1%Z)%Z)%Z) ->
    (((value (concat_l bv i)) k) = ((value bv) (k - 1%Z)%Z))) /\
   (~ ((0%Z < k)%Z /\ (k <= ((length bv) + 1%Z)%Z)%Z) ->
    (((value (concat_l bv i)) k) = 0%Z))).

Axiom concat_l_value_b :
  forall (bv:bitvec) (i:Z) (k:Z),
  ((0%Z <= k)%Z /\ (k < ((length bv) + 1%Z)%Z)%Z) ->
  ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((k = 0%Z) -> (((value (concat_l bv i)) k) = i)) /\
  (~ (k = 0%Z) -> (((value (concat_l bv i)) k) = ((value bv) (k - 1%Z)%Z))).

Axiom concat_ht :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  (bv = (concat_l (tail bv) (head bv))).

Axiom concat_ht_union :
  forall (bv:bitvec), (2%Z <= (length bv))%Z ->
  ~ (bv = (concat_l (tail bv) 0%Z)) -> (bv = (concat_l (tail bv) 1%Z)).

Parameter result10: bitvec -> Z -> Z.

Axiom result_def10 :
  forall (bv:bitvec) (k:Z),
  ((in_range bv k) ->
   (((result10 bv) k) =
    (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)) /\
  (~ (in_range bv k) -> (((result10 bv) k) = 1%Z)).

(* Why3 assumption *)
Definition bv_to_int (bv:bitvec) : Z :=
  ind_isum (result10 bv) 0%Z (length bv).

Axiom bv_to_int_spec :
  forall (bv:bitvec),
  ((bv_to_int bv) =
   (ind_isum
    (fun (k:Z) =>
     (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))) /\
  (0%Z <= (bv_to_int bv))%Z.

Axiom bv_to_int_eq :
  forall (bv1:bitvec) (bv2:bitvec), (bv1 = bv2) ->
  ((bv_to_int bv1) = (bv_to_int bv2)).

Axiom bv_to_int_sum :
  forall (bv:bitvec),
  ((bv_to_int bv) =
   (ind_isum
    (fun (k:Z) =>
     (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))).

Axiom bv_to_int_sum_inv :
  forall (bv:bitvec),
  ((bv_to_int bv) =
   (ind_isum
    (fun (k:Z) =>
     (((value bv) (((length bv) - 1%Z)%Z - k)%Z) * (power 2%Z k))%Z)
    0%Z (length bv))).

Axiom bv_to_int_sum_opp :
  forall (bv:bitvec),
  ((-(bv_to_int bv))%Z =
   (ind_isum
    (fun (k:Z) =>
     ((-((value bv) k))%Z * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    0%Z (length bv))).

Axiom bv_to_int_onebit :
  forall (bv:bitvec), ((length bv) = 1%Z) ->
  ((bv_to_int bv) = ((value bv) 0%Z)).

Axiom ind_isum_bv_rev :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    i (length bv))
   =
   (ind_isum
    (fun (l:Z) =>
     (((value bv) (((length bv) - 1%Z)%Z - l)%Z) * (power 2%Z l))%Z)
    0%Z ((length bv) - i)%Z)).

Axiom ind_isum_bin_rev :
  forall (f:Z -> Z) (n:Z) (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (binary f) ->
  ((ind_isum (fun (l:Z) => ((f l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z) i n)
   =
   (ind_isum (fun (l:Z) => ((f ((n - 1%Z)%Z - l)%Z) * (power 2%Z l))%Z) 0%Z
    (n - i)%Z)).

Axiom ind_isum_bin_rev_z :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  ((ind_isum (fun (l:Z) => ((f l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z) 0%Z
    n)
   =
   (ind_isum (fun (l:Z) => ((f ((n - 1%Z)%Z - l)%Z) * (power 2%Z l))%Z) 0%Z
    n)).

Axiom bv_to_int_sum_rev :
  forall (bv:bitvec),
  ((ind_isum
    (fun (k:Z) =>
     (((value bv) (((length bv) - 1%Z)%Z - k)%Z) * (power 2%Z k))%Z)
    0%Z (length bv))
   = (bv_to_int bv)).

Axiom ind_isum_bv_bound_growing :
  forall (bv:bitvec) (i:Z), ((0%Z < i)%Z /\ (i < (length bv))%Z) ->
  ((ind_isum (fun (l:Z) => (((value bv) l) * (power 2%Z l))%Z) 0%Z i) <
   (power 2%Z i))%Z.

Axiom ind_isum_bv_bound :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    i (length bv))
   < (power 2%Z ((length bv) - i)%Z))%Z.

Axiom ind_isum_bin_bound :
  forall (f:Z -> Z) (n:Z) (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> (binary f) ->
  ((ind_isum (fun (l:Z) => ((f l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z) i n)
   < (power 2%Z (n - i)%Z))%Z.

Axiom bv_to_int_bound :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  ((bv_to_int bv) < (power 2%Z (length bv)))%Z.

Parameter is_a_ket: (matrix complex) -> Prop.

Axiom Is_a_ket :
  forall (m:matrix complex),
  (is_a_ket m) <->
  (((columns m) = 1%Z) /\
   exists s:Z, (0%Z <= s)%Z /\ ((rows m) = (power 2%Z s))).

Parameter xor_i: Z -> Z -> Z.

Axiom xor_i_def :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) ->
  ((i = 0%Z) -> ((xor_i i i') = i')) /\
  (~ (i = 0%Z) -> ((xor_i i i') = (1%Z - i')%Z)).

Axiom xor_i_spec :
  forall (i:Z) (i':Z), ((0%Z <= i)%Z /\ (i < 2%Z)%Z) ->
  ((0%Z <= i')%Z /\ (i' < 2%Z)%Z) ->
  ((i = 0%Z) -> (i' = 0%Z) -> ((xor_i i i') = 0%Z)) /\
  (((i = 0%Z) -> (i' = 1%Z) -> ((xor_i i i') = 1%Z)) /\
   (((i = 1%Z) -> (i' = 0%Z) -> ((xor_i i i') = 1%Z)) /\
    ((i = 1%Z) -> (i' = 1%Z) -> ((xor_i i i') = 0%Z)))).

(* Why3 assumption *)
Definition is_a_ket_l (m:matrix complex) (l:Z) : Prop :=
  (0%Z <= l)%Z /\ (((columns m) = 1%Z) /\ ((rows m) = (power 2%Z l))).

Axiom ket_l_rows :
  forall (m:matrix complex) (l:Z), (is_a_ket_l m l) ->
  ((rows m) = (power 2%Z l)).

Axiom ket_l_columns :
  forall (m:matrix complex), (exists l:Z, is_a_ket_l m l) ->
  ((columns m) = 1%Z).

Parameter ket_length: (matrix complex) -> Z.

Axiom ket_length_def :
  forall (m:matrix complex), (is_a_ket m) ->
  ((ket_length m) = ((binary_length (rows m)) - 1%Z)%Z).

Axiom ket_length_spec :
  forall (m:matrix complex), (is_a_ket m) ->
  (0%Z <= (ket_length m))%Z /\ ((rows m) = (power 2%Z (ket_length m))).

Axiom get_ket_rev : True.

Parameter get_ket_bv: (matrix complex) -> bitvec -> complex.

Axiom get_ket_bv_def :
  forall (x:matrix complex) (bv:bitvec), (is_a_ket_l x (length bv)) ->
  ((get_ket_bv x bv) = (get x (bv_to_int bv) 0%Z)).

Axiom get_ket_add :
  forall (x:matrix complex) (y:matrix complex) (i:Z), (is_a_ket x) ->
  (is_a_ket y) -> ((ket_length x) = (ket_length y)) ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z (ket_length y)))%Z) ->
  ((get (add_mat x y) i 0%Z) = (infix_pldt (get x i 0%Z) (get y i 0%Z))).

Axiom get_ket_substr :
  forall (x:matrix complex) (y:matrix complex) (i:Z), (is_a_ket x) ->
  (is_a_ket y) -> ((ket_length x) = (ket_length y)) ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z (ket_length y)))%Z) ->
  ((get (mat_substr x y) i 0%Z) = (infix_mndt (get x i 0%Z) (get y i 0%Z))).

Axiom mat_mult_ket_l :
  forall (m:matrix complex) (k:matrix complex) (n:Z), (is_a_ket_l k n) ->
  ((rows m) = (power 2%Z n)) -> ((columns m) = (power 2%Z n)) ->
  is_a_ket_l (mat_mult m k) n.

Axiom ket_kronecker_values :
  forall (m:matrix complex) (n:matrix complex) (i:Z), (is_a_ket m) ->
  (is_a_ket n) -> ((0%Z <= i)%Z /\ (i < ((rows m) * (rows n))%Z)%Z) ->
  ((get (kronecker m n) i 0%Z) =
   (infix_asdt (get m (int.EuclideanDivision.div i (rows n)) 0%Z)
    (get n (int.EuclideanDivision.mod1 i (rows n)) 0%Z))).

Axiom ket_l_to_ket :
  forall (m:matrix complex) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket m) /\ ((ket_length m) = l).

Axiom ket_l_to_ket_gen :
  forall (m:matrix complex), (exists l:Z, is_a_ket_l m l) -> is_a_ket m.

Axiom ket_to_ket_l :
  forall (m:matrix complex), (is_a_ket m) -> is_a_ket_l m (ket_length m).

Axiom set_ket_valid_index :
  forall (m:matrix complex) (i:Z), (is_a_ket m) ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) -> valid_index m i 0%Z.

Axiom ket_to_ket_l_l :
  forall (m:matrix complex) (i:Z), (is_a_ket m) -> ((ket_length m) = i) ->
  is_a_ket_l m i.

Axiom set_constant_size_ket :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a) (f:a -> matrix complex),
  (forall (e:a), (mem e s) -> is_a_ket (f e)) ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) ->
   ((ket_length (f e)) = (ket_length (f e')))) ->
  constant_size s f.

Parameter ket_norm_l: (matrix complex) -> Z -> complex.

Axiom ket_norm_l_def :
  forall (x:matrix complex) (n:Z), (is_a_ket_l x n) ->
  ((ket_norm_l x n) =
   (square_rt
    (sum (to_fset 0%Z (power 2%Z n))
     (fun (k:Z) =>
      (infix_asdt (modulus (get x k 0%Z)) (modulus (get x k 0%Z))))))).

Parameter inv_func:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv_func_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e':b), (p_bijective f s s') ->
  (mem e' s') ->
  ((inv_func f s s' e') =
   (element (my_filter s (fun (e:a) => (indic_bool (f e) e'))))).

Axiom inv_func_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e':b), (p_bijective f s s') ->
  (mem e' s') ->
  (mem (inv_func f s s' e') s) /\ ((f (inv_func f s s' e')) = e').

Axiom inv_rec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e:a), (p_bijective f s s') ->
  (mem e s) -> ((inv_func f s s' (f e)) = e).

Parameter inv_:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv__def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e:b), (p_bijective f s s') ->
  (mem e s') -> ((inv_ f s s' e) = (inv_func f s s' e)).

Axiom inv__spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b) (e:b), (p_bijective f s s') ->
  (mem e s') -> (mem (inv_ f s s' e) s) /\ ((f (inv_ f s s' e)) = e).

Axiom inv_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  p_bijective
  ((((fun (y0:a -> b) (y1:set a) (y2:set b) (y3:b) => (inv_ y0 y1 y2 y3)) f)
    s)
   s')
  s' s.

Axiom set_bijective_inv :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a) (b1:b), (mem b1 (map f s)) ->
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  (p_bijective f s (map f s)) /\ ((inv_func f s (map f s) b1) = (g b1)).

Axiom set_bij_inv :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (g:b -> a) (s:set a),
  (forall (e:a) (e':a), (mem e s) -> (mem e' s) -> ~ (e = e') ->
   ~ ((f e) = (f e'))) ->
  (forall (e':b), (mem e' (map f s)) -> (mem (g e') s) /\ ((f (g e')) = e')) ->
  (p_bijective f s (map f s)) /\
  ((p_bijective g (map f s) s) /\
   forall (b1:b), (mem b1 (map f s)) ->
   ((inv_func f s (map f s) b1) = (g b1))).

Parameter inv_f:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> (set b) -> b -> a.

Axiom inv_f_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_bijective f s s') ->
  (forall (e:b), (mem e s') -> mem ((inv_f f s s') e) s) /\
  ((forall (e:b), (mem e s') -> ((f ((inv_f f s s') e)) = e)) /\
   (p_bijective (inv_f f s s') s' s)).

Axiom injective_is_bijective :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (s:set a) (s':set b), (p_injective f s) ->
  (forall (e:a), (mem e s) -> mem (f e) s') ->
  ((cardinal s) = (cardinal s')) -> p_bijective f s s'.

Axiom injective_is_bijective_auto :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a), (p_injective f s) ->
  (forall (e:a), (mem e s) -> mem (f e) s) ->
  (p_bijective f s s) /\ ((map f s) = s).

Parameter inv_auto:
  forall {a:Type} {a_WT:WhyType a}, (a -> a) -> (set a) -> a -> a.

Axiom inv_auto_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a), (p_injective f s) ->
  (forall (e:a), (mem e s) -> mem (f e) s) ->
  ((inv_auto f s) = (inv_f f s s)).

Axiom inv_auto_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (f:a -> a) (s:set a), (p_injective f s) ->
  (forall (e:a), (mem e s) -> mem (f e) s) ->
  (forall (e:a), (mem e s) -> mem ((inv_auto f s) e) s) /\
  ((forall (e:a), (mem e s) -> ((f ((inv_auto f s) e)) = e)) /\
   (p_bijective (inv_auto f s) s s)).

Axiom ind_isum_mod_div :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((int.EuclideanDivision.mod1
    (ind_isum
     (fun (k:Z) =>
      (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
     0%Z (length bv))
    (power 2%Z ((length bv) - i)%Z))
   =
   (ind_isum
    (fun (k:Z) =>
     (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
    i (length bv))) /\
  ((int.EuclideanDivision.div
    (ind_isum
     (fun (k:Z) =>
      (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)
     0%Z (length bv))
    (power 2%Z ((length bv) - i)%Z))
   =
   (ind_isum
    (fun (k:Z) => (((value bv) k) * (power 2%Z ((i - 1%Z)%Z - k)%Z))%Z) 0%Z
    i)).

Axiom mod_ind_isum :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power 2%Z i))
   =
   (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z)
    (l - i)%Z l)).

Axiom mod_ind_isum_z :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power 2%Z i))
   =
   (ind_isum
    (fun (k:Z) =>
     ((f ((k + l)%Z - i)%Z) * (power 2%Z ((i - 1%Z)%Z - k)%Z))%Z)
    0%Z i)).

Axiom div_ind_isum :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.div
    (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power 2%Z i))
   =
   (ind_isum
    (fun (k:Z) => ((f k) * (power 2%Z (((l - 1%Z)%Z - k)%Z - i)%Z))%Z) 0%Z
    (l - i)%Z)).

Axiom ind_isum_mod :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (l:Z) => (((value bv) l) * (power 2%Z (i - l)%Z))%Z) 0%Z
     (i + 1%Z)%Z)
    2%Z)
   = ((value bv) i)).

Axiom mod_ind_isum_ :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (k:Z) => ((f k) * (power_ 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power_ 2%Z i))
   =
   (ind_isum (fun (k:Z) => ((f k) * (power_ 2%Z ((l - 1%Z)%Z - k)%Z))%Z)
    (l - i)%Z l)).

Axiom mod_ind_isum_z_ :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (k:Z) => ((f k) * (power_ 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power_ 2%Z i))
   =
   (ind_isum
    (fun (k:Z) =>
     ((f ((k + l)%Z - i)%Z) * (power_ 2%Z ((i - 1%Z)%Z - k)%Z))%Z)
    0%Z i)).

Axiom div_ind_isum_ :
  forall (f:Z -> Z) (i:Z) (l:Z), ((0%Z <= i)%Z /\ (i <= l)%Z) ->
  (binary f) ->
  ((int.EuclideanDivision.div
    (ind_isum (fun (k:Z) => ((f k) * (power_ 2%Z ((l - 1%Z)%Z - k)%Z))%Z) 0%Z
     l)
    (power_ 2%Z i))
   =
   (ind_isum
    (fun (k:Z) => ((f k) * (power_ 2%Z (((l - 1%Z)%Z - k)%Z - i)%Z))%Z) 0%Z
    (l - i)%Z)).

Axiom ind_isum_mod_ :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
  ((int.EuclideanDivision.mod1
    (ind_isum (fun (l:Z) => (((value bv) l) * (power_ 2%Z (i - l)%Z))%Z) 0%Z
     (i + 1%Z)%Z)
    2%Z)
   = ((value bv) i)).

Axiom bv_to_int_kth_pre :
  forall (bv:bitvec) (k:Z),
  ((0%Z <= k)%Z /\ (k < ((length bv) - 1%Z)%Z)%Z) ->
  (((value bv) k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div
     (ind_isum
      (fun (l:Z) =>
       (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
      0%Z (length bv))
     (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))
    2%Z)) /\
  (((value bv) k) =
   (int.EuclideanDivision.div
    (int.EuclideanDivision.mod1
     (ind_isum
      (fun (l:Z) =>
       (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
      0%Z (length bv))
     (power 2%Z ((length bv) - k)%Z))
    (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))).

Parameter int_to_bv: Z -> Z -> bitvec.

Parameter result11: Z -> Z -> Z -> Z.

Axiom result_def11 :
  forall (i:Z) (n:Z) (k:Z),
  (((0%Z <= k)%Z /\ (k < n)%Z) ->
   (((result11 i n) k) =
    (int.EuclideanDivision.div
     (int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z))
     (power 2%Z ((n - k)%Z - 1%Z)%Z)))) /\
  (~ ((0%Z <= k)%Z /\ (k < n)%Z) -> (((result11 i n) k) = 0%Z)).

Axiom int_to_bv_def :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((int_to_bv i n) = (make_bv (result11 i n) n)).

Axiom int_to_bv_spec :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((length (int_to_bv i n)) = n) /\
  ((int_to_bv i n) =
   (make_bv
    (fun (k:Z) =>
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i (power 2%Z (n - k)%Z))
      (power 2%Z ((n - k)%Z - 1%Z)%Z)))
    n)).

Axiom int_to_bv_sum_pre :
  forall (i:Z) (n:Z) (k:Z), ((k <= n)%Z /\ (0%Z <= k)%Z) ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) l) * (power 2%Z ((n - l)%Z - 1%Z)%Z))%Z)
    (n - k)%Z n)).

Axiom int_to_bv_sum :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (i =
   (ind_isum
    (fun (k:Z) =>
     (((value (int_to_bv i n)) k) * (power 2%Z ((n - 1%Z)%Z - k)%Z))%Z)
    0%Z n)).

Axiom int_to_bv_sum_rev :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((ind_isum
    (fun (k:Z) =>
     (((value (int_to_bv i n)) k) * (power_ 2%Z ((n - k)%Z - 1%Z)%Z))%Z)
    0%Z n)
   = i).

Axiom int_to_bv_mod_div :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_bv i n) =
   (make_bv
    (fun (k:Z) =>
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.div i (power 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z))
    n)).

Axiom mod_isum :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z)
    (n - k)%Z n)).

Axiom mod_isum_z :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.mod1 i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) (l + (n - k)%Z)%Z) *
      (power 2%Z ((k - l)%Z - 1%Z)%Z))%Z)
    0%Z k)).

Axiom div_isum :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.div i (power 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) l) *
      (power 2%Z (((n - 1%Z)%Z - k)%Z - l)%Z))%Z)
    0%Z (n - k)%Z)).

Axiom int_to_bv_div_mod :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int_to_bv i n) =
   (make_bv
    (fun (k1:Z) =>
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i (power 2%Z (n - k1)%Z))
      (power 2%Z ((n - k1)%Z - 1%Z)%Z)))
    n)).

Axiom int_to_bv_value :
  forall (i:Z) (n:Z) (k:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (((value (int_to_bv i n)) k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z)).

Axiom int_to_bv_value_zero :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((i < (power 2%Z (n - 1%Z)%Z))%Z -> (((value (int_to_bv i n)) 0%Z) = 0%Z)) /\
  (~ (i < (power 2%Z (n - 1%Z)%Z))%Z ->
   (((value (int_to_bv i n)) 0%Z) = 1%Z)).

Axiom int_to_bv_mod_div_ :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((int_to_bv i n) =
   (make_bv
    (fun (k:Z) =>
     (int.EuclideanDivision.mod1
      (int.EuclideanDivision.div i (power_ 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z))
    n)).

Axiom mod_isum_ :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.mod1 i (power_ 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) l) * (power_ 2%Z ((n - 1%Z)%Z - l)%Z))%Z)
    (n - k)%Z n)).

Axiom mod_isum_z_ :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.mod1 i (power_ 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) (l + (n - k)%Z)%Z) *
      (power_ 2%Z ((k - l)%Z - 1%Z)%Z))%Z)
    0%Z k)).

Axiom div_isum_ :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int.EuclideanDivision.div i (power_ 2%Z k)) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) l) *
      (power_ 2%Z (((n - 1%Z)%Z - k)%Z - l)%Z))%Z)
    0%Z (n - k)%Z)).

Axiom int_to_bv_div_mod_ :
  forall (i:Z) (k:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  ((int_to_bv i n) =
   (make_bv
    (fun (k1:Z) =>
     (int.EuclideanDivision.div
      (int.EuclideanDivision.mod1 i (power_ 2%Z (n - k1)%Z))
      (power_ 2%Z ((n - k1)%Z - 1%Z)%Z)))
    n)).

Axiom int_to_bv_value_ :
  forall (i:Z) (n:Z) (k:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (((value (int_to_bv i n)) k) =
   (int.EuclideanDivision.mod1
    (int.EuclideanDivision.div i (power_ 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z)).

Axiom int_to_bv_value_zero_ :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((i < (power_ 2%Z (n - 1%Z)%Z))%Z -> (((value (int_to_bv i n)) 0%Z) = 0%Z)) /\
  (~ (i < (power_ 2%Z (n - 1%Z)%Z))%Z ->
   (((value (int_to_bv i n)) 0%Z) = 1%Z)).

Axiom int_to_bv_zero :
  forall (n:Z), forall (k:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
  (((value (int_to_bv 0%Z n)) k) = 0%Z).

Axiom int_to_sum :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (i =
   (ind_isum
    (fun (k:Z) =>
     (((value (int_to_bv i n)) k) * (power 2%Z ((n - k)%Z - 1%Z)%Z))%Z)
    0%Z n)).

Axiom int_to_bv_transl :
  forall (i:Z) (k:Z) (n:Z) (t:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= k)%Z /\ (k < (n - t)%Z)%Z) -> ((0%Z < t)%Z /\ (t <= n)%Z) ->
  (((value
     (int_to_bv (int.EuclideanDivision.mod1 i (power_ 2%Z (n - t)%Z))
      (n - t)%Z))
    k)
   = ((value (int_to_bv i n)) (k + t)%Z)).

Axiom int_to_bv_transl_div :
  forall (i:Z) (k:Z) (n:Z) (n':Z) (t:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> ((0%Z <= k)%Z /\ (k < t)%Z) ->
  (n' = t) -> ((0%Z < t)%Z /\ (t <= n)%Z) ->
  (((value
     (int_to_bv (int.EuclideanDivision.div i (power_ 2%Z (n - t)%Z)) n'))
    k)
   = ((value (int_to_bv i n)) k)).

Axiom product_int_to_bv_inv :
  forall (n:Z) (i:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((i = 0%Z) ->
   ((ind_iproduct (fun (j:Z) => (1%Z - ((value (int_to_bv i n)) j))%Z) 0%Z n)
    = 1%Z)) /\
  (~ (i = 0%Z) ->
   ((ind_iproduct (fun (j:Z) => (1%Z - ((value (int_to_bv i n)) j))%Z) 0%Z n)
    = 0%Z)).

Parameter bin_to_int: (Z -> Z) -> Z -> Z.

Axiom bin_to_int_def :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  ((bin_to_int f n) = (bv_to_int (make_bv f n))).

Axiom bin_to_int_spec :
  forall (f:Z -> Z) (n:Z), (0%Z <= n)%Z -> (binary f) ->
  ((bin_to_int f n) =
   (ind_isum (fun (k:Z) => ((f k) * (power 2%Z ((n - 1%Z)%Z - k)%Z))%Z) 0%Z
    n)) /\
  (0%Z <= (bin_to_int f n))%Z.

Parameter int_to_bin: Z -> Z -> Z -> Z.

Axiom int_to_bin_def :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_bin i n) = (value (int_to_bv i n))).

Axiom int_to_bin_spec :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  (i =
   (ind_isum
    (fun (k:Z) =>
     (((int_to_bin i n) k) * (power_ 2%Z ((n - 1%Z)%Z - k)%Z))%Z)
    0%Z n)) /\
  ((binary (int_to_bin i n)) /\
   forall (k:Z), ((0%Z <= k)%Z /\ (k < n)%Z) ->
   (((int_to_bin i n) k) =
    (int.EuclideanDivision.mod1
     (int.EuclideanDivision.div i (power_ 2%Z ((n - k)%Z - 1%Z)%Z)) 2%Z))).

Axiom int_to_bv_tail :
  forall (i:Z) (n:Z), (1%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((int_to_bv (tail_bits i n) (n - 1%Z)%Z) = (tail (int_to_bv i n))).

Axiom bound_sum_dec :
  forall (bv:bitvec) (i:Z), ((1%Z <= i)%Z /\ (i <= (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) => (((value bv) l) * (power 2%Z ((length bv) - l)%Z))%Z) i
    ((length bv) + 1%Z)%Z)
   < (power 2%Z (((length bv) - i)%Z + 1%Z)%Z))%Z.

Axiom bv_to_int_to_bv :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((bv_to_int (int_to_bv i n)) = i).

Axiom bv_to_int_to_bv_ :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z n))%Z) ->
  ((bv_to_int (int_to_bv i n)) = i).

Axiom tail_bits_sum :
  forall (i:Z) (n:Z), (1%Z < n)%Z -> (0%Z <= i)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((tail_bits i n) =
   (ind_isum
    (fun (l:Z) =>
     (((value (int_to_bv i n)) l) * (power 2%Z ((n - 1%Z)%Z - l)%Z))%Z)
    1%Z n)).

Axiom int_to_bv_to_int :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  ((int_to_bv (bv_to_int bv) (length bv)) = bv).

Axiom int_to_bv_to_int_ :
  forall (bv:bitvec) (l:Z), (1%Z <= l)%Z -> ((length bv) = l) ->
  ((int_to_bv (bv_to_int bv) l) = bv).

Axiom concat_to_int :
  forall (bv:bitvec) (i:Z), ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  ((bv_to_int (concat_l bv i)) =
   ((bv_to_int bv) + (i * (power 2%Z (length bv)))%Z)%Z).

Axiom bounded_to_int :
  forall (bv:bitvec), ((bv_to_int bv) < (power 2%Z (length bv)))%Z.

Axiom int_to_bv_to_int_value :
  forall (bv:bitvec) (i:Z), (1%Z <= (length bv))%Z ->
  (((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
   (((value (int_to_bv (bv_to_int bv) (length bv))) i) = ((value bv) i))) /\
  (~ ((0%Z <= i)%Z /\ (i < (length bv))%Z) ->
   (((value (int_to_bv (bv_to_int bv) (length bv))) i) = 0%Z)).

Axiom int_to_bv_to_int_gen :
  forall (bv:bitvec) (n:Z), (1%Z <= (length bv))%Z -> (n = (length bv)) ->
  ((int_to_bv (bv_to_int bv) n) = bv).

Axiom bv_to_int_mod :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  ((int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - k)%Z))
   =
   (ind_isum
    (fun (l:Z) =>
     (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    k (length bv))).

Axiom bv_to_int_mod_rev :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    k (length bv))
   =
   (int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - k)%Z))).

Axiom bv_to_int_mod_gen :
  forall (k:Z) (n:Z), ((0%Z <= k)%Z /\ (k < n)%Z) -> forall (bv:bitvec),
  ((length bv) = n) ->
  ((int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - k)%Z))
   =
   (ind_isum
    (fun (l:Z) =>
     (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    k (length bv))).

Axiom to_int_head_tail :
  forall (bv:bitvec), (1%Z <= (length bv))%Z ->
  ((bv_to_int bv) =
   ((bv_to_int (tail bv)) +
    ((head bv) * (power 2%Z ((length bv) - 1%Z)%Z))%Z)%Z) /\
  ((bv_to_int (tail bv)) =
   (int.EuclideanDivision.mod1 (bv_to_int bv)
    (power 2%Z ((length bv) - 1%Z)%Z))).

Axiom not_disj :
  forall (a:bool) (b:bool), ~ (a = true) -> ~ (b = true) ->
  ~ ((a = true) \/ (b = true)).

Parameter my_map:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> b) ->
  (set a) -> set b.

Axiom my_map_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a),
  (((cardinal u) = 0%Z) -> ((my_map f u) = (empty : set b))) /\
  (~ ((cardinal u) = 0%Z) ->
   ((my_map f u) = (add (f (choose u)) (my_map f (remove (choose u) u))))).

Axiom my_map_spec :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((my_map f u) = (map f u)).

Axiom my_map_to_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((my_map f u) = (map f u)).

Axiom map_to_my_map :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:a -> b) (u:set a), ((map f u) = (my_map f u)).

Parameter mapz_pre: Z -> (set bitvec) -> set bitvec.

Axiom mapz_pre_def :
  forall (n:Z) (s:set bitvec), (1%Z <= n)%Z ->
  (forall (f:bitvec), (mem f s) <-> ((length f) = (n - 1%Z)%Z)) ->
  ((mapz_pre n s) = (my_map (fun (bv:bitvec) => (concat_l bv 0%Z)) s)).

Axiom mapz_pre_spec :
  forall (n:Z) (s:set bitvec), (1%Z <= n)%Z ->
  (forall (f:bitvec), (mem f s) <-> ((length f) = (n - 1%Z)%Z)) ->
  (mem (make_bv (fun (us:Z) => 0%Z) n) (mapz_pre n s)) /\
  ((forall (e:bitvec), (mem e (mapz_pre n s)) -> (((value e) 0%Z) = 0%Z)) /\
   ((forall (e:bitvec), (mem e (mapz_pre n s)) ->
     exists bv:bitvec, (mem bv s) /\ (e = (concat_l bv 0%Z))) /\
    ((forall (e:bitvec), (mem e (mapz_pre n s)) -> ((length e) = n)) /\
     forall (e:bitvec), ((length e) = n) -> (((value e) 0%Z) = 0%Z) ->
     mem e (mapz_pre n s)))).

Parameter mapo_pre: Z -> (set bitvec) -> set bitvec.

Axiom mapo_pre_def :
  forall (n:Z) (s:set bitvec), (1%Z <= n)%Z ->
  (forall (f:bitvec), (mem f s) <-> ((length f) = (n - 1%Z)%Z)) ->
  ((mapo_pre n s) = (my_map (fun (bv:bitvec) => (concat_l bv 1%Z)) s)).

Axiom mapo_pre_spec :
  forall (n:Z) (s:set bitvec), (1%Z <= n)%Z ->
  (forall (f:bitvec), (mem f s) <-> ((length f) = (n - 1%Z)%Z)) ->
  (mem (make_bv (fun (us:Z) => 1%Z) n) (mapo_pre n s)) /\
  ((forall (e:bitvec), (mem e (mapo_pre n s)) -> (((value e) 0%Z) = 1%Z)) /\
   ((forall (e:bitvec), (mem e (mapo_pre n s)) ->
     exists bv:bitvec, (mem bv s) /\ (e = (concat_l bv 1%Z))) /\
    ((forall (e:bitvec), (mem e (mapo_pre n s)) -> ((length e) = n)) /\
     forall (e:bitvec), ((length e) = n) -> (((value e) 0%Z) = 1%Z) ->
     mem e (mapo_pre n s)))).

Parameter n_bvs: Z -> set bitvec.

Axiom n_bvs_spec :
  forall (n:Z), (0%Z <= n)%Z ->
  ((1%Z <= n)%Z -> forall (s:set bitvec),
   (forall (f:bitvec), (mem f s) <-> ((length f) = (n - 1%Z)%Z)) ->
   ((n_bvs n) = (union (mapz_pre n s) (mapo_pre n s)))) /\
  ((forall (f:bitvec), (mem f (n_bvs n)) -> ((length f) = n)) /\
   ((forall (f:bitvec), (mem f (n_bvs n)) <-> ((length f) = n)) /\
    (0%Z < (cardinal (n_bvs n)))%Z)).

Axiom in_n_bvs :
  forall (x:bitvec) (n:Z), (0%Z <= n)%Z -> ((length x) = n) ->
  mem x (n_bvs n).

Parameter mapz: Z -> set bitvec.

Axiom mapz_def :
  forall (n:Z), (1%Z <= n)%Z -> ((mapz n) = (mapz_pre n (n_bvs (n - 1%Z)%Z))).

Axiom mapz_spec :
  forall (n:Z), (1%Z <= n)%Z ->
  ((mapz n) =
   (my_map (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs (n - 1%Z)%Z))) /\
  ((0%Z < (cardinal (mapz n)))%Z /\
   ((forall (e:bitvec), (mem e (mapz n)) -> (((value e) 0%Z) = 0%Z)) /\
    ((forall (e:bitvec), (mem e (mapz n)) ->
      exists bv:bitvec,
      (mem bv (n_bvs (n - 1%Z)%Z)) /\ (e = (concat_l bv 0%Z))) /\
     ((forall (e:bitvec), (mem e (mapz n)) -> ((length e) = n)) /\
      forall (e:bitvec), ((length e) = n) -> (((value e) 0%Z) = 0%Z) ->
      mem e (mapz n))))).

Parameter mapo: Z -> set bitvec.

Axiom mapo_def :
  forall (n:Z), (1%Z <= n)%Z -> ((mapo n) = (mapo_pre n (n_bvs (n - 1%Z)%Z))).

Axiom mapo_spec :
  forall (n:Z), (1%Z <= n)%Z ->
  ((mapo n) =
   (my_map (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs (n - 1%Z)%Z))) /\
  ((0%Z < (cardinal (mapo n)))%Z /\
   ((forall (e:bitvec), (mem e (mapo n)) -> (((value e) 0%Z) = 1%Z)) /\
    ((forall (e:bitvec), (mem e (mapo n)) ->
      exists bv:bitvec,
      (mem bv (n_bvs (n - 1%Z)%Z)) /\ (e = (concat_l bv 1%Z))) /\
     ((forall (e:bitvec), (mem e (mapo n)) -> ((length e) = n)) /\
      forall (e:bitvec), ((length e) = n) -> (((value e) 0%Z) = 1%Z) ->
      mem e (mapo n))))).

Axiom n_bvs_node :
  forall (n:Z), (0%Z < n)%Z ->
  ((inter (mapz n) (mapo n)) = (empty : set bitvec)) /\
  ((union (mapz n) (mapo n)) = (n_bvs n)).

Axiom n_bvsz_spec :
  (forall (x:bitvec), ((length x) = 0%Z) -> mem x (n_bvs 0%Z)) /\
  ((forall (x:bitvec), (mem x (n_bvs 0%Z)) ->
    (x = (make_bv (fun (us:Z) => 0%Z) 0%Z))) /\
   (((n_bvs 0%Z) =
     (add (make_bv (fun (us:Z) => 0%Z) 0%Z) (empty : set bitvec))) /\
    (((choose (n_bvs 0%Z)) = (make_bv (fun (us:Z) => 0%Z) 0%Z)) /\
     forall (f:bitvec -> matrix complex),
     ((mat_sum (n_bvs 0%Z) f) = (f (make_bv (fun (us:Z) => 0%Z) 0%Z)))))).

Axiom n_bvso_spec :
  (forall (x:bitvec), ((length x) = 1%Z) -> mem x (n_bvs 1%Z)) /\
  ((forall (x:bitvec), (mem x (n_bvs 1%Z)) -> ((length x) = 1%Z)) /\
   (((n_bvs 1%Z) =
     (add (make_bv (fun (us:Z) => 0%Z) 1%Z)
      (add (make_bv (fun (us:Z) => 1%Z) 1%Z) (empty : set bitvec)))) /\
    forall (f:bitvec -> matrix complex), (constant_size (n_bvs 1%Z) f) ->
    ((mat_sum (n_bvs 1%Z) f) =
     (add_mat (f (make_bv (fun (us:Z) => 0%Z) 1%Z))
      (f (make_bv (fun (us:Z) => 1%Z) 1%Z)))))).

Axiom injective_node :
  forall (n:Z), (0%Z <= n)%Z ->
  (p_injective (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs n)) /\
  (p_injective (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs n)).

Axiom mat_sum_n_bvs_pos :
  forall (n:Z) (f:bitvec -> matrix complex), (0%Z < n)%Z ->
  (constant_size (n_bvs n) f) ->
  ((mat_sum (n_bvs n) f) =
   (add_mat
    (mat_sum (n_bvs (n - 1%Z)%Z) (fun (bv:bitvec) => (f (concat_l bv 0%Z))))
    (mat_sum (n_bvs (n - 1%Z)%Z) (fun (bv:bitvec) => (f (concat_l bv 1%Z)))))).

Axiom mat_sum_n_bvs_null :
  forall (f:bitvec -> matrix complex),
  ((mat_sum (n_bvs 0%Z) f) =
   (f (make_bv ((fun (y0:Z) (y1:Z) => y0) 0%Z) 0%Z))).

Axiom mat_sum_n_bvs_null_eq :
  forall (f:bitvec -> matrix complex) (x:matrix complex),
  (x = (f (make_bv ((fun (y0:Z) (y1:Z) => y0) 0%Z) 0%Z))) ->
  ((mat_sum (n_bvs 0%Z) f) = x).

Axiom get_n_bvs : forall (bv:bitvec), mem bv (n_bvs (length bv)).

Axiom get_n_bvs_gen :
  forall (bv:bitvec) (l:Z), (l = (length bv)) -> mem bv (n_bvs l).

Axiom set_n_bvs :
  forall (bv:bitvec), (mem bv (n_bvs (length bv))) -> forall (i:Z),
  ~ ((0%Z <= i)%Z /\ (i < (length bv))%Z) -> (((value bv) i) = 0%Z).

Axiom int_to_bv_n_bvs :
  forall (i:Z) (n:Z), (0%Z <= n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> mem (int_to_bv i n) (n_bvs n).

Axiom n_bvs_def_pos :
  forall (n:Z), (0%Z < n)%Z ->
  ((n_bvs n) =
   (union (map (fun (bv:bitvec) => (concat_l bv 0%Z)) (n_bvs (n - 1%Z)%Z))
    (map (fun (bv:bitvec) => (concat_l bv 1%Z)) (n_bvs (n - 1%Z)%Z)))).

Axiom map_n_bvs :
  forall (n:Z), (0%Z < n)%Z ->
  ((to_fset 0%Z (power 2%Z n)) =
   (map (fun (y0:bitvec) => (bv_to_int y0)) (n_bvs n))).

Axiom ind_sum_bv :
  forall (f:Z -> complex) (n:Z), (1%Z <= n)%Z ->
  ((ind_sum f 0%Z (power_ 2%Z n)) =
   (sum (n_bvs n) (fun (k:bitvec) => (f (bv_to_int k))))).

Parameter first_div: bitvec -> bitvec -> Z.

Axiom first_div_spec :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) ->
  (forall (j:Z), ((0%Z <= j)%Z /\ (j < (first_div bv1 bv2))%Z) ->
   (((value bv1) j) = ((value bv2) j))) /\
  ((((first_div bv1 bv2) < (length bv1))%Z ->
    ~ (((value bv1) (first_div bv1 bv2)) = ((value bv2) (first_div bv1 bv2)))) /\
   ((0%Z <= (first_div bv1 bv2))%Z /\ ((first_div bv1 bv2) < (length bv1))%Z)).

Axiom injective_concat :
  forall (i:Z) (n:Z), (0%Z <= n)%Z -> ((0%Z <= i)%Z /\ (i <= 1%Z)%Z) ->
  p_injective (fun (bv:bitvec) => (concat_l bv i)) (n_bvs n).

Axiom inf_first_div :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) -> forall (j:Z), (1%Z <= j)%Z ->
  ~ (((value bv1) j) = ((value bv2) j)) -> ((first_div bv1 bv2) <= j)%Z.

Axiom first_div_diff :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) ->
  ~ (((value bv1) (first_div bv1 bv2)) = ((value bv2) (first_div bv1 bv2))).

Axiom exists_first_div :
  forall (bv1:bitvec) (bv2:bitvec), ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2) ->
  exists i:Z,
  ((0%Z <= i)%Z /\ (i < (length bv1))%Z) /\ (i = (first_div bv1 bv2)).

Axiom set_diff_length :
  forall (bv1:bitvec) (bv2:bitvec), ~ ((length bv1) = (length bv2)) ->
  ~ (bv1 = bv2).

Axiom set_diff_val :
  forall (bv1:bitvec) (bv2:bitvec) (i:Z), ((length bv1) = (length bv2)) ->
  ((0%Z <= i)%Z /\ (i < (length bv1))%Z) ->
  ~ (((value bv1) i) = ((value bv2) i)) -> ~ (bv1 = bv2).

Parameter fc6: bitvec -> Z -> Z.

Parameter fc7: bitvec -> Z -> Z.

Axiom fc_def6 :
  forall (bv:bitvec) (l:Z),
  ((l < (length bv))%Z ->
   (((fc6 bv) l) =
    (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)) /\
  (~ (l < (length bv))%Z -> (((fc6 bv) l) = 0%Z)).

Axiom fc_def7 :
  forall (bv:bitvec) (l:Z),
  ((l < (length bv))%Z ->
   (((fc7 bv) l) =
    (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)) /\
  (~ (l < (length bv))%Z -> (((fc7 bv) l) = 0%Z)).

Axiom kth_decomp :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  ((bv_to_int bv) =
   (((ind_isum (fc6 bv) 0%Z k) +
     (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)%Z
    + (ind_isum (fc7 bv) (k + 1%Z)%Z (length bv)))%Z) /\
  ((bv_to_int bv) =
   (((ind_isum
      (fun (l:Z) =>
       (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
      0%Z k)
     + (((value bv) k) * (power 2%Z (((length bv) - 1%Z)%Z - k)%Z))%Z)%Z
    +
    (ind_isum
     (fun (l:Z) =>
      (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
     (k + 1%Z)%Z (length bv)))%Z).

Axiom int_to_bv_prod :
  forall (i:Z) (j:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((ind_product
    (fun (k:Z) =>
     (indic ((value (int_to_bv i n)) k) ((value (int_to_bv j n)) k)))
    0%Z n)
   = (indic i j)).

Axiom int_to_bv_prod_gen :
  forall (i:Z) (n:Z), (0%Z < n)%Z ->
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> forall (j:Z),
  ((0%Z <= j)%Z /\ (j < (power 2%Z n))%Z) ->
  ((ind_product
    (fun (k:Z) =>
     (indic ((value (int_to_bv i n)) k) ((value (int_to_bv j n)) k)))
    0%Z n)
   = (indic i j)).

Axiom kth_decomp_bound_zero :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  (((value bv) k) = 0%Z) ->
  ((ind_isum
    (fun (l:Z) =>
     (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
    0%Z k)
   <= (bv_to_int bv))%Z /\
  ((bv_to_int bv) <
   ((ind_isum
     (fun (l:Z) =>
      (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
     0%Z k)
    + (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))%Z)%Z.

Axiom kth_decomp_bound_one :
  forall (bv:bitvec) (k:Z), ((0%Z <= k)%Z /\ (k < (length bv))%Z) ->
  (((value bv) k) = 1%Z) ->
  (((ind_isum
     (fun (l:Z) =>
      (((value bv) l) * (power 2%Z (((length bv) - 1%Z)%Z - l)%Z))%Z)
     0%Z k)
    + (power 2%Z (((length bv) - k)%Z - 1%Z)%Z))%Z
   <= (bv_to_int bv))%Z /\
  ((bv_to_int bv) <
   ((ind_isum
     (fun (l:Z) =>
      (((value bv) l) * (power 2%Z (((length bv) - l)%Z - 1%Z)%Z))%Z)
     0%Z k)
    + (power 2%Z ((length bv) - k)%Z))%Z)%Z.

Axiom ind_sum_ket_norm_l :
  forall (x:matrix complex) (n:Z), (is_a_ket_l x n) ->
  ((ket_norm_l x n) =
   (square_rt
    (ind_sum
     (fun (k:Z) =>
      (infix_asdt (modulus (get x k 0%Z)) (modulus (get x k 0%Z))))
     0%Z (power 2%Z n)))).

Axiom ket_norm_one :
  forall (x:matrix complex) (n:Z), (n = 1%Z) -> (is_a_ket_l x n) ->
  ((ket_norm_l x n) =
   (square_rt
    (infix_pldt
     (infix_asdt (modulus (get x 0%Z 0%Z)) (modulus (get x 0%Z 0%Z)))
     (infix_asdt (modulus (get x 1%Z 0%Z)) (modulus (get x 1%Z 0%Z)))))).

Axiom ket_norm_one_c_one :
  forall (x:matrix complex) (n:Z), (n = 1%Z) -> (is_a_ket_l x n) ->
  ((infix_pldt
    (infix_asdt (modulus (get x 0%Z 0%Z)) (modulus (get x 0%Z 0%Z)))
    (infix_asdt (modulus (get x 1%Z 0%Z)) (modulus (get x 1%Z 0%Z))))
   = c_one) ->
  ((ket_norm_l x n) = c_one).

Axiom scalar_ket_norm_l :
  forall (x:matrix complex) (a:complex) (n:Z), (infix_lseqdt c_zero a) ->
  (is_a_ket_l x n) ->
  ((ket_norm_l (infix_asdtdt a x) n) = (infix_asdt a (ket_norm_l x n))).

Axiom zero_ket_norm_l :
  forall (x:matrix complex) (n:Z), (is_a_ket_l x n) ->
  ((ket_norm_l x n) = c_zero) -> forall (i:Z) (j:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) -> (j = 0%Z) ->
  ((get x i j) = c_zero).

Parameter normalized_l: (matrix complex) -> Z -> matrix complex.

Axiom normalized_l_def :
  forall (x:matrix complex) (n:Z), (is_a_ket_l x n) ->
  (exists i:Z,
   ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\ ~ ((get x i 0%Z) = c_zero)) ->
  ((normalized_l x n) = (infix_asdtdt (infix_sldt c_one (ket_norm_l x n)) x)).

Axiom normalized_l_spec :
  forall (x:matrix complex) (n:Z), (is_a_ket_l x n) ->
  (exists i:Z,
   ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) /\ ~ ((get x i 0%Z) = c_zero)) ->
  is_a_ket_l (normalized_l x n) n.

Parameter make_ket: Z -> (Z -> complex) -> matrix complex.

Axiom make_ket_def :
  forall (n:Z) (f:Z -> complex), (0%Z <= n)%Z ->
  ((make_ket n f) = (make_f (power 2%Z n) 1%Z (fun (x:Z) (us:Z) => (f x)))).

Axiom make_ket_spec :
  forall (n:Z) (f:Z -> complex), (0%Z <= n)%Z ->
  (is_a_ket_l (make_ket n f) n) /\
  ((forall (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
    ((get (make_ket n f) i 0%Z) = (f i))) /\
   forall (i:Z) (j:Z), (valid_index (make_ket n f) i j) ->
   ((get (make_ket n f) i j) = (f i))).

Axiom assert_make_ket :
  forall (r:Z) (c:Z) (f:Z -> complex) (i:Z), (c = 1%Z) ->
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z r))%Z) ->
  ((get (make_ket r f) i 0%Z) = (f i)).

Axiom assert_make_ket_l :
  forall (l:Z) (f:Z -> complex) (i:Z), (0%Z <= l)%Z ->
  ((get (make_ket l f) i 0%Z) = (f i)).

Axiom make_ket_length :
  forall (l:Z) (f:Z -> complex), (0%Z <= l)%Z ->
  ((ket_length (make_ket l f)) = l).

Axiom make_ket_rows :
  forall (l:Z) (f:Z -> complex), (0%Z <= l)%Z ->
  ((rows (make_ket l f)) = (power_ 2%Z l)).

Axiom make_ket_columns :
  forall (l:Z) (f:Z -> complex), (0%Z <= l)%Z ->
  ((columns (make_ket l f)) = 1%Z).

Parameter make_ket_constant: Z -> complex -> matrix complex.

Axiom make_ket_constant_def :
  forall (n:Z) (c:complex), (0%Z <= n)%Z ->
  ((make_ket_constant n c) = (make_ket n (fun (i:Z) => c))).

Axiom make_ket_constant_spec :
  forall (n:Z) (c:complex), (0%Z <= n)%Z ->
  (is_a_ket_l (make_ket_constant n c) n) /\
  ((forall (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z n))%Z) ->
    ((get (make_ket_constant n c) i 0%Z) = c)) /\
   forall (i:Z) (j:Z), (valid_index (make_ket_constant n c) i j) ->
   ((get (make_ket_constant n c) i j) = c)).

Axiom set_equal_ket :
  forall (m:matrix complex) (n:matrix complex), (is_a_ket m) ->
  (is_a_ket n) -> ((ket_length m) = (ket_length n)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) ->
   ((get m i 0%Z) = (get n i 0%Z))) ->
  (m = n).

Axiom set_equal_ket_ :
  forall (m:matrix complex) (n:matrix complex),
  (exists l:Z,
   (is_a_ket_l m l) /\
   ((is_a_ket_l n l) /\
    forall (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z l))%Z) ->
    ((get m i 0%Z) = (get n i 0%Z)))) ->
  (m = n).

Parameter add_ket: (matrix complex) -> (matrix complex) -> matrix complex.

Axiom add_ket_def :
  forall (m:matrix complex) (n:matrix complex), (is_a_ket m) ->
  (is_a_ket n) -> ((ket_length m) = (ket_length n)) ->
  ((add_ket m n) = (add_mat m n)).

Axiom add_ket_spec :
  forall (m:matrix complex) (n:matrix complex), (is_a_ket m) ->
  (is_a_ket n) -> ((ket_length m) = (ket_length n)) ->
  (is_a_ket (add_ket m n)) /\
  (((ket_length (add_ket m n)) = (ket_length m)) /\
   forall (i:Z), (valid_index (add_ket m n) i 0%Z) ->
   ((get (add_ket m n) i 0%Z) = (infix_pldt (get m i 0%Z) (get n i 0%Z)))).

Parameter add_ket_l:
  (matrix complex) -> (matrix complex) -> Z -> matrix complex.

Axiom add_ket_l_def :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (0%Z <= l)%Z ->
  ((add_ket_l m n l) =
   (make_ket l (fun (i:Z) => (infix_pldt (get m i 0%Z) (get n i 0%Z))))).

Axiom add_ket_l_spec :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (0%Z <= l)%Z ->
  (is_a_ket_l (add_ket_l m n l) l) /\
  (((ket_length (add_ket_l m n l)) = l) /\
   ((forall (i:Z),
     ((get (add_ket_l m n l) i 0%Z) =
      (infix_pldt (get m i 0%Z) (get n i 0%Z)))) /\
    ((is_a_ket_l m l) -> (is_a_ket_l n l) ->
     ((add_ket_l m n l) = (add_mat m n))))).

Axiom null_add_ket_l :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) -> (null_mat m) -> ((add_ket_l m n l) = n).

Axiom add_ket_l_null :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) -> (null_mat n) -> ((add_ket_l m n l) = m).

Parameter add_ket_l_eq:
  (matrix complex) -> (matrix complex) -> (matrix complex) ->
  (matrix complex) -> Z -> unit.

Axiom add_ket_l_eq_def :
  forall (m:matrix complex) (m':matrix complex) (n:matrix complex)
    (n':matrix complex) (l:Z),
  (is_a_ket_l m l) -> (is_a_ket_l n l) -> (m = m') -> (n = n') ->
  ((add_ket_l_eq m m' n n' l) = tt).

Axiom add_ket_l_eq_spec :
  forall (m:matrix complex) (m':matrix complex) (n:matrix complex)
    (n':matrix complex) (l:Z),
  (is_a_ket_l m l) -> (is_a_ket_l n l) -> (m = m') -> (n = n') ->
  ((((fun (y0:matrix complex) (y1:matrix complex) (y2:Z) =>
      (add_ket_l y0 y1 y2))
     m)
    n)
   =
   (((fun (y0:matrix complex) (y1:matrix complex) (y2:Z) =>
      (add_ket_l y0 y1 y2))
     m')
    n')).

Axiom add_ket_l_value :
  forall (m:matrix complex) (n:matrix complex) (l:Z) (i:Z),
  ((0%Z <= i)%Z /\ (i < (power 2%Z l))%Z) -> (0%Z <= l)%Z ->
  ((get (add_ket_l m n l) i 0%Z) = (infix_pldt (get m i 0%Z) (get n i 0%Z))).

Axiom add_ket_l_length :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (0%Z <= l)%Z ->
  ((ket_length (add_ket_l m n l)) = l).

Axiom add_ket_l_rows :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (0%Z <= l)%Z ->
  ((rows (add_ket_l m n l)) = (power_ 2%Z l)).

Axiom add_ket_l_columns :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (0%Z <= l)%Z ->
  ((columns (add_ket_l m n l)) = 1%Z).

Axiom add_ket_l_values :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (0%Z <= l)%Z ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < (power_ 2%Z l))%Z) ->
  ((get (add_ket_l m n l) i 0%Z) = (infix_pldt (get m i 0%Z) (get n i 0%Z))).

Axiom set_equal_ket_l :
  forall (m:matrix complex) (n:matrix complex),
  (exists l:Z, (is_a_ket_l m l) /\ (is_a_ket_l n l)) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (power 2%Z (ket_length m)))%Z) ->
   ((get m i 0%Z) = (get n i 0%Z))) ->
  (m = n).

Axiom set_equal_ket_l_ :
  forall (m:matrix complex) (n:matrix complex) (l:Z), (is_a_ket_l m l) ->
  (is_a_ket_l n l) ->
  (forall (i:Z), ((0%Z <= i)%Z /\ (i < (power_ 2%Z l))%Z) ->
   ((get m i 0%Z) = (get n i 0%Z))) ->
  (m = n).

Axiom get_ket_length :
  forall (m:matrix complex) (n:Z), (0%Z <= n)%Z -> ((columns m) = 1%Z) ->
  ((rows m) = (power 2%Z n)) -> ((ket_length m) = n).

Axiom set_ket_length :
  forall (m:matrix complex) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((ket_length m) = n) -> ((rows m) = (power 2%Z n)).

Axiom scalar_ket :
  forall (x:matrix complex) (a:complex), (is_a_ket x) ->
  is_a_ket (infix_asdtdt a x).

Axiom scalar_ket_length :
  forall (m:matrix complex) (a:complex), (is_a_ket m) ->
  ((ket_length (infix_asdtdt a m)) = (ket_length m)).

Axiom scalar_ket_valid_index :
  forall (m:matrix complex) (a:complex) (i:Z), (valid_index m i 0%Z) ->
  (is_a_ket m) -> valid_index (infix_asdtdt a m) i 0%Z.

Axiom scalar_ket_l :
  forall (x:matrix complex) (l:Z) (a:complex), (is_a_ket_l x l) ->
  is_a_ket_l (infix_asdtdt a x) l.

Axiom scalar_ket_l_values :
  forall (a:complex) (x:matrix complex) (l:Z), (is_a_ket_l x l) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i < (power_ 2%Z l))%Z) ->
  ((get (infix_asdtdt a x) i 0%Z) = (infix_asdt a (get x i 0%Z))).

Axiom scalar_ket_l_value :
  forall (a:complex) (x:matrix complex) (i:Z) (l:Z),
  ((0%Z <= i)%Z /\ (i < (power_ 2%Z l))%Z) -> (is_a_ket_l x l) ->
  ((get (infix_asdtdt a x) i 0%Z) = (infix_asdt a (get x i 0%Z))).

Axiom scalar_ket_value :
  forall (x:matrix complex) (i:Z) (a:complex),
  ((get (infix_asdtdt a x) i 0%Z) = (infix_asdt a (get x i 0%Z))).

Axiom scalar_ket_value_rev :
  forall (x:matrix complex) (i:Z) (a:complex),
  ((infix_asdt a (get x i 0%Z)) = (get (infix_asdtdt a x) i 0%Z)).

Axiom add_ket_is_a_ket :
  forall (x:matrix complex) (y:matrix complex), (is_a_ket x) ->
  (is_a_ket y) -> ((ket_length x) = (ket_length y)) -> is_a_ket (add_mat x y).

Axiom set_ket_length_gen :
  forall (m:matrix complex) (n:Z), (0%Z <= n)%Z -> (is_a_ket m) ->
  ((power 2%Z (ket_length m)) = n) -> ((rows m) = n).

Axiom set_is_a_ket :
  forall (m:matrix complex), ((columns m) = 1%Z) ->
  (exists s:Z, (0%Z <= s)%Z /\ ((rows m) = (power 2%Z s))) -> is_a_ket m.

Axiom set_is_a_ket_l :
  forall (m:matrix complex) (l:Z), (0%Z <= l)%Z -> ((columns m) = 1%Z) ->
  ((rows m) = (power 2%Z l)) -> is_a_ket_l m l.

Axiom set_is_a_ket_p :
  forall (m:matrix complex) (l:Z), (0%Z <= l)%Z -> ((columns m) = 1%Z) ->
  ((rows m) = (power 2%Z l)) -> is_a_ket m.

Axiom get_is_a_ket :
  forall (m:matrix complex), (is_a_ket m) ->
  ((columns m) = 1%Z) /\ ((rows m) = (power 2%Z (ket_length m))).

Axiom get_ket_columns :
  forall (m:matrix complex), (is_a_ket m) -> ((columns m) = 1%Z).

Axiom get_ket_rows :
  forall (m:matrix complex), (is_a_ket m) ->
  ((rows m) = (power 2%Z (ket_length m))).

Axiom get_ket_rows_gen :
  forall (m:matrix complex) (i:Z), (is_a_ket m) ->
  (i = (power 2%Z (ket_length m))) -> ((rows m) = i).

Axiom get_ket_rows_length :
  forall (m:matrix complex) (l:Z), (is_a_ket m) -> ((ket_length m) = l) ->
  ((rows m) = (power 2%Z l)).

Axiom ket_kronecker :
  forall (m:matrix complex) (n:matrix complex), (is_a_ket m) ->
  (is_a_ket n) ->
  (is_a_ket (kronecker m n)) /\
  ((ket_length (kronecker m n)) = ((ket_length m) + (ket_length n))%Z).

Axiom ket_kronecker_l :
  forall (m:matrix complex) (n:matrix complex) (l:Z) (l':Z),
  (is_a_ket_l m l) -> (is_a_ket_l n l') ->
  is_a_ket_l (kronecker m n) (l + l')%Z.

Axiom set_ket_kron_l :
  forall (m:matrix complex) (n:matrix complex) (l:Z) (l':Z) (l'':Z),
  (is_a_ket_l m l) -> (is_a_ket_l n l') -> (l'' = (l + l')%Z) ->
  is_a_ket_l (kronecker m n) l''.

Parameter result12: complex -> Z -> Z -> complex.

Axiom result_def12 :
  forall (x:complex) (i:Z) (us:Z),
  ((i = 0%Z) -> ((((result12 x) i) us) = (t_real_part x))) /\
  (~ (i = 0%Z) -> ((((result12 x) i) us) = (t_im_part x))).

(* Why3 assumption *)
Definition complex_as_a_vector (x:complex) : matrix complex :=
  make_f 2%Z 1%Z (result12 x).

Axiom complex_as_a_vector_spec :
  forall (x:complex),
  (is_a_ket_l (complex_as_a_vector x) 1%Z) /\
  ((ket_norm_l (complex_as_a_vector x) 1%Z) = (modulus x)).

Parameter sin: complex -> complex.

Axiom sin_def :
  forall (x:complex), (real_ x) ->
  ((sin x) = (t_im_part (exp (infix_asdt im x)))).

Axiom sin_spec : forall (x:complex), (real_ x) -> real_ (sin x).

Parameter cos: complex -> complex.

Axiom cos_def :
  forall (x:complex), (real_ x) ->
  ((cos x) = (t_real_part (exp (infix_asdt im x)))).

Axiom cos_spec : forall (x:complex), (real_ x) -> real_ (cos x).

Axiom euler_real_r :
  forall (x:complex), (real_ x) ->
  ((cos x) = (r_to_c (real_part (exp (infix_asdt im x))))).

Axiom euler_im_r :
  forall (x:complex), (real_ x) ->
  ((sin x) = (r_to_c (im_part (exp (infix_asdt im x))))).

Axiom cos_zero : ((cos c_zero) = c_one).

Axiom cos_half_pi :
  ((cos (infix_sldt pi (infix_pldt c_one c_one))) = c_zero).

Axiom cos_quarter_pi :
  ((cos (infix_sldt pi (i_to_c 4%Z))) =
   (infix_sldt (square_rt (infix_pldt c_one c_one)) (infix_pldt c_one c_one))).

Axiom cos_pi : ((cos pi) = (prefix_mndt c_one)).

Axiom sin_zero : ((sin c_zero) = c_zero).

Axiom sin_half_pi : ((sin (infix_sldt pi (infix_pldt c_one c_one))) = c_one).

Axiom sin_ang_exp :
  forall (x:complex), (real_ x) ->
  ((sin (infix_asdt (infix_asdt (infix_pldt c_one c_one) pi) x)) =
   (t_im_part (ang_exp (real_to_ang x)))).

Axiom cos_ang_exp :
  forall (x:complex), (real_ x) ->
  ((cos (infix_asdt (infix_asdt (infix_pldt c_one c_one) pi) x)) =
   (t_real_part (ang_exp (real_to_ang x)))).

Axiom sin_ang_exp_ :
  forall (x:complex), (real_ x) ->
  ((sin x) =
   (t_im_part
    (ang_exp
     (real_to_ang (infix_sldt x (infix_asdt (infix_pldt c_one c_one) pi)))))).

Axiom cos_ang_exp_ :
  forall (x:complex), (real_ x) ->
  ((cos x) =
   (t_real_part
    (ang_exp
     (real_to_ang (infix_sldt x (infix_asdt (infix_pldt c_one c_one) pi)))))).

Axiom cos_sin_square_add :
  forall (x:complex), (real_ x) ->
  ((infix_pldt (cpower (cos x) 2%Z) (cpower (sin x) 2%Z)) = c_one).

Axiom c_one_minus_sin_square :
  forall (x:complex), (real_ x) ->
  ((infix_mndt c_one (cpower (sin x) 2%Z)) = (cpower (cos x) 2%Z)).

Axiom c_one_minus_cos_square :
  forall (x:complex), (real_ x) ->
  ((infix_mndt c_one (cpower (cos x) 2%Z)) = (cpower (sin x) 2%Z)).

Axiom bounded_by_sine :
  forall (x:complex), (real_ x) ->
  ((infix_lseqdt c_zero x) /\
   (infix_lseqdt x (infix_sldt c_one (infix_pldt c_one c_one)))) ->
  infix_lseqdt (infix_asdt (infix_pldt c_one c_one) x)
  (modulus (sin (infix_asdt pi x))).

Axiom euler_real :
  forall (x:complex), (real_ x) ->
  ((cos x) = (t_real_part (exp (infix_asdt im x)))).

Axiom euler_im :
  forall (x:complex), (real_ x) ->
  ((sin x) = (t_im_part (exp (infix_asdt im x)))).

Axiom cos_add :
  forall (x:complex) (x':complex), (real_ x) -> (real_ x') ->
  ((cos (infix_pldt x x')) =
   (infix_mndt (infix_asdt (cos x) (cos x')) (infix_asdt (sin x) (sin x')))).

Axiom sin_add :
  forall (x:complex) (x':complex), (real_ x) -> (real_ x') ->
  ((sin (infix_pldt x x')) =
   (infix_pldt (infix_asdt (sin x) (cos x')) (infix_asdt (cos x) (sin x')))).

Axiom cos_two_x :
  forall (x:complex), (real_ x) ->
  ((cos (infix_asdt (infix_pldt c_one c_one) x)) =
   (infix_mndt (cpower (cos x) 2%Z) (cpower (sin x) 2%Z))).

Axiom sin_two_x :
  forall (x:complex) (x':complex), (real_ x) -> (real_ x') ->
  ((sin (infix_asdt (infix_pldt c_one c_one) x)) =
   (infix_asdt (infix_asdt (infix_pldt c_one c_one) (sin x)) (cos x))).

Axiom cos_minus :
  forall (x:complex), (real_ x) -> ((cos (prefix_mndt x)) = (cos x)).

Axiom sin_minus :
  forall (x:complex), (real_ x) ->
  ((sin (prefix_mndt x)) = (prefix_mndt (sin x))).

Axiom symetries_vert :
  forall (x:complex), (real_ x) ->
  ((sin (infix_pldt (infix_sldt pi (infix_pldt c_one c_one)) x)) =
   (sin (infix_mndt (infix_sldt pi (infix_pldt c_one c_one)) x))) /\
  ((cos (infix_pldt (infix_sldt pi (infix_pldt c_one c_one)) x)) =
   (prefix_mndt
    (cos (infix_mndt (infix_sldt pi (infix_pldt c_one c_one)) x)))).

Axiom pi_minus :
  forall (x:complex), (real_ x) ->
  ((sin (infix_mndt pi x)) = (sin x)) /\
  ((cos (infix_mndt pi x)) = (prefix_mndt (cos x))).

Axiom sin_plus_pi_pos :
  forall (x:complex) (k:Z), (real_ x) -> (0%Z <= k)%Z ->
  (((even k) = true) ->
   ((sin (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (sin (infix_asdt pi x)))) /\
  (((odd k) = true) ->
   ((sin (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (prefix_mndt (sin (infix_asdt pi x))))).

Axiom sin_plus_pi :
  forall (x:complex) (k:Z), (real_ x) ->
  (((even k) = true) ->
   ((sin (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (sin (infix_asdt pi x)))) /\
  (((odd k) = true) ->
   ((sin (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (prefix_mndt (sin (infix_asdt pi x))))).

Axiom cos_plus_pi_pos :
  forall (x:complex) (k:Z), (real_ x) -> (0%Z <= k)%Z ->
  (((even k) = true) ->
   ((cos (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (cos (infix_asdt pi x)))) /\
  (((odd k) = true) ->
   ((cos (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (prefix_mndt (cos (infix_asdt pi x))))).

Axiom cos_plus_pi :
  forall (x:complex) (k:Z), (real_ x) ->
  (((even k) = true) ->
   ((cos (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (cos (infix_asdt pi x)))) /\
  (((odd k) = true) ->
   ((cos (infix_asdt pi (infix_pldt x (i_to_c k)))) =
    (prefix_mndt (cos (infix_asdt pi x))))).

Axiom mod_sin_plus_pi :
  forall (x:complex) (k:Z), (real_ x) ->
  ((modulus (sin (infix_asdt pi (infix_pldt x (i_to_c k))))) =
   (modulus (sin (infix_asdt pi x)))).

Axiom mod_cos_plus_pi :
  forall (x:complex) (k:Z), (real_ x) ->
  ((modulus (cos (infix_asdt pi (infix_pldt x (i_to_c k))))) =
   (modulus (cos (infix_asdt pi x)))).

Axiom sin_mod_two_pi :
  forall (x:complex), (real_ x) ->
  ((sin (infix_asdt (infix_asdt (infix_pldt c_one c_one) pi) x)) =
   (sin (infix_asdt (infix_asdt (infix_pldt c_one c_one) pi) (dec_part x)))).

Axiom cos_mod_two_pi :
  forall (x:complex), (real_ x) ->
  ((cos (infix_asdt (infix_asdt (infix_pldt c_one c_one) pi) x)) =
   (cos (infix_asdt (infix_asdt (infix_pldt c_one c_one) pi) (dec_part x)))).

Axiom square_modulus_c_one_minus :
  forall (phi:complex), (real_ phi) ->
  ((cpower (modulus (infix_mndt c_one (ang_exp (real_to_ang phi)))) 2%Z) =
   (infix_asdt (i_to_c 4%Z) (cpower (modulus (sin (infix_asdt pi phi))) 2%Z))).

Axiom growing_sine :
  forall (a:complex) (b:complex),
  ((infix_lseqdt c_zero a) /\
   ((infix_lsdt a b) /\
    (infix_lseqdt b (infix_sldt c_one (infix_pldt c_one c_one))))) ->
  infix_lsdt (sin (infix_asdt pi a)) (sin (infix_asdt pi b)).

Parameter x: complex.

Axiom H : infix_lsdt c_zero x.

Axiom H1 : infix_lsdt x pi.

Axiom H2 :
  ((infix_sldt pi (infix_pldt c_one c_one)) =
   (infix_asdt pi (inv (infix_pldt c_one c_one)))).

Axiom H3 : ~ (infix_lseqdt x (infix_sldt pi (infix_pldt c_one c_one))).

Axiom H4 : ((sin (infix_mndt pi x)) = (sin x)).

Axiom H5 : ((cos (infix_mndt pi x)) = (prefix_mndt (cos x))).

(* Why3 goal *)
Theorem VC_non_null_sine :
  infix_lseqdt (infix_mndt pi x) (infix_sldt c_one (infix_pldt c_one c_one)).
Proof.


Qed.


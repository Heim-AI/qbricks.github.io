(set-logic AUFNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: real arithmetic
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun prefix_mndt (t) t)

(declare-fun infix_pldt (t t) t)

(declare-fun infix_asdt (t t) t)

(declare-fun inv (t) t)

;; Mul_distr_l
  (assert
  (forall ((x t) (y t) (z t))
  (= (infix_asdt x (infix_pldt y z)) (infix_pldt (infix_asdt x y)
                                     (infix_asdt x z)))))

;; Comm
  (assert (forall ((x t) (y t)) (= (infix_asdt x y) (infix_asdt y x))))

;; Unitary
  (assert (forall ((x t)) (= (infix_asdt tone x) x)))

;; NonTrivialRing
  (assert (not (= tzero tone)))

(declare-fun infix_mndt (t t) t)

;; infix -._def
  (assert
  (forall ((x t) (y t)) (= (infix_mndt x y) (infix_pldt x (prefix_mndt y)))))

(declare-fun infix_sldt (t t) t)

;; infix /._def
  (assert
  (forall ((x t) (y t))
  (=> (not (= y tzero)) (= (infix_sldt x y) (infix_asdt x (inv y))))))

(declare-fun from_int (Int) Real)

;; Absorbing_zero
  (assert
  (forall ((a t) (b t))
  (= (= (infix_asdt a b) tzero) (=> (not (= a tzero)) (= b tzero)))))

;; opposite
  (assert (forall ((a t)) (= (infix_mndt a a) tzero)))

(declare-fun im () t)

;; im_Def
  (assert (= (infix_asdt im im) (prefix_mndt tone)))

(declare-fun r_to_t (Real) t)

(declare-fun im_part (t) Real)

(declare-fun real_ (t) Bool)

;; real__def
  (assert (forall ((x t)) (= (real_ x) (= (im_part x) 0.0))))

;; real_r_to_t
  (assert (forall ((x Real)) (real_ (r_to_t x))))

;; twice_half
  (assert
  (= (infix_asdt (infix_pldt tone tone)
     (infix_sldt tone (infix_pldt tone tone))) tone))

(declare-fun pi1 () t)

;; real_inv
  (assert
  (forall ((x t))
  (=> (real_ x) (=> (not (= x tzero)) (real_ (infix_sldt tone x))))))

(declare-fun infix_mngt (ty ty) ty)

(declare-sort angle 0)

(declare-fun angle1 () ty)

(declare-fun ang_exp (angle) t)

(declare-fun i_to_t (Int) t)

;; i_to_t_def
  (assert (forall ((i Int)) (= (i_to_t i) (r_to_t (from_int i)))))

;; i_to_t_one
  (assert (= (i_to_t 1) tone))

;; i_to_t_add
  (assert
  (forall ((i Int) (j Int))
  (= (infix_pldt (i_to_t i) (i_to_t j)) (i_to_t (+ i j)))))

(declare-fun exp (t) t)

;; Exp_sum
  (assert
  (forall ((x t) (y t))
  (= (exp (infix_pldt x y)) (infix_asdt (exp x) (exp y)))))

;; exp_h_pi
  (assert
  (= (exp (infix_sldt (infix_asdt im pi1) (infix_pldt tone tone))) im))

;; exp_two_pi
  (assert
  (= (exp (infix_asdt (infix_asdt im pi1) (infix_pldt tone tone))) tone))

(declare-fun real_to_ang (t) angle)

;; Real_To_Ang_value
  (assert
  (forall ((phi t))
  (=> (real_ phi)
  (= (ang_exp (real_to_ang phi)) (exp
                                 (infix_asdt
                                 (infix_asdt (infix_asdt im pi1)
                                 (infix_pldt tone tone)) phi))))))

;; Real_To_Ang_cyclic
  (assert
  (forall ((phi t))
  (forall ((k Int))
  (=> (real_ phi)
  (= (real_to_ang phi) (real_to_ang
                       (infix_pldt tone (infix_asdt (i_to_t k) phi))))))))

(assert
;; h
  (not false))
(check-sat)

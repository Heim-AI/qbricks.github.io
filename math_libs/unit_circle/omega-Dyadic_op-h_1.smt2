;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: real arithmetic
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun t () ty)

(declare-fun infix_lseqdt (uni uni) Bool)

(declare-fun infix_lsdt (uni uni) Bool)

(declare-fun infix_gteqdt (uni uni) Bool)

(declare-fun infix_gtdt (uni uni) Bool)

(declare-fun set (ty) ty)

(declare-fun infix_mngt (ty ty) ty)

(declare-fun infix_at (ty ty uni uni) uni)

;; infix @_sort
  (assert
  (forall ((a ty) (b ty))
  (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

(declare-fun opposite_n (ty uni uni uni) Bool)

(declare-fun opposite (ty uni uni) Bool)

(declare-fun opposite_com (ty uni uni) Bool)

(declare-fun inverse_tuple (ty uni uni uni) Bool)

(declare-fun infix_pl_closure () (Array Int (Array Int Int)))

(declare-fun infix_mn_closure () (Array Int (Array Int Int)))

(declare-fun t2tb ((Array Int Int)) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array Int Int))) (sort (infix_mngt int int) (t2tb x))))

(declare-fun tb2t (uni) (Array Int Int))

;; BridgeL
  (assert
  (forall ((i (Array Int Int)))
  (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

(declare-fun t2tb1 (Int) uni)

;; t2tb_sort
  (assert (forall ((x Int)) (sort int (t2tb1 x))))

(declare-fun tb2t1 (uni) Int)

;; BridgeL
  (assert
  (forall ((i Int)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb1 (tb2t1 j)) j) :pattern ((t2tb1 (tb2t1 j))) )))

(declare-fun t2tb2 ((Array Int (Array Int Int))) uni)

;; t2tb_sort
  (assert
  (forall ((x (Array Int (Array Int Int)))) (sort
  (infix_mngt int (infix_mngt int int)) (t2tb2 x))))

(declare-fun tb2t2 (uni) (Array Int (Array Int Int)))

;; BridgeL
  (assert
  (forall ((i (Array Int (Array Int Int))))
  (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (= (t2tb2 (tb2t2 j)) j) :pattern ((t2tb2 (tb2t2 j))) )))

;; infix +_closure_def
  (assert
  (forall ((y Int) (y1 Int))
  (= (tb2t1
     (infix_at int int
     (infix_at (infix_mngt int int) int (t2tb2 infix_pl_closure) (t2tb1 y))
     (t2tb1 y1))) (+ y y1))))

;; infix -_closure_def
  (assert
  (forall ((y Int) (y1 Int))
  (= (tb2t1
     (infix_at int int
     (infix_at (infix_mngt int int) int (t2tb2 infix_mn_closure) (t2tb1 y))
     (t2tb1 y1))) (- y y1))))

;; isum_iter_
  (assert
  (and (opposite_n int (t2tb2 infix_pl_closure) (t2tb2 infix_mn_closure)
  (t2tb1 0))
  (and (opposite int (t2tb2 infix_pl_closure) (t2tb2 infix_mn_closure))
  (and (opposite_com int (t2tb2 infix_pl_closure) (t2tb2 infix_mn_closure))
  (inverse_tuple int (t2tb2 infix_pl_closure) (t2tb2 infix_mn_closure)
  (t2tb1 0))))))

(declare-fun ind_isum ((Array Int Int) Int Int) Int)

(declare-fun power (Int Int) Int)

(declare-fun fc () (Array Int Int))

;; fc_def
  (assert
  (forall ((k Int))
  (= (tb2t1 (infix_at int int (t2tb fc) (t2tb1 k))) (power 2 (+ k 1)))))

;; power_decomp
  (assert
  (forall ((i Int)) (=> (>= i 1) (< (ind_isum fc 0 i) (power 2 (+ i 1))))))

;; init_exp
  (assert
  (forall ((k Int))
  (and (= (power k 0) 1) (and (= (power k 1) k) (= (power k 2) (* k k))))))

(declare-fun cpower (uni Int) uni)

;; cpower_sort
  (assert (forall ((x uni) (x1 Int)) (sort t (cpower x x1))))

(declare-fun nonn_part (ty ty uni uni uni) uni)

;; nonn_part_sort
  (assert
  (forall ((a ty) (im ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (set a)
  (nonn_part im a x x1 x2)))))

(declare-fun n_part (ty ty uni uni uni) uni)

;; n_part_sort
  (assert
  (forall ((a ty) (im ty))
  (forall ((x uni) (x1 uni) (x2 uni)) (sort (set a) (n_part im a x x1 x2)))))

(declare-sort d_frac 0)

(declare-fun d_frac1 () ty)

(declare-fun den (d_frac) Int)

(declare-fun dyadic (Int Int) d_frac)

;; d_den
  (assert
  (forall ((k Int) (n Int))
  (=> (<= 0 n)
  (=> (=> (not (= 0 k)) (= (mod k 2) 1))
  (=> (and (<= 0 k) (< k (power 2 n))) (= (den (dyadic k n)) n))))))

;; d_up
  (assert
  (forall ((k Int) (n Int))
  (=> (>= n 0) (= (dyadic k n) (dyadic (* 2 k) (+ n 1))))))

(declare-fun neutral_dyadic () d_frac)

;; neutral_dyadic_def
  (assert (= neutral_dyadic (dyadic 0 1)))

(assert
;; h
  (not false))
(check-sat)

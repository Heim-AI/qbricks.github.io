;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: real arithmetic
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun real () ty)

(declare-fun infix_eqeq (ty uni uni) Bool)

(declare-sort t 0)

(declare-fun t1 () ty)

(declare-fun tzero () t)

(declare-fun tone () t)

(declare-fun prefix_mndt (t) t)

(declare-fun infix_pldt (t t) t)

(declare-fun infix_asdt (t t) t)

;; NonTrivialRing
  (assert (not (= tzero tone)))

(declare-fun infix_mndt (t t) t)

;; infix -._def
  (assert
  (forall ((x t) (y t)) (= (infix_mndt x y) (infix_pldt x (prefix_mndt y)))))

(declare-fun infix_mnas (Real Real) Real)

;; infix -*_def
  (assert (forall ((x Real) (y Real)) (= (infix_mnas x y) (+ x (- y)))))

;; opposite
  (assert (forall ((a t)) (= (infix_mndt a a) tzero)))

(declare-fun im () t)

;; im_Def
  (assert (= (infix_asdt im im) (prefix_mndt tone)))

(declare-fun r_to_t (Real) t)

(declare-fun real_part (t) Real)

(declare-fun im_part (t) Real)

;; Unic_decomp
  (assert
  (forall ((i t))
  (forall ((x Real) (y Real))
  (=> (= i (infix_pldt (r_to_t x) (infix_asdt im (r_to_t y))))
  (and (= x (real_part i)) (= y (im_part i)))))))

(declare-fun real_ (t) Bool)

(declare-fun t2tb (Real) uni)

;; t2tb_sort
  (assert (forall ((x Real)) (sort real (t2tb x))))

(declare-fun tb2t (uni) Real)

;; BridgeL
  (assert (forall ((i Real)) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

;; real__def
  (assert
  (forall ((x t))
  (= (real_ x) (infix_eqeq real (t2tb (im_part x)) (t2tb 0.0)))))

;; r_to_t_real
  (assert (forall ((x t)) (=> (real_ x) (= x (r_to_t (real_part x))))))

;; decomp_mult_real_part
  (assert
  (forall ((a t) (b t))
  (= (real_part (infix_asdt a b)) (infix_mnas (* (real_part a) (real_part b))
                                  (* (im_part a) (im_part b))))))

(declare-fun infix_lseqdt (t t) Bool)

;; infix <=._def
  (assert
  (forall ((x t) (y t))
  (= (infix_lseqdt x y)
  (and (real_ x) (and (real_ y) (<= (real_part x) (real_part y)))))))

;; Refl
  (assert (forall ((x t)) (infix_lseqdt x x)))

;; supeq_elim_left
  (assert
  (forall ((a t) (b t))
  (=> (infix_lseqdt b a) (infix_lseqdt (infix_mndt b a) tzero))))

(declare-fun infix_mngt (ty ty) ty)

(assert
;; h
  (not false))
(check-sat)
